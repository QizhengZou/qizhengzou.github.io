<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Coding - 分类 - Jefo</title><link>https://qizhengzou.github.io/categories/coding/</link><description>Coding - 分类 - Jefo</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>2838264218@qq.com (Jefo)</managingEditor><webMaster>2838264218@qq.com (Jefo)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 31 Jul 2022 14:17:48 +0800</lastBuildDate><atom:link href="https://qizhengzou.github.io/categories/coding/" rel="self" type="application/rss+xml"/><item><title>Patterns_principles</title><link>https://qizhengzou.github.io/patterns_principles/</link><pubDate>Sun, 31 Jul 2022 14:17:48 +0800</pubDate><author>作者</author><guid>https://qizhengzou.github.io/patterns_principles/</guid><description>https://github.com/geekhall/gof/blob/main/README.md?plain=1 1. 软件设计的七大原则 也叫solid原则 迪米特与合成/复用是后加的 Principle 1 : 开闭原则（Open Close Principle, OCP） 内容：对扩展开放，对修改关闭 实现方式：</description></item><item><title>Algorithm_find</title><link>https://qizhengzou.github.io/algorithm_find/</link><pubDate>Sun, 20 Feb 2022 19:52:33 +0800</pubDate><author>作者</author><guid>https://qizhengzou.github.io/algorithm_find/</guid><description>查找算法 散列查找：也称哈希查找，有拉链法查找，也有线性探测法查找，拉链法使用数组链表结构，线性探测法使用数组。 树查找：有搜索二叉树，平衡查找</description></item><item><title>Algorithm_sort</title><link>https://qizhengzou.github.io/algorithm_sort/</link><pubDate>Sun, 20 Feb 2022 19:52:01 +0800</pubDate><author>作者</author><guid>https://qizhengzou.github.io/algorithm_sort/</guid><description>排序算法 稳定性概念 定义：能保证两个相等的数，经过排序之后，其在序列的前后位置顺序不变。（A1=A2，排序前A1在A2前面，排序后A1还在A2</description></item><item><title>Structural_type</title><link>https://qizhengzou.github.io/structural_type/</link><pubDate>Sat, 22 Jan 2022 09:21:00 +0800</pubDate><author>作者</author><guid>https://qizhengzou.github.io/structural_type/</guid><description>结构型设计模式 常用的有：代理模式、桥接模式、装饰者模式、适配器模式。不常用的有：门面模式、组合模式、享元模式。 代理模式：代理模式在不改变原始</description></item><item><title>Behavioral_type</title><link>https://qizhengzou.github.io/behavioral_type/</link><pubDate>Sat, 22 Jan 2022 09:20:41 +0800</pubDate><author>作者</author><guid>https://qizhengzou.github.io/behavioral_type/</guid><description>行为型设计模式 常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。 不常用的有：命令模式、备忘录模式、解释器模式、访问</description></item><item><title>Create_type</title><link>https://qizhengzou.github.io/create_type/</link><pubDate>Sat, 22 Jan 2022 09:19:30 +0800</pubDate><author>作者</author><guid>https://qizhengzou.github.io/create_type/</guid><description>创建型设计模式 常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。不常用的有：原型模式。 创建型模式主要解决对象的创建问题，封装复</description></item><item><title>Algo_catalogue</title><link>https://qizhengzou.github.io/algo_catalogue/</link><pubDate>Wed, 19 Jan 2022 10:06:22 +0800</pubDate><author>作者</author><guid>https://qizhengzou.github.io/algo_catalogue/</guid><description>学习代码随想录笔记 algorithm_array algorithm_backTracking algorithm_binaryTree algorithm_doublePointer algorithm_dp algorithm_find algorithm_greedy algorithm_hashTable algorithm_linkedList algorithm_sort algorithm_stackAndQueue algorithm_string</description></item><item><title>Algorithm_dynamicProgramming</title><link>https://qizhengzou.github.io/algorithm_dynamicprogramming/</link><pubDate>Thu, 06 Jan 2022 08:27:39 +0800</pubDate><author>作者</author><guid>https://qizhengzou.github.io/algorithm_dynamicprogramming/</guid><description>学习代码随想录笔记 动态规划 有很多重叠子问题，优先考虑使用动态规划。 与贪心的区别：贪心不会考虑之前的状态而只考虑局部最优。 理论基础 dp步骤： 确</description></item><item><title>Algorithm_greedy</title><link>https://qizhengzou.github.io/algorithm_greedy/</link><pubDate>Thu, 06 Jan 2022 08:23:51 +0800</pubDate><author>作者</author><guid>https://qizhengzou.github.io/algorithm_greedy/</guid><description>学习代码随想录笔记 贪心算法 理论基础 贪心算法一般分为如下四步： 将问题分解为若干个子问题 找出适合的贪心策略 求解每一个子问题的最优解 将局部最优解堆</description></item><item><title>Algorithm_backTracking</title><link>https://qizhengzou.github.io/algorithm_backtracking/</link><pubDate>Thu, 06 Jan 2022 08:22:27 +0800</pubDate><author>作者</author><guid>https://qizhengzou.github.io/algorithm_backtracking/</guid><description>学习代码随想录笔记 回溯算法 理论基础 也叫回溯搜索算法。 回溯是递归的副产品，只要有递归就会有回溯 回溯的本质是穷举，穷举所有可能，然后选出我们想要</description></item></channel></rss>