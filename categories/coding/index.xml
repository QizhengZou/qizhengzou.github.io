<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Coding - 分类 - Jefo</title><link>https://qizhengzou.github.io/categories/coding/</link><description>Coding - 分类 - Jefo</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>2838264218@qq.com (Jefo)</managingEditor><webMaster>2838264218@qq.com (Jefo)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 22 Jan 2022 09:21:00 +0800</lastBuildDate><atom:link href="https://qizhengzou.github.io/categories/coding/" rel="self" type="application/rss+xml"/><item><title>Structural_type</title><link>https://qizhengzou.github.io/structural_type/</link><pubDate>Sat, 22 Jan 2022 09:21:00 +0800</pubDate><author>作者</author><guid>https://qizhengzou.github.io/structural_type/</guid><description>facade API 为facade 模块的外观接口，大部分代码使用此接口简化对facade类的访问。 facade模块同时暴露了a和b 两个Module 的NewX</description></item><item><title>Behavioral_type</title><link>https://qizhengzou.github.io/behavioral_type/</link><pubDate>Sat, 22 Jan 2022 09:20:41 +0800</pubDate><author>作者</author><guid>https://qizhengzou.github.io/behavioral_type/</guid><description>mediator 中介者模式封装对象之间互交，使依赖变的简单，并且使复杂互交简单化，封装在中介者中。 例子中的中介者使用单例模式生成中介者。 中介者的chang</description></item><item><title>Create_type</title><link>https://qizhengzou.github.io/create_type/</link><pubDate>Sat, 22 Jan 2022 09:19:30 +0800</pubDate><author>作者</author><guid>https://qizhengzou.github.io/create_type/</guid><description>simple factory go 语言没有构造函数一说，所以一般会定义NewXXX函数来初始化相关类。 NewXXX 函数返回接口时就是简单工厂模式，也就是说Golang的一般推荐做</description></item><item><title>Algorithm_dynamicProgramming</title><link>https://qizhengzou.github.io/algorithm_dynamicprogramming/</link><pubDate>Thu, 06 Jan 2022 08:27:39 +0800</pubDate><author>作者</author><guid>https://qizhengzou.github.io/algorithm_dynamicprogramming/</guid><description>学习代码随想录笔记 动态规划 有很多重叠子问题，优先考虑使用动态规划。 与贪心的区别：贪心不会考虑之前的状态，只考虑局部最优。 理论基础 dp步骤： 确</description></item><item><title>Algorithm_greedy</title><link>https://qizhengzou.github.io/algorithm_greedy/</link><pubDate>Thu, 06 Jan 2022 08:23:51 +0800</pubDate><author>作者</author><guid>https://qizhengzou.github.io/algorithm_greedy/</guid><description>学习代码随想录笔记 贪心算法 理论基础 贪心算法一般分为如下四步： 将问题分解为若干个子问题 找出适合的贪心策略 求解每一个子问题的最优解 将局部最优解堆</description></item><item><title>Algorithm_backTracking</title><link>https://qizhengzou.github.io/algorithm_backtracking/</link><pubDate>Thu, 06 Jan 2022 08:22:27 +0800</pubDate><author>作者</author><guid>https://qizhengzou.github.io/algorithm_backtracking/</guid><description>学习代码随想录笔记 回溯算法 理论基础 也叫回溯搜索算法。 回溯是递归的副产品，只要有递归就会有回溯 回溯的本质是穷举，穷举所有可能，然后选出我们想要</description></item><item><title>Algorithm_binaryTree</title><link>https://qizhengzou.github.io/algorithm_binarytree/</link><pubDate>Thu, 06 Jan 2022 08:21:45 +0800</pubDate><author>作者</author><guid>https://qizhengzou.github.io/algorithm_binarytree/</guid><description>学习代码随想录笔记 二叉树 理论基础 一般主要会碰到满二叉树以及完全二叉树。 完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余</description></item><item><title>Algorithm_stackAndQueue</title><link>https://qizhengzou.github.io/algorithm_stackandqueue/</link><pubDate>Thu, 06 Jan 2022 08:20:54 +0800</pubDate><author>作者</author><guid>https://qizhengzou.github.io/algorithm_stackandqueue/</guid><description>学习代码随想录笔记 栈和队列 需要知道栈和队列的底层实现，不同编程语言不同STL的实现原理都是不尽相同的。 理论基础(c++) 栈其实就是递归的一种</description></item><item><title>Algorithm_doublePointer</title><link>https://qizhengzou.github.io/algorithm_doublepointer/</link><pubDate>Thu, 06 Jan 2022 08:19:19 +0800</pubDate><author>作者</author><guid>https://qizhengzou.github.io/algorithm_doublepointer/</guid><description>学习代码随想录笔记 双指针法 双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</description></item><item><title>Algorithm_string</title><link>https://qizhengzou.github.io/algorithm_string/</link><pubDate>Thu, 06 Jan 2022 08:18:50 +0800</pubDate><author>作者</author><guid>https://qizhengzou.github.io/algorithm_string/</guid><description>学习代码随想录笔记 字符串 库函数是工具，基础更重要。 反转字符串 I 和反转链表相同，都用双指针法。 1 2 3 4 5 6 7 8 9 func reverseString(s []byte) { left:=0 right:=len(s)-1 for left&amp;lt;right{ s[left],s[right]=s[right],s[left] left++ right-- } } II 给</description></item></channel></rss>