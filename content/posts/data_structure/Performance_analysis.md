---
title: "Performance_analysis"
date: 2022-01-02T19:28:23+08:00
lastmod: 2022-01-02
tags: [data structure]
categories: [Coding]
slug: performance_analysis
draft: false
---
# 算法性能分析
## 时间复杂度
- 时间复杂度是定性描述算法运行时间的函数。
- 实际情况中会因为数据用例、数据规模不同而变化，一般讨论一般情况。
- 时间复杂度$O(log(n))$并不以某一个确定的数为底数，因为可以通过乘以某个对数常数达到换底数的效果。

递归算法的时间复杂度：递归次数*每次递归的时间复杂度（操作的次数）
## 空间复杂度分析
空间复杂度：程序运行时占用内存的大小，受很多因素的影响，比如编译器的内存对齐，编程语言容器的底层实现等

递归算法的空间复杂度：递归深度*每次递归的空间复杂度
- 递归所需的空间都被压到调用栈里，一次递归结束，这个栈就是就是把本次递归的数据弹出去。所以这个栈最大的长度就是递归的深度。
## 算法复杂度主方法
主方法亦可称为主定理。适用于求那些用分治法以及有递推关系式的算法的复杂度。

假设有递推关系式：$T(n)=aT(n/b)+f(n)$ 
- n是问题规模
- a为递推的子问题数量
- n/b是每个子问题的规模，假设每个子问题规模一致
- f(n)为递推以外进行的计算工作
- T(n)为非负整数

分类讨论：
- 若$f(n)=O(n^{log_b(a-e)}),e>0$
    - 则$T(n)=Θ(n^{log_b(a)})$
- 若$f(n)=Θ(n^{log_b(a)})$
    - 则$T(n)=Θ(n^{log_b(a)}log(n))$
- 若$f(n)=Ω(n^{log_b(a+e)}),e>0$，且对于某个常数c < 1和所有充分大的n有$af(n/b)<=cf(n)$，
    - 则$T(n)=Θ(f(n))$

不是很容易记忆。下面有一种简化的版本：

若算法运行时间$T(n)<=aT(n/b)+O(n^d)$
- a>=1是子问题的个数，b>=1是输入规模减小的倍数，d>=0是递归过程之外的步骤的时间复杂度指数，则：
- ![](https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20220303125128.png)
## 代码的内存消耗
每种语言都有着自己的内存管理方式。
### 内存对齐

为什么会有内存对齐？
- 平台原因：不是所有的硬件平台都能访问任意内存地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。为了同一个程序可以在多平台运行，需要内存对齐。
- **硬件原因**：经过内存对齐后，CPU访问内存的速度大大提升

CPU读取内存不是一次读取单个字节，而是一块一块的来读取内存，块的大小可以是2，4，8，16个字节，具体取多少个字节取决于硬件。

只要可以跨平台的编程语言都需要做内存对齐，不做内存对齐会使运行速度下降，因为寻址访存次数多了。现在的编译器一般都会做内存对齐的优化操作，也就是说当考虑程序真正占用的内存大小的时候，也需要认识到内存对齐的影响。
### go语言的内存管理
显然，go的内存管理内部机制建立于操作系统以及机器硬件如何管理内存之上的。尽可能扬长避短。

介绍一下和开发者关系较大的操作系统内存管理机制。
暂停