# Performance_analysis

# 算法性能分析
## 时间复杂度
- 时间复杂度是定性描述算法运行时间的函数。
- 实际情况中会因为数据用例、数据规模不同而变化，一般讨论一般情况。
- 时间复杂度$O(log(n))$并不以某一个确定的数为底数，因为可以通过乘以某个对数常数达到换底数的效果。

递归算法的时间复杂度：递归次数*每次递归的时间复杂度（操作的次数）
## 空间复杂度分析
空间复杂度：程序运行时占用内存的大小，受很多因素的影响，比如编译器的内存对齐，编程语言容器的底层实现等

递归算法的空间复杂度：递归深度*每次递归的空间复杂度
- 递归所需的空间都被压到调用栈里，一次递归结束，这个栈就是就是把本次递归的数据弹出去。所以这个栈最大的长度就是递归的深度。
## 代码的内存消耗
每种语言都有着自己的内存管理方式。
### 内存对齐

为什么会有内存对齐？
- 平台原因：不是所有的硬件平台都能访问任意内存地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。为了同一个程序可以在多平台运行，需要内存对齐。
- **硬件原因**：经过内存对齐后，CPU访问内存的速度大大提升

CPU读取内存不是一次读取单个字节，而是一块一块的来读取内存，块的大小可以是2，4，8，16个字节，具体取多少个字节取决于硬件。

只要可以跨平台的编程语言都需要做内存对齐，不做内存对齐会使运行速度下降，因为寻址访存次数多了。现在的编译器一般都会做内存对齐的优化操作，也就是说当考虑程序真正占用的内存大小的时候，也需要认识到内存对齐的影响。
### go语言的内存管理

