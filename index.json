[{"categories":["Advanced learning"],"content":" 来自极客时间学习笔记 HTTP ","date":"2022-01-24 20:52:12","objectID":"https://qizhengzou.github.io/cn_http/:0:0","tags":["computer network"],"title":"CN_HTTP","uri":"https://qizhengzou.github.io/cn_http/"},{"categories":["Advanced learning"],"content":"前言 据 NetCraft 公司统计，目前全球至少有 16 亿个网站、2 亿多个独立域名，而这个庞大网络世界的底层运转机制就是 HTTP。 HTTP 不就是请求 / 响应、GET/POST、Header/Body 吗？好像是哎，但又简略了点。 本文内容： 广度上从 HTTP 尽量向外扩展，不只讲协议本身，与它相关的 TCP/IP、DNS、SSL/TLS、Web Server 等 基于最新RFC标准文档 分析 HTTPS时用 Wireshark 从建立 TCP 连接时就开始抓包，从二进制最底层来分析里面的 Record、Cipher Suite、Extension，讲 ECDHE、AES、SHA384，再画出详细的流程图，做到“一览无余” 学习网络协议最重要的就是实践，咱们会用 Nginx 搭建一个“麻雀虽小，五脏俱全”的实验环境（自身就是一个完整的网络环境，即使不联网也能够在里面收发 HTTP 消息。） ","date":"2022-01-24 20:52:12","objectID":"https://qizhengzou.github.io/cn_http/:1:0","tags":["computer network"],"title":"CN_HTTP","uri":"https://qizhengzou.github.io/cn_http/"},{"categories":["Advanced learning"],"content":"破冰 ","date":"2022-01-24 20:52:12","objectID":"https://qizhengzou.github.io/cn_http/:2:0","tags":["computer network"],"title":"CN_HTTP","uri":"https://qizhengzou.github.io/cn_http/"},{"categories":["Advanced learning"],"content":"历史 20 世纪 60 年代，美国国防部高等研究计划署（ARPA）建立了 ARPA 网，它有四个分布在各地的节点，被认为是如今互联网的“始祖”。 然后在 70 年代，基于对 ARPA 网的实践和思考，研究人员发明出了著名的 TCP/IP 协议。由于具有良好的分层结构和稳定的性能，TCP/IP 协议迅速战胜其他竞争对手流行起来，并在 80 年代中期进入了 UNIX 系统内核，促使更多的计算机接入了互联网。 1989 年，任职于欧洲核子研究中心（CERN）的蒂姆·伯纳斯 - 李（Tim Berners-Lee）发表了一篇论文，提出了在互联网上构建超链接文档系统的构想。这篇论文中他确立了三项关键技术。 URI：即统一资源标识符，作为互联网上资源的唯一身份； HTML：即超文本标记语言，描述超文本文档； HTTP：即超文本传输协议，用来传输超文本。 （超文本有超链接，是网状结构，而普通文本是线性结构。） 蒂姆把这个系统称为“万维网”（World Wide Web），也就是我们现在所熟知的 Web。 20 世纪 90 年代初期的互联网世界非常简陋，计算机处理能力低，存储容量小，网速很慢。网络上绝大多数的资源都是纯文本，很多通信协议也都使用纯文本。这一时期的 HTTP 被定义为 0.9 版，结构比较简单，为了便于服务器和客户端处理，它也采用了纯文本格式。蒂姆·伯纳斯 - 李最初设想的系统里的文档都是只读的，所以只允许用“GET”动作从服务器上获取 HTML 文档，并且在响应请求之后立即关闭连接，功能非常有限。 1993 年，NCSA（美国国家超级计算应用中心）开发出了 Mosaic，是第一个可以图文混排的浏览器，随后又在 1995 年开发出了服务器软件 Apache，简化了 HTTP 服务器的搭建工作。同一时期，计算机多媒体技术也有了新的发展：1992 年发明了 JPEG 图像格式，1995 年发明了 MP3 音乐格式。HTTP/1.0 版本在 1996 年正式发布。它在多方面增强了 0.9 版，形式上已经和我们现在的 HTTP 差别不大了，例如： 增加了 HEAD、POST 等新方法； 增加了响应状态码，标记可能的错误原因； 引入了协议版本号概念； 引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活； 传输的数据不再仅限于文本。 但 HTTP/1.0 并不是一个“标准”，只是记录已有实践和模式的一份参考文档，不具有实际的约束力，相当于一个“备忘录”。 1995 年，网景的 Netscape Navigator 和微软的 Internet Explorer 开始了著名的“浏览器大战”，都希望在互联网上占据主导地位。最终微软的 IE 取得了决定性的胜利，而网景则“败走麦城”（但后来却凭借 Mozilla Firefox 又扳回一局） 在“浏览器大战”结束之后的 1999 年，HTTP/1.1 发布了 RFC 文档，编号为 2616，正式确立了延续十余年的传奇。 HTTP/1.1 与 HTTP/1.0 的一个重要的区别是：它是一个“正式的标准”，而不是一份可有可无的“参考文档”。这意味着今后互联网上所有的浏览器、服务器、网关、代理等等，只要用到 HTTP 协议，就必须严格遵守这个标准，相当于是互联网世界的一个“立法”。 HTTP/1.1 主要的变更点有： 增加了 PUT、DELETE 等新的方法； 增加了缓存管理和控制； 明确了连接管理，允许持久连接； 允许响应数据分块（chunked），利于传输大文件； 强制要求 Host 头，让互联网主机托管成为可能 只要是HTTP/1.1，就都是文本格式，虽然里面的数据可能是二进制，但分隔符还是文本。 现在许多的知名网站都是在HTTP/1.1这个时间点左右创立的，例如 Google、新浪、搜狐、网易、腾讯等，互联网开始爆发式增长。不过由于 HTTP/1.1 太过庞大和复杂，所以在 2014 年又做了一次修订，原来的一个大文档被拆分成了六份较小的文档，编号为 7230-7235，优化了一些细节，但此外没有任何实质性的改动。 当时也有一些弊病：主要是连接慢。但标准固定人们只能耍技巧，比如切图、js合并等网页优化手段。 Google 首先开发了自己的浏览器 Chrome，然后推出了新的 SPDY 协议，并在 Chrome 里应用于自家的服务器，如同十多年前的网景与微软一样，从实际的用户方来“倒逼”HTTP 协议的变革，这也开启了第二次的“浏览器大战”。 历史再次重演，不过这次的胜利者是 Google，Chrome 目前的全球的占有率超过了 60%。Google 借此顺势把 SPDY 推上了标准的宝座，互联网标准化组织以 SPDY 为基础开始制定新版本的 HTTP 协议，最终在 2015 年发布了 HTTP/2，RFC 编号 7540。 HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有： 二进制协议，不再是纯文本； 可发起多个请求，废弃了 1.1 里的管道； 使用专用算法压缩头部，减少数据传输量； 允许服务器主动向客户端推送数据； 增强了安全性，“事实上”要求加密通信。 在 HTTP/2 还处于草案之时，Google 又发明了一个新的协议，叫做 QUIC，而且还是相同的“套路”，继续在 Chrome 和自家服务器里试验着“玩”，依托它的庞大用户量和数据量，持续地推动 QUIC 协议成为互联网上的“既成事实”。 2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段。HTTP/3 现在还没正式推出，不过自 2017 年起， HTTP/3 已经更新到 30 多个草案了。 ","date":"2022-01-24 20:52:12","objectID":"https://qizhengzou.github.io/cn_http/:2:1","tags":["computer network"],"title":"CN_HTTP","uri":"https://qizhengzou.github.io/cn_http/"},{"categories":["Advanced learning"],"content":"HTTP的定义 HyperText Transfer Protocol。 协议意味着有多个参与者为了达成某个共同的目的而站在了一起，除了要无疑义地沟通交流之外，还必须明确地规定各方的“责、权、利”，约定该做什么不该做什么，先做什么后做什么，做错了怎么办，有没有补救措施等等。 HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。 HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范 最终定义： HTTP 是一个在计算机世界里专门在两点之间传输超文本数据的约定和规范” 在互联网世界里，HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位。 与HTTP相关的协议与技术：","date":"2022-01-24 20:52:12","objectID":"https://qizhengzou.github.io/cn_http/:2:2","tags":["computer network"],"title":"CN_HTTP","uri":"https://qizhengzou.github.io/cn_http/"},{"categories":["Advanced learning"],"content":"基础 ","date":"2022-01-24 20:52:12","objectID":"https://qizhengzou.github.io/cn_http/:3:0","tags":["computer network"],"title":"CN_HTTP","uri":"https://qizhengzou.github.io/cn_http/"},{"categories":["Advanced learning"],"content":"进阶 ","date":"2022-01-24 20:52:12","objectID":"https://qizhengzou.github.io/cn_http/:4:0","tags":["computer network"],"title":"CN_HTTP","uri":"https://qizhengzou.github.io/cn_http/"},{"categories":["Advanced learning"],"content":"安全 ","date":"2022-01-24 20:52:12","objectID":"https://qizhengzou.github.io/cn_http/:5:0","tags":["computer network"],"title":"CN_HTTP","uri":"https://qizhengzou.github.io/cn_http/"},{"categories":["Advanced learning"],"content":"飞翔 ","date":"2022-01-24 20:52:12","objectID":"https://qizhengzou.github.io/cn_http/:6:0","tags":["computer network"],"title":"CN_HTTP","uri":"https://qizhengzou.github.io/cn_http/"},{"categories":["Advanced learning"],"content":"探索 ","date":"2022-01-24 20:52:12","objectID":"https://qizhengzou.github.io/cn_http/:7:0","tags":["computer network"],"title":"CN_HTTP","uri":"https://qizhengzou.github.io/cn_http/"},{"categories":["Advanced learning"],"content":"总结 ","date":"2022-01-24 20:52:12","objectID":"https://qizhengzou.github.io/cn_http/:8:0","tags":["computer network"],"title":"CN_HTTP","uri":"https://qizhengzou.github.io/cn_http/"},{"categories":["School courses"],"content":" 笔记来自 中科大郑烇 计网PPT，改编自计算机网络-自顶向下 第七版 应用层 目标： 网络应用的原理：网络应用协议的概念和实现方面 传输层的服务模型 客户-服务器模式 对等模式(peer-to-peer) 内容分发网络 网络应用的 ：互联网流行的应用层协议 HTTP FTP SMTP / POP3 / IMAP DNS 编程 ：网络应用程序 Socket API 创建一个新的网络应用 编程 在不同的端系统上运行 通过网络基础设施提供的服务，应用进程彼此通信 如Web: Web 服务器软件与浏览器软件通信 网络核心中没有应用层软件 网络核心没有应用层功能 网络应用只在端系统上存在，快速网络应用开发和部署 ","date":"2022-01-23 10:50:28","objectID":"https://qizhengzou.github.io/cn_base_02/:0:0","tags":["computer network"],"title":"CN_base_02","uri":"https://qizhengzou.github.io/cn_base_02/"},{"categories":["School courses"],"content":"2.1 应用层协议原理 网络应用的体系结构 可能的应用架构： 客户-服务器模式（C/S:client/server） 服务器: 一直运行 固定的IP地址和周知的端口号（约定） 扩展性：服务器场 数据中心进行扩展 扩展性差 客户端: 主动与服务器通信 与互联网有间歇性的连接 可能是动态IP 地址 不直接与其它客户端通信 对等模式(P2P:Peer To Peer) （几乎）没有一直运行的服务器 任意端系统之间可以进行通信 每一个节点既是客户端又是服务器 自扩展性-新peer节点带来新的服务能力，当然也带来新的服 务请求 参与的主机间歇性连接且可以改变IP 地址 难以管理 例子: Gnutella，迅雷 混合体：客户-服务器和对等体系结构 Napster 文件搜索：集中 主机在中心服务器上注册其资源 主机向中心服务器查询资源位置 文件传输：P2P 任意Peer节点之间 即时通信 在线检测：集中 当用户上线时，向中心服务器注册其IP地址 用户与中心服务器联系，以找到其在线好友的位置 两个用户之间聊天：P2P 进程通信： 进程：在主机上运行的应用程序 客户端进程：发起通信的进程 服务器进程：等待连接的进程 在同一个主机内，使用进程间通信机制通信（ 操作系统定义） 不同主机，通过交换报文（Message）来通信 使用OS提供的通信服务 按照应用协议交换报文 借助传输层提供的服务 注意：P2P架构的应用也有客户端进程和服务器进程之分 分布式进程通信需要解决的问题： 问题1：进程标示和寻址问题（服务用户） 问题1解决：对进程进行编址（addressing） 进程为了接收报文，必须有一个标识即：SAP（发送也需要标示） 主机：唯一的 32位IP地址 仅仅有IP地址不能够唯一标示一个进程；在一台端系统上有很多应用进程在运行 所采用的传输层协议：TCP or UDP 端口号（Port Numbers） 一些知名端口号的例子： HTTP: TCP 80 Mail: TCP25 ftp:TCP 2 一个进程：用IP+port标示 端节点 本质上，一对主机进程之间的通信由2个端节点构成 问题2：传输层-应用层提供服务是如何（服务） 位置：层间界面的SAP （TCP/IP ：socket） 形式：应用程序接口API （TCP/IP ：socket API） 解决：传输层提供的服务 需要穿过层间的信息 层间接口必须要携带的信息 要传输的报文（对于本层来说：SDU） 谁传的：自己的应用进程标示：IP+TCP(UDP) 端口 传给谁：对方的应用进程标示：对方的IP+TCP(UDP)端口号 传输层实体（tcp或者udp实体）根据这些信息进行TCP报文段（UDP数据报）的封装 源端口号，目标端口号，数据等 将IP地址往下交IP实体，用于封装IP数据报：源IP,目标IP 层间信息的代表 如果Socket API 每次传输报文，都携带如此多的信息，太繁琐易错，不便于管理 用个代号标示通信的双方或者单方：socket 就像OS打开文件返回的句柄一样 对句柄的操作，就是对文件的操作 TCP socket： TCP服务，两个进程之间的通信需要之前要建立连接 两个进程通信会持续一段时间，通信关系稳定 可以用一个整数表示两个应用实体之间的通信关系，本地标示 穿过层间接口的信息量最小 TCP socket：源IP,源端口，目标IP，目标IP,目标 端口 TCP之上的套接字（socket） 对于使用面向连接服务（TCP）的应用而言，套接字是4元组的一个具有本地意义的标示 4元组：(源IP，源port，目标IP，目标port) 唯一的指定了一个会话（2个进程之间的会话关系） 应用使用这个 ，与远程的应用进程通信 不必在每一个报文的发送都要指定这4元组 就像使用操作系统打开一个文件，OS返回一个文件句柄一样，以后使用这个文件句柄,而不是使用这个文件的目录名、文件名 简单，便于管理 层间信息代码 UDP socket： UDP服务，两个进程之间的通信需要之前无需建立连接 每个报文都是独立传输的 前后报文可能给不同的分布式进程 因此，只能用一个整数表示本应用实体的标示 因为这个报文可能传给另外一个分布式进程 ·1 穿过层间接口的信息大小最小 UDP socket：本IP,本端口 但是传输 报文时：必须要提供对方IP，port 接收报文时： 传输层需要上传对方的IP，port UDP之上的套接字（socket） 对于使用无连接服务（UDP）的应用而言，套接字是2元组的一个具有本地意义的标示 2元组：IP，port （源端指定） UDP套接字指定了应用所在的一个端节点（end point） 在发送数据报时，采用创建好的本地套接字（标示ID），就不必在发送每个报文中指明自己所采用的ip和port 但是在发送报文时，必须要指定对方的ip和udp port(另外一个段节点) 套接字（Socket） 进程向套接字发送报文或从套接字接收报文 套接字 \u003c-\u003e 门户 发送进程将报文 门户，发送进程依赖于传输层设施在另外一侧的门将报文交付给接受进程 接收进程从另外一端的门户 报文（依赖于传输层设施） 问题3：如何使用传输层提供的服务，实现应用进程之间的报文交换，实现应用（用户使用服务） 定义应用层协议：报文格式，解释，时序等 定义了：运行在不同端系统上的应用 如何相互交换报文 交换的报文类型：请求和应答报文 各种报文类型的语法：报文中的各个字段及其描述 字段的语义：即字段取值的含义 进程何时、如何发送报文及对报文进行响应的规则 应用协议仅仅是应用的一个组成部分 Web应用：HTTP协议，web客户端，web服务器，HTML 公开协议： 由RFC文档定义 允许互操作 如HTTP, SMTP 专用（私有）协议： 协议不公开 如：Skype 如何描述传输层的服务？ 数据丢失率 有些应用则要求100%的可靠数据传输（如文件） 有些应用（如音频）能容忍一定比例以下的数据丢失延迟 延迟 一些应用 出于有效性考虑，对数据传输有严格的时间限制 Internet 电话、交互式游戏 延迟、延迟差 吞吐 一些应用（如多媒体）必须需要最小限度的吞吐，从而使得应用能够有效运转 一些应用能充分利用可供使用的吞吐(弹性应用) 安全性 机密性 完整性 可认证性（鉴别） 常见应用对传输服务的要求： Internet 传输层提供的服务 TCP 服务： 可靠的传输服务 流量控制：发送方不会淹没接受方 拥塞控制：当网络出现拥塞时，能抑制发送方 不能提供的服务：时间保证、最小吞吐保证和安全 面向连接：要求在客户端进程和服务器进程之间建立连接 UDP 服务 不可靠数据传输 不提供的服务：可靠，流量控制、拥塞控制、时间、带宽保证、建立连接 编制程序，使用OS提供的API ，调用网络基础设施提供通信服务传报文，实现应用时序等； UDP存在的必要性 能够区分不同的进程，而IP服务不能 在IP提供的主机到主机端到端功能的基础上，区分了主机的应用进程 无需建立连接，省去了建立连接时间，适合事务性的应用 不做可靠性的工作，例如检错重发，适合那些对实时性要求比较高而对正确性要求不高的应用 因为为了实现可靠性（准确性、保序等），必须付出时间代价（检错重发） 没有拥塞控制和流量控制，应用能够按照设定的速度发送数据 而在TCP上面的应用，应用发送数据的速度和主机向网络发送的实际速度是不一致的，因为有流量控制和拥塞控制 Internet应用及其应用层协议和传输协议：安全TCP TCP \u0026 UDP 都没有加密 明文通过互联网传输，甚至密码 SSL 在TCP上面实现，提供加密的TCP连接 私密性 数据完整性 端到端的鉴别 SSL在应用层 应用采用SSL库，SSL库使用TCP通信 SSL socket API 应用通过API将明文交给socket，SSL将其加密在互联网上传输 ","date":"2022-01-23 10:50:28","objectID":"https://qizhengzou.github.io/cn_base_02/:1:0","tags":["computer network"],"title":"CN_base_02","uri":"https://qizhengzou.github.io/cn_base_02/"},{"categories":["School courses"],"content":"2.2 Web and HTTP Web 与 HTTP 一些术语 Web页：由一些对象组成 对象可以是HTML文件、JPEG图像、Java小程序、声音剪辑文件等 Web页含有一个基本的HTML文件，该基本HTML文件又包含若干对象的引用（链接） 通过URL对每个对象进行引用 访问协议，用户名，口令字，端口，目录文件等； URL格式: Prot:// user:psw@ www.someSchool.edu:port/someDept/pic.gif [协议名][用户:口令][主机名 ][路径名 ][端口] HTTP概况 HTTP: 超文本传输协议 Web的应用层协议 客户/服务器模式 客户: 请求、接收和显示Web对象的浏览器 服务器: 对请求进行响应，发送对象的Web服务器 HTTP 1.0: RFC 1945 HTTP 1.1: RFC 2068 使用TCP: 客户发起一个与服务器的TCP连接 (建立套接字) ，端口号为 80 服务器接受客户的TCP连接 在浏览器(HTTP客户端)与 Web服务器(HTTP服务器 server)交换HTTP报文 (应用层协议报文) TCP连接关闭 HTTP是无状态的 服务器并不维护关于客户的任何信息 维护状态的协议很复杂！ 必须维护历史信息(状态) 如果服务器/客户端死机，它们的状态信息可能不一致，二者的信息必须是一致 无状态的服务器能够支持更多的客户端 HTTP连接 非持久HTTP 最多只有一个对象在TCP连接上发送 下载多个对象需要多个TCP连接 HTTP/1.0使用非持久连接 持久HTTP 多个对象可以在一个（在客户端和服务器之间的）TCP连接上传输 HTTP/1.1 默认使用持久连接 响应时间模型 往返时间RTT（round-trip time）：一个小的分组从客户端到服务器，在回到客户端的时间（传输时间忽略） 响应时间： 一个RTT用来发起TCP连接 一个 RTT用来HTTP请求并等待HTTP响应 文件传输时间 共：2RTT+传输时间 持久HTTP 非持久HTTP的缺点： 每个对象要2个 RTT 操作系统必须为每个TCP连接分配资源 但浏览器通常打开并行TCP连接，以获取引用对象 持久HTTP 服务器在发送响应后，仍保持TCP连接 在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送 客户端在遇到一个引用对象的时候，就可以尽快发送该对象的请求 非流水方式的持久HTTP： 客户端只能在收到前一个响应后才能发出新的请求 每个引用对象花费一个RTT 流水方式的持久HTTP： HTTP/1.1的默认模式 客户端遇到一个引用对象就立即产生一个请求 所有引用（小）对象只花费一个RTT是可能的 HTTP请求报文： 两种类型的HTTP报文：请求、响应 HTTP请求报文: ASCII (人能阅读) 通用格式 提交表单输入： Post方式： 网页通常包括表单输入 包含在实体主体(entity body )中的输入被提交到服务器 URL方式： 方法：GET 输入通过请求行的URL字段上载 方法类型： HTTP/1.0 GET POST HEAD 要求服务器在响应报文中不包含请求对象 -\u003e 故障跟踪 HTTP/1.1 GET, POST, HEAD PUT 将实体主体中的文件上载到URL字段规定的路径 DELETE 删除URL字段规定的 HTTP响应报文：HTTP响应状态码：位于服务器-\u003e客户端的响应报文中的首行一些状态码的例子： 200 OK 请求成功，请求对象包含在响应报文的后续部分 301 Moved Permanently 请求的对象已经被永久转移了；新的URL在响应报文的Location:首部行中指定 客户端软件自动用新的URL去获取对象 400 Bad Request 一个通用的差错代码，表示该请求不能被服务器解读 404 Not Found 请求的文档在该服务上没有找到 505 HTTP Version Not Supported 用户-服务器状态：cookies 大多数主要的门户网站使用 cookies 四个组成部分： 在HTTP响应报文中有一个cookie的首部行 在HTTP请求报文含有一个cookie的首部行 在用户端系统中保留有一个cookie文件，由用户的浏览器管理 在Web站点有一个后端数据库 例子： Susan总是用同一个PC使用Internet Explore上网 她第一次访问了一个使用了Cookie的电子商务网站 当最初的HTTP请求到达服务器时，该Web站点产生一个唯一的ID，并以此作为索引在它的后端数据库中产生一个项 如何维持状态： 协议端节点：在多个事务上，发送端和接收端维持状态 cookies: http报文携带状态信息 Cookies与隐私： Cookies允许站点知道许多关于用户的信息 可能将它知道的东西卖给第三方 使用重定向和cookie的搜索引擎还能知道用户更多的信息 如通过某个用户在大量站点上的行为，了解其个人浏览方式的大致模式 广告公司从站点获得信息 cookies:维护状态 Web缓存 (代理服务器) 目标：不访问 服务器，就满足客户的请求 用户设置浏览器： 通过缓存访问Web 浏览器将所有的HTTP 请求发给缓存 在缓存中的对象：缓存直接返回对象 如对象不在缓存，缓存请求原始服务器，然后再将对象返回给客户端 缓存既是客户端又是服务器 通常缓存是由ISP安装 (大学、公司、居民区ISP) 为什么要使用Web缓存？ 降低客户端的请求响应时间 可以大大减少一个机构内部网络与Internent接入链路上的流量 互联网大量采用了缓存：可以使较弱的ICP也能够有效提供内容 缓存示例： 可以更快地接入链路，但会因为接入链路带宽增加使代价昂贵。 可以安装本地缓存，使web缓存变得廉价。且可能比方法1延迟更低 条件GET方法： 目标：如果缓存器中的对象拷贝是最新的，就不要发送对象 缓存器: 在HTTP请求中指定缓存拷贝的日期 If-modified-since: \u003c date \u003e 服务器: 如果缓存拷贝陈旧，则响应报文没包含对象: HTTP/1.0 304 Not Modified ","date":"2022-01-23 10:50:28","objectID":"https://qizhengzou.github.io/cn_base_02/:2:0","tags":["computer network"],"title":"CN_base_02","uri":"https://qizhengzou.github.io/cn_base_02/"},{"categories":["School courses"],"content":"2.3 FTP* FTP文件传输协议： 向远程主机上传输文件或从远程主机接收文件 客户/服务器模式 客户端：发起传输的一方 服务器：远程主机 ftp: RFC 959 ftp服务器：端口号为2 FTP: 控制连接与数据连接分开 FTP客户端与FTP服务器通过端口21联系，并使用TCP为传输协议 客户端通过控制连接获得身份确认 客户端通过控制连接发送命令浏览远程目录 收到一个文件传输命令时，服务器打开一个到客户端的数据连接 一个文件传输完成后，服务器关闭连接 服务器打开第二个TCP数据连接用来传输另一个文件 控制连接： 带外（ “out of band” ）传送 FTP服务器维护用户的状态信息：当前路径、用户帐户与控制连接对应 = 有状态 FTP命令、响应： 命令样例： 在上以ASCII文本方式传送 USER username PASS password LIST 请服务器返回远程主机当前目录的文件列表 RETR filename 从远程主机的当前目录检索文件(gets) STOR filename 向远程主机的当前目录存放文件(puts) 返回码样例： 状态码和状态信息 (同HTTP) 331 Username OK, password required 125 data connection already open; transfer starting 425 Can t open data connection 452 Error writing file ","date":"2022-01-23 10:50:28","objectID":"https://qizhengzou.github.io/cn_base_02/:3:0","tags":["computer network"],"title":"CN_base_02","uri":"https://qizhengzou.github.io/cn_base_02/"},{"categories":["School courses"],"content":"2.4 Email 3个主要组成部分： 用户代理 又名 “邮件阅读器” 撰写、编辑和阅读邮件 如Outlook、Foxmail 输出和输入邮件保存在服务器上 邮件服务器 简单邮件传输协议：SMTP 邮件服务器： 邮箱中管理和维护发送给用户的邮件 输出报文队列保持待发送邮件报文 邮件服务器之间的SMTP协议：发送email报文 客户：发送方邮件服务器 服务器：接收端邮件服务器 ","date":"2022-01-23 10:50:28","objectID":"https://qizhengzou.github.io/cn_base_02/:4:0","tags":["computer network"],"title":"CN_base_02","uri":"https://qizhengzou.github.io/cn_base_02/"},{"categories":["School courses"],"content":"SMTP EMail: SMTP [RFC 2821] 使用TCP在客户端和服务器之间传送报文，端口号为25 直接传输：从发送方服务器到接收方服务器 传输的3个阶段 握手 传输报文 关闭 命令/响应交互 命令：ASCII文本 响应：状态码和状态信息 报文必须为7位ASCII 举例：Alice给Bob发送报文：简单的SMTP交互：SMTP：总结 SMTP使用持久连接 SMTP要求报文（首部和主体）为7位ASCII编码 SMTP服务器使用CRLF.CRLF决定报文的尾部 HTTP比较： HTTP：拉（pull） SMTP：推（push） 二者都是ASCII形式的命令/响应交互、状态码 HTTP：每个对象封装在各自的响应报文中 SMTP：多个对象包含在一个报文中 邮件报文格式：报文格式：多媒体扩展 MIME：多媒体邮件扩展（multimedia mail extension）, RFC 2045, 2056 在报文首部用额外的行申明MIME内容类型 邮件访问协议： SMTP: 传送到接收方的邮件服务器 邮件访问协议：从服务器访问邮件 POP：邮局访问协议（Post Office Protocol）[RFC 1939] 用户身份确认 (代理\u003c–\u003e服务器) 并下载 IMAP：Internet邮件访问协议（Internet Mail Access Protocol）[RFC 1730] 更多特性 (更复杂) 在服务器上处理存储的报文 HTTP：Hotmail , Yahoo! Mail等 方便 ","date":"2022-01-23 10:50:28","objectID":"https://qizhengzou.github.io/cn_base_02/:4:1","tags":["computer network"],"title":"CN_base_02","uri":"https://qizhengzou.github.io/cn_base_02/"},{"categories":["School courses"],"content":"POP3 \u0026 IMAP ","date":"2022-01-23 10:50:28","objectID":"https://qizhengzou.github.io/cn_base_02/:4:2","tags":["computer network"],"title":"CN_base_02","uri":"https://qizhengzou.github.io/cn_base_02/"},{"categories":["School courses"],"content":"2.5 DNS DNS的必要性 IP地址标识主机、路由器 但IP地址不好记忆，不便人类使用(没有意义) 人类一般倾向于使用一些有意义的字符串来标识Internet上的设备 例如：qzheng@ustc.edu.cn 所在的邮件服务器www.ustc.edu.cn 所在的web服务器 存在着“字符串”—IP地址的转换的必要性 人类用户提供要访问机器的“字符串”名称 由DNS负责转换成为二进制的网络地址 DNS系统需要解决的问题 问题1：如何命名设备 用有意义的字符串：好记，便于人类用使用 解决一个平面命名的重名问题：层次化命名 问题2：如何完成名字到IP地址的转换 分布式的数据库维护和响应名字查询 问题3：如何维护：增加或者删除一个域，需要在域名系统中做哪些工作 DNS(Domain Name System)的历史 ARPANET的名字解析解决方案 主机名：没有层次的一个字符串（一个平面） 存在着 维护站：维护着一张 主机名-IP地址的映射文件：Hosts.txt 每台主机定时从维护站取文件 ARPANET解决方案的问题 当网络中主机数量很大时 没有层次的主机名称很难分配 文件的管理、发布、查找都很麻烦 DNS(Domain Name System)总体思路和目标 DNS的主要思路 的、基于域的命名机制 若干分布式的数据库完成名字到IP地址的转换 运行在UDP之上端口号为53的应用服务 核心的Internet功能，但以应用层协议实现 在网络边缘处理复杂性 DNS主要目的： 实现主机名-IP地址的转换(name/IP translate) 其它目的 主机别名到规范名字的转换：Host aliasing 邮件服务器别名到邮件服务器的正规名字的转换：Mail server aliasing 负载均衡：Load Distribution 问题1：DNS名字空间(The DNS Name Space) DNS域名结构 一个层面命名设备会有很多重名 NDS采用层次树状结构的 命名方法 Internet 根被划为几百个顶级域(top lever domains) 通用的(generic) .com; .edu ; .gov ; .int ; .mil ; .net ; .org; .firm ; .hsop ; .web ; .arts ; .rec ; 国家的(countries) .cn ; .us ; .nl ; .jp 每个(子)域下面可划分为若干子域(subdomains) 树叶是主机 DNS: 根名字服务器DNS名字空间(The DNS Name Space): 域名(Domain Name) 从本域往上，直到树根 中间使用“.”间隔不同的级别 例如：ustc.edu.cn auto.ustc.edu.cn www.auto. ustc.edu.cn 域的域名：可以用于表示一个域 主机的域名：一个域上的一个主机 域名的管理 一个域管理其下的子域 .jp 被划分为 ac.jp co.jp .cn 被划分为 edu.cn com.cn 创建一个新的域，必须征得它所属域的同意 域与物理网络无关 域遵从组织界限，而不是物理网络 一个域的主机可以不在一个网络 一个网络的主机不一定在一个域 域的划分是逻辑的，而不是物理的 问题2：解析问题-名字服务器(Name Server) 一个名字服务器的问题 可靠性问题：单点故障 扩展性问题：通信容量 维护问题：远距离的集中式数据库 区域(zone) 区域的划分有区域管理者自己决定 将DNS名字空间划分为互不相交的区域，每个区域都是 树的一部分 名字服务器： 每个区域都有一个名字服务器：维护着它所管辖区域的权威信息(authoritative record) 名字服务器允许被放置在区域之外，以保障可靠性 名字空间划分为若干区域：Zone 权威DNS服务器：组织机构的DNS服务器， 提供组织机构服务器（如Web和mail）可访问的主机和IP之间的映射组织机构可以选择实现自己维护或由某个服务提供商来维护 TLD服务器 顶级域(TLD)服务器：负责顶级域名（如com, org, net, edu和gov）和所有国家级的顶级域名（如cn, uk, fr, ca, jp ） Network solutions 公司维护com TLD服务器 Educause公司维护edu TLD服务器 区域名字服务器维护资源记录 资源记录(resource records) 作用：维护 域名-IP地址(其它)的映射关系 位置：Name Server的分布式数据库中 RR格式: (domain_name, ttl, type,class,Value) Domain_name: 域名 Ttl: time to live : 生存时间(权威，缓冲记录) Class 类别 ：对于Internet，值为IN Value 值：可以是数字，域名或ASCII串 Type 类别：资源记录的类型—见下页 DNS记录 DNS ：保存资源记录(RR)的分布式数据库 资源记录(resource records) 一个例子 DNS(Domain Name System) DNS大致工作过程 应用调用 解析器(resolver) 解析器作为客户 向Name Server发出查询报文（封装在UDP段中） Name Server返回响应报文(name/ip) 本地名字服务器（Local Name Server） 并不严格属于层次结构 每个ISP (居民区的ISP、公司、大学）都有一个本地DNS服务器 也称为“默认名字服务器” 当一个主机发起一个DNS查询时，查询被送到其本地DNS服务器 起着代理的作用，将查询转发到层次结构 名字服务器(Name Server) 名字解析过程 目标名字在Local Name Server中 情况1：查询的名字在该区域内部 情况2：缓存(cashing) 当与本地名字服务器不能解析名字时，联系根名字服务器顺着根-TLD 一直找到 权威名 字服务器 递归查询： 名字解析负担都放在当前联络的名字服务器上 问题：根服务器的负担太重 解决： 迭代查询(iterated queries) 迭代查询 主机cis.poly.edu 想知道主机 gaia.cs.umass.edu的IP地址 根（及各级域名）服务器返回的不是查询结果，而是下一个NS的地址 最后由权威名字服务器给出解析结果 当前联络的服务器给出可以联系的服务器的名字 “我不知道这个名字，但可以向这个服务器请求” DNS协议、报文: DNS协议：查询和响应报文的报文格式相同 提高性能：缓存 一旦名字服务器学到了一个映射，就将该映射 缓存起来 根服务器通常都在本地服务器中缓存着 使得根服务器不用经常被访问 目的：提高效率 可能存在的问题：如果情况变化，缓存结果和 权威资源记录不一致 解决方案：TTL（默认2天） 问题3：维护问题：新增一个域 在上级域的名字服务器中增加两条记录，指向这个新增的子域的域名 和 域名服务器的地址 在新增子域 的名字服务器上运行名字服务器，负责本域的名字解析： 名字-\u003eIP地址 例子：在com域中建立一个“Network Utopia” 到注册登记机构注册域名networkutopia.com 需要向该机构提供权威DNS服务器（基本的、和辅助的）的名字和IP地址 登记机构在com TLD服务器中插入两条RR记录: (networkutopia.com, dns1.networkutopia.com, NS) (dns1.networkutopia.com, 212.212.212.1, A) 在networkutopia.com的权威服务器中确保有 用于Web服务器的www.networkuptopia.com的类型为A的记录 用于邮件服务器mail.networkutopia.com的类型为MX的记录 攻击DNS DDoS 攻击 对根服务器进行流量轰炸攻击：发送大量ping 没有成功 原因１：根目录服务器配置了流量过滤器，防火墙 原因２：Local DNS 服务器缓存了TLD服务器的IP地址, 因此无需查询根服务器 向TLD服务器流量轰炸攻击：发送大量查询 可能更危险 效果一般，大部分DNS缓存了TLD 重定向攻击 中间人攻击 截获查询，伪造回答，从而攻击某个（DNS回答指定的IP）站点 DNS中毒 发送伪造的应答给DNS服务器，希望它能够缓存这个虚假的结果 技术上较困难：分布式截获和伪造利用DNS基础设施进行DDoS 伪造某个IP进行查询， 攻击这个目标IP 查询放大，响应报文比查询报文大 效果有限 总的说来，DNS比较健壮 ","date":"2022-01-23 10:50:28","objectID":"https://qizhengzou.github.io/cn_base_02/:5:0","tags":["computer network"],"title":"CN_base_02","uri":"https://qizhengzou.github.io/cn_base_02/"},{"categories":["School courses"],"content":"2.6 P2P 应用 纯P2P架构 没有（或极少）一直运行的服务器 任意端系统都可以直接通信 利用peer的服务能力 Peer节点间歇上网，每次IP地址都有可能变化 例子: 文件分发 (BitTorrent) 流媒体(KanKan) VoIP (Skype) 文件分发: C/S vs P2P 问题: 从一台服务器分发文件（大小F）到N个peer 需要多少时间？ Peer节点上下载能力是有限的资源 P2P文件分发： BitTorrent Peer加入torrent: 一开始没有块，但是将会通过其他节点处累积文件块 向跟踪服务器注册，获得peer节点列表，和部分peer节点构成邻居关系 (“连接”) 当peer下载时，该peer可以同时向其他节点提供上载服务 Peer可能会变换用于交换块的peer节点 扰动churn: peer节点可能会上线或者下线 一旦一个peer拥有整个文件，它会（自私的）离开或者保留（利他主义）在torrent中 BitTorrent: 请求，发送文件块 请求块： 在任何给定时间，不同peer节点拥有一个文件块的子集 周期性的，Alice节点向邻居询问他们拥有哪些块的信息 Alice向peer节点请求它希望的块，稀缺的块 发送块：一报还一报tit-for-tat Alice向4个peer发送块，这些块向它自己提供最大带宽的服务 其他peer被Alice阻塞 (将不会从Alice处获得服务) 每10秒重新评估一次：前4位 每个30秒：随机选择其他peer节点，向这个节点发送块 “优化疏通” 这个节点 新选择的节点可以加入这个top 4 BitTorrent: tit-for-tat (1) Alice “优化疏通” Bob (2) Alice 变成了Bob的前4位提供者; Bob答谢Alice (3) Bob 变成了Alice的前4提供者 P2P文件共享例子: Alice在其笔记本电脑上运行P2P客户端程序 间歇性地连接到Internet，每次从其ISP得到新的IP地址 请求“双截棍.MP3” - 应用程序显示其他有“双截棍.MP3” 拷贝的对等方 Alice选择其中一个对等方，如Bob. 文件从Bob’s PC传送到Alice的笔记本上：HTTP 当Alice下载时，其他用户也可以从Alice处下载 Alice的对等方既是一个Web客户端，也是一个瞬时Web服务器 所有的对等方都是服务器= 可扩展性好！ P2P文件共享 两大问题： 如何定位所需资源 如何处理对等方的加入与离开 可能的方案 集中 分散 半分散 P2P：集中式目录 最初的“Napster”设计 当对等方连接时，它告知中心服务器： IP地址 内容 Alice查询 “双截棍.MP3” 3) Alice从Bob处请求文件 P2P：集中式目录中存在的问题（文件传输是分散的，而定位内容则是高度集中的） 单点故障 性能瓶颈 侵犯版权 查询洪泛：Gnutella 全分布式 没有中心服务器 开放文件共享协议 许多Gnutella客户端实现了Gnutella协议 类似HTTP有许多的浏览器 覆盖网络：图 如果X和Y之间有一个TCP连接，则二者之间存在一条边 所有活动的对等方和边就是覆盖网络 边并不是物理链路 给定一个对等方，通常所连接的节点少于10个 Gnutella：对等方加入 对等方X必须首先发现某些已经在覆盖网络中的其他对等方：使用可用对等方列表自己维持一张对等方列表（经常开机的对等方的IP）联系维持列表的Gnutella站点 X接着试图与该列表上的对等方建立TCP连接，直到与某个对等方Y建立连接 X向Y发送一个Ping报文，Y转发该Ping报文 所有收到Ping报文的对等方以Pong报文响应IP地址、共享文件的数量及总字节数 X收到许多Pong报文，然后它能建立其他TCP连接 利用不匀称性：KaZaA:KaZaA：查询 每个文件有一个散列标识码和一个描述符 客户端向其组长发送关键字查询 组长用匹配进行响应： 对每个匹配：元数据、散列标识码和IP地址 如果组长将查询转发给其他组长，其他组长也以匹配进行响应 客户端选择要下载的文件 向拥有文件的对等方发送一个带散列标识码的HTTP请求 Kazaa小技巧 请求排队 限制并行上载的数量 确保每个被传输的文件从上载节点接收一定量的带宽 激励优先权 鼓励用户上载文件 加强系统的扩展性 并行下载 从多个对等方下载同一个文件的不同部分 HTTP的字节范围首部 更快地检索一个文件 Distributed Hash Table (DHT) 哈希表 DHT方案 环形DHT 以及覆盖网络 Peer波动 ","date":"2022-01-23 10:50:28","objectID":"https://qizhengzou.github.io/cn_base_02/:6:0","tags":["computer network"],"title":"CN_base_02","uri":"https://qizhengzou.github.io/cn_base_02/"},{"categories":["School courses"],"content":"2.7 CDN 视频流化服务和CDN：上下文 视频流量：占据着互联网大部分的带宽 Netflix, YouTube: 占据37%, 16% 的ISP下行流量 ~1B YouTube 用户, ~75M Netflix用户 挑战：规模性-如何服务者 ~1B 用户? 单个超级服务器无法提供服务（为什么） 挑战：异构性 不同用户拥有不同的能力（例如：有线接入和移动用户；带宽丰富和受限用户） 解决方案: 分布式的，应用层面的基础设施 多媒体：视频 CBR: (constant bit rate): 以固定速率编码 VBR: (variable bit rate): 视频编码速率随时间的变化而变化 例子: MPEG 1 (CD-ROM) 1.5 Mbps MPEG2 (DVD) 3-6 Mbps MPEG4 (often used in Internet, \u003c 1 Mbps) 存储视频的流化服务：多媒体流化服务：DASH DASH: Dynamic, Adaptive Streaming over HTTP 服务器: 将视频文件分割成多个块 每个块独立存储，编码于不同码率（8-10种） 告示文件（manifest file）: 提供不同块的URL 客户端: 先获取告示文件 周期性地测量服务器到客户端的带宽 查询告示文件,在一个时刻请求一个块，HTTP头部指定字节范围 如果带宽足够，选择最大码率的视频块 会话中的不同时刻，可以切换请求不同的编码块 (取决于当时的可用带宽) 流式多媒体技术3: DASH “智能”客户端: 客户端自适应决定 什么时候去请求块 (不至于缓存挨饿，或者溢出) 请求什么编码速率的视频块 (当带宽够用时，请求高质量的视频块) 哪里去请求块 (可以向离自己近的服务器发送URL，或者向高可用带宽的服务器请求) Content Distribution Networks 挑战: 服务器如何通过网络向上百万用户同时流化视频内容 (上百万视频内容)? 选择1: 单个的、大的超级服务中心“mega server” 服务器到客户端路径上跳数较多，瓶颈链路的带宽小导致停顿 “二八规律”决定了网络同时充斥着同一个视频的多个拷贝，效率低（付费高、带宽浪费、效果差） 单点故障点，性能瓶颈 周边网络的拥塞 评述：相当简单，但是这个方法不可扩展 选项2: 通过CDN，全网部署缓存节点，存储服务内容，就近为用户提供服务，提高用户体验 enter deep: 将CDN服务器深入到许多接入网 更接近用户，数量多，离用户近，管理困难 Akamai, 1700个位置 bring home: 部署在少数(10个左右)关键位置，如将服务器簇安装于POP附近（离若干1stISP POP较近） 采用租用线路将服务器簇连接起来 Limelight CDN: 在CDN节点中存储内容的多个拷贝 e.g. Netflix stores copies of MadMen 用户从CDN中请求内容 重定向到最近的拷贝，请求内容 如果网络路径拥塞，可能选择不同的拷贝 Netflix:","date":"2022-01-23 10:50:28","objectID":"https://qizhengzou.github.io/cn_base_02/:7:0","tags":["computer network"],"title":"CN_base_02","uri":"https://qizhengzou.github.io/cn_base_02/"},{"categories":["School courses"],"content":"2.8 TCP 套接字（Socket ）编程 Socket编程 应用进程使用传输层提供的服务才能够交换报文，实现应用协议，实现应用 TCP/IP：应用进程使用Socket API访问传输服务 地点：界面上的SAP(Socket） 方式：Socket API 目标: 学习如何构建能借助sockets进行通信的C/S应用程序 socket: 分布式应用进程之间的门，传输层协议提供的端到端服务接口 2种传输层服务的socket类型: TCP: 可靠的、字节流的服务 UDP: 不可靠（数据UDP数据报）服务 TCP套接字编程 套接字：应用进程与端到端传输协议（TCP或UDP）之间的门户 TCP服务：从一个进程向另一个进程可靠地传输字节流 TCP套接字编程 服务器首先运行，等待连接建立 服务器进程必须先处于运行状态 创建欢迎socket 和本地端口捆绑 在欢迎socket上阻塞式等待接收用户的连接 客户端主动和服务器建立连接： 2. 创建客户端本地套接字（隐式捆绑到本地port） 指定服务器进程的IP地址和端口号，与服务器进程连接 连接API调用有效时，客户端P与服务器建立了TCP连接 当与客户端连接请求到来时 服务器接受来自用户端的请求，解除阻塞式等待，返回一个新的socket（与欢迎socket不一样），与客户端通信 允许服务器与多个客户端通信 使用源IP和源端口来区分不同的客户端 从应用程序的角度 TCP在客户端和服务器进程之间提供了可靠的、字节流（管道）服务 C/S模式的应用样例: 客户端从标准输入装置读取一行字符，发送给服务器 服务器从socket读取字符 服务器将字符转换成大写，然后返回给客户端 客户端从socket中读取一行字符，然后打印出来 C/S socket 交互: TCP 数据结构 sockaddr_in: IP地址和port捆绑关系的数据结构（标示进程的端节点） struct sockaddr_ in { short sin_ family;//AF INET u_ short sin_ port;// port struct in_ addr sin_ addr ;// IP address, unsigned long char sin_ zero[8]; // align }; 数据结构 hostent: 域名和IP地址的数据结构 struct hostent { char *h name; char **h_ aliases; int h_addrtype; int h_ length; /*地址长度*/ char **h_addr_list; #define h_ addr h_ addr_ list[0]; } 作为调用域名解析函数时的参数返回后，将IP地址拷贝到 sockaddr_in的IP地址部分 例子: C客户端(TCP) 例子: C服务器（TCP） ","date":"2022-01-23 10:50:28","objectID":"https://qizhengzou.github.io/cn_base_02/:8:0","tags":["computer network"],"title":"CN_base_02","uri":"https://qizhengzou.github.io/cn_base_02/"},{"categories":["School courses"],"content":"2.9 UDP 套接字编程 UDP Socket编程 UDP: 在客户端和服务器之间没有连接 没有握手 发送端在每一个报文中明确地指定目标的IP地址和端口号 服务器必须从收到的分组中提取出发送端的IP地址和端口号 UDP: 传送的数据可能乱序，也可能丢失 进程视角看UDP服务 UDP 为客户端和服务器提供不可靠的字节组的传送服务 Client/server socket 交互: UDP 样例: C客户端 (UDP) 样例: C服务器(UDP) ","date":"2022-01-23 10:50:28","objectID":"https://qizhengzou.github.io/cn_base_02/:9:0","tags":["computer network"],"title":"CN_base_02","uri":"https://qizhengzou.github.io/cn_base_02/"},{"categories":["School courses"],"content":"小结 应用程序体系结构 客户-服务器 P2P 混合 应用程序需要的服务品质描述: 可靠性、带宽、延时、安全 Internet传输层服务模式 可靠的、面向连接的服务：TCP 不可靠的数据报：UD 流行的应用层协议: HTTP FTP SMTP, POP, IMAP DNS Socket编程 更重要的：学习协议的知识 应用层协议报文类型：请求/响应报文： 客户端请求信息或服务 服务器以数据、状态码进行响应 报文格式： 首部：关于数据信息的字段 数据：被交换的信息 控制报文 vs. 数据报文 带内、带外 集中式 vs. 分散式 无状态 vs. 维护状态 可靠的 vs. 不可靠的报文传输 在网络边缘处理复杂性 一个协议定义了在两个或多个通信实体之间交换报文的格式和次序、以及就一条报文传输和接收或其他事件采取的动作 ","date":"2022-01-23 10:50:28","objectID":"https://qizhengzou.github.io/cn_base_02/:10:0","tags":["computer network"],"title":"CN_base_02","uri":"https://qizhengzou.github.io/cn_base_02/"},{"categories":["School courses"],"content":" 笔记来自 中科大郑烇 计网PPT，改编自计算机网络-自顶向下 第七版 概论 ","date":"2022-01-23 10:50:16","objectID":"https://qizhengzou.github.io/cn_base_01/:0:0","tags":["computer network"],"title":"CN_base_01","uri":"https://qizhengzou.github.io/cn_base_01/"},{"categories":["School courses"],"content":"1.1 什么是Internet? 具体构成角度： 计算设备 主机=端系统（运行网络应用程序） 通信链路 光纤、同轴电缆、无线电、卫星（传输速率：带宽（bps=BitPerSecond）） 分组交换设备 路由器和交换机（转发分组packets） 或者说： 节点 主机及其上运行的应用程序 路由器、交换机等网络交换设备 边：通信链路 接入网链路：主机连接到互联网的链路 主干链路：路由器间的链路 协议：控制发送、接收消息 eg:TCP,IP,HTTP,FTP,PPP…… Internet标准： RFC: Request for comments IETF: Internet Engineering Task Force 什么是协议： 发送特定的消息以及收到消息时采取的特定行动或其他事件 Internet 中所有的通信行为都受协议制约 协议定义了两个或多个通信实体之间交换的报文格式和次序，以及在报文传输或接收或其他事件方面所采取的行动。 服务角度看什么是Internet: 使用通信设施进行通信的分布式应用 Web、VoIP、email、分布式游戏、电子商务、社交网络 通信基础设施为apps提供编程接口（通信服务） 将发送和接收数据的apps与互联网连接起来 为app应用提供服务选择，类似于邮政服务： 无连接不可靠服务 面向连接的可靠服务 ","date":"2022-01-23 10:50:16","objectID":"https://qizhengzou.github.io/cn_base_01/:1:0","tags":["computer network"],"title":"CN_base_01","uri":"https://qizhengzou.github.io/cn_base_01/"},{"categories":["School courses"],"content":"1.2 网络边缘 网络结构： 网络边缘 主机 应用程序（客户端和服务器） 网络核心 互联着的路由器 网络的网络（互连的ISP互联网服务提供商以及公用Internet,专用Internet） 接入网、物理媒体 有线或者无线通信链路 网络边缘： 端系统（主机） 运行应用程序（web,email等） 在“网络的边缘” 客户/服务器模式 客户端向服务器请求、接收服务 如web浏览器/服务器；email客户端/服务器 对等（peer-peer）模式 很少或者没有专门的服务器 eg:Gnutella,KaZaA,Emule 网络边缘： 采用网络设施的面向连接服务 目标：在端系统之间传输数据 握手：在数据传输之前做好准备 人类协议：你好，你好 两个通信主机之间为连接建立状态 TCP-传输控制协议(Transmission Control Protocol) Internet上面向连接的服务 TCP服务[RFC 793] 可靠地按顺序地传送数据 确认和重传 流量控制 发送方不会淹没接收方 拥塞控制 当网络拥塞时，发送方降低发送速率 采用基础设施的无连接服务 目标：在端系统之间传输数据 无连接服务 UDP-用户数据报协议(User Datagram Protocol) 无连接 不可靠数据传输 无流量控制 无拥塞控制 使用TCP的应用 HTTP(Web) FTP(文件传送) Telnet(远程登陆) SMTP(email) 使用UDP的应用 流媒体 远程会议 DNS Internet电话 ","date":"2022-01-23 10:50:16","objectID":"https://qizhengzou.github.io/cn_base_01/:2:0","tags":["computer network"],"title":"CN_base_01","uri":"https://qizhengzou.github.io/cn_base_01/"},{"categories":["School courses"],"content":"1.3 网络核心 网络分类： 通信网络 电路交换网络 FDM TDM 分组交换网络 虚电路网络 数据报网络 网络核心的关键功能： 路由：决定分组采用的源到目标的路径（路由算法） 转发：将分组从路由器的输入链路转移到输出链路 网络核心：路由器的网状网络 数据怎样通过网络进行传输？ 电路交换 为每个呼叫预留一条专有电路：如电话网 分组交换 将要传送的数据分成一个个单位：分组 将分组从一个路由器传到相邻路由器（hop），一段段最终从源端传到目标端 每段：采用链路的最大传输能力（带宽） 网络核心：电路交换 端到端的资源被分配给从源端到目标端的呼叫 “call”： 独享资源：不同享 每个呼叫一旦建立起来就能够保证性能 如果呼叫没有数据发送，被分配的资源就会被浪费 (no sharing) 通常被传统电话网络采用 为呼叫预留端-端资源 链路带宽、交换能力 专用资源：不共享 保证性能 要求建立呼叫连 网络资源（如带宽）被分成片 为呼叫分配片 如果某个呼叫没有数据，则其资源片处于空闲状态（不共享） 将带宽分成片 频分(Frequency-division multiplexing) 时分(Time-division multiplexing) 波分(Wave-division multiplexing) 计算举例：在一个电路交换网络上，从主机A到主机B发送一个640,000比特的文件需要多长时间？ 所有的链路速率为1.536 Mbps 每条链路使用时隙数为24的TDM 建立端-端的电路需500 m 解： 每条链路的速率（一个时间片）：1.536Mbps/24=64kbps 传输事件：640kb/64kps=10s 共用时间：传输时间+建立链路时间=10s+500ms=10.5s 电路交换不适合计算机之间的通信 连接建立时间长 计算机之间的通信有突发性，如果使用线路交换，则浪费的片较多 即使这个呼叫没有数据传递，其所占据的片也不能够被别的呼叫使用 可靠性不高 网络核心：分组交换 以分组为单位存储-转发方式 网络带宽资源不再分分为一个个片，传输时使用全部带宽 主机之间传输的数据被分为一个个分组 资源共享，按需使用： 存储-转发：分组每次移动一跳（ hop ） 在转发之前，节点必须收到整个分组 延迟比线路交换要大 排队时间 分组交换 存储-转发 被传输到下一个链路之前，整个分组必须到达路由器：存储-转发 在一个速率为R bps的链路，一个长度为L bits 的分组的存储转发延时： L/R s 分组的存储转发一段一段从源端传到目标端，按照有无网络层的连接，分成： 数据报网络： 数据报工作原理： 在通信之前,无须建立起一个连接,有数据就传输 每一个分组都独立路由(路径不一样,可能会失序) 路由器根据分组的目标地址进行路 分组的目标地址决定下一跳 在不同的阶段，路由可以改变 类似：问路 Internent 虚电路网络： 虚电路工作原理： 每个分组都带标签（虚电路标识 VC ID），标签决定下一跳 在呼叫建立时决定路径，在整个呼叫中路径保持不变 路由器维持每个呼叫的状态信息 X.25 和ATM 排队延迟和丢失 排队和延迟： 如果到达速率 \u003e 链路的输出速率： 分组将会排队，等待传输 如果路由器的缓存用完了，分组将会被抛弃 统计多路复用 A\u0026B时复用链路资源，A\u0026B分组没有固定的模式，所有需要统计多路复用 分组交换VS电路交换 同样的网络资源，分组交换允许更多用户使用网络 分组交换是“突发数据的胜利者” 适合于对突发式数据传输 资源共享 简单，不必建立呼叫 过度使用会造成网络拥塞：分组延时和丢失 对可靠地数据传输需要协议来约束：拥塞控制 Q: 怎样提供类似电路交换的服务？ 保证音频/视频应用需要的带宽 一个仍未解决的问题(chapter 7) ","date":"2022-01-23 10:50:16","objectID":"https://qizhengzou.github.io/cn_base_01/:3:0","tags":["computer network"],"title":"CN_base_01","uri":"https://qizhengzou.github.io/cn_base_01/"},{"categories":["School courses"],"content":"1.4 接入网和物理媒体 ","date":"2022-01-23 10:50:16","objectID":"https://qizhengzou.github.io/cn_base_01/:4:0","tags":["computer network"],"title":"CN_base_01","uri":"https://qizhengzou.github.io/cn_base_01/"},{"categories":["School courses"],"content":"接入网 接入网：digital subscriber line (DSL,数字用户线) 接入网：线缆网络 接入网：家庭网络 怎样将端系统和边缘路由器连接？ 住宅接入网络（调制解调器modem） 将上网数据调制加载音频信号上，在电话线上传输，在局端将其中的数据解调出来；反之亦然 调频 调幅 调相位 综合调制 拨号调制解调器 56Kbps 的速率直接接入路由器(通常更低) 不能同时上网和打电话：不能总是在线 电缆模式 单位接入网络 （学校、公司） 无线接入网络 注意： 接入网络的带宽 (bits per second) 共享/专用 ","date":"2022-01-23 10:50:16","objectID":"https://qizhengzou.github.io/cn_base_01/:4:1","tags":["computer network"],"title":"CN_base_01","uri":"https://qizhengzou.github.io/cn_base_01/"},{"categories":["School courses"],"content":"物理媒体 Bit: 在发送-接收对间传播 物理链路：连接每个发送-接收对之间的物理媒体 导引型媒体: 信号沿着固体媒介被导引：同轴电缆、光纤、 双绞线 同轴电缆 两根同轴的铜导线 双向 基带电缆： 电缆上一个单个信道 Ethernet 宽带电缆： 电缆上有多个信道 HFC 光纤和光缆 光脉冲，每个脉冲表示一个bit，在玻璃纤维中传输 高速：点到点的高速传输（如10Gbps-100Gbps传输速率） 低误码率：在两个中继器之间可以有很长的距离，不受电磁噪声的干扰 安全 非导引型媒体： 开放的空间传输电磁波或者光信号，在电磁或者光信号中承载数字数据 无线链路： 开放空间传输电磁波，携带要传输的数据 无需物理“线缆” 双向 传播环境效应： 反射 吸收 干扰 类型有： 地面微波:45Mbps LAN（eg:wifi） wide-area（eg:蜂窝） 3G:~Mbps 4G:10Mbps 5G:数Gbps 卫星 每个信道Kbps到45Mbps（或者多个聚集信道） 270msec端到端延迟 同步静止卫星和低轨卫星 双绞线 (TP) 两根绝缘铜导线拧合 5类：100Mbps 以太网，Gbps 千兆位以太网 6类：10Gbps万兆以太 ","date":"2022-01-23 10:50:16","objectID":"https://qizhengzou.github.io/cn_base_01/:4:2","tags":["computer network"],"title":"CN_base_01","uri":"https://qizhengzou.github.io/cn_base_01/"},{"categories":["School courses"],"content":"1.5 Internet结构和ISP 互联网络结构：网络的网络 端系统通过接入ISPs (Internet Service Providers)连接到互联网 住宅，公司和大学的ISPs 接入ISPs相应的必须是互联的 因此任何2个端系统可相互发送分组到对方 导致的“网络的网络”非常复杂 发展和演化是通过经济的和国家的政策来驱动的 让我们采用渐进方法来描述当前互联网的结构 给定数百万接入ISPs，如何将它们互联到一起？ 但是，如果全局ISP是可行的业务，那会有竞争者有利可图，一定会有竞争。与此同时，通过ISP之间的合作可以完成业务的扩展，肯定会有互联，对等互联的结算关系 然后业务会细分（全球接入和区域接入），区域网络将出现，用与将接入ISPs连接到全局ISPs 然后内容提供商网络(Internet Content Providers,e.g., Google,Microsoft，Akamai) 可能会构建它们自己的网络，将它们的服务、内容更加靠近端用户，向用户提供更好的服务,减少自己的运营支出 很多内容提供商(如：Google, Akamai )可能会部署自己的网络,连接自己的在各地的DC（数据中心），走自己的数据 连接若干local ISP和各级（包括一层）ISP,更加靠近用户 ISP之间的连接 POP: 高层ISP面向客户网络的接入点，涉及费用结算 如一个低层ISP接入多个高层ISP，多宿（multi home） 对等接入：2个ISP对等互接，不涉及费用结算 IXP：多个对等ISP互联互通之处，通常不涉及费用结算 对等接入 ICP自己部署专用网络，同时和各级ISP连接 ","date":"2022-01-23 10:50:16","objectID":"https://qizhengzou.github.io/cn_base_01/:5:0","tags":["computer network"],"title":"CN_base_01","uri":"https://qizhengzou.github.io/cn_base_01/"},{"categories":["School courses"],"content":"1.6 分组延时、丢失和吞吐量 分组丢失和延时是怎样发生的？ 在路由器缓冲区的分组队列 分组到达链路的速率超过了链路输出的能力 分组等待排到队头、被传输 四种分组延时： 节点处理延时： 检查 bit级差错 检查分组首部和决定将分组导向何处 排队延时 在输出链路上等待传输的时间 依赖于路由器的拥塞程度 传输延时: R=链路带宽(bps) L=分组长度(bits) 将分组发送到链路上的时间= L/R 存储转发延时 传播延时: d = 物理链路的长度 s = 在媒体上的传播速度(~2x108 m/sec) 传播延时 = d/s 车队类比：节点延时： $d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}$ $d_{proc}$ = 处理延时 通常是微秒数量级或更少 $d_{queue}$ = 排队延时 取决于拥塞程度 $d_{trans}$ = 传输延时 = L/R, 对低速率的链路而言很大（如拨号），通常为微秒级到毫秒级 $d_{prop}$ = 传播延时 几微秒到几百毫秒 Internet的延时和路由 Internet 的延时和路由是什么样的呢? Traceroute 诊断程序: 提供从源端，经过路由器，到目的的延时测量 For all i: 沿着目的的路径，向每个路由器发送3个探测分组 路由器 i 将向发送方返回一个分组 发送方对发送和回复之间间隔计时 关于traceroute 在Windows系统下 Tracerert hostname 如 Tracerert www.gucas.ac.cn 更完整的例子 tracert [-d] [-h maximum_hops] [-j computer-list] [-w timeout] target_name 测试网址： www.traceroute.org www.linkwan.com 分组丢失： 链路的队列缓冲区容量有限 当分组到达一个满的队列时，该分组将会丢失 丢失的分组可能会被前一个节点或源端系统重传，或根本不重传 吞吐量： 吞吐量: 在源端和目标端之间传输的速率（数据量/单位时间） 瞬间吞吐量: 在一个时间点的速率 平均吞吐量: 在一个长时间内平均值 互联网场景： ","date":"2022-01-23 10:50:16","objectID":"https://qizhengzou.github.io/cn_base_01/:6:0","tags":["computer network"],"title":"CN_base_01","uri":"https://qizhengzou.github.io/cn_base_01/"},{"categories":["School courses"],"content":"1.7 协议层次及服务模型 网络是一个复杂的系统! 网络功能繁杂：数字信号的物理信号承载、点到点、路由、rdt、进程区分、应用等 现实来看，网络的许多构成元素和设备: 主机 路由器 各种媒体的链路 应用 协议 硬件,软件 如何组织和实现这个复杂的网络功能？ 层次化方式实现复杂网络功能: 将网络复杂的功能分层功能明确的层次，每一层实现了其中一个或一组功能，功能中有其上层可以使用的功能：服务 本层协议实体相互交互执行本层的协议动作，目的是实现本层功能，通过接口为上层提供更好的服务 在实现本层协议的时候，直接利用了下层所提供的服务 本层的服务：借助下层服务实现的本层协议实体之间交互带来的新功能（上层可以利用的）+更下层所提供的服务 服务和服务访问点： 服务( Service)：低层实体向上层实体提供它们之间的通信的能力 服务用户(service user) 服务提供者(service provider ) 原语(primitive)：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语来进行交互的形式 服务访问点 SAP (Services Access Point) ：上层使用下层提供的服务通过层间的接口—地点； 例子:邮箱 地址(address)：下层的一个实体支撑着上层的多个实体，SAP有标志不同上层实体的作用 可以有不同的实现，队列 例子:传输层的SAP: 端口(port) 服务的类型： 面向连接的服务和无连接的服务-方式 面向连接的服务（Connection-oriented Service） 连接 (Connection)：两个通信实体为进行通信而建立的一种结合 面向连接的服务通信的过程：建立连接，通信，拆除连接 面向连接的服务的例子：网络层的连接被成为虚电路 适用范围：对于大的数据块要传输; 不适合小的零星报文 特点：保序 服务类型: 可靠的信息流 传送页面(可靠的获得，通过接收方的确认) 可靠的字节流 远程登陆 不可靠的连接 数字化声音 面向连接的服务和无连接的服务 无连接的服务(Connectionless Service) 无连接服务：两个对等层实体在通信前不需要建立一个连接，不预留资源；不需要通信双方都是活跃；(例：寄信) 特点：不可靠、可能重复、可能失序 IP分组，数据包； 适用范围：适合传送零星数据； 服务类型： 不可靠的数据报 电子方式的函件 有确认的数据报 挂号信 请求回答 信息查询 服务和协议的区别和联系： 区别 服务(Service)：低层实体向上层实体提供它们之间的通信的能力，是通过原语(primitive)来操作的，垂直 协议(protocol) ：对等层实体(peer entity)之间在相互通信的过程中，需要遵循的规则的集合，水平 联系 本层协议的实现要靠下层提供的服务来实现 本层实体通过协议为上层提供更高级的服务 数据单元（DU） 分层处理和实现复杂系统的好处： 对付复杂的系统 概念化：结构清晰，便于标示网络组件，以及描述其相互关系 分层参考模型 结构化：模块化更易于维护和系统升级 改变某一层服务的实现不影响系统中的其他层次 对于其他层次而言是透明的 如改变登机程序并不影响系统的其它部分 改变2个秘书使用的通信方式不影响2个翻译的工作 改变2个翻译使用的语言也不影响上下2个层次的工作 Internet协议栈 应用层: 网络应用 为人类用户或者其他应用进程提供网络应用服务 FTP, SMTP, HTTP,DNS 传输层: 主机之间的数据传输 在网络层提供的端到端通信基础上，细分为进程到进程，将不可靠的通信变成可靠地通信 TCP, UDP 网络层: 为数据报从源到目的选择路由 主机主机之间的通信，端到端通信，不可靠 IP, 路由协议 链路层: 相邻网络节点间的数据传输 2个相邻2点的通信，点到点通信，可靠或不可靠 点对对协议PPP, 802.11(wifi), Ethernet 物理层: 在线路上传送bit ISO/OSI 参考模型: 表示层: 允许应用解释传输的数据, e.g., 加密，压缩，机 器相关的表示转换 会话层: 数据交换的同步，检查点，恢复 互联网协议栈没有这两层! 这些服务，如果需要的话，必须被应用实现 封装和解封装：各层次的协议数据单元 应用层：报文(message) 传输层：报文段(segment)：TCP段，UDP数据报 网络层：分组packet（如果无连接方式：数据报datagram） 数据链路层：帧(frame) 物理层：位(bit) ","date":"2022-01-23 10:50:16","objectID":"https://qizhengzou.github.io/cn_base_01/:7:0","tags":["computer network"],"title":"CN_base_01","uri":"https://qizhengzou.github.io/cn_base_01/"},{"categories":["School courses"],"content":"1.8 历史 ","date":"2022-01-23 10:50:16","objectID":"https://qizhengzou.github.io/cn_base_01/:8:0","tags":["computer network"],"title":"CN_base_01","uri":"https://qizhengzou.github.io/cn_base_01/"},{"categories":["School courses"],"content":"回顾与小结 什么是Internet ? 什么是协议? 网络边缘 接入网、物理媒体 网络核心：分组交换、线路交换 Internet/ISP 结构 性能：丢包、延时、吞吐量 协议层次、服务模型 历史 组成角度看 什么是互联网 边缘：端系统（包括应用）+接入网 核心：网络交换设备+通信链路 协议：对等层实体通信过程中遵守的规则的集合 语法，语义，时序 为了实现复杂的网络功能，采用分层方式设计、实现和调试 应用层，传输层，网络层，数据链路层，物理层 协议数据单位： 报文，报文段，分组，帧，位 从服务角度看互联网 通信服务基础设施 提供的通信服务：面向连接 无连接 应用 应用之间的交互 C/S模式 P2P模 数据交换 分组数据交换 线路交换 比较线路交换和分组交换 分组交换的2种方式 虚电路 数据报 接入网和物理媒介 接入网技术： 住宅：ADSL，拨号，cable modem 单位：以太网 无线接入方式 物理媒介 光纤，同轴电缆，以太网，双绞线 ISP层次结构 分组交换网络中延迟和丢失是如何发生的 延迟的组成：处理、传输、传播、排队 网络的分层体系结构 分层体系结构 服务 协议数据单元 封装与解封装 历史 ","date":"2022-01-23 10:50:16","objectID":"https://qizhengzou.github.io/cn_base_01/:9:0","tags":["computer network"],"title":"CN_base_01","uri":"https://qizhengzou.github.io/cn_base_01/"},{"categories":["Coding"],"content":"facade API 为facade 模块的外观接口，大部分代码使用此接口简化对facade类的访问。 facade模块同时暴露了a和b 两个Module 的NewXXX和interface，其它代码如果需要使用细节功能时可以直接调用。 package facade import \"fmt\" func NewAPI() API { return \u0026apiImpl{ a: NewAModuleAPI(), b: NewBModuleAPI(), } } //API is facade interface of facade package type API interface { Test() string } //facade implement type apiImpl struct { a AModuleAPI b BModuleAPI } func (a *apiImpl) Test() string { aRet := a.a.TestA() bRet := a.b.TestB() return fmt.Sprintf(\"%s\\n%s\", aRet, bRet) } //NewAModuleAPI return new AModuleAPI func NewAModuleAPI() AModuleAPI { return \u0026aModuleImpl{} } //AModuleAPI ... type AModuleAPI interface { TestA() string } type aModuleImpl struct{} func (*aModuleImpl) TestA() string { return \"A module running\" } //NewBModuleAPI return new BModuleAPI func NewBModuleAPI() BModuleAPI { return \u0026bModuleImpl{} } //BModuleAPI ... type BModuleAPI interface { TestB() string } type bModuleImpl struct{} func (*bModuleImpl) TestB() string { return \"B module running\" } package facade import \"testing\" var expect = \"A module running\\nB module running\" // TestFacadeAPI ... func TestFacadeAPI(t *testing.T) { api := NewAPI() ret := api.Test() if ret != expect { t.Fatalf(\"expect %s, return %s\", expect, ret) } } ","date":"2022-01-22 09:21:00","objectID":"https://qizhengzou.github.io/structural_type/:1:0","tags":["design mode"],"title":"Structural_type","uri":"https://qizhengzou.github.io/structural_type/"},{"categories":["Coding"],"content":"adapter 适配器模式用于转换一种接口适配另一种接口。 实际使用中Adaptee一般为接口，并且使用工厂函数生成实例。 在Adapter中匿名组合Adaptee接口，所以Adapter类也拥有SpecificRequest实例方法，又因为Go语言中非入侵式接口特征，其实Adapter也适配Adaptee接口。 package adapter //Target 是适配的目标接口 type Target interface { Request() string } //Adaptee 是被适配的目标接口 type Adaptee interface { SpecificRequest() string } //NewAdaptee 是被适配接口的工厂函数 func NewAdaptee() Adaptee { return \u0026adapteeImpl{} } //AdapteeImpl 是被适配的目标类 type adapteeImpl struct{} //SpecificRequest 是目标类的一个方法 func (*adapteeImpl) SpecificRequest() string { return \"adaptee method\" } //NewAdapter 是Adapter的工厂函数 func NewAdapter(adaptee Adaptee) Target { return \u0026adapter{ Adaptee: adaptee, } } //Adapter 是转换Adaptee为Target接口的适配器 type adapter struct { Adaptee } //Request 实现Target接口 func (a *adapter) Request() string { return a.SpecificRequest() } package adapter import \"testing\" var expect = \"adaptee method\" func TestAdapter(t *testing.T) { adaptee := NewAdaptee() target := NewAdapter(adaptee) res := target.Request() if res != expect { t.Fatalf(\"expect: %s, actual: %s\", expect, res) } } ","date":"2022-01-22 09:21:00","objectID":"https://qizhengzou.github.io/structural_type/:2:0","tags":["design mode"],"title":"Structural_type","uri":"https://qizhengzou.github.io/structural_type/"},{"categories":["Coding"],"content":"proxy 代理模式用于延迟处理操作或者在进行实际操作前后进行其它处理。 代理模式的常见用法有 虚代理 COW代理 远程代理 保护代理 Cache 代理 防火墙代理 同步代理 智能指引 等。。。 package proxy type Subject interface { Do() string } type RealSubject struct{} func (RealSubject) Do() string { return \"real\" } type Proxy struct { real RealSubject } func (p Proxy) Do() string { var res string // 在调用真实对象之前的工作，检查缓存，判断权限，实例化真实对象等。。 res += \"pre:\" // 调用真实对象 res += p.real.Do() // 调用之后的操作，如缓存结果，对结果进行处理等。。 res += \":after\" return res } package proxy import \"testing\" func TestProxy(t *testing.T) { var sub Subject sub = \u0026Proxy{} res := sub.Do() if res != \"pre:real:after\" { t.Fail() } } ","date":"2022-01-22 09:21:00","objectID":"https://qizhengzou.github.io/structural_type/:3:0","tags":["design mode"],"title":"Structural_type","uri":"https://qizhengzou.github.io/structural_type/"},{"categories":["Coding"],"content":"composite 组合模式统一对象和对象集，使得使用相同接口使用对象和对象集。 组合模式常用于树状结构，用于统一叶子节点和树节点的访问，并且可以用于应用某一操作到所有子节点。 package composite import \"fmt\" type Component interface { Parent() Component SetParent(Component) Name() string SetName(string) AddChild(Component) Print(string) } const ( LeafNode = iota CompositeNode ) func NewComponent(kind int, name string) Component { var c Component switch kind { case LeafNode: c = NewLeaf() case CompositeNode: c = NewComposite() } c.SetName(name) return c } type component struct { parent Component name string } func (c *component) Parent() Component { return c.parent } func (c *component) SetParent(parent Component) { c.parent = parent } func (c *component) Name() string { return c.name } func (c *component) SetName(name string) { c.name = name } func (c *component) AddChild(Component) {} func (c *component) Print(string) {} type Leaf struct { component } func NewLeaf() *Leaf { return \u0026Leaf{} } func (c *Leaf) Print(pre string) { fmt.Printf(\"%s-%s\\n\", pre, c.Name()) } type Composite struct { component childs []Component } func NewComposite() *Composite { return \u0026Composite{ childs: make([]Component, 0), } } func (c *Composite) AddChild(child Component) { child.SetParent(c) c.childs = append(c.childs, child) } func (c *Composite) Print(pre string) { fmt.Printf(\"%s+%s\\n\", pre, c.Name()) pre += \" \" for _, comp := range c.childs { comp.Print(pre) } } package composite func ExampleComposite() { root := NewComponent(CompositeNode, \"root\") c1 := NewComponent(CompositeNode, \"c1\") c2 := NewComponent(CompositeNode, \"c2\") c3 := NewComponent(CompositeNode, \"c3\") l1 := NewComponent(LeafNode, \"l1\") l2 := NewComponent(LeafNode, \"l2\") l3 := NewComponent(LeafNode, \"l3\") root.AddChild(c1) root.AddChild(c2) c1.AddChild(c3) c1.AddChild(l1) c2.AddChild(l2) c2.AddChild(l3) root.Print(\"\") // Output: // +root // +c1 // +c3 // -l1 // +c2 // -l2 // -l3 } ","date":"2022-01-22 09:21:00","objectID":"https://qizhengzou.github.io/structural_type/:4:0","tags":["design mode"],"title":"Structural_type","uri":"https://qizhengzou.github.io/structural_type/"},{"categories":["Coding"],"content":"flyweight 享元模式从对象中剥离出不发生改变且多个实例需要的重复数据，独立出一个享元，使多个对象共享，从而节省内存以及减少对象数量。 package flyweight import \"fmt\" type ImageFlyweightFactory struct { maps map[string]*ImageFlyweight } var imageFactory *ImageFlyweightFactory func GetImageFlyweightFactory() *ImageFlyweightFactory { if imageFactory == nil { imageFactory = \u0026ImageFlyweightFactory{ maps: make(map[string]*ImageFlyweight), } } return imageFactory } func (f *ImageFlyweightFactory) Get(filename string) *ImageFlyweight { image := f.maps[filename] if image == nil { image = NewImageFlyweight(filename) f.maps[filename] = image } return image } type ImageFlyweight struct { data string } func NewImageFlyweight(filename string) *ImageFlyweight { // Load image file data := fmt.Sprintf(\"image data %s\", filename) return \u0026ImageFlyweight{ data: data, } } func (i *ImageFlyweight) Data() string { return i.data } type ImageViewer struct { *ImageFlyweight } func NewImageViewer(filename string) *ImageViewer { image := GetImageFlyweightFactory().Get(filename) return \u0026ImageViewer{ ImageFlyweight: image, } } func (i *ImageViewer) Display() { fmt.Printf(\"Display: %s\\n\", i.Data()) } package flyweight import \"testing\" func ExampleFlyweight() { viewer := NewImageViewer(\"image1.png\") viewer.Display() // Output: // Display: image data image1.png } func TestFlyweight(t *testing.T) { viewer1 := NewImageViewer(\"image1.png\") viewer2 := NewImageViewer(\"image1.png\") if viewer1.ImageFlyweight != viewer2.ImageFlyweight { t.Fail() } } ","date":"2022-01-22 09:21:00","objectID":"https://qizhengzou.github.io/structural_type/:5:0","tags":["design mode"],"title":"Structural_type","uri":"https://qizhengzou.github.io/structural_type/"},{"categories":["Coding"],"content":"decorator 装饰模式使用对象组合的方式动态改变或增加对象行为。 Go语言借助于匿名组合和非入侵式接口可以很方便实现装饰模式。 使用匿名组合，在装饰器中不必显式定义转调原对象方法。 package decorator type Component interface { Calc() int } type ConcreteComponent struct{} func (*ConcreteComponent) Calc() int { return 0 } type MulDecorator struct { Component num int } func WarpMulDecorator(c Component, num int) Component { return \u0026MulDecorator{ Component: c, num: num, } } func (d *MulDecorator) Calc() int { return d.Component.Calc() * d.num } type AddDecorator struct { Component num int } func WarpAddDecorator(c Component, num int) Component { return \u0026AddDecorator{ Component: c, num: num, } } func (d *AddDecorator) Calc() int { return d.Component.Calc() + d.num } package decorator import \"fmt\" func ExampleDecorator() { var c Component = \u0026ConcreteComponent{} c = WarpAddDecorator(c, 10) c = WarpMulDecorator(c, 8) res := c.Calc() fmt.Printf(\"res %d\\n\", res) // Output: // res 80 } ","date":"2022-01-22 09:21:00","objectID":"https://qizhengzou.github.io/structural_type/:6:0","tags":["design mode"],"title":"Structural_type","uri":"https://qizhengzou.github.io/structural_type/"},{"categories":["Coding"],"content":"bridge 桥接模式分离抽象部分和实现部分。使得两部分独立扩展。 桥接模式类似于策略模式，区别在于策略模式封装一系列算法使得算法可以互相替换。 策略模式使抽象部分和实现部分分离，可以独立变化。 package bridge import \"fmt\" type AbstractMessage interface { SendMessage(text, to string) } type MessageImplementer interface { Send(text, to string) } type MessageSMS struct{} func ViaSMS() MessageImplementer { return \u0026MessageSMS{} } func (*MessageSMS) Send(text, to string) { fmt.Printf(\"send %s to %s via SMS\", text, to) } type MessageEmail struct{} func ViaEmail() MessageImplementer { return \u0026MessageEmail{} } func (*MessageEmail) Send(text, to string) { fmt.Printf(\"send %s to %s via Email\", text, to) } type CommonMessage struct { method MessageImplementer } func NewCommonMessage(method MessageImplementer) *CommonMessage { return \u0026CommonMessage{ method: method, } } func (m *CommonMessage) SendMessage(text, to string) { m.method.Send(text, to) } type UrgencyMessage struct { method MessageImplementer } func NewUrgencyMessage(method MessageImplementer) *UrgencyMessage { return \u0026UrgencyMessage{ method: method, } } func (m *UrgencyMessage) SendMessage(text, to string) { m.method.Send(fmt.Sprintf(\"[Urgency] %s\", text), to) } package bridge func ExampleCommonSMS() { m := NewCommonMessage(ViaSMS()) m.SendMessage(\"have a drink?\", \"bob\") // Output: // send have a drink? to bob via SMS } func ExampleCommonEmail() { m := NewCommonMessage(ViaEmail()) m.SendMessage(\"have a drink?\", \"bob\") // Output: // send have a drink? to bob via Email } func ExampleUrgencySMS() { m := NewUrgencyMessage(ViaSMS()) m.SendMessage(\"have a drink?\", \"bob\") // Output: // send [Urgency] have a drink? to bob via SMS } func ExampleUrgencyEmail() { m := NewUrgencyMessage(ViaEmail()) m.SendMessage(\"have a drink?\", \"bob\") // Output: // send [Urgency] have a drink? to bob via Email } 参考 ","date":"2022-01-22 09:21:00","objectID":"https://qizhengzou.github.io/structural_type/:7:0","tags":["design mode"],"title":"Structural_type","uri":"https://qizhengzou.github.io/structural_type/"},{"categories":["Coding"],"content":"mediator 中介者模式封装对象之间互交，使依赖变的简单，并且使复杂互交简单化，封装在中介者中。 例子中的中介者使用单例模式生成中介者。 中介者的change使用switch判断类型。 package mediator import ( \"fmt\" \"strings\" ) type CDDriver struct { Data string } func (c *CDDriver) ReadData() { c.Data = \"music,image\" fmt.Printf(\"CDDriver: reading data %s\\n\", c.Data) GetMediatorInstance().changed(c) } type CPU struct { Video string Sound string } func (c *CPU) Process(data string) { sp := strings.Split(data, \",\") c.Sound = sp[0] c.Video = sp[1] fmt.Printf(\"CPU: split data with Sound %s, Video %s\\n\", c.Sound, c.Video) GetMediatorInstance().changed(c) } type VideoCard struct { Data string } func (v *VideoCard) Display(data string) { v.Data = data fmt.Printf(\"VideoCard: display %s\\n\", v.Data) GetMediatorInstance().changed(v) } type SoundCard struct { Data string } func (s *SoundCard) Play(data string) { s.Data = data fmt.Printf(\"SoundCard: play %s\\n\", s.Data) GetMediatorInstance().changed(s) } type Mediator struct { CD *CDDriver CPU *CPU Video *VideoCard Sound *SoundCard } var mediator *Mediator func GetMediatorInstance() *Mediator { if mediator == nil { mediator = \u0026Mediator{} } return mediator } func (m *Mediator) changed(i interface{}) { switch inst := i.(type) { case *CDDriver: m.CPU.Process(inst.Data) case *CPU: m.Sound.Play(inst.Sound) m.Video.Display(inst.Video) } } package mediator import \"testing\" func TestMediator(t *testing.T) { mediator := GetMediatorInstance() mediator.CD = \u0026CDDriver{} mediator.CPU = \u0026CPU{} mediator.Video = \u0026VideoCard{} mediator.Sound = \u0026SoundCard{} //Tiggle mediator.CD.ReadData() if mediator.CD.Data != \"music,image\" { t.Fatalf(\"CD unexpect data %s\", mediator.CD.Data) } if mediator.CPU.Sound != \"music\" { t.Fatalf(\"CPU unexpect sound data %s\", mediator.CPU.Sound) } if mediator.CPU.Video != \"image\" { t.Fatalf(\"CPU unexpect video data %s\", mediator.CPU.Video) } if mediator.Video.Data != \"image\" { t.Fatalf(\"VidoeCard unexpect data %s\", mediator.Video.Data) } if mediator.Sound.Data != \"music\" { t.Fatalf(\"SoundCard unexpect data %s\", mediator.Sound.Data) } } ","date":"2022-01-22 09:20:41","objectID":"https://qizhengzou.github.io/behavioral_type/:1:0","tags":["design mode"],"title":"Behavioral_type","uri":"https://qizhengzou.github.io/behavioral_type/"},{"categories":["Coding"],"content":"observer 观察者模式用于触发联动。 一个对象的改变会触发其它观察者的相关动作，而此对象无需关心连动对象的具体实现。 package observer import \"fmt\" type Subject struct { observers []Observer context string } func NewSubject() *Subject { return \u0026Subject{ observers: make([]Observer, 0), } } func (s *Subject) Attach(o Observer) { s.observers = append(s.observers, o) } func (s *Subject) notify() { for _, o := range s.observers { o.Update(s) } } func (s *Subject) UpdateContext(context string) { s.context = context s.notify() } type Observer interface { Update(*Subject) } type Reader struct { name string } func NewReader(name string) *Reader { return \u0026Reader{ name: name, } } func (r *Reader) Update(s *Subject) { fmt.Printf(\"%s receive %s\\n\", r.name, s.context) } package observer func ExampleObserver() { subject := NewSubject() reader1 := NewReader(\"reader1\") reader2 := NewReader(\"reader2\") reader3 := NewReader(\"reader3\") subject.Attach(reader1) subject.Attach(reader2) subject.Attach(reader3) subject.UpdateContext(\"observer mode\") // Output: // reader1 receive observer mode // reader2 receive observer mode // reader3 receive observer mode } ","date":"2022-01-22 09:20:41","objectID":"https://qizhengzou.github.io/behavioral_type/:2:0","tags":["design mode"],"title":"Behavioral_type","uri":"https://qizhengzou.github.io/behavioral_type/"},{"categories":["Coding"],"content":"command 命令模式本质是把某个对象的方法调用封装到对象中，方便传递、存储、调用。 示例中把主板单中的启动(start)方法和重启(reboot)方法封装为命令对象，再传递到主机(box)对象中。于两个按钮进行绑定： 第一个机箱(box1)设置按钮1(button1) 为开机按钮2(button2)为重启。 第二个机箱(box1)设置按钮2(button2) 为开机按钮1(button1)为重启。 从而得到配置灵活性。 除了配置灵活外，使用命令模式还可以用作： 批处理 任务队列 undo, redo 等把具体命令封装到对象中使用的场合 package command import \"fmt\" type Command interface { Execute() } type StartCommand struct { mb *MotherBoard } func NewStartCommand(mb *MotherBoard) *StartCommand { return \u0026StartCommand{ mb: mb, } } func (c *StartCommand) Execute() { c.mb.Start() } type RebootCommand struct { mb *MotherBoard } func NewRebootCommand(mb *MotherBoard) *RebootCommand { return \u0026RebootCommand{ mb: mb, } } func (c *RebootCommand) Execute() { c.mb.Reboot() } type MotherBoard struct{} func (*MotherBoard) Start() { fmt.Print(\"system starting\\n\") } func (*MotherBoard) Reboot() { fmt.Print(\"system rebooting\\n\") } type Box struct { button1 Command button2 Command } func NewBox(button1, button2 Command) *Box { return \u0026Box{ button1: button1, button2: button2, } } func (b *Box) PressButton1() { b.button1.Execute() } func (b *Box) PressButton2() { b.button2.Execute() } package command func ExampleCommand() { mb := \u0026MotherBoard{} startCommand := NewStartCommand(mb) rebootCommand := NewRebootCommand(mb) box1 := NewBox(startCommand, rebootCommand) box1.PressButton1() box1.PressButton2() box2 := NewBox(rebootCommand, startCommand) box2.PressButton1() box2.PressButton2() // Output: // system starting // system rebooting // system rebooting // system starting } ","date":"2022-01-22 09:20:41","objectID":"https://qizhengzou.github.io/behavioral_type/:3:0","tags":["design mode"],"title":"Behavioral_type","uri":"https://qizhengzou.github.io/behavioral_type/"},{"categories":["Coding"],"content":"iterator 迭代器模式用于使用相同方式送代不同类型集合或者隐藏集合类型的具体实现。 可以使用迭代器模式使遍历同时应用送代策略，如请求新对象、过滤、处理对象等。 package iterator import \"fmt\" type Aggregate interface { Iterator() Iterator } type Iterator interface { First() IsDone() bool Next() interface{} } type Numbers struct { start, end int } func NewNumbers(start, end int) *Numbers { return \u0026Numbers{ start: start, end: end, } } func (n *Numbers) Iterator() Iterator { return \u0026NumbersIterator{ numbers: n, next: n.start, } } type NumbersIterator struct { numbers *Numbers next int } func (i *NumbersIterator) First() { i.next = i.numbers.start } func (i *NumbersIterator) IsDone() bool { return i.next \u003e i.numbers.end } func (i *NumbersIterator) Next() interface{} { if !i.IsDone() { next := i.next i.next++ return next } return nil } func IteratorPrint(i Iterator) { for i.First(); !i.IsDone(); { c := i.Next() fmt.Printf(\"%#v\\n\", c) } } package iterator func ExampleIterator() { var aggregate Aggregate aggregate = NewNumbers(1, 10) IteratorPrint(aggregate.Iterator()) // Output: // 1 // 2 // 3 // 4 // 5 // 6 // 7 // 8 // 9 // 10 } ","date":"2022-01-22 09:20:41","objectID":"https://qizhengzou.github.io/behavioral_type/:4:0","tags":["design mode"],"title":"Behavioral_type","uri":"https://qizhengzou.github.io/behavioral_type/"},{"categories":["Coding"],"content":"template method 模版方法模式使用继承机制，把通用步骤和通用方法放到父类中，把具体实现延迟到子类中实现。使得实现符合开闭原则。 如实例代码中通用步骤在父类中实现（准备、下载、保存、收尾）下载和保存的具体实现留到子类中，并且提供 保存方法的默认实现。 因为Golang不提供继承机制，需要使用匿名组合模拟实现继承。 此处需要注意：因为父类需要调用子类方法，所以子类需要匿名组合父类的同时，父类需要持有子类的引用。 package templatemethod import \"fmt\" type Downloader interface { Download(uri string) } type template struct { implement uri string } type implement interface { download() save() } func newTemplate(impl implement) *template { return \u0026template{ implement: impl, } } func (t *template) Download(uri string) { t.uri = uri fmt.Print(\"prepare downloading\\n\") t.implement.download() t.implement.save() fmt.Print(\"finish downloading\\n\") } func (t *template) save() { fmt.Print(\"default save\\n\") } type HTTPDownloader struct { *template } func NewHTTPDownloader() Downloader { downloader := \u0026HTTPDownloader{} template := newTemplate(downloader) downloader.template = template return downloader } func (d *HTTPDownloader) download() { fmt.Printf(\"download %s via http\\n\", d.uri) } func (*HTTPDownloader) save() { fmt.Printf(\"http save\\n\") } type FTPDownloader struct { *template } func NewFTPDownloader() Downloader { downloader := \u0026FTPDownloader{} template := newTemplate(downloader) downloader.template = template return downloader } func (d *FTPDownloader) download() { fmt.Printf(\"download %s via ftp\\n\", d.uri) } package templatemethod func ExampleHTTPDownloader() { var downloader Downloader = NewHTTPDownloader() downloader.Download(\"http://example.com/abc.zip\") // Output: // prepare downloading // download http://example.com/abc.zip via http // http save // finish downloading } func ExampleFTPDownloader() { var downloader Downloader = NewFTPDownloader() downloader.Download(\"ftp://example.com/abc.zip\") // Output: // prepare downloading // download ftp://example.com/abc.zip via ftp // default save // finish downloading } ","date":"2022-01-22 09:20:41","objectID":"https://qizhengzou.github.io/behavioral_type/:5:0","tags":["design mode"],"title":"Behavioral_type","uri":"https://qizhengzou.github.io/behavioral_type/"},{"categories":["Coding"],"content":"strategy 定义一系列算法，让这些算法在运行时可以互换，使得分离算法，符合开闭原则。 package strategy import \"fmt\" type Payment struct { context *PaymentContext strategy PaymentStrategy } type PaymentContext struct { Name, CardID string Money int } func NewPayment(name, cardid string, money int, strategy PaymentStrategy) *Payment { return \u0026Payment{ context: \u0026PaymentContext{ Name: name, CardID: cardid, Money: money, }, strategy: strategy, } } func (p *Payment) Pay() { p.strategy.Pay(p.context) } type PaymentStrategy interface { Pay(*PaymentContext) } type Cash struct{} func (*Cash) Pay(ctx *PaymentContext) { fmt.Printf(\"Pay $%d to %s by cash\", ctx.Money, ctx.Name) } type Bank struct{} func (*Bank) Pay(ctx *PaymentContext) { fmt.Printf(\"Pay $%d to %s by bank account %s\", ctx.Money, ctx.Name, ctx.CardID) } package strategy func ExamplePayByCash() { payment := NewPayment(\"Ada\", \"\", 123, \u0026Cash{}) payment.Pay() // Output: // Pay $123 to Ada by cash } func ExamplePayByBank() { payment := NewPayment(\"Bob\", \"0002\", 888, \u0026Bank{}) payment.Pay() // Output: // Pay $888 to Bob by bank account 0002 } ","date":"2022-01-22 09:20:41","objectID":"https://qizhengzou.github.io/behavioral_type/:6:0","tags":["design mode"],"title":"Behavioral_type","uri":"https://qizhengzou.github.io/behavioral_type/"},{"categories":["Coding"],"content":"state 状态模式用于分离状态和行为。 package state import \"fmt\" type Week interface { Today() Next(*DayContext) } type DayContext struct { today Week } func NewDayContext() *DayContext { return \u0026DayContext{ today: \u0026Sunday{}, } } func (d *DayContext) Today() { d.today.Today() } func (d *DayContext) Next() { d.today.Next(d) } type Sunday struct{} func (*Sunday) Today() { fmt.Printf(\"Sunday\\n\") } func (*Sunday) Next(ctx *DayContext) { ctx.today = \u0026Monday{} } type Monday struct{} func (*Monday) Today() { fmt.Printf(\"Monday\\n\") } func (*Monday) Next(ctx *DayContext) { ctx.today = \u0026Tuesday{} } type Tuesday struct{} func (*Tuesday) Today() { fmt.Printf(\"Tuesday\\n\") } func (*Tuesday) Next(ctx *DayContext) { ctx.today = \u0026Wednesday{} } type Wednesday struct{} func (*Wednesday) Today() { fmt.Printf(\"Wednesday\\n\") } func (*Wednesday) Next(ctx *DayContext) { ctx.today = \u0026Thursday{} } type Thursday struct{} func (*Thursday) Today() { fmt.Printf(\"Thursday\\n\") } func (*Thursday) Next(ctx *DayContext) { ctx.today = \u0026Friday{} } type Friday struct{} func (*Friday) Today() { fmt.Printf(\"Friday\\n\") } func (*Friday) Next(ctx *DayContext) { ctx.today = \u0026Saturday{} } type Saturday struct{} func (*Saturday) Today() { fmt.Printf(\"Saturday\\n\") } func (*Saturday) Next(ctx *DayContext) { ctx.today = \u0026Sunday{} } package state func ExampleWeek() { ctx := NewDayContext() todayAndNext := func() { ctx.Today() ctx.Next() } for i := 0; i \u003c 8; i++ { todayAndNext() } // Output: // Sunday // Monday // Tuesday // Wednesday // Thursday // Friday // Saturday // Sunday } ","date":"2022-01-22 09:20:41","objectID":"https://qizhengzou.github.io/behavioral_type/:7:0","tags":["design mode"],"title":"Behavioral_type","uri":"https://qizhengzou.github.io/behavioral_type/"},{"categories":["Coding"],"content":"memento 备忘录模式用于保存程序内部状态到外部，又不希望暴露内部状态的情形。 程序内部状态使用窄接口传递给外部进行存储，从而不暴露程序实现细节。 备忘录模式同时可以离线保存内部状态，如保存到数据库，文件等。 package memento import \"fmt\" type Memento interface{} type Game struct { hp, mp int } type gameMemento struct { hp, mp int } func (g *Game) Play(mpDelta, hpDelta int) { g.mp += mpDelta g.hp += hpDelta } func (g *Game) Save() Memento { return \u0026gameMemento{ hp: g.hp, mp: g.mp, } } func (g *Game) Load(m Memento) { gm := m.(*gameMemento) g.mp = gm.mp g.hp = gm.hp } func (g *Game) Status() { fmt.Printf(\"Current HP:%d, MP:%d\\n\", g.hp, g.mp) } package memento func ExampleGame() { game := \u0026Game{ hp: 10, mp: 10, } game.Status() progress := game.Save() game.Play(-2, -3) game.Status() game.Load(progress) game.Status() // Output: // Current HP:10, MP:10 // Current HP:7, MP:8 // Current HP:10, MP:10 } ","date":"2022-01-22 09:20:41","objectID":"https://qizhengzou.github.io/behavioral_type/:8:0","tags":["design mode"],"title":"Behavioral_type","uri":"https://qizhengzou.github.io/behavioral_type/"},{"categories":["Coding"],"content":"iterpreter 解释器模式定义一套语言文法，并设计该语言解释器，使用户能使用特定文法控制解释器行为。 解释器模式的意义在于，它分离多种复杂功能的实现，每个功能只需关注自身的解释。 对于调用者不用关心内部的解释器的工作，只需要用简单的方式组合命令就可以。 package interpreter import ( \"strconv\" \"strings\" ) type Node interface { Interpret() int } type ValNode struct { val int } func (n *ValNode) Interpret() int { return n.val } type AddNode struct { left, right Node } func (n *AddNode) Interpret() int { return n.left.Interpret() + n.right.Interpret() } type MinNode struct { left, right Node } func (n *MinNode) Interpret() int { return n.left.Interpret() - n.right.Interpret() } type Parser struct { exp []string index int prev Node } func (p *Parser) Parse(exp string) { p.exp = strings.Split(exp, \" \") for { if p.index \u003e= len(p.exp) { return } switch p.exp[p.index] { case \"+\": p.prev = p.newAddNode() case \"-\": p.prev = p.newMinNode() default: p.prev = p.newValNode() } } } func (p *Parser) newAddNode() Node { p.index++ return \u0026AddNode{ left: p.prev, right: p.newValNode(), } } func (p *Parser) newMinNode() Node { p.index++ return \u0026MinNode{ left: p.prev, right: p.newValNode(), } } func (p *Parser) newValNode() Node { v, _ := strconv.Atoi(p.exp[p.index]) p.index++ return \u0026ValNode{ val: v, } } func (p *Parser) Result() Node { return p.prev } package interpreter import \"testing\" func TestInterpreter(t *testing.T) { p := \u0026Parser{} p.Parse(\"1 + 2 + 3 - 4 + 5 - 6\") res := p.Result().Interpret() expect := 1 if res != expect { t.Fatalf(\"expect %d got %d\", expect, res) } } ","date":"2022-01-22 09:20:41","objectID":"https://qizhengzou.github.io/behavioral_type/:9:0","tags":["design mode"],"title":"Behavioral_type","uri":"https://qizhengzou.github.io/behavioral_type/"},{"categories":["Coding"],"content":"chain of responsibility 职责链模式用于分离不同职责，并且动态组合相关职责。 Golang实现职责链模式时候，因为没有继承的支持，使用链对象包涵职责的方式，即： 链对象包含当前职责对象以及下一个职责链。 职责对象提供接口表示是否能处理对应请求。 职责对象提供处理函数处理相关职责。 同时可在职责链类中实现职责接口相关函数，使职责链对象可以当做一般职责对象是用。 package chain import \"fmt\" type Manager interface { HaveRight(money int) bool HandleFeeRequest(name string, money int) bool } type RequestChain struct { Manager successor *RequestChain } func (r *RequestChain) SetSuccessor(m *RequestChain) { r.successor = m } func (r *RequestChain) HandleFeeRequest(name string, money int) bool { if r.Manager.HaveRight(money) { return r.Manager.HandleFeeRequest(name, money) } if r.successor != nil { return r.successor.HandleFeeRequest(name, money) } return false } func (r *RequestChain) HaveRight(money int) bool { return true } type ProjectManager struct{} func NewProjectManagerChain() *RequestChain { return \u0026RequestChain{ Manager: \u0026ProjectManager{}, } } func (*ProjectManager) HaveRight(money int) bool { return money \u003c 500 } func (*ProjectManager) HandleFeeRequest(name string, money int) bool { if name == \"bob\" { fmt.Printf(\"Project manager permit %s %d fee request\\n\", name, money) return true } fmt.Printf(\"Project manager don't permit %s %d fee request\\n\", name, money) return false } type DepManager struct{} func NewDepManagerChain() *RequestChain { return \u0026RequestChain{ Manager: \u0026DepManager{}, } } func (*DepManager) HaveRight(money int) bool { return money \u003c 5000 } func (*DepManager) HandleFeeRequest(name string, money int) bool { if name == \"tom\" { fmt.Printf(\"Dep manager permit %s %d fee request\\n\", name, money) return true } fmt.Printf(\"Dep manager don't permit %s %d fee request\\n\", name, money) return false } type GeneralManager struct{} func NewGeneralManagerChain() *RequestChain { return \u0026RequestChain{ Manager: \u0026GeneralManager{}, } } func (*GeneralManager) HaveRight(money int) bool { return true } func (*GeneralManager) HandleFeeRequest(name string, money int) bool { if name == \"ada\" { fmt.Printf(\"General manager permit %s %d fee request\\n\", name, money) return true } fmt.Printf(\"General manager don't permit %s %d fee request\\n\", name, money) return false } package chain func ExampleChain() { c1 := NewProjectManagerChain() c2 := NewDepManagerChain() c3 := NewGeneralManagerChain() c1.SetSuccessor(c2) c2.SetSuccessor(c3) var c Manager = c1 c.HandleFeeRequest(\"bob\", 400) c.HandleFeeRequest(\"tom\", 1400) c.HandleFeeRequest(\"ada\", 10000) c.HandleFeeRequest(\"floar\", 400) // Output: // Project manager permit bob 400 fee request // Dep manager permit tom 1400 fee request // General manager permit ada 10000 fee request // Project manager don't permit floar 400 fee request } ","date":"2022-01-22 09:20:41","objectID":"https://qizhengzou.github.io/behavioral_type/:10:0","tags":["design mode"],"title":"Behavioral_type","uri":"https://qizhengzou.github.io/behavioral_type/"},{"categories":["Coding"],"content":"visitor 访问者模式可以给一系列对象透明的添加功能，并且把相关代码封装到一个类中。 对象只要预留访问者接口Accept则后期为对象添加功能的时候就不需要改动对象。 package visitor import \"fmt\" type Customer interface { Accept(Visitor) } type Visitor interface { Visit(Customer) } type EnterpriseCustomer struct { name string } type CustomerCol struct { customers []Customer } func (c *CustomerCol) Add(customer Customer) { c.customers = append(c.customers, customer) } func (c *CustomerCol) Accept(visitor Visitor) { for _, customer := range c.customers { customer.Accept(visitor) } } func NewEnterpriseCustomer(name string) *EnterpriseCustomer { return \u0026EnterpriseCustomer{ name: name, } } func (c *EnterpriseCustomer) Accept(visitor Visitor) { visitor.Visit(c) } type IndividualCustomer struct { name string } func NewIndividualCustomer(name string) *IndividualCustomer { return \u0026IndividualCustomer{ name: name, } } func (c *IndividualCustomer) Accept(visitor Visitor) { visitor.Visit(c) } type ServiceRequestVisitor struct{} func (*ServiceRequestVisitor) Visit(customer Customer) { switch c := customer.(type) { case *EnterpriseCustomer: fmt.Printf(\"serving enterprise customer %s\\n\", c.name) case *IndividualCustomer: fmt.Printf(\"serving individual customer %s\\n\", c.name) } } // only for enterprise type AnalysisVisitor struct{} func (*AnalysisVisitor) Visit(customer Customer) { switch c := customer.(type) { case *EnterpriseCustomer: fmt.Printf(\"analysis enterprise customer %s\\n\", c.name) } } package visitor func ExampleRequestVisitor() { c := \u0026CustomerCol{} c.Add(NewEnterpriseCustomer(\"A company\")) c.Add(NewEnterpriseCustomer(\"B company\")) c.Add(NewIndividualCustomer(\"bob\")) c.Accept(\u0026ServiceRequestVisitor{}) // Output: // serving enterprise customer A company // serving enterprise customer B company // serving individual customer bob } func ExampleAnalysis() { c := \u0026CustomerCol{} c.Add(NewEnterpriseCustomer(\"A company\")) c.Add(NewIndividualCustomer(\"bob\")) c.Add(NewEnterpriseCustomer(\"B company\")) c.Accept(\u0026AnalysisVisitor{}) // Output: // analysis enterprise customer A company // analysis enterprise customer B company } 参考 ","date":"2022-01-22 09:20:41","objectID":"https://qizhengzou.github.io/behavioral_type/:11:0","tags":["design mode"],"title":"Behavioral_type","uri":"https://qizhengzou.github.io/behavioral_type/"},{"categories":["Coding"],"content":"simple factory go 语言没有构造函数一说，所以一般会定义NewXXX函数来初始化相关类。 NewXXX 函数返回接口时就是简单工厂模式，也就是说Golang的一般推荐做法就是简单工厂。 在这个simplefactory包中只有API 接口和NewAPI函数为包外可见，封装了实现细节。 package simplefactory import \"fmt\" //API is interface type API interface { Say(name string) string } //NewAPI return Api instance by type func NewAPI(t int) API { if t == 1 { return \u0026hiAPI{} } else if t == 2 { return \u0026helloAPI{} } return nil } //hiAPI is one of API implement type hiAPI struct{} //Say hi to name func (*hiAPI) Say(name string) string { return fmt.Sprintf(\"Hi, %s\", name) } //HelloAPI is another API implement type helloAPI struct{} //Say hello to name func (*helloAPI) Say(name string) string { return fmt.Sprintf(\"Hello, %s\", name) } package simplefactory import \"testing\" //TestType1 test get hiapi with factory func TestType1(t *testing.T) { api := NewAPI(1) s := api.Say(\"Tom\") if s != \"Hi, Tom\" { t.Fatal(\"Type1 test fail\") } } func TestType2(t *testing.T) { api := NewAPI(2) s := api.Say(\"Tom\") if s != \"Hello, Tom\" { t.Fatal(\"Type2 test fail\") } } ","date":"2022-01-22 09:19:30","objectID":"https://qizhengzou.github.io/create_type/:1:0","tags":["design mode"],"title":"Create_type","uri":"https://qizhengzou.github.io/create_type/"},{"categories":["Coding"],"content":"factory method 工厂方法模式使用子类的方式延迟生成对象到子类中实现。 Go中不存在继承 所以使用匿名组合来实现 package factorymethod //Operator 是被封装的实际类接口 type Operator interface { SetA(int) SetB(int) Result() int } //OperatorFactory 是工厂接口 type OperatorFactory interface { Create() Operator } //OperatorBase 是Operator 接口实现的基类，封装公用方法 type OperatorBase struct { a, b int } //SetA 设置 A func (o *OperatorBase) SetA(a int) { o.a = a } //SetB 设置 B func (o *OperatorBase) SetB(b int) { o.b = b } //PlusOperatorFactory 是 PlusOperator 的工厂类 type PlusOperatorFactory struct{} func (PlusOperatorFactory) Create() Operator { return \u0026PlusOperator{ OperatorBase: \u0026OperatorBase{}, } } //PlusOperator Operator 的实际加法实现 type PlusOperator struct { *OperatorBase } //Result 获取结果 func (o PlusOperator) Result() int { return o.a + o.b } //MinusOperatorFactory 是 MinusOperator 的工厂类 type MinusOperatorFactory struct{} func (MinusOperatorFactory) Create() Operator { return \u0026MinusOperator{ OperatorBase: \u0026OperatorBase{}, } } //MinusOperator Operator 的实际减法实现 type MinusOperator struct { *OperatorBase } //Result 获取结果 func (o MinusOperator) Result() int { return o.a - o.b } package factorymethod import \"testing\" func compute(factory OperatorFactory, a, b int) int { op := factory.Create() op.SetA(a) op.SetB(b) return op.Result() } func TestOperator(t *testing.T) { var ( factory OperatorFactory ) factory = PlusOperatorFactory{} if compute(factory, 1, 2) != 3 { t.Fatal(\"error with factory method pattern\") } factory = MinusOperatorFactory{} if compute(factory, 4, 2) != 2 { t.Fatal(\"error with factory method pattern\") } } ","date":"2022-01-22 09:19:30","objectID":"https://qizhengzou.github.io/create_type/:2:0","tags":["design mode"],"title":"Create_type","uri":"https://qizhengzou.github.io/create_type/"},{"categories":["Coding"],"content":"abstract factory 抽象工厂模式用于生成产品族的工厂，所生成的对象是有关联的。 如果抽象工厂退化成生成的对象无关联则成为工厂函数模式。 比如本例子中使用RDB和XML存储订单信息，抽象工厂分别能生成相关的主订单信息和订单详情信息。 如果业务逻辑中需要替换使用的时候只需要改动工厂函数相关的类就能替换使用不同的存储方式了。 package abstractfactory import \"fmt\" //OrderMainDAO 为订单主记录 type OrderMainDAO interface { SaveOrderMain() } //OrderDetailDAO 为订单详情纪录 type OrderDetailDAO interface { SaveOrderDetail() } //DAOFactory DAO 抽象模式工厂接口 type DAOFactory interface { CreateOrderMainDAO() OrderMainDAO CreateOrderDetailDAO() OrderDetailDAO } //RDBMainDAP 为关系型数据库的OrderMainDAO实现 type RDBMainDAO struct{} //SaveOrderMain ... func (*RDBMainDAO) SaveOrderMain() { fmt.Print(\"rdb main save\\n\") } //RDBDetailDAO 为关系型数据库的OrderDetailDAO实现 type RDBDetailDAO struct{} // SaveOrderDetail ... func (*RDBDetailDAO) SaveOrderDetail() { fmt.Print(\"rdb detail save\\n\") } //RDBDAOFactory 是RDB 抽象工厂实现 type RDBDAOFactory struct{} func (*RDBDAOFactory) CreateOrderMainDAO() OrderMainDAO { return \u0026RDBMainDAO{} } func (*RDBDAOFactory) CreateOrderDetailDAO() OrderDetailDAO { return \u0026RDBDetailDAO{} } //XMLMainDAO XML存储 type XMLMainDAO struct{} //SaveOrderMain ... func (*XMLMainDAO) SaveOrderMain() { fmt.Print(\"xml main save\\n\") } //XMLDetailDAO XML存储 type XMLDetailDAO struct{} // SaveOrderDetail ... func (*XMLDetailDAO) SaveOrderDetail() { fmt.Print(\"xml detail save\") } //XMLDAOFactory 是RDB 抽象工厂实现 type XMLDAOFactory struct{} func (*XMLDAOFactory) CreateOrderMainDAO() OrderMainDAO { return \u0026XMLMainDAO{} } func (*XMLDAOFactory) CreateOrderDetailDAO() OrderDetailDAO { return \u0026XMLDetailDAO{} } package abstractfactory func getMainAndDetail(factory DAOFactory) { factory.CreateOrderMainDAO().SaveOrderMain() factory.CreateOrderDetailDAO().SaveOrderDetail() } func ExampleRdbFactory() { var factory DAOFactory factory = \u0026RDBDAOFactory{} getMainAndDetail(factory) // Output: // rdb main save // rdb detail save } func ExampleXmlFactory() { var factory DAOFactory factory = \u0026XMLDAOFactory{} getMainAndDetail(factory) // Output: // xml main save // xml detail save } ","date":"2022-01-22 09:19:30","objectID":"https://qizhengzou.github.io/create_type/:3:0","tags":["design mode"],"title":"Create_type","uri":"https://qizhengzou.github.io/create_type/"},{"categories":["Coding"],"content":"builder package builder //Builder 是生成器接口 type Builder interface { Part1() Part2() Part3() } type Director struct { builder Builder } // NewDirector ... func NewDirector(builder Builder) *Director { return \u0026Director{ builder: builder, } } //Construct Product func (d *Director) Construct() { d.builder.Part1() d.builder.Part2() d.builder.Part3() } type Builder1 struct { result string } func (b *Builder1) Part1() { b.result += \"1\" } func (b *Builder1) Part2() { b.result += \"2\" } func (b *Builder1) Part3() { b.result += \"3\" } func (b *Builder1) GetResult() string { return b.result } type Builder2 struct { result int } func (b *Builder2) Part1() { b.result += 1 } func (b *Builder2) Part2() { b.result += 2 } func (b *Builder2) Part3() { b.result += 3 } func (b *Builder2) GetResult() int { return b.result } package builder import \"testing\" func TestBuilder1(t *testing.T) { builder := \u0026Builder1{} director := NewDirector(builder) director.Construct() res := builder.GetResult() if res != \"123\" { t.Fatalf(\"Builder1 fail expect 123 acture %s\", res) } } func TestBuilder2(t *testing.T) { builder := \u0026Builder2{} director := NewDirector(builder) director.Construct() res := builder.GetResult() if res != 6 { t.Fatalf(\"Builder2 fail expect 6 acture %d\", res) } } ","date":"2022-01-22 09:19:30","objectID":"https://qizhengzou.github.io/create_type/:4:0","tags":["design mode"],"title":"Create_type","uri":"https://qizhengzou.github.io/create_type/"},{"categories":["Coding"],"content":"prototype 原型模式使对象能复制自身，并且暴露到接口中，使客户端面向接口编程时，不知道接口实际对象的情况下生成新的对象。 原型模式配合原型管理器使用，使得客户端在不知道具体类的情况下，通过接口管理器得到新的实例，并且包含部分预设定配置。 package prototype //Cloneable 是原型对象需要实现的接口 type Cloneable interface { Clone() Cloneable } type PrototypeManager struct { prototypes map[string]Cloneable } func NewPrototypeManager() *PrototypeManager { return \u0026PrototypeManager{ prototypes: make(map[string]Cloneable), } } func (p *PrototypeManager) Get(name string) Cloneable { return p.prototypes[name].Clone() } func (p *PrototypeManager) Set(name string, prototype Cloneable) { p.prototypes[name] = prototype } package prototype import \"testing\" var manager *PrototypeManager type Type1 struct { name string } func (t *Type1) Clone() Cloneable { tc := *t return \u0026tc } type Type2 struct { name string } func (t *Type2) Clone() Cloneable { tc := *t return \u0026tc } func TestClone(t *testing.T) { t1 := manager.Get(\"t1\") t2 := t1.Clone() if t1 == t2 { t.Fatal(\"error! get clone not working\") } } func TestCloneFromManager(t *testing.T) { c := manager.Get(\"t1\").Clone() t1 := c.(*Type1) if t1.name != \"type1\" { t.Fatal(\"error\") } } func init() { manager = NewPrototypeManager() t1 := \u0026Type1{ name: \"type1\", } manager.Set(\"t1\", t1) } ","date":"2022-01-22 09:19:30","objectID":"https://qizhengzou.github.io/create_type/:5:0","tags":["design mode"],"title":"Create_type","uri":"https://qizhengzou.github.io/create_type/"},{"categories":["Coding"],"content":"singleton 使用懒惰模式的单例模式，使用双重检查加锁保证线程安全 package singleton import \"sync\" // Singleton 是单例模式接口，导出的 // 通过该接口可以避免 GetInstance 返回一个包私有类型的指针 type Singleton interface { foo() } // singleton 是单例模式类，包私有的 type singleton struct{} func (s singleton) foo() {} var ( instance *singleton once sync.Once ) //GetInstance 用于获取单例模式对象 func GetInstance() Singleton { once.Do(func() { instance = \u0026singleton{} }) return instance } package singleton import ( \"sync\" \"testing\" ) const parCount = 100 func TestSingleton(t *testing.T) { ins1 := GetInstance() ins2 := GetInstance() if ins1 != ins2 { t.Fatal(\"instance is not equal\") } } func TestParallelSingleton(t *testing.T) { start := make(chan struct{}) wg := sync.WaitGroup{} wg.Add(parCount) instances := [parCount]Singleton{} for i := 0; i \u003c parCount; i++ { go func(index int) { //协程阻塞，等待channel被关闭才能继续运行 \u003c-start instances[index] = GetInstance() wg.Done() }(i) } //关闭channel，所有协程同时开始运行，实现并行(parallel) close(start) wg.Wait() for i := 1; i \u003c parCount; i++ { if instances[i] != instances[i-1] { t.Fatal(\"instance is not equal\") } } } 参考 ","date":"2022-01-22 09:19:30","objectID":"https://qizhengzou.github.io/create_type/:6:0","tags":["design mode"],"title":"Create_type","uri":"https://qizhengzou.github.io/create_type/"},{"categories":["Hero"],"content":"摘自1.6万字马斯克访谈实录 21年末，Youtube知名科技UP主，拥有143万粉丝的大V Lex Fridman与马斯克进行了一场长达2小时31分47秒的深度对话，从SpaceX的载人飞船、猛禽火箭、殖民火星，一口气聊到特斯拉面临的自动驾驶工程难题，机器人，以及马斯克知名的第一性思考原则。 一、首次太空载人曾下跪祈祷 下一步要在火星建立文明 1、Lex Fridman：2020年5月，SpaceX的载人火箭进入太空轨道，被许多人视为人类太空探索新时代的第一步。这些人类太空飞行对我和数百万人来说是希望的灯塔，在过去的两年里，我们的世界一直在经历人类历史上最困难的时期之一。 我们看到分裂、恐惧、愤世嫉俗和共同人性的丧失，就在最需要的时候，所以感谢你给了世界希望和对未来兴奋的理由。 马斯克：哦，谢谢你这么说。我确实想这么做。人类显然有很多问题，而且你知道，人们有时会做坏事，但我爱这个群体。我认为我们应该确保我们所做的一切，能够让我们可以有一个美好的未来，一个令人兴奋的未来，去最大化人类幸福。 2、Lex Fridman：我想问一下“载人龙飞船”的飞行任务（Crew dragon dem-2），这是Space X的第一次载人飞行，你在发射前感觉如何？你当时害怕吗？你兴奋吗？你在想什么？你的脑海中是否有这么多的利害关系？ 马斯克：是的，当时我内心确实非常紧张。我们显然不能在任何方面让他们失望，所以压力极大。我相信在飞船发射的时候，没有人能够想到它成功的概率是多少。 我们绞尽脑汁去想能够提升成功概率的方法，但我们已经竭尽所能了，美国宇航局也是。我们已经在能力范围内做到最好了，所以我们继续往前推进并发射那艘飞船。我并不是一名宗教人士，但是我还是跪下为那次任务做了祈祷。 1.6万字马斯克访谈实录：载人飞船上天前，我曾跪地祈祷 ▲SpaceX首次太空飞行的四名航天员 3、Lex Fridman：当飞船发射成功之后，你们睡得着吗？或者说，当飞船成功返程落地时你们内心的感受是什么？ 马斯克：高压之后内心的石头终于落了地。与其说是高兴，不如说是一种解脱。在SpaceX随后的任务中，肯定会有很多乐趣，我认为Inspiration Mission实际上是非常鼓舞人心的。我推荐大家去看一部Netflix纪录片《发射倒计时：灵感4号平民太空任务》（Countdown: Inspiration 4 Mission to Space），这部纪录片内容非常好。 我本人也受到了启发。在飞船发射过程中，我甚至有些感觉有些享受，而不像第一次SpaceX发射飞船时那么紧张。 1.6万字马斯克访谈实录：载人飞船上天前，我曾跪地祈祷 ▲Netflix纪录片《发射倒计时：灵感4号平民太空任务》 4、Lex Fridman：所以大部分人其实不知道Inspiratin 4 Mission是全球首次的商业飞行任务，也是“普通人”的首次太空旅行。 马斯克：是的，过去30～40年内，人类离地球最远的飞行应该是航天飞机维修哈勃望远镜任务和1972年阿波罗号的登月任务。这其实有点令人费解，当然这两次任务确实很酷。作为人类，我们希望可以继续做得更好，达到更高的境界。 我个人认为，如果阿波罗号标志着人类的最高水平，那将是非常悲惨的。人类登上月球是我们曾经达到的水平，但现在已经过去了49年，我们还没有进行过第二次登月。这是否意味着我们的技术已经达到顶峰？所以我认为我们必须再次登陆月球，在那里建立一个科学基地，就像南极洲和世界其他地方的科学基地一样。在那里，我们能了解到更多关于宇宙本质的东西。 1.6万字马斯克访谈实录：载人飞船上天前，我曾跪地祈祷 ▲阿波罗号登月 我认为这一切都是相关联的，所以这就是我认为的下一件大事——建造一个基地，然后把人类送上火星，建立火星文明。 5、Lex Fridman：下面我会采访您其中的一些细节。由于您忙于处理工程挑战，你还有精力惊叹于太空旅行或是每次火箭升空的神奇之处？ 你有没有对将要面临的挑战有不知所措的感觉？5月30日SpaceX首次载人飞行的任务已经过去一段时间了，你现在可以回顾一下它对你产生的影响。 当时影响你最深的可能是工程问题，但现在这已经成为了一个历史性时刻。 你觉得21世纪值得被人铭记的时刻有哪些？对我个人而言，其中的一个时刻可能就是Inspiration 4 Mission，它或许会作为人类在新太空探索时代的早期尝试被铭记。 马斯克：关于这次飞行，我想也许有些人知道，但更多的人都不知道。其实这就像，我实际上是SpaceX的首席工程师，我在所有的工程设计项目上都签了字，因此如果任何设备有任何问题，本质上都是我的错。所以我实际上脑子里想的都是工程设计。 当我看到火箭时，我脑海里会想到那些可能会出错的因素和能够提升的部分。也就是说我看到龙飞船的时候也是如此。所以一般人看到火箭可能会说：“这个航天器或火箭看起来很酷！”，但我就会像一个读数机一样，一直在说有哪些风险，哪些问题。 6、Lex Fridman：正如你所说，当你看到火箭的时候，你会列出风险清单。同时，你也说过星际飞船是一个非常困难的挑战。那么，以同样的方式让你列出一个星舰风险清单，并且如果能完美地解决其中一件工程问题，那么这个问题会是什么？也许是效率、引擎、不同部件的重量、各种事物交织复杂性甚至是星舰的着陆有关。 马斯克：都不是，目前最需要花费时间的不是发动机的设计，而是发动机的生产。我经常说原型设计很简单，困难之处在于把它们生产出来，我们已经设计出了最先进的火箭发动机。 1.6万字马斯克访谈实录：载人飞船上天前，我曾跪地祈祷 ▲Starship火箭推进器 目前最好的火箭发动机可能是RD-180或RD-170，基本上是俄罗斯的双燃烧室、双喷嘴发动机。而我认为一个发动机成功与否在于它是否能把飞船送入轨道，而我们的发动机还没有把星舰送入轨道，但实际上其性能要比俄罗斯的RD系列发动机更好。 7、Lex Fridman：所以你指的是猛禽发动机。猛禽发动机与其他发动机不同之处在哪？ 马斯克：猛禽发动机是一种全流量分级燃烧循环发动机，它在一个非常高的室压下运行。衡量发动机好坏的关键就在于这个室压的数字是多少。 这个数字就是燃烧室的压力，猛禽发动机可以在300Bar的压力下运行，甚至可能更高。当前运行的RD发动机的室压应该在267Bar左右。而提升室压的难度是以非线性方式增加的，因此，增加10%的室压更像增加了50%的难度，发动机需要获得更高的功率密度。 这样就有了很高的推量比和很高的比冲量。因此，特定脉冲就像是火箭发动机效率的衡量标准，它实际上是发动机排出气体的有效排气速度。所以在一个非常高的压力下，你可以有一个紧凑的发动机，尽管如此它还是有一个高膨胀率，也就是出口喷管和喉部之间的比率。 8、Lex Fridman：那为什么猛禽是一种难以大规模量产的发动机？ 马斯克：它的构造非常复杂。发动机有很多零部件和很多独特的材料。因此，我们不得不发明几种不存在的合金，以使发动机工作，这是材料问题。此外，在一个全流量分级燃烧系统中，有很多反馈回路，推进剂和热气同时流向发动机的不同的地方，而且它们都对彼此有一个递归的影响。所以如果这里改变一些，那里就会受到一些影响，再去改变别处，事情就很难控制了。这也是为什么以前没有人做过这类发动机。我们之所以做一个阶段性燃烧的全流发动机，是因为理论上其效率最高。 为了制造一个完全可重复使用的火箭，必须把一切都做到极致——制造最好的发动机、最好的机身、最好的热屏蔽、最好的航空电子设备以及超智能控制机制。 例如，在减轻发动机自身质量上，我们不在助推器上安装着陆腿，而是用塔架承接返回的发动机。所以这就像是用一双筷子手臂在一座巨大的塔上抓住有史以来最大的飞行物一样。或者说这和空手道小子抓苍蝇一样，只不过这只苍蝇要大得多。 9、Lex Fridman：你提到在一些时刻，你会怀疑这是否能够实现，因为这是非常困难的。 马斯克：可能实现的一点是，我认为SpaceX会让星舰运转起来。这只是一个时间问题，我们要花多长时间来做这件事？我们要花多长时间才能真正实现火箭全面和迅速的重复使用？在其能够达到全面并迅速的重复使用前，需要多次发射试验。这些试验我可以用物理学计算。 1.6万字马斯克访谈实录：载人飞船上天前，我曾跪地祈祷 ▲SpaceX测试火箭发射 我对成功充满信心，计算结果在预测成功区间内。在SpaceX，我们有一支天才团队，他们夜以继日地工作，让愿景成为现实——实现航天革命和使人类成为星际文明的关键，要有一个完全和快速可重复使用的轨道火箭。在这之前，从来没有一支轨道火箭是完全可重复使用的。而这一直是火箭技术的梦想，许多人曾试图这么做，但都没有成功。 10、Lex Fridman：你知道有很多人，包括许多专家、记者和一般的公众，都对可重复使用的火箭表示怀疑。而你自己认为这是一个非空集，虽然成功比较困难，但你还是全身心地投入，作为一名工程师、团队的一份子去负责推进这个项目，将其完成。你的力量来源是什么？ 马斯克：我只是知道自己思考问题的方式。对我来说，这是一件很重要的事情，我们应该继续做下去，否则就会失败。而我也不需要什么力量来源。 11、Lex Fridman：所以放弃不是你的性格？ 马斯克：放弃这两个字不在我的字典里，管他乐观还是悲观，都滚蛋，干就完了！ 12、Lex Fridman：你能不能再放大到星舰的具体问题或你工作的任何工程问题上？你能不能试着描述下你思考问题的方式？比如不同的工程和设计问题？是否有一个系统的过程？你已经说过了思考的第一原则，但是否有一个过程？ 马斯克：物理学是基础，其他都是建议。我见过很多违反法","date":"2022-01-19 19:49:08","objectID":"https://qizhengzou.github.io/musk/:0:0","tags":["hero"],"title":"MUSK","uri":"https://qizhengzou.github.io/musk/"},{"categories":["Go"],"content":" 参考学习go语言中文网、C语言中文网、golang官方文档等 并发编程 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:0:0","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"并发介绍 进程和线程 进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。 线程是进程的一个执行实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。 一个进程可以创建和撤销多个线程;同一个进程中的多个线程之间可以并发执行。 并发和并行 多线程程序在一个核的cpu上运行，就是并发。（一段时间内都有运行） 多线程程序在多个核的cpu上运行，就是并行。（同时运行） 协程和线程 协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。 线程：一个线程上可以跑多个协程，协程是轻量级的线程。 goroutine 只是由官方实现的超级”线程池”。 每个实力4~5KB的栈内存占用和由于实现机制而大幅减少的创建和销毁开销是go高并发的根本原因。 并发不是并行： 并发主要由切换时间片来实现”同时”运行，并行则是直接利用多核实现多线程的运行，go可以设置使用核数，以发挥多核计算机的能力。 goroutine 奉行通过通信来共享内存，而不是共享内存来通信。 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:1:0","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"Goroutine 在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行呢？ Go语言中的goroutine就是这样一种机制，goroutine的概念类似于线程，但 goroutine是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。 在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个goroutine去执行这个函数就可以了，就是这么简单粗暴。 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:2:0","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"使用goroutine Go语言中使用goroutine非常简单，只需要在调用函数的时候在前面加上go关键字，就可以为一个函数创建一个goroutine。 一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数。 启动单个goroutine 启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个go关键字。 举个例子如下： func hello() { fmt.Println(\"Hello Goroutine!\") } func main() { hello() fmt.Println(\"main goroutine done!\") } 这个示例中hello函数和下面的语句是串行的，执行的结果是打印完Hello Goroutine!后打印main goroutine done!。 接下来我们在调用hello函数前面加上关键字go，也就是启动一个goroutine去执行hello这个函数。 func main() { go hello() // 启动另外一个goroutine去执行hello函数 fmt.Println(\"main goroutine done!\") } 这一次的执行结果只打印了main goroutine done!，并没有打印Hello Goroutine!。为什么呢？ 在程序启动时，Go程序就会为main()函数创建一个默认的goroutine。 当main()函数返回的时候该goroutine就结束了，所有在main()函数中启动的goroutine会一同结束，main函数所在的goroutine就像是权利的游戏中的夜王，其他的goroutine都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。 所以我们要想办法让main函数等一等hello函数，最简单粗暴的方式就是time.Sleep了。 func main() { go hello() // 启动另外一个goroutine去执行hello函数 fmt.Println(\"main goroutine done!\") time.Sleep(time.Second) } 执行上面的代码你会发现，这一次先打印main goroutine done!，然后紧接着打印Hello Goroutine!。 首先为什么会先打印main goroutine done!是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的goroutine是继续执行的。 启动多个goroutine 在Go语言中实现并发就是这样简单，我们还可以启动多个goroutine。让我们再来一个例子： （这里使用了sync.WaitGroup来实现goroutine的同步） var wg sync.WaitGroup func hello(i int) { defer wg.Done() // goroutine结束就登记-1 fmt.Println(\"Hello Goroutine!\", i) } func main() { for i := 0; i \u003c 10; i++ { wg.Add(1) // 启动一个goroutine就登记+1 go hello(i) } wg.Wait() // 等待所有登记的goroutine都结束 } 多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个goroutine是并发执行的，而goroutine的调度是随机的。 注意 如果主协程退出了，其他任务还执行吗（运行下面的代码测试一下吧） package main import ( \"fmt\" \"time\" ) func main() { // 合起来写 go func() { i := 0 for { i++ fmt.Printf(\"new goroutine: i = %d\\n\", i) time.Sleep(time.Second) } }() i := 0 for { i++ fmt.Printf(\"main goroutine: i = %d\\n\", i) time.Sleep(time.Second) if i == 2 { break } } } ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:2:1","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"goroutine与线程 可增长的栈 OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine的栈不是固定的，他可以按需增大和缩小，goroutine的栈大小限制可以达到1GB，虽然极少会用到这个大。所以在Go语言中一次创建十万左右的goroutine也是可以的。 goroutine调度 GPM是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。 G很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。 P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。 M（machine）是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的； P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。 P的个数是通过runtime.GOMAXPROCS设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。 单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，goroutine则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:2:2","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"runtime包 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:3:0","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"runtime.Gosched() 让出CPU时间片，重新等待安排任务(大概意思就是本来计划的好好的周末出去烧烤，但是你妈让你去相亲,两种情况第一就是你相亲速度非常快，见面就黄不耽误你继续烧烤，第二种情况就是你相亲速度特别慢，见面就是你侬我侬的，耽误了烧烤，但是还馋就是耽误了烧烤你还得去烧烤) package main import ( \"fmt\" \"runtime\" ) func main() { go func(s string) { for i := 0; i \u003c 2; i++ { fmt.Println(s) } }(\"world\") // 主协程 for i := 0; i \u003c 2; i++ { // 切一下，再次分配任务 runtime.Gosched() fmt.Println(\"hello\") } } ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:3:1","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"runtime.Goexit() 退出当前协程(一边烧烤一边相亲，突然发现相亲对象太丑影响烧烤，果断让她滚蛋，然后也就没有然后了) package main import ( \"fmt\" \"runtime\" ) func main() { go func() { defer fmt.Println(\"A.defer\") func() { defer fmt.Println(\"B.defer\") // 结束协程 runtime.Goexit() defer fmt.Println(\"C.defer\") fmt.Println(\"B\") }() fmt.Println(\"A\") }() for { } } ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:3:2","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"runtime.GOMAXPROCS Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。 Go语言中可以通过runtime.GOMAXPROCS()函数设置当前程序并发时占用的CPU逻辑核心数。 Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。 我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子： func a() { for i := 1; i \u003c 10; i++ { fmt.Println(\"A:\", i) } } func b() { for i := 1; i \u003c 10; i++ { fmt.Println(\"B:\", i) } } func main() { runtime.GOMAXPROCS(1) go a() go b() time.Sleep(time.Second) } 两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。 将逻辑核心数设为2，此时两个任务并行执行，代码如下。 func a() { for i := 1; i \u003c 10; i++ { fmt.Println(\"A:\", i) } } func b() { for i := 1; i \u003c 10; i++ { fmt.Println(\"B:\", i) } } func main() { runtime.GOMAXPROCS(2) go a() go b() time.Sleep(time.Second) } Go语言中的操作系统线程和goroutine的关系： 一个操作系统线程对应用户态多个goroutine。 go程序可以同时使用多个操作系统线程。 goroutine和OS线程是多对多的关系，即m:n。 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:3:3","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"Channel ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:4:0","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"channel 单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。 虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。 Go语言的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存而不是通过共享内存而实现通信。 如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。 Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:4:1","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"channel类型 channel是一种类型，一种引用类型。声明通道类型的格式如下： var 变量 chan 元素类型 举几个例子： var ch1 chan int // 声明一个传递整型的通道 var ch2 chan bool // 声明一个传递布尔型的通道 var ch3 chan []int // 声明一个传递int切片的通道 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:4:2","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"创建channel 通道是引用类型，通道类型的空值是nil。 var ch chan int fmt.Println(ch) // \u003cnil\u003e 声明的通道后需要使用make函数初始化之后才能使用。 创建channel的格式如下： make(chan 元素类型, [缓冲大小]) channel的缓冲大小是可选的。 举几个例子： ch4 := make(chan int) ch5 := make(chan bool) ch6 := make(chan []int) ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:4:3","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"channel操作 通道有发送（send）、接收(receive）和关闭（close）三种操作。 发送和接收都使用\u003c-符号。 现在我们先使用以下语句定义一个通道： ch := make(chan int) ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:4:4","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"发送 将一个值发送到通道中。 ch \u003c- 10 // 把10发送到ch中 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:4:5","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"接收 从一个通道中接收值。 x := \u003c- ch // 从ch中接收值并赋值给变量x \u003c-ch // 从ch中接收值，忽略结果 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:4:6","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"关闭 我们通过调用内置的close函数来关闭通道。 close(ch) 关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。 关闭后的通道有以下特点： 对一个关闭的通道再发送值就会导致panic。 对一个关闭的通道进行接收会一直获取值直到通道为空。 对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。 关闭一个已经关闭的通道会导致panic。 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:4:7","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"无缓冲的通道 无缓冲的通道又称为阻塞的通道。我们来看一下下面的代码： func main() { ch := make(chan int) ch \u003c- 10 fmt.Println(\"发送成功\") } 上面这段代码能够通过编译，但是执行的时候会出现以下错误： fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan send]: main.main() .../src/github.com/pprof/studygo/day06/channel02/main.go:8 +0x54 为什么会出现deadlock错误呢？ 因为我们使用ch := make(chan int)创建的是无缓冲的通道，无缓冲的通道只有在有人接收值的时候才能发送值。就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。 上面的代码会阻塞在ch \u003c- 10这一行代码形成死锁，那如何解决这个问题呢？ 一种方法是启用一个goroutine去接收值，例如： func recv(c chan int) { ret := \u003c-c fmt.Println(\"接收成功\", ret) } func main() { ch := make(chan int) go recv(ch) // 启用goroutine从通道接收值 ch \u003c- 10 fmt.Println(\"发送成功\") } 无缓冲通道上的发送操作会阻塞，直到另一个goroutine在该通道上执行接收操作，这时值才能发送成功，两个goroutine将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine在该通道上发送一个值。 使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也被称为同步通道。 有缓冲的通道 解决上面问题的方法还有一种就是使用有缓冲区的通道。 我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如： func main() { ch := make(chan int, 1) // 创建一个容量为1的有缓冲区通道 ch \u003c- 10 fmt.Println(\"发送成功\") } 只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。 我们可以使用内置的len函数获取通道内元素的数量，使用cap函数获取通道的容量，虽然我们很少会这么做。 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:4:8","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"close() 可以通过内置的close()函数关闭channel（如果你的管道不往里存值或者取值的时候一定记得关闭管道） package main import \"fmt\" func main() { c := make(chan int) go func() { for i := 0; i \u003c 5; i++ { c \u003c- i } close(c) }() for { if data, ok := \u003c-c; ok { fmt.Println(data) } else { break } } fmt.Println(\"main结束\") } ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:4:9","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"如何优雅的从通道循环取值 当通过通道发送有限的数据时，我们可以通过close函数关闭通道来告知从该通道接收值的goroutine停止等待。当通道被关闭时，往该通道发送值会引发panic，从该通道里接收的值一直都是类型零值。那如何判断一个通道是否被关闭了呢？ 我们来看下面这个例子： // channel 练习 func main() { ch1 := make(chan int) ch2 := make(chan int) // 开启goroutine将0~100的数发送到ch1中 go func() { for i := 0; i \u003c 100; i++ { ch1 \u003c- i } close(ch1) }() // 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中 go func() { for { i, ok := \u003c-ch1 // 通道关闭后再取值ok=false if !ok { break } ch2 \u003c- i * i } close(ch2) }() // 在主goroutine中从ch2中接收值打印 for i := range ch2 { // 通道关闭后会退出for range循环 fmt.Println(i) } } 从上面的例子中我们看到有两种方式在接收值的时候判断通道是否被关闭，我们通常使用的是for range的方式。 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:4:10","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"单向通道 有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。 Go语言中提供了单向通道来处理这种情况。例如，我们把上面的例子改造如下： func counter(out chan\u003c- int) { for i := 0; i \u003c 100; i++ { out \u003c- i } close(out) } func squarer(out chan\u003c- int, in \u003c-chan int) { for i := range in { out \u003c- i * i } close(out) } func printer(in \u003c-chan int) { for i := range in { fmt.Println(i) } } func main() { ch1 := make(chan int) ch2 := make(chan int) go counter(ch1) go squarer(ch2, ch1) printer(ch2) } 其中， chan\u003c- int是一个只能发送的通道，可以发送但是不能接收； \u003c-chan int是一个只能接收的通道，可以接收但是不能发送。 在函数传参及任何赋值操作中将双向通道转换为单向通道是可以的，但反过来是不可以的。 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:4:11","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"通道总结 channel常见的异常总结，如下图： 注意:关闭已经关闭的channel也会引发panic。 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:4:12","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"Goroutine池 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:5:0","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"worker pool（goroutine池） 本质上是生产者消费者模型 可以有效控制goroutine数量，防止暴涨 需求： 计算一个数字的各个位数之和，例如数字123，结果为1+2+3=6 随机生成数字进行计算 控制台输出结果如下： package main import ( \"fmt\" \"math/rand\" ) type Job struct { // id Id int // 需要计算的随机数 RandNum int } type Result struct { // 这里必须传对象实例 job *Job // 求和 sum int } func main() { // 需要2个管道 // 1.job管道 jobChan := make(chan *Job, 128) // 2.结果管道 resultChan := make(chan *Result, 128) // 3.创建工作池 createPool(64, jobChan, resultChan) // 4.开个打印的协程 go func(resultChan chan *Result) { // 遍历结果管道打印 for result := range resultChan { fmt.Printf(\"job id:%v randnum:%v result:%d\\n\", result.job.Id, result.job.RandNum, result.sum) } }(resultChan) var id int // 循环创建job，输入到管道 for { id++ // 生成随机数 r_num := rand.Int() job := \u0026Job{ Id: id, RandNum: r_num, } jobChan \u003c- job } } // 创建工作池 // 参数1：开几个协程 func createPool(num int, jobChan chan *Job, resultChan chan *Result) { // 根据开协程个数，去跑运行 for i := 0; i \u003c num; i++ { go func(jobChan chan *Job, resultChan chan *Result) { // 执行运算 // 遍历job管道所有数据，进行相加 for job := range jobChan { // 随机数接过来 r_num := job.RandNum // 随机数每一位相加 // 定义返回值 var sum int for r_num != 0 { tmp := r_num % 10 sum += tmp r_num /= 10 } // 想要的结果是Result r := \u0026Result{ job: job, sum: sum, } //运算结果扔到管道 resultChan \u003c- r } }(jobChan, resultChan) } } ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:5:1","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"定时器 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:6:0","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"定时器 Timer：时间到了，执行只执行1次 package main import ( \"fmt\" \"time\" ) func main() { // 1.timer基本使用 //timer1 := time.NewTimer(2 * time.Second) //t1 := time.Now() //fmt.Printf(\"t1:%v\\n\", t1) //t2 := \u003c-timer1.C //fmt.Printf(\"t2:%v\\n\", t2) // 2.验证timer只能响应1次 //timer2 := time.NewTimer(time.Second) //for { // \u003c-timer2.C // fmt.Println(\"时间到\") //} // 3.timer实现延时的功能 //(1) //time.Sleep(time.Second) //(2) //timer3 := time.NewTimer(2 * time.Second) //\u003c-timer3.C //fmt.Println(\"2秒到\") //(3) //\u003c-time.After(2*time.Second) //fmt.Println(\"2秒到\") // 4.停止定时器 //timer4 := time.NewTimer(2 * time.Second) //go func() { // \u003c-timer4.C // fmt.Println(\"定时器执行了\") //}() //b := timer4.Stop() //if b { // fmt.Println(\"timer4已经关闭\") //} // 5.重置定时器 timer5 := time.NewTimer(3 * time.Second) timer5.Reset(1 * time.Second) fmt.Println(time.Now()) fmt.Println(\u003c-timer5.C) for { } } Ticker：时间到了，多次执行 package main import ( \"fmt\" \"time\" ) func main() { // 1.获取ticker对象 ticker := time.NewTicker(1 * time.Second) i := 0 // 子协程 go func() { for { //\u003c-ticker.C i++ fmt.Println(\u003c-ticker.C) if i == 5 { //停止 ticker.Stop() } } }() for { } } ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:6:1","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"select ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:7:0","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"select多路复用 在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现： for{ // 尝试从ch1接收值 data, ok := \u003c-ch1 // 尝试从ch2接收值 data, ok := \u003c-ch2 … } 这种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了select关键字，可以同时响应多个通道的操作。 select的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。select会一直等待，直到某个case的通信操作完成时，就会执行case分支对应的语句。具体格式如下： select { case \u003c-chan1: // 如果chan1成功读到数据，则进行该case处理语句 case chan2 \u003c- 1: // 如果成功向chan2写入数据，则进行该case处理语句 default: // 如果上面都没有成功，则进入default处理流程 } select可以同时监听一个或多个channel，直到其中一个channel ready package main import ( \"fmt\" \"time\" ) func test1(ch chan string) { time.Sleep(time.Second * 5) ch \u003c- \"test1\" } func test2(ch chan string) { time.Sleep(time.Second * 2) ch \u003c- \"test2\" } func main() { // 2个管道 output1 := make(chan string) output2 := make(chan string) // 跑2个子协程，写数据 go test1(output1) go test2(output2) // 用select监控 select { case s1 := \u003c-output1: fmt.Println(\"s1=\", s1) case s2 := \u003c-output2: fmt.Println(\"s2=\", s2) } } 如果多个channel同时ready，则随机选择一个执行 package main import ( \"fmt\" ) func main() { // 创建2个管道 int_chan := make(chan int, 1) string_chan := make(chan string, 1) go func() { //time.Sleep(2 * time.Second) int_chan \u003c- 1 }() go func() { string_chan \u003c- \"hello\" }() select { case value := \u003c-int_chan: fmt.Println(\"int:\", value) case value := \u003c-string_chan: fmt.Println(\"string:\", value) } fmt.Println(\"main结束\") } 可以用于判断管道是否存满 package main import ( \"fmt\" \"time\" ) // 判断管道有没有存满 func main() { // 创建管道 output1 := make(chan string, 10) // 子协程写数据 go write(output1) // 取数据 for s := range output1 { fmt.Println(\"res:\", s) time.Sleep(time.Second) } } func write(ch chan string) { for { select { // 写数据 case ch \u003c- \"hello\": fmt.Println(\"write hello\") default: fmt.Println(\"channel full\") } time.Sleep(time.Millisecond * 500) } } ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:7:1","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"并发安全和锁 有时候在Go代码中可能会存在多个goroutine同时操作一个资源（临界区），这种情况会发生竞态问题（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。 举个例子： var x int64 var wg sync.WaitGroup func add() { for i := 0; i \u003c 5000; i++ { x = x + 1 } wg.Done() } func main() { wg.Add(2) go add() go add() wg.Wait() fmt.Println(x) } 上面的代码中我们开启了两个goroutine去累加变量x的值，这两个goroutine在访问和修改x变量的时候就会存在数据竞争，导致最后的结果与期待的不符。 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:8:0","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"互斥锁 互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个goroutine可以访问共享资源。Go语言中使用sync包的Mutex类型来实现互斥锁。 使用互斥锁来修复上面代码的问题： var x int64 var wg sync.WaitGroup var lock sync.Mutex func add() { for i := 0; i \u003c 5000; i++ { lock.Lock() // 加锁 x = x + 1 lock.Unlock() // 解锁 } wg.Done() } func main() { wg.Add(2) go add() go add() wg.Wait() fmt.Println(x) } 使用互斥锁能够保证同一时间有且只有一个goroutine进入临界区，其他的goroutine则在等待锁；当互斥锁释放后，等待的goroutine才可以获取锁进入临界区，多个goroutine同时等待一个锁时，唤醒的策略是随机的。 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:8:1","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"读写互斥锁 互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用sync包中的RWMutex类型。 读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的goroutine如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个goroutine获取写锁之后，其他的goroutine无论是获取读锁还是写锁都会等待。 读写锁示例： var ( x int64 wg sync.WaitGroup lock sync.Mutex rwlock sync.RWMutex ) func write() { // lock.Lock() // 加互斥锁 rwlock.Lock() // 加写锁 x = x + 1 time.Sleep(10 * time.Millisecond) // 假设读操作耗时10毫秒 rwlock.Unlock() // 解写锁 // lock.Unlock() // 解互斥锁 wg.Done() } func read() { // lock.Lock() // 加互斥锁 rwlock.RLock() // 加读锁 time.Sleep(time.Millisecond) // 假设读操作耗时1毫秒 rwlock.RUnlock() // 解读锁 // lock.Unlock() // 解互斥锁 wg.Done() } func main() { start := time.Now() for i := 0; i \u003c 10; i++ { wg.Add(1) go write() } for i := 0; i \u003c 1000; i++ { wg.Add(1) go read() } wg.Wait() end := time.Now() fmt.Println(end.Sub(start)) } 需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:8:2","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"Sync ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:9:0","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"sync.WaitGroup 在代码中生硬的使用time.Sleep肯定是不合适的，Go语言中可以使用sync.WaitGroup来实现并发任务的同步。 sync.WaitGroup有以下几个方法： 方法名 功能 (wg * WaitGroup) Add(delta int) 计数器+delta (wg *WaitGroup) Done() 计数器-1 (wg *WaitGroup) Wait() 阻塞直到计数器变为0 sync.WaitGroup内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。 我们利用sync.WaitGroup将上面的代码优化一下： var wg sync.WaitGroup func hello() { defer wg.Done() fmt.Println(\"Hello Goroutine!\") } func main() { wg.Add(1) go hello() // 启动另外一个goroutine去执行hello函数 fmt.Println(\"main goroutine done!\") wg.Wait() } 需要注意sync.WaitGroup是一个结构体，传递的时候要传递指针。 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:9:1","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"sync.Once 说在前面的话：这是一个进阶知识点。 在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。 Go语言中的sync包中提供了一个针对只执行一次场景的解决方案–sync.Once。 sync.Once只有一个Do方法，其签名如下： func (o *Once) Do(f func()) {} 注意：如果要执行的函数f需要传递参数就需要搭配闭包来使用。 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:9:2","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"加载配置文件示例 延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子： var icons map[string]image.Image func loadIcons() { icons = map[string]image.Image{ \"left\": loadIcon(\"left.png\"), \"up\": loadIcon(\"up.png\"), \"right\": loadIcon(\"right.png\"), \"down\": loadIcon(\"down.png\"), } } // Icon 被多个goroutine调用时不是并发安全的 func Icon(name string) image.Image { if icons == nil { loadIcons() } return icons[name] } 多个goroutine并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个goroutine都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果： func loadIcons() { icons = make(map[string]image.Image) icons[\"left\"] = loadIcon(\"left.png\") icons[\"up\"] = loadIcon(\"up.png\") icons[\"right\"] = loadIcon(\"right.png\") icons[\"down\"] = loadIcon(\"down.png\") } 在这种情况下就会出现即使判断了icons不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化icons的时候不会被其他的goroutine操作，但是这样做又会引发性能问题。 使用sync.Once改造的示例代码如下： var icons map[string]image.Image var loadIconsOnce sync.Once func loadIcons() { icons = map[string]image.Image{ \"left\": loadIcon(\"left.png\"), \"up\": loadIcon(\"up.png\"), \"right\": loadIcon(\"right.png\"), \"down\": loadIcon(\"down.png\"), } } // Icon 是并发安全的 func Icon(name string) image.Image { loadIconsOnce.Do(loadIcons) return icons[name] } sync.Once其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:9:3","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"sync.Map Go语言中内置的map不是并发安全的。请看下面的示例： var m = make(map[string]int) func get(key string) int { return m[key] } func set(key string, value int) { m[key] = value } func main() { wg := sync.WaitGroup{} for i := 0; i \u003c 20; i++ { wg.Add(1) go func(n int) { key := strconv.Itoa(n) set(key, n) fmt.Printf(\"k=:%v,v:=%v\\n\", key, get(key)) wg.Done() }(i) } wg.Wait() } 上面的代码开启少量几个goroutine的时候可能没什么问题，当并发多了之后执行上面的代码就会报fatal error: concurrent map writes错误。 像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的sync包中提供了一个开箱即用的并发安全版map–sync.Map。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时sync.Map内置了诸如Store、Load、LoadOrStore、Delete、Range等操作方法。 var m = sync.Map{} func main() { wg := sync.WaitGroup{} for i := 0; i \u003c 20; i++ { wg.Add(1) go func(n int) { key := strconv.Itoa(n) m.Store(key, n) value, _ := m.Load(key) fmt.Printf(\"k=:%v,v:=%v\\n\", key, value) wg.Done() }(i) } wg.Wait() } ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:9:4","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"原子操作 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:10:0","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"原子操作 代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库sync/atomic提供。 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:10:1","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"atomic包 方法 解释 func LoadInt32(addr int32) (val int32) func LoadInt64(addr int64) (val int64)\u003cbr\u003efunc LoadUint32(addruint32) (val uint32)\u003cbr\u003efunc LoadUint64(addruint64) (val uint64)\u003cbr\u003efunc LoadUintptr(addruintptr) (val uintptr)\u003cbr\u003efunc LoadPointer(addrunsafe.Pointer) (val unsafe.Pointer) 读取操作 func StoreInt32(addr *int32, val int32) func StoreInt64(addr *int64, val int64) func StoreUint32(addr *uint32, val uint32) func StoreUint64(addr *uint64, val uint64) func StoreUintptr(addr *uintptr, val uintptr) func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer) 写入操作 func AddInt32(addr *int32, delta int32) (new int32) func AddInt64(addr *int64, delta int64) (new int64) func AddUint32(addr *uint32, delta uint32) (new uint32) func AddUint64(addr *uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr) 修改操作 func SwapInt32(addr *int32, new int32) (old int32) func SwapInt64(addr *int64, new int64) (old int64) func SwapUint32(addr *uint32, new uint32) (old uint32) func SwapUint64(addr *uint64, new uint64) (old uint64) func SwapUintptr(addr *uintptr, new uintptr) (old uintptr) func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer) 交换操作 func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool) func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool) func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool) func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool) func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool) 比较并交换操作 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:10:2","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"示例 我们填写一个示例来比较下互斥锁和原子操作的性能。 var x int64 var l sync.Mutex var wg sync.WaitGroup // 普通版加函数 func add() { // x = x + 1 x++ // 等价于上面的操作 wg.Done() } // 互斥锁版加函数 func mutexAdd() { l.Lock() x++ l.Unlock() wg.Done() } // 原子操作版加函数 func atomicAdd() { atomic.AddInt64(\u0026x, 1) wg.Done() } func main() { start := time.Now() for i := 0; i \u003c 10000; i++ { wg.Add(1) // go add() // 普通版add函数 不是并发安全的 // go mutexAdd() // 加锁版add函数 是并发安全的，但是加锁性能开销大 go atomicAdd() // 原子操作版add函数 是并发安全，性能优于加锁版 } wg.Wait() end := time.Now() fmt.Println(x) fmt.Println(end.Sub(start)) } atomic包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数/类型实现同步更好。 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:10:3","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"GMP原理和调度 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:11:0","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"一、Golang “调度器” 的由来？ 单进程时代不需要调度器 我们知道，一切的软件都是跑在操作系统上，真正用来干活 (计算) 的是 CPU。早期的操作系统每个程序就是一个进程，知道一个程序运行完，才能进行下一个进程，就是 “单进程时代” 一切的程序只能串行发生。 早期的单进程操作系统，面临 2 个问题： 单一的执行流程，计算机只能一个任务一个任务处理。 进程阻塞所带来的 CPU 时间浪费。 那么能不能有多个进程来宏观一起来执行多个任务呢？ 后来操作系统就具有了最早的并发能力：多进程并发，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把 CPU 利用起来，CPU 就不浪费了。 多进程 / 线程时代有了调度器需求 在多进程 / 多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞 cpu 可以立刻切换到其他进程中去执行，而且调度 cpu 的算法可以保证在运行的进程都可以被分配到 cpu 的运行时间片。这样从宏观来看，似乎多个进程是在同时被运行。 但新的问题就又出现了，进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间，CPU 虽然利用起来了，但如果进程过多，CPU 有很大的一部分都被用来进行进程调度了。 怎么才能提高 CPU 的利用率呢？ 但是对于 Linux 操作系统来讲，cpu 对进程的态度和线程的态度是一样的。 很明显，CPU 调度切换的是进程和线程。尽管线程看起来很美好，但实际上多线程开发设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。 协程来提高 CPU 利用率 多进程、多线程已经提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存 (进程虚拟内存会占用 4GB [32 位操作系统], 而线程也要大约 4MB)。 大量的进程 / 线程出现了新的问题 高内存占用 调度的高消耗 CPU 好了，然后工程师们就发现，其实一个线程分为 “内核态 “线程和” 用户态 “线程。 一个 “用户态线程” 必须要绑定一个 “内核态线程”，但是 CPU 并不知道有 “用户态线程” 的存在，它只知道它运行的是一个 “内核态线程”(Linux 的 PCB 进程控制块)。 这样，我们再去细化去分类一下，内核线程依然叫 “线程 (thread)”，用户线程叫 “协程 (co-routine)”. 看到这里，我们就要开脑洞了，既然一个协程 (co-routine) 可以绑定一个线程 (thread)，那么能不能多个协程 (co-routine) 绑定一个或者多个线程 (thread) 上呢。 之后，我们就看到了有 3 中协程和线程的映射关系： s=\"default\"\u003e N:1 关系 N 个协程绑定 1 个线程，优点就是协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。但也有很大的缺点，1 个进程的所有协程都绑定在 1 个线程上 缺点： 某个程序用不了硬件的多核加速能力 一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。 s=\"default\"\u003e 1:1 关系 1 个协程绑定 1 个线程，这种最容易实现。协程的调度都由 CPU 完成了，不存在 N:1 缺点， 缺点： 协程的创建、删除和切换的代价都由 CPU 完成，有点略显昂贵了。 s=\"default\"\u003e M:N 关系 M 个协程绑定 1 个线程，是 N:1 和 1:1 类型的结合，克服了以上 2 种模型的缺点，但实现起来最为复杂。 协程跟线程是有区别的，线程由 CPU 调度是抢占式的，协程由用户态调度是协作式的，一个协程让出 CPU 后，才执行下一个协程。 Go 语言的协程 goroutine Go 为了提供更容易使用的并发方法，使用了 goroutine 和 channel。goroutine 来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被 runtime 调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。 Go 中，协程被称为 goroutine，它非常轻量，一个 goroutine 只占几 KB，并且这几 KB 就足够 goroutine 运行完，这就能在有限的内存空间内支持大量 goroutine，支持了更多的并发。虽然一个 goroutine 的栈只占几 KB，但实际是可伸缩的，如果需要更多内容，runtime 会自动为 goroutine 分配。 Goroutine 特点： 占用内存更小（几 kb） 调度更灵活 (runtime 调度) 被废弃的 goroutine 调度器 好了，既然我们知道了协程和线程的关系，那么最关键的一点就是调度协程的调度器的实现了。 Go 目前使用的调度器是 2012 年重新设计的，因为之前的调度器性能存在问题，所以使用 4 年就被废弃了，那么我们先来分析一下被废弃的调度器是如何运作的？ 大部分文章都是会用 G 来表示 Goroutine，用 M 来表示线程，那么我们也会用这种表达的对应关系。 下面我们来看看被废弃的 golang 调度器是如何实现的？ M 想要执行、放回 G 都必须访问全局 G 队列，并且 M 有多个，即多线程访问同一资源需要加锁进行保证互斥 / 同步，所以全局 G 队列是有互斥锁进行保护的。 老调度器有几个缺点： 创建、销毁、调度 G 都需要每个 M 获取锁，这就形成了激烈的锁竞争。 M 转移 G 会造成延迟和额外的系统负载。比如当 G 中包含创建新协程的时候，M 创建了 G’，为了继续执行 G，需要把 G’交给 M’执行，也造成了很差的局部性，因为 G’和 G 是相关的，最好放在 M 上执行，而不是其他 M’。 系统调用 (CPU 在 M 之间的切换) 导致频繁的线程阻塞和取消阻塞操作增加了系统开销。 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:11:1","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"二、Goroutine 调度器的 GMP 模型的设计思想 面对之前调度器的问题，Go 设计了新的调度器。 在新调度器中，出列 M (thread) 和 G (goroutine)，又引进了 P (Processor)。 Processor，它包含了运行 goroutine 的资源，如果线程想运行 goroutine，必须先获取 P，P 中还包含了可运行的 G 队列。 GMP 模型 在 Go 中，线程是运行 goroutine 的实体，调度器的功能是把可运行的 goroutine 分配到工作线程上。 全局队列（Global Queue）：存放等待运行的 G。 P 的本地队列：同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过 256 个。新建 G’时，G’优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列。 P 列表：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个。 M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。 Goroutine 调度器和 OS 调度器是通过 M 结合起来的，每个 M 都代表了 1 个内核线程，OS 调度器负责把内核线程分配到 CPU 的核上执行。 有关 P 和 M 的个数问题： P 的数量： 由启动时环境变量 $GOMAXPROCS 或者是由 runtime 的方法 GOMAXPROCS() 决定。这意味着在程序执行的任意时刻都只有 $GOMAXPROCS 个 goroutine 在同时运行。 M 的数量: go 语言本身的限制：go 程序启动时，会设置 M 的最大数量，默认 10000. 但是内核很难支持这么多的线程数，所以这个限制可以忽略。 runtime/debug 中的 SetMaxThreads 函数，设置 M 的最大数量 一个 M 阻塞了，会创建新的 M。 M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来。 P 和 M 何时会被创建： P 何时创建：在确定了 P 的最大数量 n 后，运行时系统会根据这个数量创建 n 个 P。 M 何时创建：没有足够的 M 来关联 P 并运行其中的可运行的 G。比如所有的 M 此时都阻塞住了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，就会去创建新的 M。 调度器的设计策略 复用线程：避免频繁的创建、销毁线程，而是对线程的复用。 1）work stealing 机制 当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程。 2）hand off 机制 当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行。 利用并行：GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行。GOMAXPROCS 也限制了并发的程度，比如 GOMAXPROCS = 核数/2，则最多利用了一半的 CPU 核进行并行。 抢占：在 coroutine 中要等待一个协程主动让出 CPU 才执行下一个协程，在 Go 中，一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死，这就是 goroutine 不同于 coroutine 的一个地方。 全局 G 队列：在新的调度器中依然有全局 G 队列，但功能已经被弱化了，当 M 执行 work stealing 从其他 P 偷不到 G 时，它可以从全局 G 队列获取 G。 go func () 调度流程 从上图我们可以分析出几个结论： 我们通过 go func () 来创建一个 goroutine； 有两个存储 G 的队列，一个是局部调度器 P 的本地队列、一个是全局 G 队列。新创建的 G 会先保存在 P 的本地队列中，如果 P 的本地队列已经满了就会保存在全局的队列中； G 只能运行在 M 中，一个 M 必须持有一个 P，M 与 P 是 1：1 的关系。M 会从 P 的本地队列弹出一个可执行状态的 G 来执行，如果 P 的本地队列为空，就会想其他的 MP 组合偷取一个可执行的 G 来执行； 一个 M 调度 G 执行的过程是一个循环机制； 当 M 执行某一个 G 时候如果发生了 syscall 或则其余阻塞操作，M 会阻塞，如果当前有一些 G 在执行，runtime 会把这个线程 M 从 P 中摘除 (detach)，然后再创建一个新的操作系统的线程 (如果有空闲的线程可用就复用空闲线程) 来服务于这个 P； 当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态， 加入到空闲线程中，然后这个 G 会被放入全局队列中。 调度器的生命周期 特殊的 M0 和 G0 M0 M0 是启动程序后的编号为 0 的主线程，这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，M0 负责执行初始化操作和启动第一个 G， 在之后 M0 就和其他的 M 一样了。 G0 G0 是每次启动一个 M 都会第一个创建的 goroutine，G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0。 我们来跟踪一段代码 package main import \"fmt\" func main() { fmt.Println(\"Hello world\") } 接下来我们来针对上面的代码对调度器里面的结构做一个分析。 也会经历如上图所示的过程： runtime 创建最初的线程 m0 和 goroutine g0，并把 2 者关联。 调度器初始化：初始化 m0、栈、垃圾回收，以及创建和初始化由 GOMAXPROCS 个 P 构成的 P 列表。 示例代码中的 main 函数是 main.main，runtime 中也有 1 个 main 函数 ——runtime.main，代码经过编译后，runtime.main 会调用 main.main，程序启动时会为 runtime.main 创建 goroutine，称它为 main goroutine 吧，然后把 main goroutine 加入到 P 的本地队列。 启动 m0，m0 已经绑定了 P，会从 P 的本地队列获取 G，获取到 main goroutine。 G 拥有栈，M 根据 G 中的栈信息和调度信息设置运行环境 M 运行 G G 退出，再次回到 M 获取可运行的 G，这样重复下去，直到 main.main 退出，runtime.main 执行 Defer 和 Panic 处理，或调用 runtime.exit 退出程序。 调度器的生命周期几乎占满了一个 Go 程序的一生，runtime.main 的 goroutine 执行之前都是为调度器做准备工作，runtime.main 的 goroutine 运行，才是调度器的真正开始，直到 runtime.main 结束而结束。 可视化 GMP 编程 有 2 种方式可以查看一个程序的 GMP 的数据。 方式 1：go tool trace trace 记录了运行时的信息，能提供可视化的 Web 页面。 简单测试代码：main 函数创建 trace，trace 会运行在单独的 goroutine 中，然后 main 打印”Hello World” 退出。 trace.go package main import ( \"os\" \"fmt\" \"runtime/trace\" ) func main() { //创建trace文件 f, err := os.Create(\"trace.out\") if err != nil { panic(err) } defer f.Close() //启动trace goroutine err = trace.Start(f) if err != nil { panic(err) } defer trace.Stop() //main fmt.Println(\"Hello World\") } 运行程序 $ go run trace.go Hello World 会得到一个 trace.out 文件，然后我们可以用一个工具打开，来分析这个文件。 $ go tool trace trace.out 2020/02/23 10:44:11 Parsing trace... 2020/02/23 10:44:11 Splitting trace... 2020/02/23 10:44:11 Opening browser. Trace viewer is listening on http://127.0.0.1:33479 我们可以通过浏览器打开 http://127.0.0.1:33479 网址，点击 view trace 能够看见可视化的调度流程。 G 信息 点击 Goroutines 那一行可视化的数据条，我们会看到一些详细的信息。 一共有两个G在程序中，一个是特殊的G0，是每个M必","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:11:2","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"三、Go 调度器调度场景过程全解析 场景 1 P 拥有 G1，M1 获取 P 后开始运行 G1，G1 使用 go func() 创建了 G2，为了局部性 G2 优先加入到 P1 的本地队列。 场景 2 G1 运行完成后 (函数：goexit)，M 上运行的 goroutine 切换为 G0，G0 负责调度时协程的切换（函数：schedule）。从 P 的本地队列取 G2，从 G0 切换到 G2，并开始运行 G2 (函数：execute)。实现了线程 M1 的复用。 场景 3 假设每个 P 的本地队列只能存 3 个 G。G2 要创建了 6 个 G，前 3 个 G（G3, G4, G5）已经加入 p1 的本地队列，p1 本地队列满了。 场景 4 G2 在创建 G7 的时候，发现 P1 的本地队列已满，需要执行负载均衡 (把 P1 中本地队列中前一半的 G，还有新创建 G 转移到全局队列) （实现中并不一定是新的 G，如果 G 是 G2 之后就执行的，会被保存在本地队列，利用某个老的 G 替换新 G 加入全局队列） 这些 G 被转移到全局队列时，会被打乱顺序。所以 G3,G4,G7 被转移到全局队列。 场景 5 G2 创建 G8 时，P1 的本地队列未满，所以 G8 会被加入到 P1 的本地队列。 G8 加入到 P1 点本地队列的原因还是因为 P1 此时在与 M1 绑定，而 G2 此时是 M1 在执行。所以 G2 创建的新的 G 会优先放置到自己的 M 绑定的 P 上。 场景 6 规定：在创建 G 时，运行的 G 会尝试唤醒其他空闲的 P 和 M 组合去执行。 假定 G2 唤醒了 M2，M2 绑定了 P2，并运行 G0，但 P2 本地队列没有 G，M2 此时为自旋线程（没有 G 但为运行状态的线程，不断寻找 G）。 (7) 场景 7 M2 尝试从全局队列 (简称 “GQ”) 取一批 G 放到 P2 的本地队列（函数：findrunnable()）。M2 从全局队列取的 G 数量符合下面的公式： n = min(len(GQ)/GOMAXPROCS + 1, len(GQ/2)) 至少从全局队列取 1 个 g，但每次不要从全局队列移动太多的 g 到 p 本地队列，给其他 p 留点。这是从全局队列到 P 本地队列的负载均衡。 假定我们场景中一共有 4 个 P（GOMAXPROCS 设置为 4，那么我们允许最多就能用 4 个 P 来供 M 使用）。所以 M2 只从能从全局队列取 1 个 G（即 G3）移动 P2 本地队列，然后完成从 G0 到 G3 的切换，运行 G3。 场景 8 假设 G2 一直在 M1 上运行，经过 2 轮后，M2 已经把 G7、G4 从全局队列获取到了 P2 的本地队列并完成运行，全局队列和 P2 的本地队列都空了，如场景 8 图的左半部分。 全局队列已经没有 G，那 m 就要执行 work stealing (偷取)：从其他有 G 的 P 哪里偷取一半 G 过来，放到自己的 P 本地队列。P2 从 P1 的本地队列尾部取一半的 G，本例中一半则只有 1 个 G8，放到 P2 的本地队列并执行。 场景 9 G1 本地队列 G5、G6 已经被其他 M 偷走并运行完成，当前 M1 和 M2 分别在运行 G2 和 G8，M3 和 M4 没有 goroutine 可以运行，M3 和 M4 处于自旋状态，它们不断寻找 goroutine。 为什么要让 m3 和 m4 自旋，自旋本质是在运行，线程在运行却没有执行 G，就变成了浪费 CPU. 为什么不销毁现场，来节约 CPU 资源。因为创建和销毁 CPU 也会浪费时间，我们希望当有新 goroutine 创建时，立刻能有 M 运行它，如果销毁再新建就增加了时延，降低了效率。当然也考虑了过多的自旋线程是浪费 CPU，所以系统中最多有 GOMAXPROCS 个自旋的线程 (当前例子中的 GOMAXPROCS=4，所以一共 4 个 P)，多余的没事做线程会让他们休眠。 场景 10 假定当前除了 M3 和 M4 为自旋线程，还有 M5 和 M6 为空闲的线程 (没有得到 P 的绑定，注意我们这里最多就只能够存在 4 个 P，所以 P 的数量应该永远是 M\u003e=P, 大部分都是 M 在抢占需要运行的 P)，G8 创建了 G9，G8 进行了阻塞的系统调用，M2 和 P2 立即解绑，P2 会执行以下判断：如果 P2 本地队列有 G、全局队列有 G 或有空闲的 M，P2 都会立马唤醒 1 个 M 和它绑定，否则 P2 则会加入到空闲 P 列表，等待 M 来获取可用的 p。本场景中，P2 本地队列有 G9，可以和其他空闲的线程 M5 绑定。 (11) 场景 11 G8 创建了 G9，假如 G8 进行了非阻塞系统调用。 M2 和 P2 会解绑，但 M2 会记住 P2，然后 G8 和 M2 进入系统调用状态。当 G8 和 M2 退出系统调用时，会尝试获取 P2，如果无法获取，则获取空闲的 P，如果依然没有，G8 会被记为可运行状态，并加入到全局队列，M2 因为没有 P 的绑定而变成休眠状态 (长时间休眠等待 GC 回收销毁)。 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:11:3","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"四、小结 总结，Go 调度器很轻量也很简单，足以撑起 goroutine 的调度工作，并且让 Go 具有了原生（强大）并发的能力。Go 调度本质是把大量的 goroutine 分配到少量线程上去执行，并利用多核并行，实现更强大的并发。 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:11:4","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"爬虫小案例 ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:12:0","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"爬虫步骤 明确目标（确定在哪个网站搜索） 爬（爬下内容） 取（筛选想要的） 处理数据（按照你的想法去处理） package main import ( \"fmt\" \"io/ioutil\" \"net/http\" \"regexp\" ) //这个只是一个简单的版本只是获取QQ邮箱并且没有进行封装操作，另外爬出来的数据也没有进行去重操作 var ( // \\d是数字 reQQEmail = `(\\d+)@qq.com` ) // 爬邮箱 func GetEmail() { // 1.去网站拿数据 resp, err := http.Get(\"https://tieba.baidu.com/p/6051076813?red_tag=1573533731\") HandleError(err, \"http.Get url\") defer resp.Body.Close() // 2.读取页面内容 pageBytes, err := ioutil.ReadAll(resp.Body) HandleError(err, \"ioutil.ReadAll\") // 字节转字符串 pageStr := string(pageBytes) //fmt.Println(pageStr) // 3.过滤数据，过滤qq邮箱 re := regexp.MustCompile(reQQEmail) // -1代表取全部 results := re.FindAllStringSubmatch(pageStr, -1) //fmt.Println(results) // 遍历结果 for _, result := range results { fmt.Println(\"email:\", result[0]) fmt.Println(\"qq:\", result[1]) } } // 处理异常 func HandleError(err error, why string) { if err != nil { fmt.Println(why, err) } } func main() { GetEmail() } ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:12:1","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"正则表达式 文档：https://studygolang.com/pkgdoc API re := regexp.MustCompile(reStr)，传入正则表达式，得到正则表达式对象 ret := re.FindAllStringSubmatch(srcStr,-1)：用正则对象，获取页面页面，srcStr是页面内容，-1代表取全部 爬邮箱 方法抽取 爬超链接 爬手机号 http://www.zhaohaowang.com/ 如果连接失效了自己找一个有手机号的就好了 爬身份证号 http://henan.qq.com/a/20171107/069413.htm 如果连接失效了自己找一个就好了 爬图片链接 package main import ( \"fmt\" \"io/ioutil\" \"net/http\" \"regexp\" ) var ( // w代表大小写字母+数字+下划线 reEmail = `\\w+@\\w+\\.\\w+` // s?有或者没有s // +代表出1次或多次 //\\s\\S各种字符 // +?代表贪婪模式 reLinke = `href=\"(https?://[\\s\\S]+?)\"` rePhone = `1[3456789]\\d\\s?\\d{4}\\s?\\d{4}` reIdcard = `[123456789]\\d{5}((19\\d{2})|(20[01]\\d))((0[1-9])|(1[012]))((0[1-9])|([12]\\d)|(3[01]))\\d{3}[\\dXx]` reImg = `https?://[^\"]+?(\\.((jpg)|(png)|(jpeg)|(gif)|(bmp)))` ) // 处理异常 func HandleError(err error, why string) { if err != nil { fmt.Println(why, err) } } func GetEmail2(url string) { pageStr := GetPageStr(url) re := regexp.MustCompile(reEmail) results := re.FindAllStringSubmatch(pageStr, -1) for _, result := range results { fmt.Println(result) } } // 抽取根据url获取内容 func GetPageStr(url string) (pageStr string) { resp, err := http.Get(url) HandleError(err, \"http.Get url\") defer resp.Body.Close() // 2.读取页面内容 pageBytes, err := ioutil.ReadAll(resp.Body) HandleError(err, \"ioutil.ReadAll\") // 字节转字符串 pageStr = string(pageBytes) return pageStr } func main() { // 2.抽取的爬邮箱 // GetEmail2(\"https://tieba.baidu.com/p/6051076813?red_tag=1573533731\") // 3.爬链接 //GetLink(\"http://www.baidu.com/s?wd=%E8%B4%B4%E5%90%A7%20%E7%95%99%E4%B8%8B%E9%82%AE%E7%AE%B1\u0026rsv_spt=1\u0026rsv_iqid=0x98ace53400003985\u0026issp=1\u0026f=8\u0026rsv_bp=1\u0026rsv_idx=2\u0026ie=utf-8\u0026tn=baiduhome_pg\u0026rsv_enter=1\u0026rsv_dl=ib\u0026rsv_sug2=0\u0026inputT=5197\u0026rsv_sug4=6345\") // 4.爬手机号 //GetPhone(\"https://www.zhaohaowang.com/\") // 5.爬身份证号 //GetIdCard(\"https://henan.qq.com/a/20171107/069413.htm\") // 6.爬图片 // GetImg(\"http://image.baidu.com/search/index?tn=baiduimage\u0026ps=1\u0026ct=201326592\u0026lm=-1\u0026cl=2\u0026nc=1\u0026ie=utf-8\u0026word=%E7%BE%8E%E5%A5%B3\") } func GetIdCard(url string) { pageStr := GetPageStr(url) re := regexp.MustCompile(reIdcard) results := re.FindAllStringSubmatch(pageStr, -1) for _, result := range results { fmt.Println(result) } } // 爬链接 func GetLink(url string) { pageStr := GetPageStr(url) re := regexp.MustCompile(reLinke) results := re.FindAllStringSubmatch(pageStr, -1) for _, result := range results { fmt.Println(result[1]) } } //爬手机号 func GetPhone(url string) { pageStr := GetPageStr(url) re := regexp.MustCompile(rePhone) results := re.FindAllStringSubmatch(pageStr, -1) for _, result := range results { fmt.Println(result) } } func GetImg(url string) { pageStr := GetPageStr(url) re := regexp.MustCompile(reImg) results := re.FindAllStringSubmatch(pageStr, -1) for _, result := range results { fmt.Println(result[0]) } } ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:12:2","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":"并发爬取美图 下面的两个是即将要爬的网站，如果网址失效自己换一个就好了 https://www.bizhizu.cn/shouji/tag-%E5%8F%AF%E7%88%B1/1.html package main import ( \"fmt\" \"io/ioutil\" \"net/http\" \"regexp\" \"strconv\" \"strings\" \"sync\" \"time\" ) func HandleError(err error, why string) { if err != nil { fmt.Println(why, err) } } // 下载图片，传入的是图片叫什么 func DownloadFile(url string, filename string) (ok bool) { resp, err := http.Get(url) HandleError(err, \"http.get.url\") defer resp.Body.Close() bytes, err := ioutil.ReadAll(resp.Body) HandleError(err, \"resp.body\") filename = \"E:/topgoer.com/src/github.com/student/3.0/img/\" + filename // 写出数据 err = ioutil.WriteFile(filename, bytes, 0666) if err != nil { return false } else { return true } } // 并发爬思路： // 1.初始化数据管道 // 2.爬虫写出：26个协程向管道中添加图片链接 // 3.任务统计协程：检查26个任务是否都完成，完成则关闭数据管道 // 4.下载协程：从管道里读取链接并下载 var ( // 存放图片链接的数据管道 chanImageUrls chan string waitGroup sync.WaitGroup // 用于监控协程 chanTask chan string reImg = `https?://[^\"]+?(\\.((jpg)|(png)|(jpeg)|(gif)|(bmp)))` ) func main() { // myTest() // DownloadFile(\"http://i1.shaodiyejin.com/uploads/tu/201909/10242/e5794daf58_4.jpg\", \"1.jpg\") // 1.初始化管道 chanImageUrls = make(chan string, 1000000) chanTask = make(chan string, 26) // 2.爬虫协程 for i := 1; i \u003c 27; i++ { waitGroup.Add(1) go getImgUrls(\"https://www.bizhizu.cn/shouji/tag-%E5%8F%AF%E7%88%B1/\" + strconv.Itoa(i) + \".html\") } // 3.任务统计协程，统计26个任务是否都完成，完成则关闭管道 waitGroup.Add(1) go CheckOK() // 4.下载协程：从管道中读取链接并下载 for i := 0; i \u003c 5; i++ { waitGroup.Add(1) go DownloadImg() } waitGroup.Wait() } // 下载图片 func DownloadImg() { for url := range chanImageUrls { filename := GetFilenameFromUrl(url) ok := DownloadFile(url, filename) if ok { fmt.Printf(\"%s 下载成功\\n\", filename) } else { fmt.Printf(\"%s 下载失败\\n\", filename) } } waitGroup.Done() } // 截取url名字 func GetFilenameFromUrl(url string) (filename string) { // 返回最后一个/的位置 lastIndex := strings.LastIndex(url, \"/\") // 切出来 filename = url[lastIndex+1:] // 时间戳解决重名 timePrefix := strconv.Itoa(int(time.Now().UnixNano())) filename = timePrefix + \"_\" + filename return } // 任务统计协程 func CheckOK() { var count int for { url := \u003c-chanTask fmt.Printf(\"%s 完成了爬取任务\\n\", url) count++ if count == 26 { close(chanImageUrls) break } } waitGroup.Done() } // 爬图片链接到管道 // url是传的整页链接 func getImgUrls(url string) { urls := getImgs(url) // 遍历切片里所有链接，存入数据管道 for _, url := range urls { chanImageUrls \u003c- url } // 标识当前协程完成 // 每完成一个任务，写一条数据 // 用于监控协程知道已经完成了几个任务 chanTask \u003c- url waitGroup.Done() } // 获取当前页图片链接 func getImgs(url string) (urls []string) { pageStr := GetPageStr(url) re := regexp.MustCompile(reImg) results := re.FindAllStringSubmatch(pageStr, -1) fmt.Printf(\"共找到%d条结果\\n\", len(results)) for _, result := range results { url := result[0] urls = append(urls, url) } return } // 抽取根据url获取内容 func GetPageStr(url string) (pageStr string) { resp, err := http.Get(url) HandleError(err, \"http.Get url\") defer resp.Body.Close() // 2.读取页面内容 pageBytes, err := ioutil.ReadAll(resp.Body) HandleError(err, \"ioutil.ReadAll\") // 字节转字符串 pageStr = string(pageBytes) return pageStr } ","date":"2022-01-06 09:16:49","objectID":"https://qizhengzou.github.io/go_base_07/:12:3","tags":["go grammar"],"title":"Go_base_07","uri":"https://qizhengzou.github.io/go_base_07/"},{"categories":["Go"],"content":" 参考学习go语言中文网、C语言中文网、golang官方文档等 网络编程 ","date":"2022-01-06 09:16:45","objectID":"https://qizhengzou.github.io/go_base_06/:0:0","tags":["go grammar"],"title":"Go_base_06","uri":"https://qizhengzou.github.io/go_base_06/"},{"categories":["Go"],"content":"互联网协议介绍 互联网的核心是一系列协议，总称为”互联网协议”（Internet Protocol Suite），正是这一些协议规定了电脑如何连接和组网。我们理解了这些协议，就理解了互联网的原理。由于这些协议太过庞大和复杂，没有办法在这里一概而全，只能介绍一下我们日常开发中接触较多的几个协议。 ","date":"2022-01-06 09:16:45","objectID":"https://qizhengzou.github.io/go_base_06/:1:0","tags":["go grammar"],"title":"Go_base_06","uri":"https://qizhengzou.github.io/go_base_06/"},{"categories":["Go"],"content":"互联网分层模型 互联网的逻辑实现被分为好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。用户接触到的只是最上面的那一层，根本不会感觉到下面的几层。要理解互联网就需要自下而上理解每一层的实现的功能。 如上图所示，互联网按照不同的模型划分会有不用的分层，但是不论按照什么模型去划分，越往上的层越靠近用户，越往下的层越靠近硬件。在软件开发中我们使用最多的是上图中将互联网划分为五个分层的模型。 接下来我们一层一层的自底向上介绍一下每一层。 物理层 我们的电脑要与外界互联网通信，需要先把电脑连接网络，我们可以用双绞线、光纤、无线电波等方式。这就叫做”实物理层”，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。 数据链路层 单纯的0和1没有任何意义，所以我们使用者会为其赋予一些特定的含义，规定解读电信号的方式：例如：多少个电信号算一组？每个信号位有何意义？这就是”数据链接层”的功能，它在”物理层”的上方，确定了物理层传输的0和1的分组方式及代表的意义。早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做”以太网”（Ethernet）的协议，占据了主导地位。 以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。其中”标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。”标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。 那么，发送者和接受者是如何标识呢？以太网规定，连入网络的所有设备都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。 我们会通过ARP协议来获取接受方的MAC地址，有了MAC地址之后，如何把数据准确的发送给接收方呢？其实这里以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机都发送，让每台计算机读取这个包的”标头”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。 网络层 按照以太网协议的规则我们可以依靠MAC地址来向外发送数据。理论上依靠MAC地址，你电脑的网卡就可以找到身在世界另一个角落的某台电脑的网卡了，但是这种做法有一个重大缺陷就是以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且发送的数据只能局限在发送者所在的子网络。也就是说如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理且必要的，因为如果互联网上每一台计算机都会收到互联网上收发的所有数据包，那是不现实的。 因此，必须找到一种方法区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。 “网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是网络管理员分配的。网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。 规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。目前，广泛采用的是IP协议第四版，简称IPv4。IPv4这个版本规定，网络地址由32个二进制位组成，我们通常习惯用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。 根据IP协议发送的数据，就叫做IP数据包。IP数据包也分为”标头”和”数据”两个部分：”标头”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65535字节。 传输层 有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。但问题是同一台主机上会有许多程序都需要用网络收发数据，比如QQ和浏览器这两个程序都需要连接互联网并收发数据，我们如何区分某个数据包到底是归哪个程序的呢？也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。 “端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。有了IP和端口我们就能实现唯一确定互联网上一个程序，进而实现网络间的程序通信。 我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。UDP数据包，也是由”标头”和”数据”两部分组成：”标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。 UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。为了解决这个问题，提高网络可靠性，TCP协议就诞生了。TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。 应用层 应用程序收到”传输层”的数据，接下来就要对数据进行解包。由于互联网是开放架构，数据来源五花八门，必须事先规定好通信的数据格式，否则接收方根本无法获得真正发送的数据内容。”应用层”的作用就是规定应用程序使用的数据格式，例如我们TCP协议之上常见的Email、HTTP、FTP等协议，这些协议就组成了互联网协议的应用层。 如下图所示，发送方的HTTP数据经过互联网的传输过程中会依次添加各层协议的标头信息，接收方收到数据包之后再依次根据协议解包得到数据。 ","date":"2022-01-06 09:16:45","objectID":"https://qizhengzou.github.io/go_base_06/:1:1","tags":["go grammar"],"title":"Go_base_06","uri":"https://qizhengzou.github.io/go_base_06/"},{"categories":["Go"],"content":"socket编程 ","date":"2022-01-06 09:16:45","objectID":"https://qizhengzou.github.io/go_base_06/:2:0","tags":["go grammar"],"title":"Go_base_06","uri":"https://qizhengzou.github.io/go_base_06/"},{"categories":["Go"],"content":"socket 图解 Socket是BSD UNIX的进程通信机制，通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄。Socket可以理解为TCP/IP网络的API，它定义了许多函数或例程，程序员可以用它们来开发TCP/IP网络上的应用程序。电脑上运行的应用程序通常通过”套接字”向网络发出请求或者应答网络请求。 socket图解 Socket是应用层与TCP/IP协议族通信的中间软件抽象层。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket后面，对用户来说只需要调用Socket规定的相关函数，让Socket去组织符合指定的协议数据然后进行通信。 Socket又称“套接字”，应用程序通常通过“套接字”向网络发出请求或者应答网络请求 常用的Socket类型有两种：流式Socket和数据报式Socket，流式是一种面向连接的Socket，针对于面向连接的TCP服务应用，数据报式Socket是一种无连接的Socket，针对于无连接的UDP服务应用 TCP：比较靠谱，面向连接，比较慢 UDP：不是太靠谱，比较快 举个例子：TCP就像货到付款的快递，送到家还必须见到你人才算一整套流程。UDP就像某快递快递柜一扔就走管你收到收不到，一般直播用UDP。 ","date":"2022-01-06 09:16:45","objectID":"https://qizhengzou.github.io/go_base_06/:2:1","tags":["go grammar"],"title":"Go_base_06","uri":"https://qizhengzou.github.io/go_base_06/"},{"categories":["Go"],"content":"TCP编程 Go语言实现TCP通信 TCP协议 TCP/IP(Transmission Control Protocol/Internet Protocol) 即传输控制协议/网际协议，是一种面向连接（连接导向）的、可靠的、基于字节流的传输层（Transport layer）通信协议，因为是面向连接的协议，数据像水流一样传输，会存在黏包问题。 TCP服务端 一个TCP服务端可以同时连接很多个客户端，例如世界各地的用户使用自己电脑上的浏览器访问淘宝网。因为Go语言中创建多个goroutine实现并发非常方便和高效，所以我们可以每建立一次链接就创建一个goroutine去处理。 TCP服务端程序的处理流程： 监听端口 接收客户端请求建立链接 创建goroutine处理链接。 我们使用Go语言的net包实现的TCP服务端代码如下： // tcp/server/main.go // TCP server端 // 处理函数 func process(conn net.Conn) { defer conn.Close() // 关闭连接 for { reader := bufio.NewReader(conn) var buf [128]byte n, err := reader.Read(buf[:]) // 读取数据 if err != nil { fmt.Println(\"read from client failed, err:\", err) break } recvStr := string(buf[:n]) fmt.Println(\"收到client端发来的数据：\", recvStr) conn.Write([]byte(recvStr)) // 发送数据 } } func main() { listen, err := net.Listen(\"tcp\", \"127.0.0.1:20000\") if err != nil { fmt.Println(\"listen failed, err:\", err) return } for { conn, err := listen.Accept() // 建立连接 if err != nil { fmt.Println(\"accept failed, err:\", err) continue } go process(conn) // 启动一个goroutine处理连接 } } 将上面的代码保存之后编译成server或server.exe可执行文件。 TCP客户端 一个TCP客户端进行TCP通信的流程如下： 建立与服务端的链接 进行数据收发 关闭链接 使用Go语言的net包实现的TCP客户端代码如下： // tcp/client/main.go // 客户端 func main() { conn, err := net.Dial(\"tcp\", \"127.0.0.1:20000\") if err != nil { fmt.Println(\"err :\", err) return } defer conn.Close() // 关闭连接 inputReader := bufio.NewReader(os.Stdin) for { input, _ := inputReader.ReadString('\\n') // 读取用户输入 inputInfo := strings.Trim(input, \"\\r\\n\") if strings.ToUpper(inputInfo) == \"Q\" { // 如果输入q就退出 return } _, err = conn.Write([]byte(inputInfo)) // 发送数据 if err != nil { return } buf := [512]byte{} n, err := conn.Read(buf[:]) if err != nil { fmt.Println(\"recv failed, err:\", err) return } fmt.Println(string(buf[:n])) } } 将上面的代码编译成client或client.exe可执行文件，先启动server端再启动client端，在client端输入任意内容回车之后就能够在server端看到client端发送的数据，从而实现TCP通信。 ","date":"2022-01-06 09:16:45","objectID":"https://qizhengzou.github.io/go_base_06/:2:2","tags":["go grammar"],"title":"Go_base_06","uri":"https://qizhengzou.github.io/go_base_06/"},{"categories":["Go"],"content":"UDP编程 Go语言实现UDP通信 UDP协议 UDP协议（User Datagram Protocol）中文名称是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联）参考模型中一种无连接的传输层协议，不需要建立连接就能直接进行数据发送和接收，属于不可靠的、没有时序的通信，但是UDP协议的实时性比较好，通常用于视频直播相关领域。 UDP服务端 使用Go语言的net包实现的UDP服务端代码如下： // UDP/server/main.go // UDP server端 func main() { listen, err := net.ListenUDP(\"udp\", \u0026net.UDPAddr{ IP: net.IPv4(0, 0, 0, 0), Port: 30000, }) if err != nil { fmt.Println(\"listen failed, err:\", err) return } defer listen.Close() for { var data [1024]byte n, addr, err := listen.ReadFromUDP(data[:]) // 接收数据 if err != nil { fmt.Println(\"read udp failed, err:\", err) continue } fmt.Printf(\"data:%v addr:%v count:%v\\n\", string(data[:n]), addr, n) _, err = listen.WriteToUDP(data[:n], addr) // 发送数据 if err != nil { fmt.Println(\"write to udp failed, err:\", err) continue } } } UDP客户端 使用Go语言的net包实现的UDP客户端代码如下： // UDP 客户端 func main() { socket, err := net.DialUDP(\"udp\", nil, \u0026net.UDPAddr{ IP: net.IPv4(0, 0, 0, 0), Port: 30000, }) if err != nil { fmt.Println(\"连接服务端失败，err:\", err) return } defer socket.Close() sendData := []byte(\"Hello server\") _, err = socket.Write(sendData) // 发送数据 if err != nil { fmt.Println(\"发送数据失败，err:\", err) return } data := make([]byte, 4096) n, remoteAddr, err := socket.ReadFromUDP(data) // 接收数据 if err != nil { fmt.Println(\"接收数据失败，err:\", err) return } fmt.Printf(\"recv:%v addr:%v count:%v\\n\", string(data[:n]), remoteAddr, n) } ","date":"2022-01-06 09:16:45","objectID":"https://qizhengzou.github.io/go_base_06/:2:3","tags":["go grammar"],"title":"Go_base_06","uri":"https://qizhengzou.github.io/go_base_06/"},{"categories":["Go"],"content":"TCP黏包 服务端代码如下： // socket_stick/server/main.go func process(conn net.Conn) { defer conn.Close() reader := bufio.NewReader(conn) var buf [1024]byte for { n, err := reader.Read(buf[:]) if err == io.EOF { break } if err != nil { fmt.Println(\"read from client failed, err:\", err) break } recvStr := string(buf[:n]) fmt.Println(\"收到client发来的数据：\", recvStr) } } func main() { listen, err := net.Listen(\"tcp\", \"127.0.0.1:30000\") if err != nil { fmt.Println(\"listen failed, err:\", err) return } defer listen.Close() for { conn, err := listen.Accept() if err != nil { fmt.Println(\"accept failed, err:\", err) continue } go process(conn) } } 客户端代码如下： // socket_stick/client/main.go func main() { conn, err := net.Dial(\"tcp\", \"127.0.0.1:30000\") if err != nil { fmt.Println(\"dial failed, err\", err) return } defer conn.Close() for i := 0; i \u003c 20; i++ { msg := `Hello, Hello. How are you?` conn.Write([]byte(msg)) } } 将上面的代码保存后，分别编译。先启动服务端再启动客户端，可以看到服务端输出结果如下： 收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you? 收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you? 收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you? 收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you? 收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you? 客户端分10次发送的数据，在服务端并没有成功的输出10次，而是多条数据“粘”到了一起。 ","date":"2022-01-06 09:16:45","objectID":"https://qizhengzou.github.io/go_base_06/:2:4","tags":["go grammar"],"title":"Go_base_06","uri":"https://qizhengzou.github.io/go_base_06/"},{"categories":["Go"],"content":"为什么会出现粘包 主要原因就是tcp数据传递模式是流模式，在保持长连接的时候可以进行多次的收和发。 “粘包”可发生在发送端也可发生在接收端： 由Nagle算法造成的发送端的粘包：Nagle算法是一种改善网络传输效率的算法。简单来说就是当我们提交一段数据给TCP发送时，TCP并不立刻发送此段数据，而是等待一小段时间看看在等待期间是否还有要发送的数据，若有则会一次把这两段数据发送出去。 接收端接收不及时造成的接收端粘包：TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时的把TCP的数据取出来，就会造成TCP缓冲区中存放了几段数据。 ","date":"2022-01-06 09:16:45","objectID":"https://qizhengzou.github.io/go_base_06/:2:5","tags":["go grammar"],"title":"Go_base_06","uri":"https://qizhengzou.github.io/go_base_06/"},{"categories":["Go"],"content":"解决办法 出现”粘包”的关键在于接收方不确定将要传输的数据包的大小，因此我们可以对数据包进行封包和拆包的操作。 封包：封包就是给一段数据加上包头，这样一来数据包就分为包头和包体两部分内容了(过滤非法包时封包会加入”包尾”内容)。包头部分的长度是固定的，并且它存储了包体的长度，根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的数据包。 我们可以自己定义一个协议，比如数据包的前4个字节为包头，里面存储的是发送的数据的长度。 // socket_stick/proto/proto.go package proto import ( \"bufio\" \"bytes\" \"encoding/binary\" ) // Encode 将消息编码 func Encode(message string) ([]byte, error) { // 读取消息的长度，转换成int32类型（占4个字节） var length = int32(len(message)) var pkg = new(bytes.Buffer) // 写入消息头 err := binary.Write(pkg, binary.LittleEndian, length) if err != nil { return nil, err } // 写入消息实体 err = binary.Write(pkg, binary.LittleEndian, []byte(message)) if err != nil { return nil, err } return pkg.Bytes(), nil } // Decode 解码消息 func Decode(reader *bufio.Reader) (string, error) { // 读取消息的长度 lengthByte, _ := reader.Peek(4) // 读取前4个字节的数据 lengthBuff := bytes.NewBuffer(lengthByte) var length int32 err := binary.Read(lengthBuff, binary.LittleEndian, \u0026length) if err != nil { return \"\", err } // Buffered返回缓冲中现有的可读取的字节数。 if int32(reader.Buffered()) \u003c length+4 { return \"\", err } // 读取真正的消息数据 pack := make([]byte, int(4+length)) _, err = reader.Read(pack) if err != nil { return \"\", err } return string(pack[4:]), nil } 接下来在服务端和客户端分别使用上面定义的proto包的Decode和Encode函数处理数据。 服务端代码如下： // socket_stick/server2/main.go func process(conn net.Conn) { defer conn.Close() reader := bufio.NewReader(conn) for { msg, err := proto.Decode(reader) if err == io.EOF { return } if err != nil { fmt.Println(\"decode msg failed, err:\", err) return } fmt.Println(\"收到client发来的数据：\", msg) } } func main() { listen, err := net.Listen(\"tcp\", \"127.0.0.1:30000\") if err != nil { fmt.Println(\"listen failed, err:\", err) return } defer listen.Close() for { conn, err := listen.Accept() if err != nil { fmt.Println(\"accept failed, err:\", err) continue } go process(conn) } } 客户端代码如下： // socket_stick/client2/main.go func main() { conn, err := net.Dial(\"tcp\", \"127.0.0.1:30000\") if err != nil { fmt.Println(\"dial failed, err\", err) return } defer conn.Close() for i := 0; i \u003c 20; i++ { msg := `Hello, Hello. How are you?` data, err := proto.Encode(msg) if err != nil { fmt.Println(\"encode msg failed, err:\", err) return } conn.Write(data) } } ","date":"2022-01-06 09:16:45","objectID":"https://qizhengzou.github.io/go_base_06/:2:6","tags":["go grammar"],"title":"Go_base_06","uri":"https://qizhengzou.github.io/go_base_06/"},{"categories":["Go"],"content":"http编程 ","date":"2022-01-06 09:16:45","objectID":"https://qizhengzou.github.io/go_base_06/:3:0","tags":["go grammar"],"title":"Go_base_06","uri":"https://qizhengzou.github.io/go_base_06/"},{"categories":["Go"],"content":"web工作流程 Web服务器的工作原理可以简单地归纳为 客户机通过TCP/IP协议建立到服务器的TCP连接 客户端向服务器发送HTTP协议请求包，请求服务器里的资源文档 服务器向客户机发送HTTP协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理“动态内容”，并将处理得到的数据返回给客户端 客户机与服务器断开。由客户端解释HTML文档，在客户端屏幕上渲染图形结果 ","date":"2022-01-06 09:16:45","objectID":"https://qizhengzou.github.io/go_base_06/:3:1","tags":["go grammar"],"title":"Go_base_06","uri":"https://qizhengzou.github.io/go_base_06/"},{"categories":["Go"],"content":"HTTP协议 超文本传输协议(HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议，它详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议 HTTP协议通常承载于TCP协议之上 ","date":"2022-01-06 09:16:45","objectID":"https://qizhengzou.github.io/go_base_06/:3:2","tags":["go grammar"],"title":"Go_base_06","uri":"https://qizhengzou.github.io/go_base_06/"},{"categories":["Go"],"content":"HTTP服务端 package main import ( \"fmt\" \"net/http\" ) func main() { //http://127.0.0.1:8000/go // 单独写回调函数 http.HandleFunc(\"/go\", myHandler) //http.HandleFunc(\"/ungo\",myHandler2 ) // addr：监听的地址 // handler：回调函数 http.ListenAndServe(\"127.0.0.1:8000\", nil) } // handler函数 func myHandler(w http.ResponseWriter, r *http.Request) { fmt.Println(r.RemoteAddr, \"连接成功\") // 请求方式：GET POST DELETE PUT UPDATE fmt.Println(\"method:\", r.Method) // /go fmt.Println(\"url:\", r.URL.Path) fmt.Println(\"header:\", r.Header) fmt.Println(\"body:\", r.Body) // 回复 w.Write([]byte(\"www.5lmh.com\")) } HTTP客户端 package main import ( \"fmt\" \"io\" \"net/http\" ) func main() { //resp, _ := http.Get(\"http://www.baidu.com\") //fmt.Println(resp) resp, _ := http.Get(\"http://127.0.0.1:8000/go\") defer resp.Body.Close() // 200 OK fmt.Println(resp.Status) fmt.Println(resp.Header) buf := make([]byte, 1024) for { // 接收服务端信息 n, err := resp.Body.Read(buf) if err != nil \u0026\u0026 err != io.EOF { fmt.Println(err) return } else { fmt.Println(\"读取完毕\") res := string(buf[:n]) fmt.Println(res) break } } } ","date":"2022-01-06 09:16:45","objectID":"https://qizhengzou.github.io/go_base_06/:3:3","tags":["go grammar"],"title":"Go_base_06","uri":"https://qizhengzou.github.io/go_base_06/"},{"categories":["Go"],"content":"WebSocket编程 ","date":"2022-01-06 09:16:45","objectID":"https://qizhengzou.github.io/go_base_06/:4:0","tags":["go grammar"],"title":"Go_base_06","uri":"https://qizhengzou.github.io/go_base_06/"},{"categories":["Go"],"content":"webSocket是什么 WebSocket是一种在单个TCP连接上进行全双工通信的协议 WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据 在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输 需要安装第三方包： cmd中：go get -u -v github.com/gorilla/websocket ","date":"2022-01-06 09:16:45","objectID":"https://qizhengzou.github.io/go_base_06/:4:1","tags":["go grammar"],"title":"Go_base_06","uri":"https://qizhengzou.github.io/go_base_06/"},{"categories":["Go"],"content":"举个聊天室的小例子 在同一级目录下新建四个go文件connection.go|data.go|hub.go|server.go 运行 go run server.go hub.go data.go connection.go 运行之后执行local.html文件 server.go文件代码 package main import ( \"fmt\" \"net/http\" \"github.com/gorilla/mux\" ) func main() { router := mux.NewRouter() go h.run() router.HandleFunc(\"/ws\", myws) if err := http.ListenAndServe(\"127.0.0.1:8080\", router); err != nil { fmt.Println(\"err:\", err) } } hub.go文件代码 package main import \"encoding/json\" var h = hub{ c: make(map[*connection]bool), u: make(chan *connection), b: make(chan []byte), r: make(chan *connection), } type hub struct { c map[*connection]bool b chan []byte r chan *connection u chan *connection } func (h *hub) run() { for { select { case c := \u003c-h.r: h.c[c] = true c.data.Ip = c.ws.RemoteAddr().String() c.data.Type = \"handshake\" c.data.UserList = user_list data_b, _ := json.Marshal(c.data) c.sc \u003c- data_b case c := \u003c-h.u: if _, ok := h.c[c]; ok { delete(h.c, c) close(c.sc) } case data := \u003c-h.b: for c := range h.c { select { case c.sc \u003c- data: default: delete(h.c, c) close(c.sc) } } } } } data.go文件代码 package main type Data struct { Ip string `json:\"ip\"` User string `json:\"user\"` From string `json:\"from\"` Type string `json:\"type\"` Content string `json:\"content\"` UserList []string `json:\"user_list\"` } connection.go文件代码 package main import ( \"encoding/json\" \"fmt\" \"net/http\" \"github.com/gorilla/websocket\" ) type connection struct { ws *websocket.Conn sc chan []byte data *Data } var wu = \u0026websocket.Upgrader{ReadBufferSize: 512, WriteBufferSize: 512, CheckOrigin: func(r *http.Request) bool { return true } } func myws(w http.ResponseWriter, r *http.Request) { ws, err := wu.Upgrade(w, r, nil) if err != nil { return } c := \u0026connection{sc: make(chan []byte, 256), ws: ws, data: \u0026Data{} } h.r \u003c- c go c.writer() c.reader() defer func() { c.data.Type = \"logout\" user_list = del(user_list, c.data.User) c.data.UserList = user_list c.data.Content = c.data.User data_b, _ := json.Marshal(c.data) h.b \u003c- data_b h.r \u003c- c }() } func (c *connection) writer() { for message := range c.sc { c.ws.WriteMessage(websocket.TextMessage, message) } c.ws.Close() } var user_list = []string{} func (c *connection) reader() { for { _, message, err := c.ws.ReadMessage() if err != nil { h.r \u003c- c break } json.Unmarshal(message, \u0026c.data) switch c.data.Type { case \"login\": c.data.User = c.data.Content c.data.From = c.data.User user_list = append(user_list, c.data.User) c.data.UserList = user_list data_b, _ := json.Marshal(c.data) h.b \u003c- data_b case \"user\": c.data.Type = \"user\" data_b, _ := json.Marshal(c.data) h.b \u003c- data_b case \"logout\": c.data.Type = \"logout\" user_list = del(user_list, c.data.User) data_b, _ := json.Marshal(c.data) h.b \u003c- data_b h.r \u003c- c default: fmt.Print(\"========default================\") } } } func del(slice []string, user string) []string { count := len(slice) if count == 0 { return slice } if count == 1 \u0026\u0026 slice[0] == user { return []string{} } var n_slice = []string{} for i := range slice { if slice[i] == user \u0026\u0026 i == count { return slice[:count] } else if slice[i] == user { n_slice = append(slice[:i], slice[i+1:]...) break } } fmt.Println(n_slice) return n_slice } local.html文件代码 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cmeta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\"\u003e \u003cstyle\u003e p { text-align: left; padding-left: 20px; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv style=\"width: 800px;height: 600px;margin: 30px auto;text-align: center\"\u003e \u003ch1\u003ewww.5lmh.comy演示聊天室\u003c/h1\u003e \u003cdiv style=\"width: 800px;border: 1px solid gray;height: 300px;\"\u003e \u003cdiv style=\"width: 200px;height: 300px;float: left;text-align: left;\"\u003e \u003cp\u003e\u003cspan\u003e当前在线:\u003c/span\u003e\u003cspan id=\"user_num\"\u003e0\u003c/span\u003e\u003c/p\u003e \u003cdiv id=\"user_list\" style=\"overflow: auto;\"\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv id=\"msg_list\" style=\"width: 598px;border: 1px solid gray; height: 300px;overflow: scroll;float: left;\"\u003e \u003c/div\u003e \u003c/div\u003e \u003cbr\u003e \u003ctextarea id=\"msg_box\" rows=\"6\" cols=\"50\" onkeydown=\"confirm(event)\"\u003e\u003c/textarea\u003e\u003cbr\u003e \u003cinput type=\"button\" value=\"发送\" onclick=\"send()\"\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e \u003cscr","date":"2022-01-06 09:16:45","objectID":"https://qizhengzou.github.io/go_base_06/:4:2","tags":["go grammar"],"title":"Go_base_06","uri":"https://qizhengzou.github.io/go_base_06/"},{"categories":["Go"],"content":" 参考学习go语言中文网、C语言中文网、golang官方文档等 面向对象 Is Go an object-oriented language? Yes and no. Although Go has types and methods and allows an object-oriented style of programming, there is no type hierarchy. The concept of “interface” in Go provides a different approach that we believe is easy to use and in some ways more general. Also, the lack of a type hierarchy makes “objects” in Go feel much more lightweight than in languages such as C++ or Java. 个人认为官网的大致意思就是go算是面向对象语言，没有继承，但有更通用的“接口”，没有继承也使对象比某些语言更轻量。 ","date":"2022-01-06 09:16:40","objectID":"https://qizhengzou.github.io/go_base_05/:0:0","tags":["go grammar"],"title":"Go_base_05","uri":"https://qizhengzou.github.io/go_base_05/"},{"categories":["Go"],"content":"匿名字段 go支持只提供类型而不写字段名的方式，也就是匿名字段，也称为嵌入字段 package main import \"fmt\" //- go支持只提供类型而不写字段名的方式，也就是匿名字段，也称为嵌入字段 //人 type Person struct { name string sex string age int } type Student struct { Person id int addr string } func main() { // 初始化 s1 := Student{Person{\"5lmh\", \"man\", 20}, 1, \"bj\"} fmt.Println(s1) s2 := Student{Person: Person{\"5lmh\", \"man\", 20} } fmt.Println(s2) s3 := Student{Person: Person{name: \"5lmh\"} } fmt.Println(s3) } output： { {5lmh man 20} 1 bj} { {5lmh man 20} 0 } { {5lmh 0} 0 } 同名字段的情况 package main import \"fmt\" //人 type Person struct { name string sex string age int } type Student struct { Person id int addr string //同名字段 name string } func main() { var s Student // 给自己字段赋值了 s.name = \"5lmh\" fmt.Println(s) // 若给父类同名字段赋值，如下 s.Person.name = \"枯藤\" fmt.Println(s) } output： { { 0} 0 5lmh} { {枯藤 0} 0 5lmh} 所有的内置类型和自定义类型都是可以作为匿名字段去使用 package main import \"fmt\" //人 type Person struct { name string sex string age int } // 自定义类型 type mystr string // 学生 type Student struct { Person int mystr } func main() { s1 := Student{Person{\"5lmh\", \"man\", 18}, 1, \"bj\"} fmt.Println(s1) } output： { {5lmh man 18} 1 bj} 指针类型匿名字段 package main import \"fmt\" //人 type Person struct { name string sex string age int } // 学生 type Student struct { *Person id int addr string } func main() { s1 := Student{\u0026Person{\"5lmh\", \"man\", 18}, 1, \"bj\"} fmt.Println(s1) fmt.Println(s1.name) fmt.Println(s1.Person.name) } output： {0xc00006a360 1 bj} 5lmh 5lmh ","date":"2022-01-06 09:16:40","objectID":"https://qizhengzou.github.io/go_base_05/:1:0","tags":["go grammar"],"title":"Go_base_05","uri":"https://qizhengzou.github.io/go_base_05/"},{"categories":["Go"],"content":"接口 接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。（也可以说是定义对象之间交互的协议的） ","date":"2022-01-06 09:16:40","objectID":"https://qizhengzou.github.io/go_base_05/:2:0","tags":["go grammar"],"title":"Go_base_05","uri":"https://qizhengzou.github.io/go_base_05/"},{"categories":["Go"],"content":"接口 接口类型 在Go语言中接口（interface）是一种类型，一种抽象的类型。 interface是一组method的集合，是duck-type programming的一种体现。接口做的事情就像是定义一个协议（规则），只要一台机器有洗衣服和甩干的功能，我就称它为洗衣机。不关心属性（数据），只关心行为（方法）。 为什么要使用接口 type Cat struct{} func (c Cat) Say() string { return \"喵喵喵\" } type Dog struct{} func (d Dog) Say() string { return \"汪汪汪\" } func main() { c := Cat{} fmt.Println(\"猫:\", c.Say()) d := Dog{} fmt.Println(\"狗:\", d.Say()) } 上面的代码中定义了猫和狗，然后它们都会叫，你会发现main函数中明显有重复的代码，如果我们后续再加上猪、青蛙等动物的话，我们的代码还会一直重复下去。那我们能不能把它们当成“能叫的动物”来处理呢？ 像类似的例子在我们编程过程中会经常遇到： 比如一个网上商城可能使用支付宝、微信、银联等方式去在线支付，我们能不能把它们当成“支付方式”来处理呢？ 比如三角形，四边形，圆形都能计算周长和面积，我们能不能把它们当成“图形”来处理呢？ 比如销售、行政、程序员都能计算月薪，我们能不能把他们当成“员工”来处理呢？ Go语言中为了解决类似上面的问题，就设计了接口这个概念。接口区别于我们之前所有的具体类型，接口是一种抽象的类型。当你看到一个接口类型的值时，你不知道它是什么，唯一知道的是通过它的方法能做什么。 接口的定义： （Go语言提倡面向接口编程。） 接口是一个或多个方法签名的集合。 任何类型的方法集中只要拥有该接口'对应的全部方法'签名。 就表示它 \"实现\" 了该接口，无须在该类型上显式声明实现了哪个接口。 这称为Structural Typing。 所谓对应方法，是指有相同名称、参数列表 (不包括参数名) 以及返回值。 当然，该类型还可以有其他方法。 接口只有方法声明，没有实现，没有数据字段。 接口可以匿名嵌入其他接口，或嵌入到结构中。 对象赋值给接口时，会发生拷贝，而接口内部存储的是指向这个复制品的指针，既无法修改复制品的状态，也无法获取指针。 只有当接口存储的类型和对象都为nil时，接口才等于nil。 接口调用不会做receiver的自动转换。 接口同样支持匿名字段方法。 接口也可实现类似OOP中的多态。 空接口可以作为任何类型数据的容器。 一个类型可实现多个接口。 接口命名习惯以 er 结尾。 每个接口由数个方法组成，接口的定义格式如下： type 接口类型名 interface{ 方法名1( 参数列表1 ) 返回值列表1 方法名2( 参数列表2 ) 返回值列表2 … } 其中： 接口名：使用type将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer，有字符串功能的接口叫Stringer等。接口名最好要能突出该接口的类型含义。 方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。 参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。 举个例子： type writer interface{ Write([]byte) error } 当你看到这个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的Write方法来做一些事情。 实现接口的条件 一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个需要实现的方法列表。 我们来定义一个Sayer接口： // Sayer 接口 type Sayer interface { say() } 定义dog和cat两个结构体： type dog struct {} type cat struct {} 因为Sayer接口里只有一个say方法，所以我们只需要给dog和cat 分别实现say方法就可以实现Sayer接口了。 // dog实现了Sayer接口 func (d dog) say() { fmt.Println(\"汪汪汪\") } // cat实现了Sayer接口 func (c cat) say() { fmt.Println(\"喵喵喵\") } 接口的实现就是这么简单，只要实现了接口中的所有方法，就实现了这个接口。 接口类型变量 那实现了接口有什么用呢？ 接口类型变量能够存储所有实现了该接口的实例。 例如上面的示例中，Sayer类型的变量能够存储dog和cat类型的变量。 func main() { var x Sayer // 声明一个Sayer类型的变量x a := cat{} // 实例化一个cat b := dog{} // 实例化一个dog x = a // 可以把cat实例直接赋值给x x.say() // 喵喵喵 x = b // 可以把dog实例直接赋值给x x.say() // 汪汪汪 } 值接收者和指针接收者实现接口的区别 使用值接收者实现接口和使用指针接收者实现接口有什么区别呢？接下来我们通过一个例子看一下其中的区别。 我们有一个Mover接口和一个dog结构体。 type Mover interface { move() } type dog struct {} 值接收者实现接口 func (d dog) move() { fmt.Println(\"狗会动\") } 此时实现接口的是dog类型： func main() { var x Mover var wangcai = dog{} // 旺财是dog类型 x = wangcai // x可以接收dog类型 var fugui = \u0026dog{} // 富贵是*dog类型 x = fugui // x可以接收*dog类型 x.move() } 从上面的代码中我们可以发现，使用值接收者实现接口之后，不管是dog结构体还是结构体指针*dog类型的变量都可以赋值给该接口变量。因为Go语言中有对指针类型变量求值的语法糖，dog指针fugui内部会自动求值*fugui。 指针接收者实现接口 同样的代码我们再来测试一下使用指针接收者有什么区别： func (d *dog) move() { fmt.Println(\"狗会动\") } func main() { var x Mover var wangcai = dog{} // 旺财是dog类型 x = wangcai // x不可以接收dog类型 var fugui = \u0026dog{} // 富贵是*dog类型 x = fugui // x可以接收*dog类型 } 此时实现Mover接口的是*dog类型，所以不能给x传入dog类型的wangcai，此时x只能存储*dog类型的值。 用接口实现多态 接口的最佳实践 倾向于使⽤⼩的接⼝定义，很多接⼝只包含⼀个⽅法 较⼤的接⼝定义，可以由多个⼩接⼝定义组合⽽成 只依赖于必要功能的最小接口，这样方法的复用性更强。 下面的代码是一个比较好的面试题 请问下面的代码是否能通过编译？ type People interface { Speak(string) string } type Student struct{} func (stu *Student) Speak(think string) (talk string) { if think == \"sb\" { talk = \"你是个大帅比\" } else { talk = \"您好\" } return } func main() { var peo People = Student{} think := \"bitch\" fmt.Println(peo.Speak(think)) } ","date":"2022-01-06 09:16:40","objectID":"https://qizhengzou.github.io/go_base_05/:2:1","tags":["go grammar"],"title":"Go_base_05","uri":"https://qizhengzou.github.io/go_base_05/"},{"categories":["Go"],"content":"类型与接口的关系 一个类型实现多个接口 一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。 例如，狗可以叫，也可以动。我们就分别定义Sayer接口和Mover接口，如下： Mover接口。 // Sayer 接口 type Sayer interface { say() } // Mover 接口 type Mover interface { move() } dog既可以实现Sayer接口，也可以实现Mover接口。 type dog struct { name string } // 实现Sayer接口 func (d dog) say() { fmt.Printf(\"%s会叫汪汪汪\\n\", d.name) } // 实现Mover接口 func (d dog) move() { fmt.Printf(\"%s会动\\n\", d.name) } func main() { var x Sayer var y Mover var a = dog{name: \"旺财\"} x = a y = a x.say() y.move() } 多个类型实现同一接口 Go语言中不同的类型还可以实现同一接口 首先我们定义一个Mover接口，它要求必须由一个move方法。 // Mover 接口 type Mover interface { move() } 例如狗可以动，汽车也可以动，可以使用如下代码实现这个关系： type dog struct { name string } type car struct { brand string } // dog类型实现Mover接口 func (d dog) move() { fmt.Printf(\"%s会跑\\n\", d.name) } // car类型实现Mover接口 func (c car) move() { fmt.Printf(\"%s速度70迈\\n\", c.brand) } 这个时候我们在代码中就可以把狗和汽车当成一个会动的物体来处理了，不再需要关注它们具体是什么，只需要调用它们的move方法就可以了。 func main() { var x Mover var a = dog{name: \"旺财\"} var b = car{brand: \"保时捷\"} x = a x.move() x = b x.move() } 上面的代码执行结果如下： 旺财会跑 保时捷速度70迈 并且一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。 // WashingMachine 洗衣机 type WashingMachine interface { wash() dry() } // 甩干器 type dryer struct{} // 实现WashingMachine接口的dry()方法 func (d dryer) dry() { fmt.Println(\"甩一甩\") } // 海尔洗衣机 type haier struct { dryer //嵌入甩干器 } // 实现WashingMachine接口的wash()方法 func (h haier) wash() { fmt.Println(\"洗刷刷\") } 接口嵌套 接口与接口间可以通过嵌套创造出新的接口。 // Sayer 接口 type Sayer interface { say() } // Mover 接口 type Mover interface { move() } // 接口嵌套 type animal interface { Sayer Mover } 嵌套得到的接口的使用与普通接口一样，这里我们让cat实现animal接口： type cat struct { name string } func (c cat) say() { fmt.Println(\"喵喵喵\") } func (c cat) move() { fmt.Println(\"猫会动\") } func main() { var x animal x = cat{name: \"花花\"} x.move() x.say() } ","date":"2022-01-06 09:16:40","objectID":"https://qizhengzou.github.io/go_base_05/:2:2","tags":["go grammar"],"title":"Go_base_05","uri":"https://qizhengzou.github.io/go_base_05/"},{"categories":["Go"],"content":"空接口 空接口的定义 空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。 空接口类型的变量可以存储任意类型的变量。 func main() { // 定义一个空接口x var x interface{} s := \"pprof.cn\" x = s fmt.Printf(\"type:%T value:%v\\n\", x, x) i := 100 x = i fmt.Printf(\"type:%T value:%v\\n\", x, x) b := true x = b fmt.Printf(\"type:%T value:%v\\n\", x, x) } ","date":"2022-01-06 09:16:40","objectID":"https://qizhengzou.github.io/go_base_05/:2:3","tags":["go grammar"],"title":"Go_base_05","uri":"https://qizhengzou.github.io/go_base_05/"},{"categories":["Go"],"content":"空接口的应用 空接口作为函数的参数 使用空接口实现可以接收任意类型的函数参数。 // 空接口作为函数参数 func show(a interface{}) { fmt.Printf(\"type:%T value:%v\\n\", a, a) } 空接口作为map的值 使用空接口实现可以保存任意值的字典。 // 空接口作为map值 var studentInfo = make(map[string]interface{}) studentInfo[\"name\"] = \"李白\" studentInfo[\"age\"] = 18 studentInfo[\"married\"] = false fmt.Println(studentInfo) ","date":"2022-01-06 09:16:40","objectID":"https://qizhengzou.github.io/go_base_05/:2:4","tags":["go grammar"],"title":"Go_base_05","uri":"https://qizhengzou.github.io/go_base_05/"},{"categories":["Go"],"content":"类型断言 空接口可以存储任意类型的值，那我们如何获取其存储的具体数据呢？ 接口值 一个接口的值（简称接口值）是由一个具体类型和具体类型的值两部分组成的。这两部分分别称为接口的动态类型和动态值。 我们来看一个具体的例子： var w io.Writer w = os.Stdout w = new(bytes.Buffer) w = nil 请看下图分解（来自go中文文档）：想要判断空接口中的值这个时候就可以使用类型断言，其语法格式： x.(T) 其中： x：表示类型为interface{}的变量 T：表示断言x可能是的类型。 该语法返回两个参数，第一个参数是x转化为T类型后的变量，第二个值是一个布尔值，若为true则表示断言成功，为false则表示断言失败。 举个例子： func main() { var x interface{} x = \"pprof.cn\" v, ok := x.(string) if ok { fmt.Println(v) } else { fmt.Println(\"类型断言失败\") } } 上面的示例中如果要断言多次就需要写多个if判断，这个时候我们可以使用switch语句来实现： func justifyType(x interface{}) { switch v := x.(type) { case string: fmt.Printf(\"x is a string，value is %v\\n\", v) case int: fmt.Printf(\"x is a int is %v\\n\", v) case bool: fmt.Printf(\"x is a bool is %v\\n\", v) default: fmt.Println(\"unsupport type！\") } } 因为空接口可以存储任意类型值的特点，所以空接口在Go语言中的使用十分广泛。 关于接口需要注意的是，只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。不要为了接口而写接口，那样只会增加不必要的抽象，导致不必要的运行时损耗。 ","date":"2022-01-06 09:16:40","objectID":"https://qizhengzou.github.io/go_base_05/:2:5","tags":["go grammar"],"title":"Go_base_05","uri":"https://qizhengzou.github.io/go_base_05/"},{"categories":["Go"],"content":" 参考学习go语言中文网、C语言中文网、golang官方文档等 方法 ","date":"2022-01-06 09:16:37","objectID":"https://qizhengzou.github.io/go_base_04/:0:0","tags":["go grammar"],"title":"Go_base_04","uri":"https://qizhengzou.github.io/go_base_04/"},{"categories":["Go"],"content":"方法定义 Golang 方法总是绑定对象实例，并隐式将实例作为第一实参 (receiver)。 只能为当前包内命名类型定义方法。 参数 receiver 可任意命名。如方法中未曾使用 ，可省略参数名。 参数 receiver 类型可以是 T 或 *T。基类型 T 不能是接口或指针。 不支持方法重载，receiver 只是参数签名的组成部分。 可用实例 value 或 pointer 调用全部方法，编译器自动转换。 一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。 所有给定类型的方法属于该类型的方法集。 func (recevier type) methodName(参数列表)(返回值列表){} //参数和返回值可以省略 package main type Test struct{} // 无参数、无返回值 func (t Test) method0() { } // 单参数、无返回值 func (t Test) method1(i int) { } // 多参数、无返回值 func (t Test) method2(x, y int) { } // 无参数、单返回值 func (t Test) method3() (i int) { return } // 多参数、多返回值 func (t Test) method4(x, y int) (z int, err error) { return } // 无参数、无返回值 func (t *Test) method5() { } // 单参数、无返回值 func (t *Test) method6(i int) { } // 多参数、无返回值 func (t *Test) method7(x, y int) { } // 无参数、单返回值 func (t *Test) method8() (i int) { return } // 多参数、多返回值 func (t *Test) method9(x, y int) (z int, err error) { return } func main() {} 下面定义一个结构体类型和该类型的一个方法： package main import ( \"fmt\" ) //结构体 type User struct { Name string Email string } //方法 func (u User) Notify() { fmt.Printf(\"%v : %v \\n\", u.Name, u.Email) } func main() { // 值类型调用方法 u1 := User{\"golang\", \"golang@golang.com\"} u1.Notify() // 指针类型调用方法 u2 := User{\"go\", \"go@go.com\"} u3 := \u0026u2 u3.Notify() } output： golang : golang@golang.com go : go@go.com 解释： 首先我们定义了一个叫做 User 的结构体类型，然后定义了一个该类型的方法叫做 Notify，该方法的接受者是一个 User 类型的值。要调用 Notify 方法我们需要一个 User 类型的值或者指针。 在这个例子中当我们使用指针时，Go 调整和解引用指针使得调用可以被执行。注意，当接受者不是一个指针时，该方法操作对应接受者的值的副本(意思就是即使你使用了指针调用函数，但是函数的接受者是值类型，所以函数内部操作还是对副本的操作，而不是指针操作。 我们修改 Notify 方法，让它的接受者使用指针类型： package main import ( \"fmt\" ) //结构体 type User struct { Name string Email string } //方法 func (u *User) Notify() { fmt.Printf(\"%v : %v \\n\", u.Name, u.Email) } func main() { // 值类型调用方法 u1 := User{\"golang\", \"golang@golang.com\"} u1.Notify() // 指针类型调用方法 u2 := User{\"go\", \"go@go.com\"} u3 := \u0026u2 u3.Notify() } output： golang : golang@golang.com go : go@go.com 注意：当接受者是指针时，即使用值类型调用那么函数内部也是对指针的操作。 方法不过是一种特殊的函数，只需将其还原，就知道 receiver T 和 *T 的差别。 package main import \"fmt\" type Data struct { x int } func (self Data) ValueTest() { // func ValueTest(self Data); fmt.Printf(\"Value: %p\\n\", \u0026self) } func (self *Data) PointerTest() { // func PointerTest(self *Data); fmt.Printf(\"Pointer: %p\\n\", self) } func main() { d := Data{} p := \u0026d fmt.Printf(\"Data: %p\\n\", p) d.ValueTest() // ValueTest(d) d.PointerTest() // PointerTest(\u0026d) p.ValueTest() // ValueTest(*p) p.PointerTest() // PointerTest(p) } output: Data: 0xc42007c008 Value: 0xc42007c018 Pointer: 0xc42007c008 Value: 0xc42007c020 Pointer: 0xc42007c008 普通函数与方法的区别 1.对于普通函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然。 2.对于方法（如struct的方法），接收者为值类型时，可以直接用指针类型的变量调用方法，反过来同样也可以。 package main //普通函数与方法的区别（在接收者分别为值类型和指针类型的时候） import ( \"fmt\" ) //1.普通函数 //接收值类型参数的函数 func valueIntTest(a int) int { return a + 10 } //接收指针类型参数的函数 func pointerIntTest(a *int) int { return *a + 10 } func structTestValue() { a := 2 fmt.Println(\"valueIntTest:\", valueIntTest(a)) //函数的参数为值类型，则不能直接将指针作为参数传递 //fmt.Println(\"valueIntTest:\", valueIntTest(\u0026a)) //compile error: cannot use \u0026a (type *int) as type int in function argument b := 5 fmt.Println(\"pointerIntTest:\", pointerIntTest(\u0026b)) //同样，当函数的参数为指针类型时，也不能直接将值类型作为参数传递 //fmt.Println(\"pointerIntTest:\", pointerIntTest(b)) //compile error:cannot use b (type int) as type *int in function argument } //2.方法 type PersonD struct { id int name string } //接收者为值类型 func (p PersonD) valueShowName() { fmt.Println(p.name) } //接收者为指针类型 func (p *PersonD) pointShowName() { fmt.Println(p.name) } func structTestFunc() { //值类型调用方法 personValue := PersonD{101, \"hello world\"} personValue.valueShowName() personValue.pointShowName() //指针类型调用方法 personPointer := \u0026PersonD{102, \"hello golang\"} personPointer.valueShowName() personPointer.pointShowName() //与普通函数不同，接收者为指针类型和值类型的方法，指针类型和值类型的变量均可相互调用 } func main() { structTestValue() structTestFunc() } output： valueIntTest: 12 pointerIntTest: 15 hello world hello world hello golang hello golang ","date":"2022-01-06 09:16:37","objectID":"https://qizhengzou.github.io/go_base_04/:1:0","tags":["go grammar"],"title":"Go_base_04","uri":"https://qizhengzou.github.io/go_base_04/"},{"categories":["Go"],"content":"匿名字段 Golang匿名字段 ：可以像字段成员那样访问匿名字段方法，编译器负责查找。 package main import \"fmt\" type User struct { id int name string } type Manager struct { User } func (self *User) ToString() string { // receiver = \u0026(Manager.User) return fmt.Sprintf(\"User: %p, %v\", self, self) } func main() { m := Manager{User{1, \"Tom\"} } fmt.Printf(\"Manager: %p\\n\", \u0026m) fmt.Println(m.ToString()) } output: Manager: 0xc42000a060 User: 0xc42000a060, \u0026{1 Tom} 通过匿名字段，可获得和继承类似的复用能力。依据编译器查找次序，只需在外层定义同名方法，就可以实现 “override”。 package main import \"fmt\" type User struct { id int name string } type Manager struct { User title string } func (self *User) ToString() string { return fmt.Sprintf(\"User: %p, %v\", self, self) } func (self *Manager) ToString() string { return fmt.Sprintf(\"Manager: %p, %v\", self, self) } func main() { m := Manager{User{1, \"Tom\"}, \"Administrator\"} fmt.Println(m.ToString()) fmt.Println(m.User.ToString()) } output: Manager: 0xc420074180, \u0026\\{\\{1 Tom} Administrator} User: 0xc420074180, \u0026{1 Tom} ","date":"2022-01-06 09:16:37","objectID":"https://qizhengzou.github.io/go_base_04/:2:0","tags":["go grammar"],"title":"Go_base_04","uri":"https://qizhengzou.github.io/go_base_04/"},{"categories":["Go"],"content":"方法集 Golang方法集 ：每个类型都有与之关联的方法集，这会影响到接口实现规则。 类型 T 方法集包含全部 receiver T 方法。 类型 *T 方法集包含全部 receiver T + *T 方法。 如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。 如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T + *T 方法。 不管嵌入 T 或 *T，*S 方法集总是包含 T + *T 方法。 用实例 value 和 pointer 调用方法 (含匿名字段) 不受方法集约束，编译器总是查找全部方法，并自动转换 receiver 实参。 Go 语言中内部类型方法集提升的规则： 类型 T 方法集包含全部 receiver T 方法。 package main import ( \"fmt\" ) type T struct { int } func (t T) test() { fmt.Println(\"类型 T 方法集包含全部 receiver T 方法。\") } func main() { t1 := T{1} fmt.Printf(\"t1 is : %v\\n\", t1) t1.test() } output： t1 is : {1} 类型 T 方法集包含全部 receiver T 方法。 类型 *T 方法集包含全部 receiver T + *T 方法。 package main import ( \"fmt\" ) type T struct { int } func (t T) testT() { fmt.Println(\"类型 *T 方法集包含全部 receiver T 方法。\") } func (t *T) testP() { fmt.Println(\"类型 *T 方法集包含全部 receiver *T 方法。\") } func main() { t1 := T{1} t2 := \u0026t1 fmt.Printf(\"t2 is : %v\\n\", t2) t2.testT() t2.testP() } output： t2 is : \u0026{1} 类型 *T 方法集包含全部 receiver T 方法。 类型 *T 方法集包含全部 receiver *T 方法。 给定一个结构体类型 S 和一个命名为 T 的类型，方法提升像下面规定的这样被包含在结构体方法集中： 如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。 这条规则说的是当我们嵌入一个类型，嵌入类型的接受者为值类型的方法将被提升，可以被外部类型的值和指针调用。 package main import ( \"fmt\" ) type S struct { T } type T struct { int } func (t T) testT() { fmt.Println(\"如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。\") } func main() { s1 := S{T{1} } s2 := \u0026s1 fmt.Printf(\"s1 is : %v\\n\", s1) s1.testT() fmt.Printf(\"s2 is : %v\\n\", s2) s2.testT() } output： s1 is : { {1} } 如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。 s2 is : \u0026{ {1} } 如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。 如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T + *T 方法。 这条规则说的是当我们嵌入一个类型的指针，嵌入类型的接受者为值类型或指针类型的方法将被提升，可以被外部类型的值或者指针调用。 package main import ( \"fmt\" ) type S struct { T } type T struct { int } func (t T) testT() { fmt.Println(\"如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T 方法\") } func (t *T) testP() { fmt.Println(\"如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 *T 方法\") } func main() { s1 := S{T{1} } s2 := \u0026s1 fmt.Printf(\"s1 is : %v\\n\", s1) s1.testT() s1.testP() fmt.Printf(\"s2 is : %v\\n\", s2) s2.testT() s2.testP() } output： s1 is : { {1} } 如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T 方法 如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 *T 方法 s2 is : \u0026{ {1} } 如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T 方法 如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 *T 方法 ","date":"2022-01-06 09:16:37","objectID":"https://qizhengzou.github.io/go_base_04/:3:0","tags":["go grammar"],"title":"Go_base_04","uri":"https://qizhengzou.github.io/go_base_04/"},{"categories":["Go"],"content":"表达式 Golang 表达式 ：根据调用者不同，方法分为两种表现形式: instance.method(args...) ---\u003e \u003ctype\u003e.func(instance, args...) 前者称为 method value，后者 method expression。 两者都可像普通函数那样赋值和传参，区别在于 method value 绑定实例，而 method expression 则须显式传参。 package main import \"fmt\" type User struct { id int name string } func (self *User) Test() { fmt.Printf(\"%p, %v\\n\", self, self) } func main() { u := User{1, \"Tom\"} u.Test() mValue := u.Test mValue() // 隐式传递 receiver mExpression := (*User).Test mExpression(\u0026u) // 显式传递 receiver } output: 0xc42000a060, \u0026{1 Tom} 0xc42000a060, \u0026{1 Tom} 0xc42000a060, \u0026{1 Tom} 需要注意，method value 会复制 receiver。 package main import \"fmt\" type User struct { id int name string } func (self User) Test() { fmt.Println(self) } func main() { u := User{1, \"Tom\"} mValue := u.Test // 立即复制 receiver，因为不是指针类型，不受后续修改影响。 u.id, u.name = 2, \"Jack\" u.Test() mValue() } output: {2 Jack} {1 Tom} 在汇编层面，method value 和闭包的实现方式相同，实际返回 FuncVal 类型对象。 FuncVal { method_address, receiver_copy } 可依据方法集转换 method expression，注意 receiver 类型的差异。 package main import \"fmt\" type User struct { id int name string } func (self *User) TestPointer() { fmt.Printf(\"TestPointer: %p, %v\\n\", self, self) } func (self User) TestValue() { fmt.Printf(\"TestValue: %p, %v\\n\", \u0026self, self) } func main() { u := User{1, \"Tom\"} fmt.Printf(\"User: %p, %v\\n\", \u0026u, u) mv := User.TestValue mv(u) mp := (*User).TestPointer mp(\u0026u) mp2 := (*User).TestValue // *User 方法集包含 TestValue。签名变为 func TestValue(self *User)。实际依然是 receiver value copy。 mp2(\u0026u) } output: User: 0xc42000a060, {1 Tom} TestValue: 0xc42000a0a0, {1 Tom} TestPointer: 0xc42000a060, \u0026{1 Tom} TestValue: 0xc42000a100, {1 Tom} 将方法 “还原” 成函数，就容易理解下面的代码了。 package main type Data struct{} func (Data) TestValue() {} func (*Data) TestPointer() {} func main() { var p *Data = nil p.TestPointer() (*Data)(nil).TestPointer() // method value (*Data).TestPointer(nil) // method expression // p.TestValue() // invalid memory address or nil pointer dereference // (Data)(nil).TestValue() // cannot convert nil to type Data // Data.TestValue(nil) // cannot use nil as type Data in function argument } ","date":"2022-01-06 09:16:37","objectID":"https://qizhengzou.github.io/go_base_04/:4:0","tags":["go grammar"],"title":"Go_base_04","uri":"https://qizhengzou.github.io/go_base_04/"},{"categories":["Go"],"content":"自定义error ","date":"2022-01-06 09:16:37","objectID":"https://qizhengzou.github.io/go_base_04/:5:0","tags":["go grammar"],"title":"Go_base_04","uri":"https://qizhengzou.github.io/go_base_04/"},{"categories":["Go"],"content":"抛异常和处理异常 系统抛 package main import \"fmt\" // 系统抛 func test01() { a := [5]int{0, 1, 2, 3, 4} a[1] = 123 fmt.Println(a) //a[10] = 11 index := 10 a[index] = 10 fmt.Println(a) } func getCircleArea(radius float32) (area float32) { if radius \u003c 0 { // 自己抛 panic(\"半径不能为负\") } return 3.14 * radius * radius } func test02() { getCircleArea(-5) } // func test03() { // 延时执行匿名函数 // 延时到何时？（1）程序正常结束 （2）发生异常时 defer func() { // recover() 恢复 // 会返回程序为什么挂了 if err := recover(); err != nil { fmt.Println(err) } }() getCircleArea(-5) fmt.Println(\"这里有没有执行\") } func test04() { test03() fmt.Println(\"test04\") } func main() { test04() } 返回异常 package main import ( \"errors\" \"fmt\" ) func getCircleArea(radius float32) (area float32, err error) { if radius \u003c 0 { // 构建个异常对象 err = errors.New(\"半径不能为负\") return } area = 3.14 * radius * radius return } func main() { area, err := getCircleArea(-5) if err != nil { fmt.Println(err) } else { fmt.Println(area) } } 自定义error： package main import ( \"fmt\" \"os\" \"time\" ) type PathError struct { path string op string createTime string message string } func (p *PathError) Error() string { return fmt.Sprintf(\"path=%s \\nop=%s \\ncreateTime=%s \\nmessage=%s\", p.path, p.op, p.createTime, p.message) } func Open(filename string) error { file, err := os.Open(filename) if err != nil { return \u0026PathError{ path: filename, op: \"read\", message: err.Error(), createTime: fmt.Sprintf(\"%v\", time.Now()), } } defer file.Close() return nil } func main() { err := Open(\"/Users/5lmh/Desktop/go/src/test.txt\") switch v := err.(type) { case *PathError: fmt.Println(\"get path error,\", v) default: } } output： get path error, path=/Users/pprof/Desktop/go/src/test.txt op=read createTime=2018-04-05 11:25:17.331915 +0800 CST m=+0.000441790 message=open /Users/pprof/Desktop/go/src/test.txt: no such file or directory ","date":"2022-01-06 09:16:37","objectID":"https://qizhengzou.github.io/go_base_04/:5:1","tags":["go grammar"],"title":"Go_base_04","uri":"https://qizhengzou.github.io/go_base_04/"},{"categories":["Go"],"content":" 参考学习go语言中文网、C语言中文网、golang官方文档等 函数 ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:0:0","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"函数定义 go的函数特点： 无需声明原型。 支持不定参、变参。 支持多返回值。 支持命名返回参数。 支持匿名函数和闭包。（闭包详见后文） 函数也是一种类型，一个函数可以赋值给变量。 有返回值的函数，必须有明确的终止语句，否则会引发编译错误。 不支持 嵌套 (nested) 一个包不能有两个名字一样的函数。 不支持 重载 (overload) （区别于重写，重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。最常用的地方就是构造器的重载。来自菜鸟教程java。） 不支持 默认参数 (default parameter)。 没有函数体的函数声明，表示该函数不是以Go实现的。这样的声明定义了函数标识符。 所有参数都是值传递：slice，map，channel 会有传引⽤的错觉 函数是第一类对象，可作为参数传递。建议将复杂签名定义为函数类型，以便于阅读。 import \"fmt\" func test(fn func() int) int { return fn() } // 定义函数类型。 type FormatFunc func(s string, x, y int) string func format(fn FormatFunc, s string, x, y int) string { return fn(s, x, y) } func main() { s1 := test(func() int { return 100 }) // 直接将匿名函数当参数。 s2 := format(func(s string, x, y int) string { return fmt.Sprintf(s, x, y) }, \"%d, %d\", 10, 20) println(s1, s2) } output: 100 10,20 fmt里的一些格式化输入输出函数： func Printf(format string, a ...interface{}) (n int, err error) func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) func Sprintf(format string, a ...interface{}) string func Print(a ...interface{}) (n int, err error) func Fprint(w io.Writer, a ...interface{}) (n int, err error) func Sprint(a ...interface{}) string func Println(a ...interface{}) (n int, err error) func Fprintln(w io.Writer, a ...interface{}) (n int, err error) func Sprintln(a ...interface{}) string func Errorf(format string, a ...interface{}) error func Scanf(format string, a ...interface{}) (n int, err error) func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error) func Sscanf(str string, format string, a ...interface{}) (n int, err error) func Scan(a ...interface{}) (n int, err error) func Fscan(r io.Reader, a ...interface{}) (n int, err error) func Sscan(str string, a ...interface{}) (n int, err error) func Scanln(a ...interface{}) (n int, err error) func Fscanln(r io.Reader, a ...interface{}) (n int, err error) func Sscanln(str string, a ...interface{}) (n int, err error) ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:1:0","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"参数 map、slice、chan、指针、interface默认以引用的方式传递，其他的在默认情况下，使用的是值传递. 无论是值传递，还是引用传递，传递给函数的都是变量的副本，不过，值传递是值的拷贝。引用传递是地址的拷贝，一般来说，地址拷贝更为高效。而值拷贝取决于拷贝的对象大小，对象越大，则性能越低。 ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:2:0","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"不定参 就是函数的参数不是固定的，后面的类型是固定的。（可变参数） Golang 可变参数本质上就是 slice。只能有一个，且必须是最后一个。 在参数赋值时可以不用用一个一个的赋值，可以直接传递一个数组或者切片，特别注意的是在参数后加上“…”即可。 func myfunc(args ...int) { //0个或多个参数 } func add(a int, args…int) int { //1个或多个参数 } func add(a int, b int, args…int) int { //2个或多个参数 } 注意：其中args是一个slice，我们可以通过arg[index]依次访问所有参数,通过len(arg)来判断传递参数的个数. 任意类型的不定参数：就是函数的参数和每个参数的类型都不是固定的。 用interface{}传递任意类型数据是Go语言的惯例用法，而且interface{}是类型安全的。 func myfunc(args ...interface{}) { } func test(s string, n ...int) string { var x int for _, i := range n { x += i } return fmt.Sprintf(s, x) } func main() { s := []int{1, 2, 3} res := test(\"sum: %d\", s...) // slice... 展开slice,而不是只写变量名 println(res) } ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:2:1","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"返回值 Go 的返回值可以被命名，并且就像在函数体开头声明的变量那样使用。 返回值的名称应当具有一定的意义，可以作为文档使用。 没有参数的 return 语句返回各个返回变量的当前值。这种用法被称作 “裸”返回。 package main import ( \"fmt\" ) func add(a, b int) (c int) { c = a + b return } func calc(a, b int) (sum int, avg int) { sum = a + b avg = (a + b) / 2 return } func main() { var a, b int = 1, 2 c := add(a, b) sum, avg := calc(a, b) fmt.Println(a, b, c, sum, avg) } 命名返回参数可被同名局部变量遮蔽，此时需要显式返回。 Golang返回值不能用容器对象接收多返回值。只能用多个变量，或 “_” 忽略。或者多返回值可直接作为其他函数调用实参。 func test() (int, int) { return 1, 2 } func add(x, y int) int { return x + y } func sum(n ...int) int { var x int for _, i := range n { x += i } return x } func main() { println(add(test())) println(sum(test())) } 命名返回参数允许 defer 延迟调用通过闭包读取和修改。 package main func add(x, y int) (z int) { defer func() { z += 100 }() z = x + y return } func main() { println(add(1, 2)) } output:103 ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:3:0","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"匿名函数 匿名函数的优越性在于可以直接使用函数内的变量，不必申明。Golang匿名函数可赋值给变量，做为结构字段，或者在 channel 里传送。 package main func main() { // --- function variable --- fn := func() { println(\"Hello, World!\") } fn() // --- function collection --- fns := [](func(x int) int){ func(x int) int { return x + 1 }, func(x int) int { return x + 2 }, } println(fns[0](100)) // --- function as field --- d := struct { fn func() string }{ fn: func() string { return \"Hello, World!\" }, } println(d.fn()) // --- channel of function --- fc := make(chan func() string, 2) fc \u003c- func() string { return \"Hello, World!\" } println((\u003c-fc)()) output: Hello, World! 101 Hello, World! Hello, World! } ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:4:0","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"闭包、递归 ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:5:0","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"闭包 闭包是由函数及其相关引用环境组合而成的实体。 “官方”的解释是：所谓“闭包”，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。 维基百科讲，闭包（Closure），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。 目前在JavaScript、Go、PHP、Scala、Scheme、Common Lisp、Smalltalk、Groovy、Ruby、 Python、Lua、objective c、Swift 以及Java8以上等语言中都能找到对闭包不同程度的支持。 通过支持闭包的语法可以发现一个特点，他们都有垃圾回收(GC)机制。 go的闭包： package main import ( \"fmt\" ) func a() func() int { i := 0 b := func() int { i++ fmt.Println(i) return i } return b } func main() { c := a() c() c() c() a() //不会输出i } output: 1 2 3 当函数a()的内部函数b()被函数a()外的一个变量引用的时候，就创建了一个闭包。 闭包复制的是原对象指针，这就很容易解释延迟引用现象。（延迟引用，引用的只是某个变量的“最终值”，延迟闭包里引用的变量是原变量指针，这解释了后面为什么derfer碰上闭包的输出都是同一值） package main import \"fmt\" func test() func() { x := 100 fmt.Printf(\"x (%p) = %d\\n\", \u0026x, x) return func() { fmt.Printf(\"x (%p) = %d\\n\", \u0026x, x) } } func main() { f := test() f() } output: x (0xc42007c008) = 100 x (0xc42007c008) = 100 在汇编层 ，test 实际返回的是 FuncVal 对象，其中包含了匿名函数地址、闭包对象指针。当调 匿名函数时，只需以某个寄存器传递该对象即可。 Funcval对象： FuncVal { func_address, closure_var_pointer ... } 外部引用函数参数局部变量: package main import \"fmt\" // 外部引用函数参数局部变量 func add(base int) func(int) int { return func(i int) int { base += i return base } } func main() { tmp1 := add(10) fmt.Println(tmp1(1), tmp1(2)) // 此时tmp1和tmp2不是一个实体了 tmp2 := add(100) fmt.Println(tmp2(1), tmp2(2)) } 返回两个闭包： package main import \"fmt\" // 返回2个函数类型的返回值 func test01(base int) (func(int) int, func(int) int) { // 定义2个函数，并返回 // 相加 add := func(i int) int { base += i return base } // 相减 sub := func(i int) int { base -= i return base } // 返回 return add, sub } func main() { f1, f2 := test01(10) // base一直是没有消 fmt.Println(f1(1), f2(2)) // 此时base是9 fmt.Println(f1(3), f2(4)) } ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:5:1","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"go递归函数 构成递归的两个条件： 子问题须与原始问题为同样的事，且更为简单。 不能无限制地调用本身，须有个出口，化简为非递归状况处理。 go的递归和其他语言基本无差别。 ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:5:2","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"延迟调用（defer） 特性： 关键字 defer 用于注册延迟调用。 这些调用直到 return 前才被执行。因此，可以用来做资源清理。 多个defer语句，按先进后出的方式执行。（因为后面的defer可能会用到前面的资源） defer语句中的变量，在defer声明时就决定了。 发生panic依然会执行defer，但不是任何情况都会执行，比如：os.Exit()不会调用defer。os.Exit()退出时不输出当前调用栈信息。 用途： 关闭文件句柄 锁资源释放 数据库连接释放 defer功能强大，对于资源管理非常方便，但是如果没用好，也会有陷阱。 defer碰上闭包： package main import \"fmt\" func main() { var whatever [5]struct{} for i := range whatever { defer func() { fmt.Println(i) }() } } output: 4 4 4 4 4 延迟引用，闭包里的i是原变量指针。 defer.f.Close: package main import \"fmt\" type Test struct { name string } func (t *Test) Close() { fmt.Println(t.name, \" closed\") } func main() { ts := []Test{\"a\", \"b\", \"c\"} for _, t := range ts { defer t.Close() } } output: c closed c closed c closed package main import \"fmt\" type Test struct { name string } func (t *Test) Close() { fmt.Println(t.name, \" closed\") } func Close(t Test) { t.Close() } func main() { ts := []Test\"a\", \"b\", \"c\"} for _, t := range ts { defer Close(t) } //或者for _, t := range ts { // t2 := t // defer t2.Close() // } } output: c closed b closed a closed 结论： defer后面的语句在执行的时候，函数调用的参数会被保存起来，但是不执行。也就是复制了一份。但是并没有说struct这里的this指针如何处理，通过这个例子可以看出go语言并没有把这个明确写出来的this指针当作参数来看待。 多个 defer 注册，按 FILO 次序执行 ( 先进后出 )。哪怕函数或某个延迟调用发生错误，比如发生panic，这些defer调用依旧会被执行。 package main func test(x int) { defer println(\"a\") defer println(\"b\") defer func() { println(100 / x) // div0 异常未被捕获，逐步往外传递，最终终止进程。 }() defer println(\"c\") } func main() { test(0) } output: c b a panic: runtime error: integer divide by zero 延迟调用参数在注册时求值或复制，可用指针或闭包 “延迟” 读取。 package main func test() { x, y := 10, 20 defer func(i int) { println(\"defer:\", i, y) // y 闭包引用 }(x) // x 被复制 x += 10 y += 100 println(\"x =\", x, \"y =\", y) } func main() { test() } output: x = 20 y = 120 defer: 10 120 滥用 defer 可能会导致性能问题，尤其是在一个 “大循环” 里。 package main import ( \"fmt\" \"sync\" \"time\" ) var lock sync.Mutex func test() { lock.Lock() lock.Unlock() } func testdefer() { lock.Lock() defer lock.Unlock() } func main() { func() { t1 := time.Now() for i := 0; i \u003c 10000; i++ { test() } elapsed := time.Since(t1) fmt.Println(\"test elapsed: \", elapsed) }() func() { t1 := time.Now() for i := 0; i \u003c 10000; i++ { testdefer() } elapsed := time.Since(t1) fmt.Println(\"testdefer elapsed: \", elapsed) }() } output: test elapsed: 223.162µs testdefer elapsed: 781.304µs ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:6:0","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"defer陷阱 defer 与 closure： package main import ( \"errors\" \"fmt\" ) func foo(a, b int) (i int, err error) { defer fmt.Printf(\"first defer err %v\\n\", err) defer func(err error) { fmt.Printf(\"second defer err %v\\n\", err) }(err) defer func() { fmt.Printf(\"third defer err %v\\n\", err) }() if b == 0 { err = errors.New(\"divided by zero!\") return } i = a / b return } func main() { foo(2, 0) } output： third defer err divided by zero! second defer err \u003cnil\u003e first defer err \u003cnil\u003e 解释：如果 defer 后面跟的不是一个 closure 最后执行的时候我们得到的并不是最新的值。 defer 与 return: package main import \"fmt\" func foo() (i int) { i = 0 defer func() { fmt.Println(i) }() return 2 } func main() { foo() } output： 2 解释：在有具名返回值的函数中（这里具名返回值为 i），执行 return 2 的时候实际上已经将 i 的值重新赋值为 2。所以defer closure 输出结果为 2 而不是 1。 defer nil 函数: package main import ( \"fmt\" ) func test() { var run func() = nil defer run() fmt.Println(\"runs\") } func main() { defer func() { if err := recover(); err != nil { fmt.Println(err) } }() test() } output： runs runtime error: invalid memory address or nil pointer dereference 解释：名为 test 的函数一直运行至结束，然后 defer 函数会被执行且会因为值为 nil 而产生 panic 异常。然而值得注意的是，run() 的声明是没有问题，因为在test函数运行完成后它才会被调用。 在错误的位置使用 defer: 当 http.Get 失败时会抛出异常。 package main import \"net/http\" func do() error { res, err := http.Get(\"http://www.google.com\") defer res.Body.Close() if err != nil { return err } // ..code... return nil } func main() { do() } output： panic: runtime error: invalid memory address or nil pointer dereference 因为在这里我们并没有检查我们的请求是否成功执行，当它失败的时候，我们访问了 Body 中的空变量 res ，因此会抛出异常 解决方案： 总是在一次成功的资源分配下面使用 defer ，对于这种情况来说意味着：当且仅当 http.Get 成功执行时才使用 defer package main import \"net/http\" func do() error { res, err := http.Get(\"http://xxxxxxxxxx\") if res != nil { defer res.Body.Close() } if err != nil { return err } // ..code... return nil } func main() { do() } 在上述的代码中，当有错误的时候，err 会被返回，否则当整个函数返回的时候，会关闭 res.Body 。 解释：在这里，你同样需要检查 res 的值是否为 nil ，这是 http.Get 中的一个警告。通常情况下，出错的时候，返回的内容应为空并且错误会被返回，可当你获得的是一个重定向 error 时， res 的值并不会为 nil ，但其又会将错误返回。上面的代码保证了无论如何 Body 都会被关闭，如果你没有打算使用其中的数据，那么你还需要丢弃已经接收的数据。 不检查错误: 在这里，f.Close() 可能会返回一个错误，可这个错误会被我们忽略掉。 package main import \"os\" func do() error { f, err := os.Open(\"book.txt\") if err != nil { return err } if f != nil { defer f.Close() } // ..code... return nil } func main() { do() } 改进一下： package main import \"os\" func do() error { f, err := os.Open(\"book.txt\") if err != nil { return err } if f != nil { defer func() { if err := f.Close(); err != nil { // log etc } }() } // ..code... return nil } func main() { do() } 再改进一下：通过命名的返回变量来返回defer内的错误。 package main import \"os\" func do() (err error) { f, err := os.Open(\"book.txt\") if err != nil { return err } if f != nil { defer func() { if ferr := f.Close(); ferr != nil { err = ferr } }() } // ..code... return nil } func main() { do() } 释放相同的资源 如果你尝试使用相同的变量释放不同的资源，那么这个操作可能无法正常执行。 package main import ( \"fmt\" \"os\" ) func do() error { f, err := os.Open(\"book.txt\") if err != nil { return err } if f != nil { defer func() { if err := f.Close(); err != nil { fmt.Printf(\"defer close book.txt err %v\\n\", err) } }() } // ..code... f, err = os.Open(\"another-book.txt\") if err != nil { return err } if f != nil { defer func() { if err := f.Close(); err != nil { fmt.Printf(\"defer close another-book.txt err %v\\n\", err) } }() } return nil } func main() { do() } 输出结果： defer close book.txt err close ./another-book.txt: file already closed 当延迟函数执行时，只有最后一个变量会被用到，因此，f 变量 会成为最后那个资源 (another-book.txt)。而且两个 defer 都会将这个资源作为最后的资源来关闭 解决方案： package main import ( \"fmt\" \"io\" \"os\" ) func do() error { f, err := os.Open(\"book.txt\") if err != nil { return err } if f != nil { defer func(f io.Closer) { if err := f.Close(); err != nil { fmt.Printf(\"defer close book.txt err %v\\n\", err) } }(f) } // ..code... f, err = os.Open(\"another-book.txt\") if err != nil { return err } if f != nil { defer func(f io.Closer) { if err := f.Close(); err != nil { fmt.Printf(\"defer close another-book.txt err %v\\n\", err) } }(f) } return nil } func main() { do() } ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:6:1","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"异常处理，错误处理 提倡及早失败，避免嵌套 Golang 没有结构化异常，使用 panic 抛出错误，recover 捕获错误。 异常的使用场景简单描述：Go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理。 panic: 内置函数 假如函数F中书写了panic语句，会终止其后要执行的代码，在panic所在函数F内如果存在要执行的defer函数列表，按照defer的逆序执行 返回函数F的调用者G，在G中，调用函数F语句之后的代码不会执行，假如函数G中存在要执行的defer函数列表，按照defer的逆序执行 直到goroutine整个退出，并报告错误 recover: 内置函数 用来控制一个goroutine的panicking行为，捕获panic，从而影响应用的行为 一般的调用建议 在defer函数中，通过recever来终止一个goroutine的panicking过程，从而恢复正常代码的执行 可以获取通过panic传递的error 注意： 利用recover处理panic指令，defer 必须放在 panic 之前定义，另外 recover 只有在 defer 调用的函数中才有效。否则当panic时，recover无法捕获到panic，无法防止panic扩散。 recover 处理异常后，逻辑并不会恢复到 panic 那个点去，函数跑到 defer 之后的那个点。 多个 defer 会形成 defer 栈，后定义的 defer 语句会被最先调用。 package main func main() { test() } func test() { defer func() { if err := recover(); err != nil { println(err.(string)) // 将 interface{} 转型为具体类型。 } }() panic(\"panic error!\") } output: panic error! 由于 panic、recover 参数类型为 interface{}，因此可抛出任何类型对象。 func panic(v interface{}) func recover() interface{} 向已关闭的通道发送数据会引发panic package main import ( \"fmt\" ) func main() { defer func() { if err := recover(); err != nil { fmt.Println(err) } }() var ch chan int = make(chan int, 10) close(ch) ch \u003c- 1 } output: send on closed channel 延迟调用中引发的错误，可被后续延迟调用捕获，但仅最后一个错误可被捕获。 package main import \"fmt\" func test() { defer func() { fmt.Println(recover()) }() defer func() { panic(\"defer panic\") }() panic(\"test panic\") } func main() { test() } output: defer panic 捕获函数 recover 只有在延迟调用内直接调用才会终止错误，否则总是返回 nil。任何未捕获的错误都会沿调用堆栈向外传递。 package main import \"fmt\" func test() { defer func() { fmt.Println(recover()) //有效 }() defer recover() //无效！ defer fmt.Println(recover()) //无效！ defer func() { func() { println(\"defer inner\") recover() //无效！ }() }() panic(\"test panic\") } func main() { test() } output: defer inner \u003cnil\u003e test panic 使用延迟匿名函数或下面这样都是有效的。 package main import ( \"fmt\" ) func except() { fmt.Println(recover()) } func test() { defer except() panic(\"test panic\") } func main() { test() } output： test panic 如果需要保护代码段，可将代码块重构成匿名函数，如此可确保后续代码被执行。 package main import \"fmt\" func test(x, y int) { var z int func() { defer func() { if recover() != nil { z = 0 } }() panic(\"test panic\") z = x / y return }() fmt.Printf(\"x / y = %d\\n\", z) } func main() { test(2, 1) } output： x / y = 0 除用 panic 引发中断性错误外，还可返回 error 类型错误对象来表示函数调用状态。（error类型实现了error接口） type error interface { Error() string } 标准库 errors.New 和 fmt.Errorf 函数用于创建实现 error 接口的错误对象。通过判断错误对象实例来确定具体错误类型。 package main import ( \"errors\" \"fmt\" ) //定义预置错误 var ErrDivByZero = errors.New(\"division by zero\") func div(x, y int) (int, error) { if y == 0 { return 0, ErrDivByZero } return x / y, nil } func main() { defer func() { fmt.Println(recover()) }() switch z, err := div(10, 0); err { case nil: println(z) case ErrDivByZero: panic(err) } } output: division by zero Go实现类似 try catch 的异常处理。 package main import \"fmt\" func Try(fun func(), handler func(interface{})) { defer func() { if err := recover(); err != nil { handler(err) } }() fun() } func main() { Try(func() { panic(\"test panic\") }, func(err interface{}) { fmt.Println(err) }) } output： test panic 如何区别使用 panic 和 error 两种方式? 惯例是:导致关键流程出现不可修复性错误的使用 panic，其他使用 error。 ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:7:0","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"单元测试 单元测试还是挺重要的。 ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:8:0","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"go test工具 Go语言中的测试依赖go test命令。编写测试代码和编写普通的Go代码过程是类似的，并不需要学习新的语法、规则或工具。 go test命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以_test.go为后缀名的源代码文件都是go test测试的一部分，不会被go build编译到最终的可执行文件中。 在*_test.go文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。 类型 格式 作用 测试函数 函数名前缀为Test 测试程序的一些逻辑行为是否正确 基准函数 函数名前缀为Benchmark 测试函数的性能 示例函数 函数名前缀为Example 为文档提供示例文档 go test命令会遍历所有的*_test.go文件中符合上述命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。 Golang单元测试对文件名和方法名，参数都有很严格的要求。 文件名必须以xx_test.go命名 方法必须是Test[^a-z]开头 方法参数必须 t *testing.T 使用go test执行单元测试 go test的参数解读： go test是go语言自带的测试工具，其中包含的是两类，单元测试和性能测试 通过go help test可以看到go test的使用说明： 格式形如： go test [-c] [-i] [build flags] [packages] [flags for test binary] 参数解读： -c : 编译go test成为可执行的二进制文件，但是不运行测试。 -i : 安装测试包依赖的package，但是不运行测试。 关于build flags，调用go help build，这些是编译运行过程中需要使用到的参数，一般设置为空 关于packages，调用go help packages，这些是关于包的管理，一般设置为空 关于flags for test binary，调用go help testflag，这些是go test过程中经常使用到的参数 -test.v : 是否输出全部的单元测试用例（不管成功或者失败），默认没有加上，所以只输出失败的单元测试用例。 -test.run pattern: 只跑哪些单元测试用例 -test.bench patten: 只跑那些性能测试用例 -test.benchmem : 是否在性能测试的时候输出内存情况 -test.benchtime t : 性能测试运行的时间，默认是1s -test.cpuprofile cpu.out : 是否输出cpu性能分析文件 -test.memprofile mem.out : 是否输出内存性能分析文件 -test.blockprofile block.out : 是否输出内部goroutine阻塞的性能分析文件 -test.memprofilerate n : 内存性能分析的时候有一个分配了多少的时候才打点记录的问题。这个参数就是设置打点的内存分配间隔，也就是profile中一个sample代表的内存大小。默认是设置为512 * 1024的。如果你将它设置为1，则每分配一个内存块就会在profile中有个打点，那么生成的profile的sample就会非常多。如果你设置为0，那就是不做打点了。 你可以通过设置memprofilerate=1和GOGC=off来关闭内存回收，并且对每个内存块的分配进行观察。 -test.blockprofilerate n: 基本同上，控制的是goroutine阻塞时候打点的纳秒数。默认不设置就相当于-test.blockprofilerate=1，每一纳秒都打点记录一下 -test.parallel n : 性能测试的程序并行cpu数，默认等于GOMAXPROCS。 -test.timeout t : 如果测试用例运行时间超过t，则抛出panic -test.cpu 1,2,4 : 程序运行在哪些CPU上面，使用二进制的1所在位代表，和nginx的nginx_worker_cpu_affinity是一个道理 -test.short : 将那些运行时间较长的测试用例运行时间缩短 目录结构： test | —— calc.go | —— calc_test.go ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:8:1","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"测试函数 测试函数的格式 每个测试函数必须导入testing包，测试函数的基本格式（签名）如下： func TestName(t *testing.T){ // ... } 测试函数的名字必须以Test开头，可选的后缀名必须以大写字母开头，举几个例子：\\ func TestAdd(t *testing.T){ ... } func TestSum(t *testing.T){ ... } func TestLog(t *testing.T){ ... } 其中参数t用于报告测试失败和附加的日志信息。 testing.T的拥有的方法如下： func (c *T) Error(args ...interface{}) func (c *T) Errorf(format string, args ...interface{}) func (c *T) Fail() func (c *T) FailNow() func (c *T) Failed() bool func (c *T) Fatal(args ...interface{}) func (c *T) Fatalf(format string, args ...interface{}) func (c *T) Log(args ...interface{}) func (c *T) Logf(format string, args ...interface{}) func (c *T) Name() string func (t *T) Parallel() func (t *T) Run(name string, f func(t *T)) bool func (c *T) Skip(args ...interface{}) func (c *T) SkipNow() func (c *T) Skipf(format string, args ...interface{}) func (c *T) Skipped() bool 测试函数示例 就像细胞是构成我们身体的基本单位，一个软件程序也是由很多单元组件构成的。单元组件可以是函数、结构体、方法和最终用户可能依赖的任意东西。总之我们需要确保这些组件是能够正常运行的。单元测试是一些利用各种方法测试单元组件的程序，它会将结果与预期输出进行比较。 接下来，我们定义一个split的包，包中定义了一个Split函数，具体实现如下： // split/split.go package split import \"strings\" // split package with a single split function. // Split slices s into all substrings separated by sep and // returns a slice of the substrings between those separators. func Split(s, sep string) (result []string) { i := strings.Index(s, sep) for i \u003e -1 { result = append(result, s[:i]) s = s[i+1:] i = strings.Index(s, sep) } result = append(result, s) return } 在当前目录下，我们创建一个split_test.go的测试文件，并定义一个测试函数如下： // split/split_test.go package split import ( \"reflect\" \"testing\" ) func TestSplit(t *testing.T) { // 测试函数名必须以Test开头，必须接收一个*testing.T类型参数 got := Split(\"a🅱c\", \":\") // 程序输出的结果 want := []string{\"a\", \"b\", \"c\"} // 期望的结果 if !reflect.DeepEqual(want, got) { // 因为slice不能比较直接，借助反射包中的方法比较 t.Errorf(\"excepted:%v, got:%v\", want, got) // 测试失败输出错误提示 } } 此时split这个包中的文件如下： split $ ls -l total 16 -rw-r--r-- 1 pprof staff 408 4 29 15:50 split.go -rw-r--r-- 1 pprof staff 466 4 29 16:04 split_test.go 在split包路径下，执行go test命令，可以看到输出结果如下： split $ go test PASS ok github.com/pprof/studygo/code_demo/test_demo/split 0.005s 一个测试用例有点单薄，我们再编写一个测试使用多个字符切割字符串的例子，在split_test.go中添加如下测试函数： func TestMoreSplit(t *testing.T) { got := Split(\"abcd\", \"bc\") want := []string{\"a\", \"d\"} if !reflect.DeepEqual(want, got) { t.Errorf(\"excepted:%v, got:%v\", want, got) } } 再次运行go test命令，输出结果如下： split $ go test --- FAIL: TestMultiSplit (0.00s) split_test.go:20: excepted:[a d], got:[a cd] FAIL exit status 1 FAIL github.com/pprof/studygo/code_demo/test_demo/split 0.006s 这一次，我们的测试失败了。我们可以为go test命令添加-v参数，查看测试函数名称和运行时间： split $ go test -v === RUN TestSplit --- PASS: TestSplit (0.00s) === RUN TestMoreSplit --- FAIL: TestMoreSplit (0.00s) split_test.go:21: excepted:[a d], got:[a cd] FAIL exit status 1 FAIL github.com/pprof/studygo/code_demo/test_demo/split 0.005s 这一次我们能清楚的看到是TestMoreSplit这个测试没有成功。 还可以在go test命令后添加-run参数，它对应一个正则表达式，只有函数名匹配上的测试函数才会被go test命令执行。 split $ go test -v -run=\"More\" === RUN TestMoreSplit --- FAIL: TestMoreSplit (0.00s) split_test.go:21: excepted:[a d], got:[a cd] FAIL exit status 1 FAIL github.com/pprof/studygo/code_demo/test_demo/split 0.006s 现在我们回过头来解决我们程序中的问题。很显然我们最初的split函数并没有考虑到sep为多个字符的情况，我们来修复下这个Bug： package split import \"strings\" // split package with a single split function. // Split slices s into all substrings separated by sep and // returns a slice of the substrings between those separators. func Split(s, sep string) (result []string) { i := strings.Index(s, sep) for i \u003e -1 { result = append(result, s[:i]) s = s[i+len(sep):] // 这里使用len(sep)获取sep的长度 i = strings.Index(s, sep) } result = append(result, s) return } 这一次我们再来测试一下，我们的程序。注意，当我们修改了我们的代码之后不要仅仅执行那些失败的测试函数，我们应该完整的运行所有的测试，保证不会因为修改代码而引入了新的问题。 split $ go test -v === RUN TestSplit --- PASS: TestSplit (0.00s) === RUN TestMoreSplit --- PASS: TestMoreSplit (0.00s) PASS ok github.com/pprof/studygo/code_demo/test_demo/split 0.006s 这一次我们的测试都通过了 ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:8:2","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"测试组 我们现在还想要测试一下split函数对中文字符串的支持，这个时候我们可以再编写一个TestChineseSplit测试函数，但是我们也可以使用如下更友好的一种方式来添加更多的测试用例。 func TestSplit(t *testing.T) { // 定义一个测试用例类型 type test struct { input string sep string want []string } // 定义一个存储测试用例的切片 tests := []test{ {input: \"a🅱c\", sep: \":\", want: []string{\"a\", \"b\", \"c\"} }, {input: \"a🅱c\", sep: \",\", want: []string{\"a🅱c\"} }, {input: \"abcd\", sep: \"bc\", want: []string{\"a\", \"d\"} }, {input: \"枯藤老树昏鸦\", sep: \"老\", want: []string{\"枯藤\", \"树昏鸦\"} }, } // 遍历切片，逐一执行测试用例 for _, tc := range tests { got := Split(tc.input, tc.sep) if !reflect.DeepEqual(got, tc.want) { t.Errorf(\"excepted:%v, got:%v\", tc.want, got) } } } 我们通过上面的代码把多个测试用例合到一起，再次执行go test命令。 split $ go test -v === RUN TestSplit --- FAIL: TestSplit (0.00s) split_test.go:42: excepted:[枯藤 树昏鸦], got:[ 枯藤 树昏鸦] FAIL exit status 1 FAIL github.com/pprof/studygo/code_demo/test_demo/split 0.006s 我们的测试出现了问题，仔细看打印的测试失败提示信息：excepted:[枯藤 树昏鸦], got:[ 枯藤 树昏鸦]，你会发现[ 枯藤 树昏鸦]中有个不明显的空串，这种情况下十分推荐使用%#v的格式化方式。 我们修改下测试用例的格式化输出错误提示部分： func TestSplit(t *testing.T) { ... for _, tc := range tests { got := Split(tc.input, tc.sep) if !reflect.DeepEqual(got, tc.want) { t.Errorf(\"excepted:%#v, got:%#v\", tc.want, got) } } } 此时运行go test命令后就能看到比较明显的提示信息了： split $ go test -v === RUN TestSplit --- FAIL: TestSplit (0.00s) split_test.go:42: excepted:[]string{\"枯藤\", \"树昏鸦\"}, got:[]string{\"\", \"枯藤\", \"树昏鸦\"} FAIL exit status 1 FAIL github.com/Q1mi/studygo/code_demo/test_demo/split 0.006s ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:8:3","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"子测试 看起来都挺不错的，但是如果测试用例比较多的时候，我们是没办法一眼看出来具体是哪个测试用例失败了。我们可能会想到下面的解决办法 func TestSplit(t *testing.T) { type test struct { // 定义test结构体 input string sep string want []string } tests := map[string]test{ // 测试用例使用map存储 \"simple\": {input: \"a🅱c\", sep: \":\", want: []string{\"a\", \"b\", \"c\"} }, \"wrong sep\": {input: \"a🅱c\", sep: \",\", want: []string{\"a🅱c\"} }, \"more sep\": {input: \"abcd\", sep: \"bc\", want: []string{\"a\", \"d\"} }, \"leading sep\": {input: \"枯藤老树昏鸦\", sep: \"老\", want: []string{\"枯藤\", \"树昏鸦\"} }, } for name, tc := range tests { got := Split(tc.input, tc.sep) if !reflect.DeepEqual(got, tc.want) { t.Errorf(\"name:%s excepted:%#v, got:%#v\", name, tc.want, got) // 将测试用例的name格式化输出 } } } 上面的做法是能够解决问题的。同时Go1.7+中新增了子测试，我们可以按照如下方式使用t.Run执行子测试： func TestSplit(t *testing.T) { type test struct { // 定义test结构体 input string sep string want []string } tests := map[string]test{ // 测试用例使用map存储 \"simple\": {input: \"a🅱c\", sep: \":\", want: []string{\"a\", \"b\", \"c\"} }, \"wrong sep\": {input: \"a🅱c\", sep: \",\", want: []string{\"a🅱c\"} }, \"more sep\": {input: \"abcd\", sep: \"bc\", want: []string{\"a\", \"d\"} }, \"leading sep\": {input: \"枯藤老树昏鸦\", sep: \"老\", want: []string{\"枯藤\", \"树昏鸦\"} }, } for name, tc := range tests { t.Run(name, func(t *testing.T) { // 使用t.Run()执行子测试 got := Split(tc.input, tc.sep) if !reflect.DeepEqual(got, tc.want) { t.Errorf(\"excepted:%#v, got:%#v\", tc.want, got) } }) } } 此时我们再执行go test命令就能够看到更清晰的输出内容了： split $ go test -v === RUN TestSplit === RUN TestSplit/leading_sep === RUN TestSplit/simple === RUN TestSplit/wrong_sep === RUN TestSplit/more_sep --- FAIL: TestSplit (0.00s) --- FAIL: TestSplit/leading_sep (0.00s) split_test.go:83: excepted:[]string{\"枯藤\", \"树昏鸦\"}, got:[]string{\"\", \"枯藤\", \"树昏鸦\"} --- PASS: TestSplit/simple (0.00s) --- PASS: TestSplit/wrong_sep (0.00s) --- PASS: TestSplit/more_sep (0.00s) FAIL exit status 1 FAIL github.com/pprof/studygo/code_demo/test_demo/split 0.006s 这个时候我们要把测试用例中的错误修改回来： func TestSplit(t *testing.T) { ... tests := map[string]test{ // 测试用例使用map存储 \"simple\": {input: \"a🅱c\", sep: \":\", want: []string{\"a\", \"b\", \"c\"} }, \"wrong sep\": {input: \"a🅱c\", sep: \",\", want: []string{\"a🅱c\"} }, \"more sep\": {input: \"abcd\", sep: \"bc\", want: []string{\"a\", \"d\"} }, \"leading sep\": {input: \"枯藤老树昏鸦\", sep: \"老\", want: []string{\"\", \"枯藤\", \"树昏鸦\"} }, } ... } 我们都知道可以通过-run=RegExp来指定运行的测试用例，还可以通过/来指定要运行的子测试用例，例如：go test -v -run=Split/simple只会运行simple对应的子测试用例。 ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:8:4","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"测试覆盖率 测试覆盖率是你的代码被测试套件覆盖的百分比。通常我们使用的都是语句的覆盖率，也就是在测试中至少被运行一次的代码占总代码的比例。 Go提供内置功能来检查你的代码覆盖率。我们可以使用go test -cover来查看测试覆盖率。例如： split $ go test -cover PASS coverage: 100.0% of statements ok github.com/pprof/studygo/code_demo/test_demo/split 0.005s 从上面的结果可以看到我们的测试用例覆盖了100%的代码。 Go还提供了一个额外的-coverprofile参数，用来将覆盖率相关的记录信息输出到一个文件。例如： split $ go test -cover -coverprofile=c.out PASS coverage: 100.0% of statements ok github.com/pprof/studygo/code_demo/test_demo/split 0.005s 上面的命令会将覆盖率相关的信息输出到当前文件夹下面的c.out文件中，然后我们执行go tool cover -html=c.out，使用cover工具来处理生成的记录信息，该命令会打开本地的浏览器窗口生成一个HTML报告。 ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:8:5","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"基准测试 基准测试函数格式 基准测试就是在一定的工作负载之下检测程序性能的一种方法。基准测试的基本格式如下： func BenchmarkName(b *testing.B){ // ... } 基准测试以Benchmark为前缀，需要一个*testing.B类型的参数b，基准测试必须要执行b.N次，这样的测试才有对照性，b.N的值是系统根据实际情况去调整的，从而保证测试的稳定性。 testing.B拥有的方法如下： func (c *B) Error(args ...interface{}) func (c *B) Errorf(format string, args ...interface{}) func (c *B) Fail() func (c *B) FailNow() func (c *B) Failed() bool func (c *B) Fatal(args ...interface{}) func (c *B) Fatalf(format string, args ...interface{}) func (c *B) Log(args ...interface{}) func (c *B) Logf(format string, args ...interface{}) func (c *B) Name() string func (b *B) ReportAllocs() func (b *B) ResetTimer() func (b *B) Run(name string, f func(b *B)) bool func (b *B) RunParallel(body func(*PB)) func (b *B) SetBytes(n int64) func (b *B) SetParallelism(p int) func (c *B) Skip(args ...interface{}) func (c *B) SkipNow() func (c *B) Skipf(format string, args ...interface{}) func (c *B) Skipped() bool func (b *B) StartTimer() func (b *B) StopTimer() 基准测试示例 我们为split包中的Split函数编写基准测试如下： func BenchmarkSplit(b *testing.B) { for i := 0; i \u003c b.N; i++ { Split(\"枯藤老树昏鸦\", \"老\") } } 基准测试并不会默认执行，需要增加-bench参数，所以我们通过执行go test -bench=Split命令执行基准测试，输出结果如下： split $ go test -bench=Split goos: darwin goarch: amd64 pkg: github.com/pprof/studygo/code_demo/test_demo/split BenchmarkSplit-8 10000000 203 ns/op PASS ok github.com/pprof/studygo/code_demo/test_demo/split 2.255s 其中BenchmarkSplit-8表示对Split函数进行基准测试，数字8表示GOMAXPROCS的值，这个对于并发基准测试很重要。10000000和203ns/op表示每次调用Split函数耗时203ns，这个结果是10000000次调用的平均值。 我们还可以为基准测试添加-benchmem参数，来获得内存分配的统计数据。 split $ go test -bench=Split -benchmem goos: darwin goarch: amd64 pkg: github.com/pprof/studygo/code_demo/test_demo/split BenchmarkSplit-8 10000000 215 ns/op 112 B/op 3 allocs/op PASS ok github.com/pprof/studygo/code_demo/test_demo/split 2.394s 其中，112 B/op表示每次操作内存分配了112字节，3 allocs/op则表示每次操作进行了3次内存分配。 我们将我们的Split函数优化如下： func Split(s, sep string) (result []string) { result = make([]string, 0, strings.Count(s, sep)+1) i := strings.Index(s, sep) for i \u003e -1 { result = append(result, s[:i]) s = s[i+len(sep):] // 这里使用len(sep)获取sep的长度 i = strings.Index(s, sep) } result = append(result, s) return } 这一次我们提前使用make函数将result初始化为一个容量足够大的切片，而不再像之前一样通过调用append函数来追加。我们来看一下这个改进会带来多大的性能提升： split $ go test -bench=Split -benchmem goos: darwin goarch: amd64 pkg: github.com/pprof/studygo/code_demo/test_demo/split BenchmarkSplit-8 10000000 127 ns/op 48 B/op 1 allocs/op PASS ok github.com/pprof/studygo/code_demo/test_demo/split 1.423s 这个使用make函数提前分配内存的改动，减少了2/3的内存分配次数，并且减少了一半的内存分配。 ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:8:6","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"x性能比较函数 上面的基准测试只能得到给定操作的绝对耗时，但是在很多性能问题是发生在两个不同操作之间的相对耗时，比如同一个函数处理1000个元素的耗时与处理1万甚至100万个元素的耗时的差别是多少？再或者对于同一个任务究竟使用哪种算法性能最佳？我们通常需要对两个不同算法的实现使用相同的输入来进行基准比较测试。 性能比较函数通常是一个带有参数的函数，被多个不同的Benchmark函数传入不同的值来调用。举个例子如下： func benchmark(b *testing.B, size int){/* ... */} func Benchmark10(b *testing.B){ benchmark(b, 10) } func Benchmark100(b *testing.B){ benchmark(b, 100) } func Benchmark1000(b *testing.B){ benchmark(b, 1000) } 例如我们编写了一个计算斐波那契数列的函数如下： // fib.go // Fib 是一个计算第n个斐波那契数的函数 func Fib(n int) int { if n \u003c 2 { return n } return Fib(n-1) + Fib(n-2) } 我们编写的性能比较函数如下： // fib_test.go func benchmarkFib(b *testing.B, n int) { for i := 0; i \u003c b.N; i++ { Fib(n) } } func BenchmarkFib1(b *testing.B) { benchmarkFib(b, 1) } func BenchmarkFib2(b *testing.B) { benchmarkFib(b, 2) } func BenchmarkFib3(b *testing.B) { benchmarkFib(b, 3) } func BenchmarkFib10(b *testing.B) { benchmarkFib(b, 10) } func BenchmarkFib20(b *testing.B) { benchmarkFib(b, 20) } func BenchmarkFib40(b *testing.B) { benchmarkFib(b, 40) } 运行基准测试： split $ go test -bench=. goos: darwin goarch: amd64 pkg: github.com/pprof/studygo/code_demo/test_demo/fib BenchmarkFib1-8 1000000000 2.03 ns/op BenchmarkFib2-8 300000000 5.39 ns/op BenchmarkFib3-8 200000000 9.71 ns/op BenchmarkFib10-8 5000000 325 ns/op BenchmarkFib20-8 30000 42460 ns/op BenchmarkFib40-8 2 638524980 ns/op PASS ok github.com/pprof/studygo/code_demo/test_demo/fib 12.944s 这里需要注意的是，默认情况下，每个基准测试至少运行1秒。如果在Benchmark函数返回时没有到1秒，则b.N的值会按1,2,5,10,20,50，…增加，并且函数再次运行。 最终的BenchmarkFib40只运行了两次，每次运行的平均值只有不到一秒。像这种情况下我们应该可以使用-benchtime标志增加最小基准时间，以产生更准确的结果。例如： split $ go test -bench=Fib40 -benchtime=20s goos: darwin goarch: amd64 pkg: github.com/pprof/studygo/code_demo/test_demo/fib BenchmarkFib40-8 50 663205114 ns/op PASS ok github.com/pprof/studygo/code_demo/test_demo/fib 33.849s 这一次BenchmarkFib40函数运行了50次，结果就会更准确一些了。 使用性能比较函数做测试的时候一个容易犯的错误就是把b.N作为输入的大小，例如以下两个例子都是错误的示范： // 错误示范1 func BenchmarkFibWrong(b *testing.B) { for n := 0; n \u003c b.N; n++ { Fib(n) } } // 错误示范2 func BenchmarkFibWrong2(b *testing.B) { Fib(b.N) } ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:8:7","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"重置时间 b.ResetTimer之前的处理不会放到执行时间里，也不会输出到报告中，所以可以在之前做一些不计划作为测试报告的操作。例如： func BenchmarkSplit(b *testing.B) { time.Sleep(5 * time.Second) // 假设需要做一些耗时的无关操作 b.ResetTimer() // 重置计时器 for i := 0; i \u003c b.N; i++ { Split(\"枯藤老树昏鸦\", \"老\") } } ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:8:8","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"并行测试 func (b B) RunParallel(body func(PB))会以并行的方式执行给定的基准测试。 RunParallel会创建出多个goroutine，并将b.N分配给这些goroutine执行， 其中goroutine数量的默认值为GOMAXPROCS。用户如果想要增加非CPU受限（non-CPU-bound）基准测试的并行性， 那么可以在RunParallel之前调用SetParallelism 。RunParallel通常会与-cpu标志一同使用。 func BenchmarkSplitParallel(b *testing.B) { // b.SetParallelism(1) // 设置使用的CPU数 b.RunParallel(func(pb *testing.PB) { for pb.Next() { Split(\"枯藤老树昏鸦\", \"老\") } }) } 执行一下基准测试： split $ go test -bench=. goos: darwin goarch: amd64 pkg: github.com/pprof/studygo/code_demo/test_demo/split BenchmarkSplit-8 10000000 131 ns/op BenchmarkSplitParallel-8 50000000 36.1 ns/op PASS ok github.com/pprof/studygo/code_demo/test_demo/split 3.308s 还可以通过在测试命令后添加-cpu参数如go test -bench=. -cpu 1来指定使用的CPU数量。 ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:8:9","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"Setup与TearDown 测试程序有时需要在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）。 TestMain 通过在*_test.go文件中定义TestMain函数来可以在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）操作。 如果测试文件包含函数:func TestMain(m *testing.M)那么生成的测试会先调用 TestMain(m)，然后再运行具体测试。TestMain运行在主goroutine中, 可以在调用 m.Run前后做任何设置（setup）和拆卸（teardown）。退出测试的时候应该使用m.Run的返回值作为参数调用os.Exit。 一个使用TestMain来设置Setup和TearDown的示例如下： func TestMain(m *testing.M) { fmt.Println(\"write setup code here...\") // 测试之前的做一些设置 // 如果 TestMain 使用了 flags，这里应该加上flag.Parse() retCode := m.Run() // 执行测试 fmt.Println(\"write teardown code here...\") // 测试之后做一些拆卸工作 os.Exit(retCode) // 退出测试 } 需要注意的是：在调用TestMain时, flag.Parse并没有被调用。所以如果TestMain 依赖于command-line标志 (包括 testing 包的标记), 则应该显示的调用flag.Parse。 子测试的Setup与Teardown 有时候我们可能需要为每个测试集设置Setup与Teardown，也有可能需要为每个子测试设置Setup与Teardown。下面我们定义两个函数工具函数如下： // 测试集的Setup与Teardown func setupTestCase(t *testing.T) func(t *testing.T) { t.Log(\"如有需要在此执行:测试之前的setup\") return func(t *testing.T) { t.Log(\"如有需要在此执行:测试之后的teardown\") } } // 子测试的Setup与Teardown func setupSubTest(t *testing.T) func(t *testing.T) { t.Log(\"如有需要在此执行:子测试之前的setup\") return func(t *testing.T) { t.Log(\"如有需要在此执行:子测试之后的teardown\") } } 使用方式如下： func TestSplit(t *testing.T) { type test struct { // 定义test结构体 input string sep string want []string } tests := map[string]test{ // 测试用例使用map存储 \"simple\": {input: \"a🅱c\", sep: \":\", want: []string{\"a\", \"b\", \"c\"} }, \"wrong sep\": {input: \"a🅱c\", sep: \",\", want: []string{\"a🅱c\"} }, \"more sep\": {input: \"abcd\", sep: \"bc\", want: []string{\"a\", \"d\"} }, \"leading sep\": {input: \"枯藤老树昏鸦\", sep: \"老\", want: []string{\"\", \"枯藤\", \"树昏鸦\"} }, } teardownTestCase := setupTestCase(t) // 测试之前执行setup操作 defer teardownTestCase(t) // 测试之后执行testdoen操作 for name, tc := range tests { t.Run(name, func(t *testing.T) { // 使用t.Run()执行子测试 teardownSubTest := setupSubTest(t) // 子测试之前执行setup操作 defer teardownSubTest(t) // 测试之后执行testdoen操作 got := Split(tc.input, tc.sep) if !reflect.DeepEqual(got, tc.want) { t.Errorf(\"excepted:%#v, got:%#v\", tc.want, got) } }) } } 测试结果如下： split $ go test -v === RUN TestSplit === RUN TestSplit/simple === RUN TestSplit/wrong_sep === RUN TestSplit/more_sep === RUN TestSplit/leading_sep --- PASS: TestSplit (0.00s) split_test.go:71: 如有需要在此执行:测试之前的setup --- PASS: TestSplit/simple (0.00s) split_test.go:79: 如有需要在此执行:子测试之前的setup split_test.go:81: 如有需要在此执行:子测试之后的teardown --- PASS: TestSplit/wrong_sep (0.00s) split_test.go:79: 如有需要在此执行:子测试之前的setup split_test.go:81: 如有需要在此执行:子测试之后的teardown --- PASS: TestSplit/more_sep (0.00s) split_test.go:79: 如有需要在此执行:子测试之前的setup split_test.go:81: 如有需要在此执行:子测试之后的teardown --- PASS: TestSplit/leading_sep (0.00s) split_test.go:79: 如有需要在此执行:子测试之前的setup split_test.go:81: 如有需要在此执行:子测试之后的teardown split_test.go:73: 如有需要在此执行:测试之后的teardown === RUN ExampleSplit --- PASS: ExampleSplit (0.00s) PASS ok github.com/Q1mi/studygo/code_demo/test_demo/split 0.006s ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:8:10","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"示例函数 示例函数的格式 被go test特殊对待的第三种函数就是示例函数，它们的函数名以Example为前缀。它们既没有参数也没有返回值。标准格式如下： func ExampleName() { // ... } 示例函数示例 下面的代码是我们为Split函数编写的一个示例函数： func ExampleSplit() { fmt.Println(split.Split(\"a🅱c\", \":\")) fmt.Println(split.Split(\"枯藤老树昏鸦\", \"老\")) // Output: // [a b c] // [ 枯藤 树昏鸦] } 为你的代码编写示例代码有如下三个用处： 示例函数能够作为文档直接使用，例如基于web的godoc中能把示例函数与对应的函数或包相关联。 示例函数只要包含了// Output:也是可以通过go test运行的可执行测试。 split $ go test -run Example PASS ok github.com/pprof/studygo/code_demo/test_demo/split 0.006s 示例函数提供了可以直接运行的示例代码，可以直接在golang.org的godoc文档服务器上使用Go Playground运行示例代码。下图为strings.ToUpper函数在Playground的示例函数效果 ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:8:11","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"func ToUpper func ToUpper(s string) string ToUpper returms a copy of the sring s with all Unicode ltters mapped to their upper case. Example: package main import ( \"fnt\" \"strings\" ) func main() { fmt. Println(strings . ToUpper(\"Gopher\")) } ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:8:12","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"压力测试 ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:9:0","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"Go怎么写测试用例 开发程序其中很重要的一点是测试，我们如何保证代码的质量，如何保证每个函数是可运行，运行结果是正确的，又如何保证写出来的代码性能是好的，我们知道单元测试的重点在于发现程序设计或实现的逻辑错误，使问题及早暴露，便于问题的定位解决，而性能测试的重点在于发现程序设计上的一些问题，让线上的程序能够在高并发的情况下还能保持稳定。本小节将带着这一连串的问题来讲解Go语言中如何来实现单元测试和性能测试。 Go语言中自带有一个轻量级的测试框架testing和自带的go test命令来实现单元测试和性能测试，testing框架和其他语言中的测试框架类似，你可以基于这个框架写针对相应函数的测试用例，也可以基于该框架写相应的压力测试用例，那么接下来让我们一一来看一下怎么写。 另外建议安装gotests插件自动生成测试代码: go get -u -v github.com/cweill/gotests/... ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:9:1","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"如何编写测试用例 由于go test命令只能在一个相应的目录下执行所有文件，所以我们接下来新建一个项目目录gotest,这样我们所有的代码和测试代码都在这个目录下。 接下来我们在该目录下面创建两个文件：gotest.go和gotest_test.go gotest.go:这个文件里面我们是创建了一个包，里面有一个函数实现了除法运算: package gotest import ( \"errors\" ) func Division(a, b float64) (float64, error) { if b == 0 { return 0, errors.New(\"除数不能为0\") } return a / b, nil } gotest_test.go:这是我们的单元测试文件，但是记住下面的这些原则： 文件名必须是_test.go结尾的，这样在执行go test的时候才会执行到相应的代码 你必须import testing这个包 所有的测试用例函数必须是Test开头 测试用例会按照源代码中写的顺序依次执行 测试函数TestXxx()的参数是testing.T，我们可以使用该类型来记录错误或者是测试状态 测试格式：func TestXxx (t *testing.T),Xxx部分可以为任意的字母数字的组合，但是首字母不能是小写字母[a-z]，例如Testintdiv是错误的函数名。 函数中通过调用testing.T的Error, Errorf, FailNow, Fatal, FatalIf方法，说明测试不通过，调用Log方法用来记录测试的信息。 下面是我们的测试用例的代码： package gotest import ( \"testing\" ) func Test_Division_1(t *testing.T) { if i, e := Division(6, 2); i != 3 || e != nil { //try a unit test on function t.Error(\"除法函数测试没通过\") // 如果不是如预期的那么就报错 } else { t.Log(\"第一个测试通过了\") //记录一些你期望记录的信息 } } func Test_Division_2(t *testing.T) { t.Error(\"就是不通过\") } 我们在项目目录下面执行go test,就会显示如下信息： --- FAIL: Test_Division_2 (0.00 seconds) gotest_test.go:16: 就是不通过 FAIL exit status 1 FAIL gotest 0.013s 从这个结果显示测试没有通过，因为在第二个测试函数中我们写死了测试不通过的代码t.Error，那么我们的第一个函数执行的情况怎么样呢？默认情况下执行go test是不会显示测试通过的信息的，我们需要带上参数go test -v，这样就会显示如下信息： === RUN Test_Division_1 --- PASS: Test_Division_1 (0.00 seconds) gotest_test.go:11: 第一个测试通过了 === RUN Test_Division_2 --- FAIL: Test_Division_2 (0.00 seconds) gotest_test.go:16: 就是不通过 FAIL exit status 1 FAIL gotest 0.012s 上面的输出详细的展示了这个测试的过程，我们看到测试函数1Test_Division_1测试通过，而测试函数2Test_Division_2测试失败了，最后得出结论测试不通过。接下来我们把测试函数2修改成如下代码： func Test_Division_2(t *testing.T) { if _, e := Division(6, 0); e == nil { //try a unit test on function t.Error(\"Division did not work as expected.\") // 如果不是如预期的那么就报错 } else { t.Log(\"one test passed.\", e) //记录一些你期望记录的信息 } } 然后我们执行go test -v，就显示如下信息，测试通过了： === RUN Test_Division_1 --- PASS: Test_Division_1 (0.00 seconds) gotest_test.go:11: 第一个测试通过了 === RUN Test_Division_2 --- PASS: Test_Division_2 (0.00 seconds) gotest_test.go:20: one test passed. 除数不能为0 PASS ok gotest 0.013s ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:9:2","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"如何编写压力测试 压力测试用来检测函数(方法）的性能，和编写单元功能测试的方法类似,此处不再赘述，但需要注意以下几点： 压力测试用例必须遵循如下格式，其中XXX可以是任意字母数字的组合，但是首字母不能是小写字母 func BenchmarkXXX(b *testing.B) { ... } go test不会默认执行压力测试的函数，如果要执行压力测试需要带上参数-test.bench，语法:-test.bench=”test_name_regex”,例如go test -test.bench=”.*“表示测试全部的压力测试函数 在压力测试用例中,请记得在循环体内使用testing.B.N,以使测试可以正常的运行 文件名也必须以_test.go结尾 下面我们新建一个压力测试文件webbench_test.go，代码如下所示： import ( \"testing\" ) func Benchmark_Division(b *testing.B) { for i := 0; i \u003c b.N; i++ { //use b.N for looping Division(4, 5) } } func Benchmark_TimeConsumingFunction(b *testing.B) { b.StopTimer() //调用该函数停止压力测试的时间计数 //做一些初始化的工作,例如读取文件数据,数据库连接之类的, //这样这些时间不影响我们测试函数本身的性能 b.StartTimer() //重新开始时间 for i := 0; i \u003c b.N; i++ { Division(4, 5) } } 我们执行命令go test webbench_test.go -test.bench=”.*\"，可以看到如下结果： Benchmark_Division-4 500000000 7.76 ns/op 456 B/op 14 allocs/op Benchmark_TimeConsumingFunction-4 500000000 7.80 ns/op 224 B/op 4 allocs/op PASS ok gotest 9.364s 上面的结果显示我们没有执行任何TestXXX的单元测试函数，显示的结果只执行了压力测试函数，第一条显示了Benchmark_Division执行了500000000次，每次的执行平均时间是7.76纳秒，第二条显示了Benchmark_TimeConsumingFunction执行了500000000，每次的平均执行时间是7.80纳秒。最后一条显示总共的执行时间。 ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:9:3","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":"小结 通过上面对单元测试和压力测试的学习，我们可以看到testing包很轻量，编写单元测试和压力测试用例非常简单，配合内置的go test命令就可以非常方便的进行测试，这样在我们每次修改完代码,执行一下go test就可以简单的完成回归测试了。 ","date":"2022-01-06 09:16:34","objectID":"https://qizhengzou.github.io/go_base_03/:9:4","tags":["go grammar"],"title":"Go_base_03","uri":"https://qizhengzou.github.io/go_base_03/"},{"categories":["Go"],"content":" 参考学习go语言中文网、C语言中文网、golang官方文档等 流程控制 ","date":"2022-01-06 09:16:07","objectID":"https://qizhengzou.github.io/go_base_02/:0:0","tags":["go grammar"],"title":"Go_base_02","uri":"https://qizhengzou.github.io/go_base_02/"},{"categories":["Go"],"content":"if Go 编程语言中 if 语句的语法如下： 可省略条件表达式括号。 持初始化语句，可定义代码块局部变量。 代码块左花括号必须在条件表达式尾部。 可嵌套 if 布尔表达式 { /* 在布尔表达式为 true 时执行 */ } Go不支持三元操作符(三目运算符) “a \u003e b ? a : b” ","date":"2022-01-06 09:16:07","objectID":"https://qizhengzou.github.io/go_base_02/:1:0","tags":["go grammar"],"title":"Go_base_02","uri":"https://qizhengzou.github.io/go_base_02/"},{"categories":["Go"],"content":"switch Golang switch 分支表达式可以是任意类型，不限于常量。可省略 break，默认自动终止。 可以同时测试多个可能符合条件的值，使用逗号分割它们，例如：case val1, val2, val3。 如： switch { case grade == \"A\" : fmt.Printf(\"优秀!\\n\" ) case grade == \"B\", grade == \"C\" : fmt.Printf(\"良好\\n\" ) case grade == \"D\" : fmt.Printf(\"及格\\n\" ) case grade == \"F\": fmt.Printf(\"不及格\\n\" ) default: fmt.Printf(\"差\\n\" ) } ","date":"2022-01-06 09:16:07","objectID":"https://qizhengzou.github.io/go_base_02/:2:0","tags":["go grammar"],"title":"Go_base_02","uri":"https://qizhengzou.github.io/go_base_02/"},{"categories":["Go"],"content":"Type Switch switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。 switch x.(type){ case type1: statement(s) case type2: statement(s) /* 你可以定义任意个数的case */ default: /* 可选 */ statement(s) } ","date":"2022-01-06 09:16:07","objectID":"https://qizhengzou.github.io/go_base_02/:2:1","tags":["go grammar"],"title":"Go_base_02","uri":"https://qizhengzou.github.io/go_base_02/"},{"categories":["Go"],"content":"select select 语句类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，且没有default语句，它将阻塞，直到有case可运行。 每个case都必须是一个通信 所有channel表达式都会被求值 所有被发送的表达式都会被求值 如果任意某个通信可以进行，它就执行；其他被忽略。 如果有多个case都可以运行，Select会随机公平地选出一个执行。其他不会执行。 否则： 如果有default子句，则执行该语句。 如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。 select可以监听channel的数据流动 select的用法与switch语法非常类似，由select开始的一个新的选择块，每个选择条件由case语句来描述 与switch语句可以选择任何使用相等比较的条件相比，select有比较多的限制，其中最大的一条限制就是每个case语句里必须是一个IO操作 select { //不停的在这里检测 case \u003c-chanl : //检测有没有数据可以读 //如果chanl成功读取到数据，则进行该case处理语句 case chan2 \u003c- 1 : //检测有没有可以写 //如果成功向chan2写入数据，则进行该case处理语句 //假如没有default，那么在以上两个条件都不成立的情况下，就会在此阻塞//一般default会不写在里面，select中的default子句总是可运行的，因为会很消耗CPU资源 default: //如果以上都没有符合条件，那么则进行default处理流程 } 在一个select语句中，Go会按顺序从头到尾评估每一个发送和接收的语句。 如果其中的任意一个语句可以继续执行（即没有被阻塞），那么就从那些可以执行的语句中任意选择一条来使用。 如果没有任意一条语句可以执行（即所有的通道都被阻塞），那么有两种可能的情况： ①如果给出了default语句，那么就会执行default的流程，同时程序的执行会从select语句后的语句中恢复。 ②如果没有default语句，那么select语句将被阻塞，直到至少有一个case可以进行下去。 ","date":"2022-01-06 09:16:07","objectID":"https://qizhengzou.github.io/go_base_02/:3:0","tags":["go grammar"],"title":"Go_base_02","uri":"https://qizhengzou.github.io/go_base_02/"},{"categories":["Go"],"content":"基本使用 select是Go中的一个控制结构，类似于switch语句，用于处理异步IO操作。select会监听case语句中channel的读写操作，当case中channel读写操作为非阻塞状态（即能读写）时，将会触发相应的动作。 select中的case语句必须是一个channel操作 select中的default子句总是可运行的。 如果有多个case都可以运行，select会随机公平地选出一个执行，其他不会执行。 如果没有可运行的case语句，且有default语句，那么就会执行default的动作。 如果没有可运行的case语句，且没有default语句，select将阻塞，直到某个case通信可以运行 例如： package main import \"fmt\" func main() { var c1, c2, c3 chan int var i1, i2 int select { case i1 = \u003c-c1: fmt.Printf(\"received \", i1, \" from c1\\n\") case c2 \u003c- i2: fmt.Printf(\"sent \", i2, \" to c2\\n\") case i3, ok := (\u003c-c3): // same as: i3, ok := \u003c-c3 if ok { fmt.Printf(\"received \", i3, \" from c3\\n\") } else { fmt.Printf(\"c3 is closed\\n\") } default: fmt.Printf(\"no communication\\n\") } } //输出：no communication ","date":"2022-01-06 09:16:07","objectID":"https://qizhengzou.github.io/go_base_02/:3:1","tags":["go grammar"],"title":"Go_base_02","uri":"https://qizhengzou.github.io/go_base_02/"},{"categories":["Go"],"content":"典型用法 超时判断： //比如在下面的场景中，使用全局resChan来接受response，如果时间超过3S,resChan中还没有数据返回，则第二条case将执行 var resChan = make(chan int) // do request func test() { select { case data := \u003c-resChan: doData(data) case \u003c-time.After(time.Second * 3): fmt.Println(\"request time out\") } } func doData(data int) { //... } 退出 //主线程（协程）中如下： var shouldQuit=make(chan struct{}) fun main(){ { //loop } //...out of the loop select { case \u003c-c.shouldQuit: cleanUp() return default: } //... } //再另外一个协程中，如果运行遇到非法操作或不可处理的错误，就向shouldQuit发送数据通知程序停止运行 close(shouldQuit) 判断channel是否阻塞 //在某些情况下是存在不希望channel缓存满了的需求的，可以用如下方法判断 ch := make (chan int, 5) //... data：=0 select { case ch \u003c- data: default: //做相应操作，比如丢弃data。视需求而定 } ","date":"2022-01-06 09:16:07","objectID":"https://qizhengzou.github.io/go_base_02/:3:2","tags":["go grammar"],"title":"Go_base_02","uri":"https://qizhengzou.github.io/go_base_02/"},{"categories":["Go"],"content":"for Go语言的For循环有3中形式，只有其中的一种使用分号。 for init; condition; post { } for condition { } for { } init： 一般为赋值表达式，给控制变量赋初值； condition： 关系表达式或逻辑表达式，循环控制条件； post： 一般为赋值表达式，给控制变量增量或减量。 for语句执行过程如下： ①先对表达式 init 赋初值； ②判别赋值表达式 init 是否满足给定 condition 条件，若其值为真，满足循环条件，则执行循环体内语句，然后执行 post，进入第二次循环，再判别 condition；否则判断 condition 的值为假，不满足条件，就终止for循环，执行循环体外语句。 可嵌套，可无限循环。 ","date":"2022-01-06 09:16:07","objectID":"https://qizhengzou.github.io/go_base_02/:4:0","tags":["go grammar"],"title":"Go_base_02","uri":"https://qizhengzou.github.io/go_base_02/"},{"categories":["Go"],"content":"range Golang range类似迭代器操作，返回 (索引, 值) 或 (键, 值)。 for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下： for key, value := range oldMap { newMap[key] = value } 注意range会复制对象： package main import \"fmt\" func main() { a := [3]int{0, 1, 2} for i, v := range a { // index、value 都是从复制品中取出。 if i == 0 { // 在修改前，我们先修改原数组。 a[1], a[2] = 999, 999 fmt.Println(a) // 确认修改有效，输出 [0, 999, 999]。 } a[i] = v + 100 // 使用复制品中取出的 value 修改原数组。 } fmt.Println(a) // 输出 [100, 101, 102]。 } output: [0 999 999] [100 101 102] 这说明开始执行range时就已经保存了当下的数组，所以在循环里修改数组也不会改动遍历时的使用的数组的值。 改用引用类型，其底层数据不会被复制： package main func main() { s := []int{1, 2, 3, 4, 5} for i, v := range s { // 复制 struct slice { pointer, len, cap }。 if i == 0 { s = s[:3] // 对 slice 的修改，不会影响 range。 s[2] = 100 // 对底层数据的修改。 } println(i, v) } } output: 0 1 1 2 2 100 3 4 4 5 另外两种引用类型 map、channel 是指针包装，而不像 slice 是 struct。 for 和 for range有什么区别? 主要是使用场景不同 for可以 遍历array和slice 遍历key为整型递增的map 遍历string for range可以完成所有for可以做的事情，却能做到for不能做的，包括 遍历key为string类型的map并同时获取key和value 遍历channel ","date":"2022-01-06 09:16:07","objectID":"https://qizhengzou.github.io/go_base_02/:5:0","tags":["go grammar"],"title":"Go_base_02","uri":"https://qizhengzou.github.io/go_base_02/"},{"categories":["Go"],"content":"Goto Break Continue 循环控制语句： Goto、Break、Continue 三个语句都可以配合标签(label)使用 标签名区分大小写，定以后若不使用会造成编译错误 continue、break配合标签(label)可用于多层循环跳出 goto是调整执行位置，与continue、break配合标签(label)的结果并不相同 ","date":"2022-01-06 09:16:07","objectID":"https://qizhengzou.github.io/go_base_02/:6:0","tags":["go grammar"],"title":"Go_base_02","uri":"https://qizhengzou.github.io/go_base_02/"},{"categories":["Coding"],"content":" 学习代码随想录笔记 动态规划 有很多重叠子问题，优先考虑使用动态规划。 与贪心的区别：贪心不会考虑之前的状态，只考虑局部最优。 ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:0:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"理论基础 dp步骤： 确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组 debug:把dp数组打印出来 ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:1:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"斐波那契数 func fib(n int) int { if n \u003c 2 { return n } a, b, c := 0, 1, 0 for i := 1; i \u003c n; i++ { c = a + b a, b = b, c } return c } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:2:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"爬楼梯 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶 func climbStairs(n int) int { if n==1{ return 1 } dp:=make([]int,n+1) dp[1]=1 dp[2]=2 for i:=3;i\u003c=n;i++{ dp[i]=dp[i-1]+dp[i-2] } return dp[n] } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:3:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"使用最小花费爬楼梯 数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。 每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。 请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。 示例 1： 输入：cost = [10, 15, 20] 输出：15 解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 func minCostClimbingStairs(cost []int) int { dp := make([]int, len(cost)) dp[0], dp[1] = cost[0], cost[1] for i := 2; i \u003c len(cost); i++ { dp[i] = min(dp[i-1], dp[i-2]) + cost[i] } return min(dp[len(cost)-1], dp[len(cost)-2]) } func min(a, b int) int { if a \u003c b { return a } return b } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:3:1","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"不同路径 ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:4:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"I 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ func uniquePaths(m int, n int) int { dp := make([][]int, m) for i := range dp { dp[i] = make([]int, n) dp[i][0] = 1 } for j := 0; j \u003c n; j++ { dp[0][j] = 1 } for i := 1; i \u003c m; i++ { for j := 1; j \u003c n; j++ { dp[i][j] = dp[i-1][j] + dp[i][j-1] } } return dp[m-1][n-1] } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:4:1","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"II 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ func uniquePathsWithObstacles(obstacleGrid [][]int) int { m,n:= len(obstacleGrid),len(obstacleGrid[0]) // 定义一个dp数组 dp := make([][]int,m) for i,_ := range dp { dp[i] = make([]int,n) } // 初始化 for i:=0;i\u003cm;i++ { // 如果是障碍物, 后面的就都是0, 不用循环了 if obstacleGrid[i][0] == 1 { break } dp[i][0]=1 } for i:=0;i\u003cn;i++ { if obstacleGrid[0][i] == 1 { break } dp[0][i]=1 } // dp数组推导过程 for i:=1;i\u003cm;i++ { for j:=1;j\u003cn;j++ { // 如果obstacleGrid[i][j]这个点是障碍物, 那么我们的dp[i][j]保持为0 if obstacleGrid[i][j] != 1 { // 否则我们需要计算当前点可以到达的路径数 dp[i][j] = dp[i-1][j]+dp[i][j-1] } } } // debug遍历dp //for i,_ := range dp { // for j,_ := range dp[i] { // fmt.Printf(\"%.2v,\",dp[i][j]) // } // fmt.Println() //} return dp[m-1][n-1] } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:4:2","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"整数拆分 给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 func integerBreak(n int) int { /** 动态五部曲 1.确定dp下标及其含义 2.确定递推公式 3.确定dp初始化 4.确定遍历顺序 5.打印dp **/ dp:=make([]int,n+1) dp[1]=1 dp[2]=1 for i:=3;i\u003cn+1;i++{ for j:=1;j\u003ci-1;j++{ // i可以差分为i-j和j。由于需要最大值，故需要通过j遍历所有存在的值，取其中最大的值作为当前i的最大值，在求最大值的时候，一个是j与i-j相乘，一个是j与dp[i-j]. dp[i]=max(dp[i],max(j*(i-j),j*dp[i-j])) } } return dp[n] } func max(a,b int) int{ if a\u003eb{ return a } return b } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:5:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"不同的二叉搜索树 给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ func numTrees(n int)int{ dp:=make([]int,n+1) dp[0]=1 for i:=1;i\u003c=n;i++{ for j:=1;j\u003c=i;j++{ dp[i]+=dp[j-1]*dp[i-j] } } return dp[n] } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:6:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"0-1背包理论基础 ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:7:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"I 暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化 代码随想录详解 func test_2_wei_bag_problem1(weight, value []int, bagweight int) int { // 定义dp数组 dp := make([][]int, len(weight)) for i, _ := range dp { dp[i] = make([]int, bagweight+1) } // 初始化 for j := bagweight; j \u003e= weight[0]; j-- { dp[0][j] = dp[0][j-weight[0]] + value[0] } // 递推公式 for i := 1; i \u003c len(weight); i++ { //正序,也可以倒序 for j := weight[i];j\u003c= bagweight ; j++ { dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i]) } } return dp[len(weight)-1][bagweight] } func max(a,b int) int { if a \u003e b { return a } return b } func main() { weight := []int{1,3,4} value := []int{15,20,30} test_2_wei_bag_problem1(weight,value,4) } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:7:1","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"II 代码随想录详解 func test_1_wei_bag_problem(weight, value []int, bagWeight int) int { // 定义 and 初始化 dp := make([]int,bagWeight+1) // 递推顺序 for i := 0 ;i \u003c len(weight) ; i++ { // 这里必须倒序,区别二维,因为二维dp保存了i的状态 for j:= bagWeight; j \u003e= weight[i] ; j-- { // 递推公式 dp[j] = max(dp[j], dp[j-weight[i]]+value[i]) } } //fmt.Println(dp) return dp[bagWeight] } func max(a,b int) int { if a \u003e b { return a } return b } func main() { weight := []int{1,3,4} value := []int{15,20,30} test_1_wei_bag_problem(weight,value,4) } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:7:2","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"分割等和子集 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200 示例 1: 输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11]. 示例 2: 输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集. // 分割等和子集 动态规划 // 时间复杂度O(n^2) 空间复杂度O(n) func canPartition(nums []int) bool { sum := 0 for _, num := range nums { sum += num } // 如果 nums 的总和为奇数则不可能平分成两个子集 if sum % 2 == 1 { return false } target := sum / 2 dp := make([]int, target + 1) for _, num := range nums { for j := target; j \u003e= num; j-- { if dp[j] \u003c dp[j - num] + num { dp[j] = dp[j - num] + num } } } return dp[target] == target } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:8:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"最后一块石头的重量II 有一堆石头，每块石头的重量都是正整数。 每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x \u003c= y。那么粉碎的可能结果如下： 如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。 示例： 输入：[2,7,4,1,8,1] 输出：1 解释： 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]， 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]， 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]， 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。 func lastStoneWeightII(stones []int) int { // 15001 = 30 * 1000 /2 +1 dp := make([]int, 15001) // 求target sum := 0 for _, v := range stones { sum += v } target := sum / 2 // 遍历顺序 for i := 0; i \u003c len(stones); i++ { for j := target; j \u003e= stones[i]; j-- { // 推导公式 dp[j] = max(dp[j], dp[j-stones[i]]+stones[i]) } } return sum - 2 * dp[target] } func max(a, b int) int { if a \u003e b { return a } return b } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:9:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"目标和 给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 示例： 输入：nums: [1, 1, 1, 1, 1], S: 3 输出：5 解释： -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3 一共有5种方法让最终目标和为3。 可回溯可dp func findTargetSumWays(nums []int, target int) int { sum := 0 for _, v := range nums { sum += v } if target \u003e sum { return 0 } if (sum+target)%2 == 1 { return 0 } // 计算背包大小 bag := (sum + target) / 2 // 定义dp数组 dp := make([]int, bag+1) // 初始化 dp[0] = 1 // 遍历顺序 for i := 0; i \u003c len(nums); i++ { for j := bag; j \u003e= nums[i]; j-- { //推导公式 dp[j] += dp[j-nums[i]] //fmt.Println(dp) } } return dp[bag] } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:10:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"一和零 给你一个二进制字符串数组 strs 和两个整数 m 和 n 。 请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。 如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。 示例 1： 输入：strs = [“10”, “0001”, “111001”, “1”, “0”], m = 5, n = 3 输出：4 解释：最多有 5 个 0 和 3 个 1 的最大子集是 {“10”,“0001”,“1”,“0”} ，因此答案是 4 。 其他满足题意但较小的子集包括 {“0001”,“1”} 和 {“10”,“1”,“0”} 。{“111001”} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。 func findMaxForm(strs []string, m int, n int) int { // 定义数组 dp := make([][]int, m+1) for i,_ := range dp { dp[i] = make([]int, n+1 ) } // 遍历 for i:=0;i\u003clen(strs);i++ { zeroNum,oneNum := 0 , 0 //计算0,1 个数 //或者直接strings.Count(strs[i],\"0\") for _,v := range strs[i] { if v == '0' { zeroNum++ } } oneNum = len(strs[i])-zeroNum // 从后往前 遍历背包容量 for j:= m ; j \u003e= zeroNum;j-- { for k:=n ; k \u003e= oneNum;k-- { // 推导公式 dp[j][k] = max(dp[j][k],dp[j-zeroNum][k-oneNum]+1) } } //fmt.Println(dp) } return dp[m][n] } func max(a,b int) int { if a \u003e b { return a } return b } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:11:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"完全背包理论基础 每件物品都有无限个（也就是可以放入背包多次） // test_CompletePack1 先遍历物品, 在遍历背包 func test_CompletePack1(weight, value []int, bagWeight int) int { // 定义dp数组 和初始化 dp := make([]int, bagWeight+1) // 遍历顺序 for i := 0; i \u003c len(weight); i++ { // 正序会多次添加 value[i] for j := weight[i]; j \u003c= bagWeight; j++ { // 推导公式 dp[j] = max(dp[j], dp[j-weight[i]]+value[i]) // debug //fmt.Println(dp) } } return dp[bagWeight] } // test_CompletePack2 先遍历背包, 在遍历物品 func test_CompletePack2(weight, value []int, bagWeight int) int { // 定义dp数组 和初始化 dp := make([]int, bagWeight+1) // 遍历顺序 // j从0 开始 for j := 0; j \u003c= bagWeight; j++ { for i := 0; i \u003c len(weight); i++ { if j \u003e= weight[i] { // 推导公式 dp[j] = max(dp[j], dp[j-weight[i]]+value[i]) } // debug //fmt.Println(dp) } } return dp[bagWeight] } func max(a, b int) int { if a \u003e b { return a } return b } func main() { weight := []int{1, 3, 4} price := []int{15, 20, 30} fmt.Println(test_CompletePack1(weight, price, 4)) fmt.Println(test_CompletePack2(weight, price, 4)) } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:12:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"零钱兑换II 给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 示例 1: 输入: amount = 5, coins = [1, 2, 5] 输出: 4 解释: 有四种方式可以凑成总金额: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1 func change(amount int, coins []int) int { // 定义dp数组 dp := make([]int, amount+1) // 初始化,0大小的背包, 当然是不装任何东西了, 就是1种方法 dp[0] = 1 // 遍历顺序 // 遍历物品 for i := 0 ;i \u003c len(coins);i++ { // 遍历背包 for j:= coins[i] ; j \u003c= amount ;j++ { // 推导公式 dp[j] += dp[j-coins[i]] } } return dp[amount] } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:13:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"组合总和（IV） 给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 示例: nums = [1, 2, 3] target = 4 所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) 请注意，顺序不同的序列被视作不同的组合。 因此输出为 7 func combinationSum4(nums []int, target int) int { //定义dp数组 dp := make([]int, target+1) // 初始化 dp[0] = 1 // 遍历顺序, 先遍历背包,再循环遍历物品 for j:=0;j\u003c=target;j++ { for i:=0 ;i \u003c len(nums);i++ { if j \u003e= nums[i] { dp[j] += dp[j-nums[i]] } } } return dp[target] } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:14:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"爬楼梯（进阶） 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶 func climbStairs(n int) int { //定义 dp := make([]int, n+1) //初始化 dp[0] = 1 // 本题物品只有两个1,2 m := 2 // 遍历顺序 for j := 1; j \u003c= n; j++ { //先遍历背包 for i := 1; i \u003c= m; i++ { //再遍历物品 if j \u003e= i { dp[j] += dp[j-i] } //fmt.Println(dp) } } return dp[n] } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:15:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"零钱兑换 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 你可以认为每种硬币的数量是无限的。 示例 1： 输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1 // 版本一, 先遍历物品,再遍历背包 func coinChange1(coins []int, amount int) int { dp := make([]int, amount+1) // 初始化dp[0] dp[0] = 0 // 初始化为math.MaxInt32 for j := 1; j \u003c= amount; j++ { dp[j] = math.MaxInt32 } // 遍历物品 for i := 0; i \u003c len(coins); i++ { // 遍历背包 for j := coins[i]; j \u003c= amount; j++ { if dp[j-coins[i]] != math.MaxInt32 { // 推导公式 dp[j] = min(dp[j], dp[j-coins[i]]+1) //fmt.Println(dp,j,i) } } } // 没找到能装满背包的, 就返回-1 if dp[amount] == math.MaxInt32 { return -1 } return dp[amount] } // 版本二,先遍历背包,再遍历物品 func coinChange2(coins []int, amount int) int { dp := make([]int, amount+1) // 初始化dp[0] dp[0] = 0 // 遍历背包,从1开始 for j := 1; j \u003c= amount; j++ { // 初始化为math.MaxInt32 dp[j] = math.MaxInt32 // 遍历物品 for i := 0; i \u003c len(coins); i++ { if j \u003e= coins[i] \u0026\u0026 dp[j-coins[i]] != math.MaxInt32 { // 推导公式 dp[j] = min(dp[j], dp[j-coins[i]]+1) //fmt.Println(dp) } } } // 没找到能装满背包的, 就返回-1 if dp[amount] == math.MaxInt32 { return -1 } return dp[amount] } func min(a, b int) int { if a \u003c b { return a } return b } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:16:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"完全平方数 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。 示例 1： 输入：n = 12 输出：3 解释：12 = 4 + 4 + 4 // 版本一,先遍历物品, 再遍历背包 func numSquares1(n int) int { //定义 dp := make([]int, n+1) // 初始化 dp[0] = 0 for i := 1; i \u003c= n; i++ { dp[i] = math.MaxInt32 } // 遍历物品 for i := 1; i \u003c= n; i++ { // 遍历背包 for j := i*i; j \u003c= n; j++ { dp[j] = min(dp[j], dp[j-i*i]+1) } } return dp[n] } // 版本二,先遍历背包, 再遍历物品 func numSquares2(n int) int { //定义 dp := make([]int, n+1) // 初始化 dp[0] = 0 // 遍历背包 for j := 1; j \u003c= n; j++ { //初始化 dp[j] = math.MaxInt32 // 遍历物品 for i := 1; i \u003c= n; i++ { if j \u003e= i*i { dp[j] = min(dp[j], dp[j-i*i]+1) } } } return dp[n] } func min(a, b int) int { if a \u003c b { return a } return b } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:17:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"单词拆分 给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。 示例 1： 输入: s = “leetcode”, wordDict = [“leet”, “code”] 输出: true 解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。 func wordBreak(s string,wordDict []string) bool { wordDictSet:=make(map[string]bool) for _,w:=range wordDict{ wordDictSet[w]=true } dp:=make([]bool,len(s)+1) dp[0]=true for i:=1;i\u003c=len(s);i++{ for j:=0;j\u003ci;j++{ if dp[j]\u0026\u0026 wordDictSet[s[j:i]]{ dp[i]=true break } } } return dp[len(s)] } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:18:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"打家劫舍 ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:19:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"I 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 func rob(nums []int) int { if len(nums)\u003c1{ return 0 } if len(nums)==1{ return nums[0] } if len(nums)==2{ return max(nums[0],nums[1]) } dp :=make([]int,len(nums)) dp[0]=nums[0] dp[1]=max(nums[0],nums[1]) for i:=2;i\u003clen(nums);i++{ dp[i]=max(dp[i-2]+nums[i],dp[i-1]) } return dp[len(dp)-1] } func max(a, b int) int { if a\u003eb{ return a } return b } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:19:1","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"II 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。 给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。 示例 1： 输入：nums = [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 // 打家劫舍Ⅱ 动态规划 // 时间复杂度O(n) 空间复杂度O(n) func rob(nums []int) int { if len(nums) == 1 { return nums[0] } if len(nums) == 2 { return max(nums[0], nums[1]) } result1 := robRange(nums, 0) result2 := robRange(nums, 1) return max(result1, result2) } // 偷盗指定的范围 func robRange(nums []int, start int) int { dp := make([]int, len(nums)) dp[1] = nums[start] for i := 2; i \u003c len(nums); i++ { dp[i] = max(dp[i - 2] + nums[i - 1 + start], dp[i - 1]) } return dp[len(nums) - 1] } func max(a, b int) int { if a \u003e b { return a } return b } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:19:2","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"III 在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 动态规划 func rob(root *TreeNode) int { res := robTree(root) return max(res[0], res[1]) } func max(a, b int) int { if a \u003e b { return a } return b } func robTree(cur *TreeNode) []int { if cur == nil { return []int{0, 0} } // 后序遍历 left := robTree(cur.Left) right := robTree(cur.Right) // 考虑去偷当前的屋子 robCur := cur.Val + left[0] + right[0] // 考虑不去偷当前的屋子 notRobCur := max(left[0], left[1]) + max(right[0], right[1]) // 注意顺序：0:不偷，1:去偷 return []int{notRobCur, robCur} } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:19:3","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"买卖股票的最佳时机 ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:20:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"I 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1： 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 func maxProfit(prices []int) int { length:=len(prices) if length==0{return 0} dp:=make([][]int,length) for i:=0;i\u003clength;i++{ dp[i]=make([]int,2) } dp[0][0]=-prices[0] dp[0][1]=0 for i:=1;i\u003clength;i++{ dp[i][0]=max(dp[i-1][0],-prices[i]) dp[i][1]=max(dp[i-1][1],dp[i-1][0]+prices[i]) } return dp[length-1][1] } func max(a,b int)int { if a\u003eb{ return a } return b } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:20:1","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"II 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 // 买卖股票的最佳时机Ⅱ 动态规划 // 时间复杂度：O(n) 空间复杂度：O(n) func maxProfit(prices []int) int { dp := make([][]int, len(prices)) status := make([]int, len(prices) * 2) for i := range dp { dp[i] = status[:2] status = status[2:] } dp[0][0] = -prices[0] for i := 1; i \u003c len(prices); i++ { dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]) dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]) } return dp[len(prices) - 1][1] } func max(a, b int) int { if a \u003e b { return a } return b } func maxProfit(prices []int) int { //创建数组 dp:=make([][]int,len(prices)) for i:=0;i\u003clen(prices);i++{ dp[i]=make([]int,2) } dp[0][0]=-prices[0] dp[0][1]=0 for i:=1;i\u003clen(prices);i++{ dp[i][0]=max(dp[i-1][0],dp[i-1][1]-prices[i]) dp[i][1]=max(dp[i-1][1],dp[i-1][0]+prices[i]) } return dp[len(prices)-1][1] } func max(a,b int)int{ if a\u003cb{ return b } return a } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:20:2","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"III 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入：prices = [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3。 func maxProfit(prices []int) int { dp:=make([][]int,len(prices)) for i:=0;i\u003clen(prices);i++{ dp[i]=make([]int,5) } dp[0][0]=0 dp[0][1]=-prices[0] dp[0][2]=0 dp[0][3]=-prices[0] dp[0][4]=0 for i:=1;i\u003clen(prices);i++{ dp[i][0]=dp[i-1][0] dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i]) dp[i][2]=max(dp[i-1][2],dp[i-1][1]+prices[i]) dp[i][3]=max(dp[i-1][3],dp[i-1][2]-prices[i]) dp[i][4]=max(dp[i-1][4],dp[i-1][3]+prices[i]) } return dp[len(prices)-1][4] } func max(a,b int)int{ if a\u003eb{ return a } return b } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:20:3","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"IV 给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1： 输入：k = 2, prices = [2,4,1] 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2。 版本一： // 买卖股票的最佳时机IV 动态规划 // 时间复杂度O(kn) 空间复杂度O(kn) func maxProfit(k int, prices []int) int { if k == 0 || len(prices) == 0 { return 0 } dp := make([][]int, len(prices)) status := make([]int, (2 * k + 1) * len(prices)) for i := range dp { dp[i] = status[:2 * k + 1] status = status[2 * k + 1:] } for j := 1; j \u003c 2 * k; j += 2 { dp[0][j] = -prices[0] } for i := 1; i \u003c len(prices); i++ { for j := 0; j \u003c 2 * k; j += 2 { dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]) dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]) } } return dp[len(prices) - 1][2 * k] } func max(a, b int) int { if a \u003e b { return a } return b } func maxProfit(k int, prices []int) int { if len(prices)==0{ return 0 } dp:=make([][]int,len(prices)) for i:=0;i\u003clen(prices);i++{ dp[i]=make([]int,2*k+1) } for i:=1;i\u003clen(dp[0]);i++{ if i%2!=0{ dp[0][i]=-prices[0] } } for i:=1;i\u003clen(prices);i++{ dp[i][0]=dp[i-1][0] for j:=1;j\u003clen(dp[0]);j++{ if j%2!=0{ dp[i][j]=max(dp[i-1][j],dp[i-1][j-1]-prices[i]) }else { dp[i][j]=max(dp[i-1][j],dp[i-1][j-1]+prices[i]) } } } return dp[len(prices)-1][2*k] } func max(a,b int)int{ if a\u003eb{ return a } return b } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:20:4","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"最佳买卖股票时机含冷冻期 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例: 输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] // 最佳买卖股票时机含冷冻期 动态规划 // 时间复杂度O(n) 空间复杂度O(n) func maxProfit(prices []int) int { n := len(prices) if n \u003c 2 { return 0 } dp := make([][]int, n) status := make([]int, n * 4) for i := range dp { dp[i] = status[:4] status = status[4:] } dp[0][0] = -prices[0] for i := 1; i \u003c n; i++ { dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][1] - prices[i], dp[i - 1][3] - prices[i])) dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]) dp[i][2] = dp[i - 1][0] + prices[i] dp[i][3] = dp[i - 1][2] } return max(dp[n - 1][1], max(dp[n - 1][2], dp[n - 1][3])) } func max(a, b int) int { if a \u003e b { return a } return b } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:20:5","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"最佳买卖股票时机含手续费 给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。 示例 1: 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2 输出: 8 解释: 能够达到的最大利润: 在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8. // 买卖股票的最佳时机含手续费 动态规划 // 时间复杂度O(n) 空间复杂度O(n) func maxProfit(prices []int, fee int) int { n := len(prices) dp := make([][2]int, n) dp[0][0] = -prices[0] for i := 1; i \u003c n; i++ { dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i] - fee) dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]) } return dp[n-1][1] } func max(a, b int) int { if a \u003e b { return a } return b } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:20:6","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"股票问题总结 代码随想录 ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:21:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"最长上升子序列 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例 1： 输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 func lengthOfLIS(nums []int ) int { dp := []int{} for _, num := range nums { if len(dp) ==0 || dp[len(dp) - 1] \u003c num { dp = append(dp, num) } else { l, r := 0, len(dp) - 1 pos := r for l \u003c= r { mid := (l + r) \u003e\u003e 1 if dp[mid] \u003e= num { pos = mid; r = mid - 1 } else { l = mid + 1 } } dp[pos] = num }//二分查找 } return len(dp) } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:22:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"最长连续递增序列 给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。 连续递增的子序列 可以由两个下标 l 和 r（l \u003c r）确定，如果对于每个 l \u003c= i \u003c r，都有 nums[i] \u003c nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。 示例 1： 输入：nums = [1,3,5,4,7] 输出：3 解释：最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 动态规划： class Solution: def findLengthOfLCIS(self, nums: List[int]) -\u003e int: if len(nums) == 0: return 0 result = 1 dp = [1] * len(nums) for i in range(len(nums)-1): if nums[i+1] \u003e nums[i]: #连续记录 dp[i+1] = dp[i] + 1 result = max(result, dp[i+1]) return result 贪心法： class Solution: def findLengthOfLCIS(self, nums: List[int]) -\u003e int: if len(nums) == 0: return 0 result = 1 #连续子序列最少也是1 count = 1 for i in range(len(nums)-1): if nums[i+1] \u003e nums[i]: #连续记录 count += 1 else: #不连续，count从头开始 count = 1 result = max(result, count) return result ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:23:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"最长重复子数组 给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。 示例： 输入： A: [1,2,3,2,1] B: [3,2,1,4,7] 输出：3 解释： 长度最长的公共子数组是 [3, 2, 1] 。 func findLength(A []int, B []int) int { m, n := len(A), len(B) res := 0 dp := make([][]int, m+1) for i := 0; i \u003c= m; i++ { dp[i] = make([]int, n+1) } for i := 1; i \u003c= m; i++ { for j := 1; j \u003c= n; j++ { if A[i-1] == B[j-1] { dp[i][j] = dp[i-1][j-1] + 1 } if dp[i][j] \u003e res { res = dp[i][j] } } } return res } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:24:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"最长公共子序列 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 例如，“ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。 若这两个字符串没有公共子序列，则返回 0。 示例 1: 输入：text1 = \"abcde\", text2 = \"ace\" 输出：3 解释：最长公共子序列是 \"ace\"，它的长度为 3。 func longestCommonSubsequence(text1 string, text2 string) int { t1 := len(text1) t2 := len(text2) dp:=make([][]int,t1+1) for i:=range dp{ dp[i]=make([]int,t2+1) } for i := 1; i \u003c= t1; i++ { for j := 1; j \u003c=t2; j++ { if text1[i-1]==text2[j-1]{ dp[i][j]=dp[i-1][j-1]+1 }else{ dp[i][j]=max(dp[i-1][j],dp[i][j-1]) } } } return dp[t1][t2] } func max(a,b int)int { if a\u003eb{ return a } return b } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:25:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"不相交的线 我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。 现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] == B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。 以这种方法绘制线条，并返回我们可以绘制的最大连线数。 func maxUncrossedLines(A []int, B []int) int { m, n := len(A), len(B) dp := make([][]int, m+1) for i := range dp { dp[i] = make([]int, n+1) } for i := 1; i \u003c= len(A); i++ { for j := 1; j \u003c= len(B); j++ { if (A[i - 1] == B[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1 } else { dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) } } } return dp[m][n] } func max(a, b int) int { if a \u003e b { return a } return b } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:26:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"最大子序和 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6 // solution // 1, dp // 2, 贪心 func maxSubArray(nums []int) int { n := len(nums) // 这里的dp[i] 表示，最大的连续子数组和，包含num[i] 元素 dp := make([]int,n) // 初始化，由于dp 状态转移方程依赖dp[0] dp[0] = nums[0] // 初始化最大的和 mx := nums[0] for i:=1;i\u003cn;i++ { // 这里的状态转移方程就是：求最大和 // 会面临2种情况，一个是带前面的和，一个是不带前面的和 dp[i] = max(dp[i-1]+nums[i],nums[i]) mx = max(mx,dp[i]) } return mx } func max(a,b int) int{ if a\u003eb { return a } return b } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:27:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"判断子序列 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，“ace\"是\"abcde\"的一个子序列，而\"aec\"不是）。 示例 1： 输入：s = “abc”, t = “ahbgdc” 输出：true 示例 2： 输入：s = “axc”, t = “ahbgdc” 输出：false func isSubsequence(s string, t string) bool { dp := make([][]int,len(s)+1) for i:=0;i\u003clen(dp);i++{ dp[i] = make([]int,len(t)+1) } for i:=1;i\u003clen(dp);i++{ for j:=1;j\u003clen(dp[i]);j++{ if s[i-1] == t[j-1]{ dp[i][j] = dp[i-1][j-1] +1 }else{ dp[i][j] = dp[i][j-1] } } } return dp[len(s)][len(t)]==len(s) } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:28:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"不同的子序列 给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。 字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，“ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是） 题目数据保证答案符合 32 位带符号整数范围。 func numDistinct(s string, t string) int { dp:= make([][]int,len(s)+1) for i:=0;i\u003clen(dp);i++{ dp[i] = make([]int,len(t)+1) } // 初始化 for i:=0;i\u003clen(dp);i++{ dp[i][0] = 1 } // dp[0][j] 为 0，默认值，因此不需要初始化 for i:=1;i\u003clen(dp);i++{ for j:=1;j\u003clen(dp[i]);j++{ if s[i-1] == t[j-1]{ dp[i][j] = dp[i-1][j-1] + dp[i-1][j] }else{ dp[i][j] = dp[i-1][j] } } } return dp[len(dp)-1][len(dp[0])-1] } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:29:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"两个字符串的删除操作 给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。 示例： 输入: \"sea\", \"eat\" 输出: 2 解释: 第一步将\"sea\"变为\"ea\"，第二步将\"eat\"变为\"ea\" ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:30:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"编辑距离 给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 1： 输入：word1 = “horse”, word2 = “ros” 输出：3 解释： horse -\u003e rorse (将 ‘h’ 替换为 ‘r’) rorse -\u003e rose (删除 ‘r’) rose -\u003e ros (删除 ‘e’) func minDistance(word1 string, word2 string) int { m, n := len(word1), len(word2) dp := make([][]int, m+1) for i := range dp { dp[i] = make([]int, n+1) } for i := 0; i \u003c m+1; i++ { dp[i][0] = i // word1[i] 变成 word2[0], 删掉 word1[i], 需要 i 部操作 } for j := 0; j \u003c n+1; j++ { dp[0][j] = j // word1[0] 变成 word2[j], 插入 word1[j]，需要 j 部操作 } for i := 1; i \u003c m+1; i++ { for j := 1; j \u003c n+1; j++ { if word1[i-1] == word2[j-1] { dp[i][j] = dp[i-1][j-1] } else { // Min(插入，删除，替换) dp[i][j] = Min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]) + 1 } } } return dp[m][n] } func Min(args ...int) int { min := args[0] for _, item := range args { if item \u003c min { min = item } } return min } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:31:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"编辑距离总结 代码随想录 ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:31:1","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"回文子串 给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 示例 1： 输入：“abc” 输出：3 解释：三个回文子串: “a”, “b”, “c” func countSubstrings(s string) int { res:=0 dp:=make([][]bool,len(s)) for i:=0;i\u003clen(s);i++{ dp[i]=make([]bool,len(s)) } for i:=len(s)-1;i\u003e=0;i--{ for j:=i;j\u003clen(s);j++{ if s[i]==s[j]{ if j-i\u003c=1{ res++ dp[i][j]=true }else if dp[i+1][j-1]{ res++ dp[i][j]=true } } } } return res } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:32:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"最长回文子序列 给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。 示例 1: 输入: “bbbab” 输出: 4 一个可能的最长回文子序列为 “bbbb”。 示例 2: 输入:“cbbd” 输出: 2 一个可能的最长回文子序列为 “bb”。 func longestPalindromeSubseq(s string) int { lenth:=len(s) dp:=make([][]int,lenth) for i:=0;i\u003clenth;i++{ for j:=0;j\u003clenth;j++{ if dp[i]==nil{ dp[i]=make([]int,lenth) } if i==j{ dp[i][j]=1 } } } for i:=lenth-1;i\u003e=0;i--{ for j:=i+1;j\u003clenth;j++{ if s[i]==s[j]{ dp[i][j]=dp[i+1][j-1]+2 }else { dp[i][j]=max(dp[i+1][j],dp[i][j-1]) } } } return dp[0][lenth-1] } ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:33:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":"DP总结 代码随想录 ","date":"2022-01-06 08:27:39","objectID":"https://qizhengzou.github.io/algorithm_dynamicprogramming/:34:0","tags":["data structure"],"title":"Algorithm_dynamicProgramming","uri":"https://qizhengzou.github.io/algorithm_dynamicprogramming/"},{"categories":["Coding"],"content":" 学习代码随想录笔记 贪心算法 ","date":"2022-01-06 08:23:51","objectID":"https://qizhengzou.github.io/algorithm_greedy/:0:0","tags":["data structure"],"title":"Algorithm_greedy","uri":"https://qizhengzou.github.io/algorithm_greedy/"},{"categories":["Coding"],"content":"理论基础 贪心算法一般分为如下四步： 将问题分解为若干个子问题 找出适合的贪心策略 求解每一个子问题的最优解 将局部最优解堆叠成全局最优解 ","date":"2022-01-06 08:23:51","objectID":"https://qizhengzou.github.io/algorithm_greedy/:1:0","tags":["data structure"],"title":"Algorithm_greedy","uri":"https://qizhengzou.github.io/algorithm_greedy/"},{"categories":["Coding"],"content":"分发饼干 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] \u003e= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例 1: 输入: g = [1,2,3], s = [1,1] 输出: 1 解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 //排序后，局部最优 func findContentChildren(g []int, s []int) int { sort.Ints(g) sort.Ints(s) // 从小到大 child := 0 for sIdx := 0; child \u003c len(g) \u0026\u0026 sIdx \u003c len(s); sIdx++ { if s[sIdx] \u003e= g[child] {//如果饼干的大小大于或等于孩子的为空则给与，否则不给予，继续寻找选一个饼干是否符合 child++ } } return child } ","date":"2022-01-06 08:23:51","objectID":"https://qizhengzou.github.io/algorithm_greedy/:2:0","tags":["data structure"],"title":"Algorithm_greedy","uri":"https://qizhengzou.github.io/algorithm_greedy/"},{"categories":["Coding"],"content":"摆动序列 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。 例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。 示例 1: 输入: [1,7,4,9,2,5] 输出: 6 解释: 整个序列均为摆动序列。 示例 2: 输入: [1,17,5,10,13,15,10,5,16,8] 输出: 7 解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。 贪心或者dp func wiggleMaxLength(nums []int) int { var count,preDiff,curDiff int count=1 if len(nums)\u003c2{ return count } for i:=0;i\u003clen(nums)-1;i++{ curDiff=nums[i+1]-nums[i] //如果有正有负则更新下标值||或者只有前一个元素为0（针对两个不等元素的序列也视作摆动序列，且摆动长度为2） if (curDiff \u003e 0 \u0026\u0026 preDiff \u003c= 0) || (preDiff \u003e= 0 \u0026\u0026 curDiff \u003c 0){ preDiff=curDiff count++ } } return count } ","date":"2022-01-06 08:23:51","objectID":"https://qizhengzou.github.io/algorithm_greedy/:3:0","tags":["data structure"],"title":"Algorithm_greedy","uri":"https://qizhengzou.github.io/algorithm_greedy/"},{"categories":["Coding"],"content":"最大子序和 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6 贪心或者dp func maxSubArray(nums []int) int { maxSum := nums[0] for i := 1; i \u003c len(nums); i++ { if nums[i] + nums[i-1] \u003e nums[i] { nums[i] += nums[i-1] } if nums[i] \u003e maxSum { maxSum = nums[i] } } return maxSum } ","date":"2022-01-06 08:23:51","objectID":"https://qizhengzou.github.io/algorithm_greedy/:4:0","tags":["data structure"],"title":"Algorithm_greedy","uri":"https://qizhengzou.github.io/algorithm_greedy/"},{"categories":["Coding"],"content":"买卖股票的最佳时机II 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0 贪心或者dp //贪心算法 func maxProfit(prices []int) int { var sum int for i := 1; i \u003c len(prices); i++ { // 累加每次大于0的交易 if prices[i]-prices[i-1] \u003e 0 { sum += prices[i]-prices[i-1] } } return sum } //确定售卖点 func maxProfit(prices []int) int { var result,buy int prices=append(prices,0)//在price末尾加个0，防止price一直递增 /** 思路：检查后一个元素是否大于当前元素，如果小于，则表明这是一个售卖点，当前元素的值减去购买时候的值 如果不小于，说明后面有更好的售卖点， **/ for i:=0;i\u003clen(prices)-1;i++{ if prices[i]\u003eprices[i+1]{ result+=prices[i]-prices[buy] buy=i+1 }else if prices[buy]\u003eprices[i]{//更改最低购买点 buy=i } } return result } ","date":"2022-01-06 08:23:51","objectID":"https://qizhengzou.github.io/algorithm_greedy/:5:0","tags":["data structure"],"title":"Algorithm_greedy","uri":"https://qizhengzou.github.io/algorithm_greedy/"},{"categories":["Coding"],"content":"跳跃游戏 ","date":"2022-01-06 08:23:51","objectID":"https://qizhengzou.github.io/algorithm_greedy/:6:0","tags":["data structure"],"title":"Algorithm_greedy","uri":"https://qizhengzou.github.io/algorithm_greedy/"},{"categories":["Coding"],"content":"I 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 func canJUmp(nums []int) bool { if len(nums)\u003c=1{ return true } dp:=make([]bool,len(nums)) dp[0]=true for i:=1;i\u003clen(nums);i++{ for j:=i-1;j\u003e=0;j--{ if dp[j]\u0026\u0026nums[j]+j\u003e=i{ dp[i]=true break } } } return dp[len(nums)-1] } ","date":"2022-01-06 08:23:51","objectID":"https://qizhengzou.github.io/algorithm_greedy/:6:1","tags":["data structure"],"title":"Algorithm_greedy","uri":"https://qizhengzou.github.io/algorithm_greedy/"},{"categories":["Coding"],"content":"II 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 func jump(nums []int) int { dp:=make([]int ,len(nums)) dp[0]=0 for i:=1;i\u003clen(nums);i++{ dp[i]=i for j:=0;j\u003ci;j++{ if nums[j]+j\u003ei{ dp[i]=min(dp[j]+1,dp[i]) } } } return dp[len(nums)-1] } ","date":"2022-01-06 08:23:51","objectID":"https://qizhengzou.github.io/algorithm_greedy/:6:2","tags":["data structure"],"title":"Algorithm_greedy","uri":"https://qizhengzou.github.io/algorithm_greedy/"},{"categories":["Coding"],"content":"K次取反后最大化的数组和 给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。） 以这种方式修改数组后，返回数组可能的最大和。 func largestSumAfterKNegations(nums []int, K int) int { sort.Slice(nums, func(i, j int) bool { return math.Abs(float64(nums[i])) \u003e math.Abs(float64(nums[j])) }) for i := 0; i \u003c len(nums); i++ { if K \u003e 0 \u0026\u0026 nums[i] \u003c 0 { nums[i] = -nums[i] K-- } } if K%2 == 1 { nums[len(nums)-1] = -nums[len(nums)-1] } result := 0 for i := 0; i \u003c len(nums); i++ { result += nums[i] } return result } ","date":"2022-01-06 08:23:51","objectID":"https://qizhengzou.github.io/algorithm_greedy/:7:0","tags":["data structure"],"title":"Algorithm_greedy","uri":"https://qizhengzou.github.io/algorithm_greedy/"},{"categories":["Coding"],"content":"加油站 在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。 如果题目有解，该答案即为唯一答案。 输入数组均为非空数组，且长度相同。 输入数组中的元素均为非负数。 func canCompleteCircuit(gas []int, cost []int) int { curSum := 0 totalSum := 0 start := 0 for i := 0; i \u003c len(gas); i++ { curSum += gas[i] - cost[i] totalSum += gas[i] - cost[i] if curSum \u003c 0 { start = i+1 curSum = 0 } } if totalSum \u003c 0 { return -1 } return start } ","date":"2022-01-06 08:23:51","objectID":"https://qizhengzou.github.io/algorithm_greedy/:8:0","tags":["data structure"],"title":"Algorithm_greedy","uri":"https://qizhengzou.github.io/algorithm_greedy/"},{"categories":["Coding"],"content":"分发糖果 老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。 你需要按照以下要求，帮助老师给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。 相邻的孩子中，评分高的孩子必须获得更多的糖果。 那么这样下来，老师至少需要准备多少颗糖果呢？ 示例 1: 输入: [1,0,2] 输出: 5 解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。 示例 2: 输入: [1,2,2] 输出: 4 解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这已满足上述两个条件。 func candy(ratings []int) int { /**先确定一边，再确定另外一边 1.先从左到右，当右边的大于左边的就加1 2.再从右到左，当左边的大于右边的就再加1 **/ need:=make([]int,len(ratings)) sum:=0 //初始化(每个人至少一个糖果) for i:=0;i\u003clen(ratings);i++{ need[i]=1 } //1.先从左到右，当右边的大于左边的就加1 for i:=0;i\u003clen(ratings)-1;i++{ if ratings[i]\u003cratings[i+1]{ need[i+1]=need[i]+1 } } //2.再从右到左，当左边的大于右边的就右边加1，但要花费糖果最少，所以需要做下判断 for i:=len(ratings)-1;i\u003e0;i--{ if ratings[i-1]\u003eratings[i]{ need[i-1]=findMax(need[i-1],need[i]+1) } } //计算总共糖果 for i:=0;i\u003clen(ratings);i++{ sum+=need[i] } return sum } func findMax(num1 int ,num2 int) int{ if num1\u003enum2{ return num1 } return num2 } ","date":"2022-01-06 08:23:51","objectID":"https://qizhengzou.github.io/algorithm_greedy/:9:0","tags":["data structure"],"title":"Algorithm_greedy","uri":"https://qizhengzou.github.io/algorithm_greedy/"},{"categories":["Coding"],"content":"柠檬水找零 在柠檬水摊上，每一杯柠檬水的售价为 5 美元。 顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。 注意，一开始你手头没有任何零钱。 如果你能给每位顾客正确找零，返回 true ，否则返回 false 。 示例 1： 输入：[5,5,5,10,20] 输出：true 解释： 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。 第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。 第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。 由于所有客户都得到了正确的找零，所以我们输出 true。 示例 2： 输入：[5,5,10] 输出：true func lemonadeChange(bills []int) bool { //left表示还剩多少 下标0位5元的个数 ，下标1为10元的个数 left:=[2]int{0,0} //第一个元素不为5，直接退出 if bills[0]!=5{ return false } for i:=0;i\u003clen(bills);i++{ //先统计5元和10元的个数 if bills[i]==5{ left[0]+=1 } if bills[i]==10{ left[1]+=1 } //接着处理找零的 tmp:=bills[i]-5 if tmp==5{ if left[0]\u003e0{ left[0]-=1 }else { return false } } if tmp==15{ if left[1]\u003e0\u0026\u0026left[0]\u003e0{ left[0]-=1 left[1]-=1 }else if left[1]==0\u0026\u0026left[0]\u003e2{ left[0]-=3 }else{ return false } } } return true } ","date":"2022-01-06 08:23:51","objectID":"https://qizhengzou.github.io/algorithm_greedy/:10:0","tags":["data structure"],"title":"Algorithm_greedy","uri":"https://qizhengzou.github.io/algorithm_greedy/"},{"categories":["Coding"],"content":"根据身高重建队列 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。 示例 1： 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]] 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 解释： 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。 func reconstructQueue(people [][]int) [][]int { //先将身高从大到小排序，确定最大个子的相对位置 sort.Slice(people,func(i,j int)bool{ if people[i][0]==people[j][0]{ return people[i][1]\u003cpeople[j][1]//这个才是当身高相同时，将K按照从小到大排序 } return people[i][0]\u003epeople[j][0]//这个只是确保身高按照由大到小的顺序来排，并不确定K是按照从小到大排序的 }) //再按照K进行插入排序，优先插入K小的 result := make([][]int, 0) for _, info := range people { result = append(result, info) copy(result[info[1] +1:], result[info[1]:])//将插入位置之后的元素后移动一位（意思是腾出空间） result[info[1]] = info//将插入元素位置插入元素 } return result } //链表法 func reconstructQueue(people [][]int) [][]int { sort.Slice(people,func (i,j int) bool { if people[i][0]==people[j][0]{ return people[i][1]\u003cpeople[j][1]//当身高相同时，将K按照从小到大排序 } //先将身高从大到小排序，确定最大个子的相对位置 return people[i][0]\u003epeople[j][0] }) l:=list.New()//创建链表 for i:=0;i\u003clen(people);i++{ position:=people[i][1] mark:=l.PushBack(people[i])//插入元素 e:=l.Front() for position!=0{//获取相对位置 position-- e=e.Next() } l.MoveBefore(mark,e)//移动位置 } res:=[][]int{} for e:=l.Front();e!=nil;e=e.Next(){ res=append(res,e.Value.([]int)) } return res } ","date":"2022-01-06 08:23:51","objectID":"https://qizhengzou.github.io/algorithm_greedy/:11:0","tags":["data structure"],"title":"Algorithm_greedy","uri":"https://qizhengzou.github.io/algorithm_greedy/"},{"categories":["Coding"],"content":"用最少数量的箭引爆气球 在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。 一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。 给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。 示例 1： 输入：points = [[10,16],[2,8],[1,6],[7,12]] 输出：2 解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球 示例 2： 输入：points = [[1,2],[3,4],[5,6],[7,8]] 输出：4 示例 3： 输入：points = [[1,2],[2,3],[3,4],[4,5]] 输出：2 示例 4： 输入：points = [[1,2]] 输出：1 示例 5： 输入：points = [[2,3],[2,3]] 输出：1 提示： 0 \u003c= points.length \u003c= 10^4 points[i].length == 2 -2^31 \u003c= xstart \u003c xend \u003c= 2^31 - 1 func findMinArrowShots(points [][]int) int { var res int =1//弓箭数 //先按照第一位排序 sort.Slice(points,func (i,j int) bool{ return points[i][0]\u003cpoints[j][0] }) for i:=1;i\u003clen(points);i++{ if points[i-1][1]\u003cpoints[i][0]{//如果前一位的右边界小于后一位的左边界，则一定不重合 res++ }else{ points[i][1] = min(points[i - 1][1], points[i][1]); // 更新重叠气球最小右边界,覆盖该位置的值，留到下一步使用 } } return res } func min(a,b int) int{ if a\u003eb{ return b } return a } ","date":"2022-01-06 08:23:51","objectID":"https://qizhengzou.github.io/algorithm_greedy/:12:0","tags":["data structure"],"title":"Algorithm_greedy","uri":"https://qizhengzou.github.io/algorithm_greedy/"},{"categories":["Coding"],"content":"无重叠区间 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 func eraseOverlapIntervals(intervals [][]int) int { var flag int //先排序 sort.Slice(intervals,func(i,j int)bool{ return intervals[i][0]\u003cintervals[j][0] }) fmt.Println(intervals) for i:=1;i\u003clen(intervals);i++{ if intervals[i-1][1]\u003eintervals[i][0]{ flag++ intervals[i][1]=min(intervals[i-1][1],intervals[i][1])//由于是先排序的，所以，第一位是递增顺序，故只需要将临近两个元素的第二个值最小值更新到该元素的第二个值即可作之后的判断 } } return flag } func min(a,b int)int{ if a\u003eb{ return b } return a } ","date":"2022-01-06 08:23:51","objectID":"https://qizhengzou.github.io/algorithm_greedy/:13:0","tags":["data structure"],"title":"Algorithm_greedy","uri":"https://qizhengzou.github.io/algorithm_greedy/"},{"categories":["Coding"],"content":"划分字母区间 字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。 示例： 输入：S = “ababcbacadefegdehijhklij” 输出：[9,7,8] 解释： 划分结果为 “ababcbaca”, “defegde”, “hijhklij”。 每个字母最多出现在一个片段中。 像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。 func partitionLabels(s string) []int { var res []int; var marks [26]int; size, left, right := len(s), 0, 0; for i := 0; i \u003c size; i++ { marks[s[i] - 'a'] = i; } for i := 0; i \u003c size; i++ { right = max(right, marks[s[i] - 'a']); if i == right { res = append(res, right - left + 1); left = i + 1; } } return res; } func max(a, b int) int { if a \u003c b { a = b; } return a; } ","date":"2022-01-06 08:23:51","objectID":"https://qizhengzou.github.io/algorithm_greedy/:14:0","tags":["data structure"],"title":"Algorithm_greedy","uri":"https://qizhengzou.github.io/algorithm_greedy/"},{"categories":["Coding"],"content":"合并区间 给出一个区间的集合，请合并所有重叠的区间。 func merge(intervals [][]int) [][]int { //先从小到大排序 sort.Slice(intervals,func(i,j int)bool{ return intervals[i][0]\u003cintervals[j][0] }) //再弄重复的 for i:=0;i\u003clen(intervals)-1;i++{ if intervals[i][1]\u003e=intervals[i+1][0]{ intervals[i][1]=max(intervals[i][1],intervals[i+1][1])//赋值最大值 intervals=append(intervals[:i+1],intervals[i+2:]...) i-- } } return intervals } func max(a,b int)int{ if a\u003eb{ return a } return b } ","date":"2022-01-06 08:23:51","objectID":"https://qizhengzou.github.io/algorithm_greedy/:15:0","tags":["data structure"],"title":"Algorithm_greedy","uri":"https://qizhengzou.github.io/algorithm_greedy/"},{"categories":["Coding"],"content":"单调递增的数字 给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增 示例： 输入: N = 332 输出: 299 func monotoneIncreasingDigits(N int) int { s := strconv.Itoa(N)//将数字转为字符串，方便使用下标 ss := []byte(s)//将字符串转为byte数组，方便更改。 n := len(ss) if n \u003c= 1 { return N } for i:=n-1 ; i\u003e0; i-- { if ss[i-1] \u003e ss[i] {//前一个大于后一位,前一位减1，后面的全部置为9 ss[i-1] -= 1 for j := i ; j \u003c n; j++ {//后面的全部置为9 ss[j] = '9' } } } res, _ := strconv.Atoi(string(ss)) return res } ","date":"2022-01-06 08:23:51","objectID":"https://qizhengzou.github.io/algorithm_greedy/:16:0","tags":["data structure"],"title":"Algorithm_greedy","uri":"https://qizhengzou.github.io/algorithm_greedy/"},{"categories":["Coding"],"content":"买卖股票的最佳时机含手续费 给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。 示例 1: 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2 输出: 8 解释: 能够达到的最大利润: 在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8. 贪心或者dp func maxProfit(prices []int, fee int) int { var minBuy int = prices[0] //第一天买入 var res int for i:=0;i\u003clen(prices);i++{ //如果当前价格小于最低价，则在此处买入 if prices[i]\u003cminBuy{ minBuy=prices[i] } //如果以当前价格卖出亏本，则不卖，继续找下一个可卖点 if prices[i]\u003e=minBuy\u0026\u0026prices[i]-fee-minBuy\u003c=0{ continue } //可以售卖了 if prices[i]\u003eminBuy+fee{ //累加每天的收益 res+=prices[i]-minBuy-fee //更新最小值（如果还在收获利润的区间里，表示并不是真正的卖出，而计算利润每次都要减去手续费，所以要让minBuy = prices[i] - fee;，这样在明天收获利润的时候，才不会多减一次手续费！） minBuy=prices[i]-fee } } return res } ","date":"2022-01-06 08:23:51","objectID":"https://qizhengzou.github.io/algorithm_greedy/:17:0","tags":["data structure"],"title":"Algorithm_greedy","uri":"https://qizhengzou.github.io/algorithm_greedy/"},{"categories":["Coding"],"content":"监控二叉树 给定一个二叉树，我们在树的节点上安装摄像头。 节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。 计算监控树的所有节点所需的最小摄像头数量。 const inf = math.MaxInt64 / 2 func minCameraCover(root *TreeNode) int { var dfs func(*TreeNode) (a, b, c int) dfs = func(node *TreeNode) (a, b, c int) { if node == nil { return inf, 0, 0 } lefta, leftb, leftc := dfs(node.Left) righta, rightb, rightc := dfs(node.Right) a = leftc + rightc + 1 b = min(a, min(lefta+rightb, righta+leftb)) c = min(a, leftb+rightb) return } _, ans, _ := dfs(root) return ans } func min(a, b int) int { if a \u003c= b { return a } return b } ","date":"2022-01-06 08:23:51","objectID":"https://qizhengzou.github.io/algorithm_greedy/:18:0","tags":["data structure"],"title":"Algorithm_greedy","uri":"https://qizhengzou.github.io/algorithm_greedy/"},{"categories":["Coding"],"content":" 学习代码随想录笔记 回溯算法 ","date":"2022-01-06 08:22:27","objectID":"https://qizhengzou.github.io/algorithm_backtracking/:0:0","tags":["data structure"],"title":"Algorithm_backTracking","uri":"https://qizhengzou.github.io/algorithm_backtracking/"},{"categories":["Coding"],"content":"理论基础 也叫回溯搜索算法。 回溯是递归的副产品，只要有递归就会有回溯 回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，并不算高效。加一些剪枝操作或许会高效一点。 一般用来解决除了暴力搜索无可奈何的情况。 回溯法，一般可以解决如下几种问题： 组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，有几种排列方式 棋盘问题：N皇后，解数独等等 回溯法解决的问题都可以抽象为树形结构 因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。 回溯模板： void backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } ","date":"2022-01-06 08:22:27","objectID":"https://qizhengzou.github.io/algorithm_backtracking/:1:0","tags":["data structure"],"title":"Algorithm_backTracking","uri":"https://qizhengzou.github.io/algorithm_backtracking/"},{"categories":["Coding"],"content":"组合问题及其优化 给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。 回溯法三部曲：函数参数、终止条件和单层搜索 剪枝优化： 可以剪枝的地方就在递归中每一层的for循环所选择的起始位置。 如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了。 var res [][]int func combine(n int, k int) [][]int { res=[][]int{} if n \u003c= 0 || k \u003c= 0 || k \u003e n { return res } backtrack(n, k, 1, []int{}) return res } func backtrack(n,k,start int,track []int){ if len(track)==k{ temp:=make([]int,k) copy(temp,track) res=append(res,temp) } if len(track)+n-start+1 \u003c k { return } for i:=start;i\u003c=n;i++{ track=append(track,i) backtrack(n,k,i+1,track) track=track[:len(track)-1] } } 剪枝： var res [][]int func combine(n int, k int) [][]int { res=[][]int{} if n \u003c= 0 || k \u003c= 0 || k \u003e n { return res } backtrack(n, k, 1, []int{}) return res } func backtrack(n,k,start int,track []int){ if len(track)==k{ temp:=make([]int,k) copy(temp,track) res=append(res,temp) } if len(track)+n-start+1 \u003c k { return } for i:=start;i\u003c=n;i++{ track=append(track,i) backtrack(n,k,i+1,track) track=track[:len(track)-1] } } ","date":"2022-01-06 08:22:27","objectID":"https://qizhengzou.github.io/algorithm_backtracking/:2:0","tags":["data structure"],"title":"Algorithm_backTracking","uri":"https://qizhengzou.github.io/algorithm_backtracking/"},{"categories":["Coding"],"content":"组合总和III 找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 说明： 所有数字都是正整数。 解集不能包含重复的组合。 回溯+减枝 func combinationSum3(k int, n int) [][]int { var track []int// 遍历路径 var result [][]int// 存放结果集 backTree(n,k,1,\u0026track,\u0026result) return result } func backTree(n,k,startIndex int,track *[]int,result *[][]int){ if len(*track)==k{ var sum int tmp:=make([]int,k) for k,v:=range *track{ sum+=v tmp[k]=v } if sum==n{ *result=append(*result,tmp) } return } for i:=startIndex;i\u003c=9-(k-len(*track))+1;i++{//减枝（k-len(*track)表示还剩多少个可填充的元素） *track=append(*track,i)//记录路径 backTree(n,k,i+1,track,result)//递归 *track=(*track)[:len(*track)-1]//回溯 } } ","date":"2022-01-06 08:22:27","objectID":"https://qizhengzou.github.io/algorithm_backtracking/:3:0","tags":["data structure"],"title":"Algorithm_backTracking","uri":"https://qizhengzou.github.io/algorithm_backtracking/"},{"categories":["Coding"],"content":"电话号码的字母组合 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如电话按键。注意 1 不对应任何字母。 主要在于递归中传递下一个数字 func letterCombinations(digits string) []string { lenth:=len(digits) if lenth==0 ||lenth\u003e4{ return nil } digitsMap:= [10]string{ \"\", // 0 \"\", // 1 \"abc\", // 2 \"def\", // 3 \"ghi\", // 4 \"jkl\", // 5 \"mno\", // 6 \"pqrs\", // 7 \"tuv\", // 8 \"wxyz\", // 9 } res:=make([]string,0) recursion(\"\",digits,0,digitsMap,\u0026res) return res } func recursion(tempString ,digits string, Index int,digitsMap [10]string, res *[]string) {//index表示第几个数字 if len(tempString)==len(digits){//终止条件，字符串长度等于digits的长度 *res=append(*res,tempString) return } tmpK:=digits[Index]-'0' // 将index指向的数字转为int（确定下一个数字） letter:=digitsMap[tmpK]// 取数字对应的字符集 for i:=0;i\u003clen(letter);i++{ tempString=tempString+string(letter[i])//拼接结果 recursion(tempString,digits,Index+1,digitsMap,res) tempString=tempString[:len(tempString)-1]//回溯 } } ","date":"2022-01-06 08:22:27","objectID":"https://qizhengzou.github.io/algorithm_backtracking/:4:0","tags":["data structure"],"title":"Algorithm_backTracking","uri":"https://qizhengzou.github.io/algorithm_backtracking/"},{"categories":["Coding"],"content":"组合总和 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。 主要在于递归中传递下一个数字 func combinationSum(candidates []int, target int) [][]int { var trcak []int var res [][]int backtracking(0,0,target,candidates,trcak,\u0026res) return res } func backtracking(startIndex,sum,target int,candidates,trcak []int,res *[][]int){ //终止条件 if sum==target{ tmp:=make([]int,len(trcak)) copy(tmp,trcak)//拷贝 *res=append(*res,tmp)//放入结果集 return } if sum\u003etarget{return} //回溯 for i:=startIndex;i\u003clen(candidates);i++{ //更新路径集合和sum trcak=append(trcak,candidates[i]) sum+=candidates[i] //递归 backtracking(i,sum,target,candidates,trcak,res) //回溯 trcak=trcak[:len(trcak)-1] sum-=candidates[i] } } ","date":"2022-01-06 08:22:27","objectID":"https://qizhengzou.github.io/algorithm_backtracking/:5:0","tags":["data structure"],"title":"Algorithm_backTracking","uri":"https://qizhengzou.github.io/algorithm_backtracking/"},{"categories":["Coding"],"content":"组合总和II 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 主要在于如何在回溯中去重 使用used数组 func combinationSum2(candidates []int, target int) [][]int { var trcak []int var res [][]int var history map[int]bool history=make(map[int]bool) sort.Ints(candidates) backtracking(0,0,target,candidates,trcak,\u0026res,history) return res } func backtracking(startIndex,sum,target int,candidates,trcak []int,res *[][]int,history map[int]bool){ //终止条件 if sum==target{ tmp:=make([]int,len(trcak)) copy(tmp,trcak)//拷贝 *res=append(*res,tmp)//放入结果集 return } if sum\u003etarget{return} //回溯 // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过 // used[i - 1] == false，说明同一树层candidates[i - 1]使用过 for i:=startIndex;i\u003clen(candidates);i++{ if i\u003e0\u0026\u0026candidates[i]==candidates[i-1]\u0026\u0026history[i-1]==false{ continue } //更新路径集合和sum trcak=append(trcak,candidates[i]) sum+=candidates[i] history[i]=true //递归 backtracking(i+1,sum,target,candidates,trcak,res,history) //回溯 trcak=trcak[:len(trcak)-1] sum-=candidates[i] history[i]=false } } 不使用used数组 func combinationSum2(candidates []int, target int) [][]int { var trcak []int var res [][]int sort.Ints(candidates) backtracking(0,0,target,candidates,trcak,\u0026res) return res } func backtracking(startIndex,sum,target int,candidates,trcak []int,res *[][]int){ //终止条件 if sum==target{ tmp:=make([]int,len(trcak)) //拷贝 copy(tmp,trcak) //放入结果集 *res=append(*res,tmp) return } //回溯 for i:=startIndex;i\u003clen(candidates) \u0026\u0026 sum+candidates[i]\u003c=target;i++{ // 若当前树层有使用过相同的元素，则跳过 if i\u003estartIndex\u0026\u0026candidates[i]==candidates[i-1]{ continue } //更新路径集合和sum trcak=append(trcak,candidates[i]) sum+=candidates[i] backtracking(i+1,sum,target,candidates,trcak,res) //回溯 trcak=trcak[:len(trcak)-1] sum-=candidates[i] } } ","date":"2022-01-06 08:22:27","objectID":"https://qizhengzou.github.io/algorithm_backtracking/:6:0","tags":["data structure"],"title":"Algorithm_backTracking","uri":"https://qizhengzou.github.io/algorithm_backtracking/"},{"categories":["Coding"],"content":"分割回文串 给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 返回 s 所有可能的分割方案。 示例: 输入: \"aab\" 输出: [ [\"aa\",\"b\"], [\"a\",\"a\",\"b\"] ] 注意切片（go切片是披着值类型外衣的引用类型） func partition(s string) [][]string { var tmpString []string//切割字符串集合 var res [][]string//结果集合 backTracking(s,tmpString,0,\u0026res) return res } func backTracking(s string,tmpString []string,startIndex int,res *[][]string){ if startIndex==len(s){//到达字符串末尾了 //进行一次切片拷贝，怕之后的操作影响tmpString切片内的值 t := make([]string, len(tmpString)) copy(t, tmpString) *res=append(*res,t) } for i:=startIndex;i\u003clen(s);i++{ //处理（首先通过startIndex和i判断切割的区间，进而判断该区间的字符串是否为回文，若为回文，则加入到tmpString，否则继续后移，找到回文区间）（这里为一层处理） if isPartition(s,startIndex,i){ tmpString=append(tmpString,s[startIndex:i+1]) }else{ continue } //递归 backTracking(s,tmpString,i+1,res) //回溯 tmpString=tmpString[:len(tmpString)-1] } } //判断是否为回文 func isPartition(s string,startIndex,end int)bool{ left:=startIndex right:=end for ;left\u003cright;{ if s[left]!=s[right]{ return false } //移动左右指针 left++ right-- } return true } ","date":"2022-01-06 08:22:27","objectID":"https://qizhengzou.github.io/algorithm_backtracking/:7:0","tags":["data structure"],"title":"Algorithm_backTracking","uri":"https://qizhengzou.github.io/algorithm_backtracking/"},{"categories":["Coding"],"content":"复原IP地址 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。 例如：“0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、“192.168.1.312” 和 “192.168@1.1” 是 无效的 IP 地址。 示例 1： 输入：s = \"25525511135\" 输出：[\"255.255.11.135\",\"255.255.111.35\"] 示例 2： 输入：s = \"0000\" 输出：[\"0.0.0.0\"] 回溯（对于前导 0的IP（特别注意s[startIndex]=='0'的判断，不应该写成s[startIndex]==0，因为s截取出来不是数字）） func restoreIpAddresses(s string) []string { var res,path []string backTracking(s,path,0,\u0026res) return res } func backTracking(s string,path []string,startIndex int,res *[]string){ //终止条件 if startIndex==len(s)\u0026\u0026len(path)==4{ tmpIpString:=path[0]+\".\"+path[1]+\".\"+path[2]+\".\"+path[3] *res=append(*res,tmpIpString) } for i:=startIndex;i\u003clen(s);i++{ //处理 path:=append(path,s[startIndex:i+1]) if i-startIndex+1\u003c=3\u0026\u0026len(path)\u003c=4\u0026\u0026isNormalIp(s,startIndex,i){ //递归 backTracking(s,path,i+1,res) }else {//如果首尾超过了3个，或路径多余4个，或前导为0，或大于255，直接回退 return } //回溯 path=path[:len(path)-1] } } func isNormalIp(s string,startIndex,end int)bool{ checkInt,_:=strconv.Atoi(s[startIndex:end+1]) if end-startIndex+1\u003e1\u0026\u0026s[startIndex]=='0'{//对于前导 0的IP（特别注意s[startIndex]=='0'的判断，不应该写成s[startIndex]==0，因为s截取出来不是数字） return false } if checkInt\u003e255{ return false } return true } ","date":"2022-01-06 08:22:27","objectID":"https://qizhengzou.github.io/algorithm_backtracking/:8:0","tags":["data structure"],"title":"Algorithm_backTracking","uri":"https://qizhengzou.github.io/algorithm_backtracking/"},{"categories":["Coding"],"content":"子集问题 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 var res [][]int func subset(nums []int) [][]int { res = make([][]int, 0) sort.Ints(nums) Dfs([]int{}, nums, 0) return res } func Dfs(temp, nums []int, start int){ tmp := make([]int, len(temp)) copy(tmp, temp) res = append(res, tmp) for i := start; i \u003c len(nums); i++{ //if i\u003estart\u0026\u0026nums[i]==nums[i-1]{ // continue //} temp = append(temp, nums[i]) Dfs(temp, nums, i+1) temp = temp[:len(temp)-1] } } ","date":"2022-01-06 08:22:27","objectID":"https://qizhengzou.github.io/algorithm_backtracking/:9:0","tags":["data structure"],"title":"Algorithm_backTracking","uri":"https://qizhengzou.github.io/algorithm_backtracking/"},{"categories":["Coding"],"content":"子集II 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 var res[][]int func subsetsWithDup(nums []int)[][]int { res=make([][]int,0) sort.Ints(nums) dfs([]int{},nums,0) return res } func dfs(temp, num []int, start int) { tmp:=make([]int,len(temp)) copy(tmp,temp) res=append(res,tmp) for i:=start;i\u003clen(num);i++{ if i\u003estart\u0026\u0026num[i]==num[i-1]{ continue } temp=append(temp,num[i]) dfs(temp,num,i+1) temp=temp[:len(temp)-1] } } ","date":"2022-01-06 08:22:27","objectID":"https://qizhengzou.github.io/algorithm_backtracking/:10:0","tags":["data structure"],"title":"Algorithm_backTracking","uri":"https://qizhengzou.github.io/algorithm_backtracking/"},{"categories":["Coding"],"content":"递增子序列 给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况 func findSubsequences(nums []int) [][]int { var subRes []int var res [][]int backTring(0,nums,subRes,\u0026res) return res } func backTring(startIndex int,nums,subRes []int,res *[][]int){ if len(subRes)\u003e1{ tmp:=make([]int,len(subRes)) copy(tmp,subRes) *res=append(*res,tmp) } history:=[201]int{}//记录本层元素使用记录 for i:=startIndex;i\u003clen(nums);i++{ //分两种情况判断：一，当前取的元素小于子集的最后一个元素，则继续寻找下一个适合的元素 // 或者二，当前取的元素在本层已经出现过了，所以跳过该元素，继续寻找 if len(subRes)\u003e0\u0026\u0026nums[i]\u003csubRes[len(subRes)-1]||history[nums[i] + 100]==1{ continue } history[nums[i] + 100]=1//表示本层该元素使用过了 subRes=append(subRes,nums[i]) backTring(i+1,nums,subRes,res) subRes=subRes[:len(subRes)-1] } } ","date":"2022-01-06 08:22:27","objectID":"https://qizhengzou.github.io/algorithm_backtracking/:11:0","tags":["data structure"],"title":"Algorithm_backTracking","uri":"https://qizhengzou.github.io/algorithm_backtracking/"},{"categories":["Coding"],"content":"全排列 给定一个 没有重复 数字的序列，返回其所有可能的全排列。 var res [][]int func permute(nums []int) [][]int { res = [][]int{} backTrack(nums,len(nums),[]int{}) return res } func backTrack(nums []int,numsLen int,path []int) { if len(nums)==0{ p:=make([]int,len(path)) copy(p,path) res = append(res,p) } for i:=0;i\u003cnumsLen;i++{ cur:=nums[i] path = append(path,cur) nums = append(nums[:i],nums[i+1:]...)//直接使用切片 backTrack(nums,len(nums),path) nums = append(nums[:i],append([]int{cur},nums[i:]...)...)//回溯的时候切片也要复原，元素位置不能变 path = path[:len(path)-1] } } ","date":"2022-01-06 08:22:27","objectID":"https://qizhengzou.github.io/algorithm_backtracking/:12:0","tags":["data structure"],"title":"Algorithm_backTracking","uri":"https://qizhengzou.github.io/algorithm_backtracking/"},{"categories":["Coding"],"content":"全排列II 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。 var res [][]int func permute(nums []int) [][]int { res = [][]int{} backTrack(nums,len(nums),[]int{}) return res } func backTrack(nums []int,numsLen int,path []int) { if len(nums)==0{ p:=make([]int,len(path)) copy(p,path) res = append(res,p) } used := [21]int{}//跟前一题唯一的区别，同一层不使用重复的数。关于used的思想carl在递增子序列那一题中提到过 for i:=0;i\u003cnumsLen;i++{ if used[nums[i]+10]==1{ continue } cur:=nums[i] path = append(path,cur) used[nums[i]+10]=1 nums = append(nums[:i],nums[i+1:]...) backTrack(nums,len(nums),path) nums = append(nums[:i],append([]int{cur},nums[i:]...)...) path = path[:len(path)-1] } } ","date":"2022-01-06 08:22:27","objectID":"https://qizhengzou.github.io/algorithm_backtracking/:13:0","tags":["data structure"],"title":"Algorithm_backTracking","uri":"https://qizhengzou.github.io/algorithm_backtracking/"},{"categories":["Coding"],"content":"回溯算法去重问题的另一种写法 https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%8E%BB%E9%87%8D%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95.html#_90-%E5%AD%90%E9%9B%86ii 看c++版的 ","date":"2022-01-06 08:22:27","objectID":"https://qizhengzou.github.io/algorithm_backtracking/:14:0","tags":["data structure"],"title":"Algorithm_backTracking","uri":"https://qizhengzou.github.io/algorithm_backtracking/"},{"categories":["Coding"],"content":"重新安排行程 深搜和回溯也是相辅相成的，都用了递归。 给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。 提示： 如果存在多种有效的行程，请你按字符自然排序返回最小的行程组合。例如，行程 [“JFK”, “LGA”] 与 [“JFK”, “LGB”] 相比就更小，排序更靠前 所有的机场都用三个大写字母表示（机场代码）。 假定所有机票至少存在一种合理的行程。 所有的机票必须都用一次 且 只能用一次。 示例 1： 输入：[[\"MUC\", \"LHR\"], [\"JFK\", \"MUC\"], [\"SFO\", \"SJC\"], [\"LHR\", \"SFO\"]] 输出：[\"JFK\", \"MUC\", \"LHR\", \"SFO\", \"SJC\"] 示例 2： 输入：[[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]] 输出：[\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"] 解释：另一种有效的行程是 [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"]。但是它自然排序更大更靠后 class Solution { private: // unordered_map\u003c出发机场, map\u003c到达机场, 航班次数\u003e\u003e targets unordered_map\u003cstring, map\u003cstring, int\u003e\u003e targets; bool backtracking(int ticketNum, vector\u003cstring\u003e\u0026 result) { if (result.size() == ticketNum + 1) { return true; } for (pair\u003cconst string, int\u003e\u0026 target : targets[result[result.size() - 1]]) { if (target.second \u003e 0 ) { // 记录到达机场是否飞过了 result.push_back(target.first); target.second--; if (backtracking(ticketNum, result)) return true; result.pop_back(); target.second++; } } return false; } public: vector\u003cstring\u003e findItinerary(vector\u003cvector\u003cstring\u003e\u003e\u0026 tickets) { targets.clear(); vector\u003cstring\u003e result; for (const vector\u003cstring\u003e\u0026 vec : tickets) { targets[vec[0]][vec[1]]++; // 记录映射关系 } result.push_back(\"JFK\"); // 起始机场 backtracking(tickets.size(), result); return result; } }; ","date":"2022-01-06 08:22:27","objectID":"https://qizhengzou.github.io/algorithm_backtracking/:15:0","tags":["data structure"],"title":"Algorithm_backTracking","uri":"https://qizhengzou.github.io/algorithm_backtracking/"},{"categories":["Coding"],"content":"N皇后 n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 import \"strings\" var res [][]string func isValid(board [][]string, row, col int) (res bool){ n := len(board) for i:=0; i \u003c row; i++ { if board[i][col] == \"Q\" { return false } } for i := 0; i \u003c n; i++{ if board[row][i] == \"Q\" { return false } } for i ,j := row, col; i \u003e= 0 \u0026\u0026 j \u003e=0 ; i, j = i - 1, j- 1{ if board[i][j] == \"Q\"{ return false } } for i, j := row, col; i \u003e=0 \u0026\u0026 j \u003c n; i,j = i-1, j+1 { if board[i][j] == \"Q\" { return false } } return true } func backtrack(board [][]string, row int) { size := len(board) if row == size{ temp := make([]string, size) for i := 0; i\u003csize;i++{ temp[i] = strings.Join(board[i],\"\") } res =append(res,temp) return } for col := 0; col \u003c size; col++ { if !isValid(board, row, col){ continue } board[row][col] = \"Q\" backtrack(board, row+1) board[row][col] = \".\" } } func solveNQueens(n int) [][]string { res = [][]string{} board := make([][]string, n) for i := 0; i \u003c n; i++{ board[i] = make([]string, n) } for i := 0; i \u003c n; i++{ for j := 0; j\u003cn;j++{ board[i][j] = \".\" } } backtrack(board, 0) return res } ","date":"2022-01-06 08:22:27","objectID":"https://qizhengzou.github.io/algorithm_backtracking/:16:0","tags":["data structure"],"title":"Algorithm_backTracking","uri":"https://qizhengzou.github.io/algorithm_backtracking/"},{"categories":["Coding"],"content":"解数独 编写一个程序，通过填充空格来解决数独问题。 func solveSudoku(board [][]byte) { var backtracking func(board [][]byte) bool backtracking=func(board [][]byte) bool{ for i:=0;i\u003c9;i++{ for j:=0;j\u003c9;j++{ //判断此位置是否适合填数字 if board[i][j]!='.'{ continue } //尝试填1-9 for k:='1';k\u003c='9';k++{ if isvalid(i,j,byte(k),board)==true{//如果满足要求就填 board[i][j]=byte(k) if backtracking(board)==true{ return true } board[i][j]='.' } } return false } } return true } backtracking(board) } //判断填入数字是否满足要求 func isvalid(row,col int,k byte,board [][]byte)bool{ for i:=0;i\u003c9;i++{//行 if board[row][i]==k{ return false } } for i:=0;i\u003c9;i++{//列 if board[i][col]==k{ return false } } //方格 startrow:=(row/3)*3 startcol:=(col/3)*3 for i:=startrow;i\u003cstartrow+3;i++{ for j:=startcol;j\u003cstartcol+3;j++{ if board[i][j]==k{ return false } } } return true } ","date":"2022-01-06 08:22:27","objectID":"https://qizhengzou.github.io/algorithm_backtracking/:17:0","tags":["data structure"],"title":"Algorithm_backTracking","uri":"https://qizhengzou.github.io/algorithm_backtracking/"},{"categories":["Coding"],"content":" 学习代码随想录笔记 二叉树 ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:0:0","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"理论基础 一般主要会碰到满二叉树以及完全二叉树。 完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^h -1 个节点。 优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。 二叉搜索树： 与前面两个树不同，该树有节点权值。 有序树，左节点 \u003c 中节点 \u003c 右节点 平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 二叉树可以链式存储，也可以顺序存储。 深度优先遍历 前序遍历（递归法，迭代法） 中序遍历（递归法，迭代法） 后序遍历（递归法，迭代法） 广度优先遍历 层次遍历（迭代法） type TreeNode struct { Val int Left *TreeNode Right *TreeNode } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:1:0","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"递归遍历 递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。 写递归还是得有方法论。 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。 确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。 前序遍历： func preorderTraversal(root *TreeNode) (res []int) { var traversal func(node *TreeNode) traversal = func(node *TreeNode) { if node == nil { return } res = append(res,node.Val) traversal(node.Left) traversal(node.Right) } traversal(root) return res } 中序遍历： func inorderTraversal(root *TreeNode) (res []int) { var traversal func(node *TreeNode) traversal = func(node *TreeNode) { if node == nil { return } traversal(node.Left) res = append(res,node.Val) traversal(node.Right) } traversal(root) return res } 后序遍历: func postorderTraversal(root *TreeNode) (res []int) { var traversal func(node *TreeNode) traversal = func(node *TreeNode) { if node == nil { return } traversal(node.Left) traversal(node.Right) res = append(res,node.Val) } traversal(root) return res } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:2:0","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"迭代遍历 迭代法前序遍历 func preorderTraversal(root *TreeNode) []int { ans := []int{} if root == nil { return ans } st := list.New() st.PushBack(root) for st.Len() \u003e 0 { node := st.Remove(st.Back()).(*TreeNode) ans = append(ans, node.Val) if node.Right != nil { st.PushBack(node.Right) } if node.Left != nil { st.PushBack(node.Left) } } return ans } 迭代法后序遍历 func postorderTraversal(root *TreeNode) []int { ans := []int{} if root == nil { return ans } st := list.New() st.PushBack(root) for st.Len() \u003e 0 { node := st.Remove(st.Back()).(*TreeNode) ans = append(ans, node.Val) if node.Left != nil { st.PushBack(node.Left) } if node.Right != nil { st.PushBack(node.Right) } } reverse(ans) return ans } func reverse(a []int) { l, r := 0, len(a) - 1 for l \u003c r { a[l], a[r] = a[r], a[l] l, r = l+1, r-1 } } 迭代法中序遍历 func inorderTraversal(root *TreeNode) []int { ans := []int{} if root == nil { return ans } st := list.New() cur := root for cur != nil || st.Len() \u003e 0 { if cur != nil { st.PushBack(cur) cur = cur.Left } else { cur = st.Remove(st.Back()).(*TreeNode) ans = append(ans, cur.Val) cur = cur.Right } } return ans } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:3:0","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"统一迭代 迭代法实现的先中后序，其实风格也不是那么统一，除了先序和后序，有关联，中序完全就是另一个风格了，一会用栈遍历，一会又用指针来遍历。 使用迭代法实现先中后序遍历，很难写出统一的代码，不像是递归法，实现了其中的一种遍历方式，其他两种只要稍稍改一下节点顺序就可以了。 要处理的节点放入栈之后，紧接着放入一个空指针作为标记。 这种方法也可以叫做标记法 前序遍历统一迭代法 /** type Element struct { // 元素保管的值 Value interface{} // 内含隐藏或非导出字段 } func (l *List) Back() *Element 前序遍历：中左右 压栈顺序：右左中 **/ func preorderTraversal(root *TreeNode) []int { if root == nil { return nil } var stack = list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u003e0{ e := stack.Back() stack.Remove(e)//弹出元素 if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：右左中 if node.Right!=nil{ stack.PushBack(node.Right) } if node.Left!=nil{ stack.PushBack(node.Left) } stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) } return res } 中序遍历统一迭代法 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ //中序遍历：左中右 //压栈顺序：右中左 func inorderTraversal(root *TreeNode) []int { if root==nil{ return nil } stack:=list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u003e0{ e := stack.Back() stack.Remove(e) if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：右中左 if node.Right!=nil{ stack.PushBack(node.Right) } stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) if node.Left!=nil{ stack.PushBack(node.Left) } } return res } 后序遍历统一迭代法 //后续遍历：左右中 //压栈顺序：中右左 func postorderTraversal(root *TreeNode) []int { if root == nil { return nil } var stack = list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u003e0{ e := stack.Back() stack.Remove(e) if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：中右左 stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) if node.Right!=nil{ stack.PushBack(node.Right) } if node.Left!=nil{ stack.PushBack(node.Left) } } return res } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:4:0","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"层序遍历 ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:5:0","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"102.二叉树的层序遍历 https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ /** 102. 二叉树的层序遍历 */ func levelOrder(root *TreeNode) [][]int { res:=[][]int{} if root==nil{//防止为空 return res } queue:=list.New() queue.PushBack(root) var tmpArr []int for queue.Len()\u003e0 { length:=queue.Len()//保存当前层的长度，然后处理当前层（十分重要，防止添加下层元素影响判断层中元素的个数） for i:=0;i\u003clength;i++{ node:=queue.Remove(queue.Front()).(*TreeNode)//出队列 if node.Left!=nil{ queue.PushBack(node.Left) } if node.Right!=nil{ queue.PushBack(node.Right) } tmpArr=append(tmpArr,node.Val)//将值加入本层切片中 } res=append(res,tmpArr)//放入结果集 tmpArr=[]int{}//清空层的数据 } return res } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:5:1","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"107.二叉树的层次遍历II https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/ /** 107. 二叉树的层序遍历 II */ func levelOrderBottom(root *TreeNode) [][]int { queue:=list.New() res:=[][]int{} if root==nil{ return res } queue.PushBack(root) for queue.Len()\u003e0{ length:=queue.Len() tmp:=[]int{} for i:=0;i\u003clength;i++{ node:=queue.Remove(queue.Front()).(*TreeNode) if node.Left!=nil{ queue.PushBack(node.Left) } if node.Right!=nil{ queue.PushBack(node.Right) } tmp=append(tmp,node.Val) } res=append(res,tmp) } //反转结果集 for i:=0;i\u003clen(res)/2;i++{ res[i],res[len(res)-i-1]=res[len(res)-i-1],res[i] } return res } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:5:2","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"199.二叉树的右视图 https://leetcode-cn.com/problems/binary-tree-right-side-view/ func rightSideView(root *TreeNode) []int { queue:=list.New() res:=[][]int{} var finaRes []int if root==nil{ return finaRes } queue.PushBack(root) for queue.Len()\u003e0{ length:=queue.Len() tmp:=[]int{} for i:=0;i\u003clength;i++{ node:=queue.Remove(queue.Front()).(*TreeNode) if node.Left!=nil{ queue.PushBack(node.Left) } if node.Right!=nil{ queue.PushBack(node.Right) } tmp=append(tmp,node.Val) } res=append(res,tmp) } //取每一层的最后一个元素 for i:=0;i\u003clen(res);i++{ finaRes=append(finaRes,res[i][len(res[i])-1]) } return finaRes } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:5:3","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"637.二叉树的层平均值 https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/ /** 637. 二叉树的层平均值 */ func averageOfLevels(root *TreeNode) []float64 { res:=[][]int{} var finRes []float64 if root==nil{//防止为空 return finRes } queue:=list.New() queue.PushBack(root) var tmpArr []int for queue.Len()\u003e0 { length:=queue.Len()//保存当前层的长度，然后处理当前层（十分重要，防止添加下层元素影响判断层中元素的个数） for i:=0;i\u003clength;i++{ node:=queue.Remove(queue.Front()).(*TreeNode)//出队列 if node.Left!=nil{ queue.PushBack(node.Left) } if node.Right!=nil{ queue.PushBack(node.Right) } tmpArr=append(tmpArr,node.Val)//将值加入本层切片中 } res=append(res,tmpArr)//放入结果集 tmpArr=[]int{}//清空层的数据 } //计算每层的平均值 length:=len(res) for i:=0;i\u003clength;i++{ var sum int for j:=0;j\u003clen(res[i]);j++{ sum+=res[i][j] } tmp:=float64(sum)/float64(len(res[i])) finRes=append(finRes,tmp)//将平均值放入结果集合 } return finRes } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:5:4","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"429.N叉树的层序遍历 https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/ func levelOrder(root *Node) [][]int { queue:=list.New() res:=[][]int{}//结果集 if root==nil{ return res } queue.PushBack(root) for queue.Len()\u003e0{ length:=queue.Len()//记录当前层的数量 var tmp []int for T:=0;T\u003clength;T++{//该层的每个元素：一添加到该层的结果集中；二找到该元素的下层元素加入到队列中，方便下次使用 myNode:=queue.Remove(queue.Front()).(*Node) tmp=append(tmp,myNode.Val) for i:=0;i\u003clen(myNode.Children);i++{ queue.PushBack(myNode.Children[i]) } } res=append(res,tmp) } return res } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:5:5","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"515.在每个树行中找最大值 https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/ /** 515. 在每个树行中找最大值 */ func largestValues(root *TreeNode) []int { res:=[][]int{} var finRes []int if root==nil{//防止为空 return finRes } queue:=list.New() queue.PushBack(root) var tmpArr []int //层次遍历 for queue.Len()\u003e0 { length:=queue.Len()//保存当前层的长度，然后处理当前层（十分重要，防止添加下层元素影响判断层中元素的个数） for i:=0;i\u003clength;i++{ node:=queue.Remove(queue.Front()).(*TreeNode)//出队列 if node.Left!=nil{ queue.PushBack(node.Left) } if node.Right!=nil{ queue.PushBack(node.Right) } tmpArr=append(tmpArr,node.Val)//将值加入本层切片中 } res=append(res,tmpArr)//放入结果集 tmpArr=[]int{}//清空层的数据 } //找到每层的最大值 for i:=0;i\u003clen(res);i++{ finRes=append(finRes,max(res[i]...)) } return finRes } func max(vals...int) int { max:=int(math.Inf(-1))//负无穷 for _, val := range vals { if val \u003e max { max = val } } return max } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:5:6","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"116.填充每个节点的下一个右侧节点指针 https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/ /** 116. 填充每个节点的下一个右侧节点指针 117. 填充每个节点的下一个右侧节点指针 II */ func connect(root *Node) *Node { res:=[][]*Node{} if root==nil{//防止为空 return root } queue:=list.New() queue.PushBack(root) var tmpArr []*Node for queue.Len()\u003e0 { length:=queue.Len()//保存当前层的长度，然后处理当前层（十分重要，防止添加下层元素影响判断层中元素的个数） for i:=0;i\u003clength;i++{ node:=queue.Remove(queue.Front()).(*Node)//出队列 if node.Left!=nil{ queue.PushBack(node.Left) } if node.Right!=nil{ queue.PushBack(node.Right) } tmpArr=append(tmpArr,node)//将值加入本层切片中 } res=append(res,tmpArr)//放入结果集 tmpArr=[]*Node{}//清空层的数据 } //遍历每层元素,指定next for i:=0;i\u003clen(res);i++{ for j:=0;j\u003clen(res[i])-1;j++{ res[i][j].Next=res[i][j+1] } } return root } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:5:7","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"117.填充每个节点的下一个右侧节点指针II https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/ /** 116. 填充每个节点的下一个右侧节点指针 117. 填充每个节点的下一个右侧节点指针 II */ func connect(root *Node) *Node { res:=[][]*Node{} if root==nil{//防止为空 return root } queue:=list.New() queue.PushBack(root) var tmpArr []*Node for queue.Len()\u003e0 { length:=queue.Len()//保存当前层的长度，然后处理当前层（十分重要，防止添加下层元素影响判断层中元素的个数） for i:=0;i\u003clength;i++{ node:=queue.Remove(queue.Front()).(*Node)//出队列 if node.Left!=nil{ queue.PushBack(node.Left) } if node.Right!=nil{ queue.PushBack(node.Right) } tmpArr=append(tmpArr,node)//将值加入本层切片中 } res=append(res,tmpArr)//放入结果集 tmpArr=[]*Node{}//清空层的数据 } //遍历每层元素,指定next for i:=0;i\u003clen(res);i++{ for j:=0;j\u003clen(res[i])-1;j++{ res[i][j].Next=res[i][j+1] } } return root } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:5:8","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"104.二叉树的最大深度 https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/ /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func maxDepth(root *TreeNode) int { ans:=0 if root==nil{ return 0 } queue:=list.New() queue.PushBack(root) for queue.Len()\u003e0{ length:=queue.Len() for i:=0;i\u003clength;i++{ node:=queue.Remove(queue.Front()).(*TreeNode) if node.Left!=nil{ queue.PushBack(node.Left) } if node.Right!=nil{ queue.PushBack(node.Right) } } ans++//记录深度，其他的是层序遍历的板子 } return ans } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:5:9","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"111.二叉树的最小深度 https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/ /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func minDepth(root *TreeNode) int { ans:=0 if root==nil{ return 0 } queue:=list.New() queue.PushBack(root) for queue.Len()\u003e0{ length:=queue.Len() for i:=0;i\u003clength;i++{ node:=queue.Remove(queue.Front()).(*TreeNode) if node.Left==nil\u0026\u0026node.Right==nil{//当前节点没有左右节点，则代表此层是最小层 return ans+1//返回当前层 ans代表是上一层 } if node.Left!=nil{ queue.PushBack(node.Left) } if node.Right!=nil{ queue.PushBack(node.Right) } } ans++//记录层数 } return ans+1 } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:5:10","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"翻转二叉树 二叉树，当然是左右翻转。 递归版本的前序遍历 func invertTree(root *TreeNode) *TreeNode { if root ==nil{ return nil } temp:=root.Left root.Left=root.Right root.Right=temp invertTree(root.Left) invertTree(root.Right) return root } 递归版本的后序遍历 func invertTree(root *TreeNode) *TreeNode { if root==nil{ return root } invertTree(root.Left)//遍历左节点 invertTree(root.Right)//遍历右节点 root.Left,root.Right=root.Right,root.Left//交换 return root } 迭代版本的前序遍历 func invertTree(root *TreeNode) *TreeNode { stack:=[]*TreeNode{} node:=root for node!=nil||len(stack)\u003e0{ for node!=nil{ node.Left,node.Right=node.Right,node.Left//交换 stack=append(stack,node) node=node.Left } node=stack[len(stack)-1] stack=stack[:len(stack)-1] node=node.Right } return root } 迭代版本的后序遍历 func invertTree(root *TreeNode) *TreeNode { stack:=[]*TreeNode{} node:=root var prev *TreeNode for node!=nil||len(stack)\u003e0{ for node!=nil{ stack=append(stack,node) node=node.Left } node=stack[len(stack)-1] stack=stack[:len(stack)-1] if node.Right==nil||node.Right==prev{ node.Left,node.Right=node.Right,node.Left//交换 prev=node node=nil }else { stack=append(stack,node) node=node.Right } } return root } 层序遍历 func invertTree(root *TreeNode) *TreeNode { if root==nil{ return root } queue:=list.New() node:=root queue.PushBack(node) for queue.Len()\u003e0{ length:=queue.Len() for i:=0;i\u003clength;i++{ e:=queue.Remove(queue.Front()).(*TreeNode) e.Left,e.Right=e.Right,e.Left//交换 if e.Left!=nil{ queue.PushBack(e.Left) } if e.Right!=nil{ queue.PushBack(e.Right) } } } return root } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:6:0","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"对称二叉树 检查二叉树是否镜像对称。 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 递归 func defs(left *TreeNode, right *TreeNode) bool { if left == nil \u0026\u0026 right == nil { return true; }; if left == nil || right == nil { return false; }; if left.Val != right.Val { return false; } return defs(left.Left, right.Right) \u0026\u0026 defs(right.Left, left.Right); } func isSymmetric(root *TreeNode) bool { return defs(root.Left, root.Right); } // 迭代 func isSymmetric(root *TreeNode) bool { var queue []*TreeNode; if root != nil { queue = append(queue, root.Left, root.Right); } for len(queue) \u003e 0 { left := queue[0]; right := queue[1]; queue = queue[2:]; if left == nil \u0026\u0026 right == nil { continue; } if left == nil || right == nil || left.Val != right.Val { return false; }; queue = append(queue, left.Left, right.Right, right.Left, left.Right); } return true; } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:7:0","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"最大深度 /** * definition for a binary tree node. * type treenode struct { * val int * left *treenode * right *treenode * } */ func max (a, b int) int { if a \u003e b { return a; } return b; } // 递归 func maxdepth(root *treenode) int { if root == nil { return 0; } return max(maxdepth(root.left), maxdepth(root.right)) + 1; } // 遍历 func maxdepth(root *treenode) int { levl := 0; queue := make([]*treenode, 0); if root != nil { queue = append(queue, root); } for l := len(queue); l \u003e 0; { for ;l \u003e 0;l-- { node := queue[0]; if node.left != nil { queue = append(queue, node.left); } if node.right != nil { queue = append(queue, node.right); } queue = queue[1:]; } levl++; l = len(queue); } return levl; } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:8:0","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"最小深度 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func min(a, b int) int { if a \u003c b { return a; } return b; } // 递归 func minDepth(root *TreeNode) int { if root == nil { return 0; } if root.Left == nil \u0026\u0026 root.Right != nil { return 1 + minDepth(root.Right); } if root.Right == nil \u0026\u0026 root.Left != nil { return 1 + minDepth(root.Left); } return min(minDepth(root.Left), minDepth(root.Right)) + 1; } // 迭代 func minDepth(root *TreeNode) int { dep := 0; queue := make([]*TreeNode, 0); if root != nil { queue = append(queue, root); } for l := len(queue); l \u003e 0; { dep++; for ; l \u003e 0; l-- { node := queue[0]; if node.Left == nil \u0026\u0026 node.Right == nil { return dep; } if node.Left != nil { queue = append(queue, node.Left); } if node.Right != nil { queue = append(queue, node.Right); } queue = queue[1:]; } l = len(queue); } return dep; } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:9:0","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"完全二叉树的节点个数 递归版本 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ //本题直接就是求有多少个节点，无脑存进数组算长度就行了。 func countNodes(root *TreeNode) int { if root == nil { return 0 } res := 1 if root.Right != nil { res += countNodes(root.Right) } if root.Left != nil { res += countNodes(root.Left) } return res } 利用完全二叉树特性的递归解法 func countNodes(root *TreeNode) int { if root == nil { return 0 } leftH, rightH := 0, 0 leftNode := root.Left rightNode := root.Right for leftNode != nil { leftNode = leftNode.Left leftH++ } for rightNode != nil { rightNode = rightNode.Right rightH++ } if leftH == rightH { return (2 \u003c\u003c leftH) - 1 } return countNodes(root.Left) + countNodes(root.Right) + 1 } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:10:0","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"平衡二叉树 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 func isBalanced(root *TreeNode) bool { if root==nil{ return true } if !isBalanced(root.Left) || !isBalanced(root.Right){ return false } LeftH:=maxdepth(root.Left)+1 RightH:=maxdepth(root.Right)+1 if abs(LeftH-RightH)\u003e1{ return false } return true } func maxdepth(root *TreeNode)int{ if root==nil{ return 0 } return max(maxdepth(root.Left),maxdepth(root.Right))+1 } func max(a,b int)int{ if a\u003eb{ return a } return b } func abs(a int)int{ if a\u003c0{ return -a } return a } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:11:0","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"二叉树的所有路径 递归法： func binaryTreePaths(root *TreeNode) []string { res := make([]string, 0) var travel func(node *TreeNode, s string) travel = func(node *TreeNode, s string) { if node.Left == nil \u0026\u0026 node.Right == nil { v := s + strconv.Itoa(node.Val) res = append(res, v) return } s = s + strconv.Itoa(node.Val) + \"-\u003e\" if node.Left != nil { travel(node.Left, s) } if node.Right != nil { travel(node.Right, s) } } travel(root, \"\") return res } 迭代法： func binaryTreePaths(root *TreeNode) []string { stack := []*TreeNode{} paths := make([]string, 0) res := make([]string, 0) if root != nil { stack = append(stack, root) paths = append(paths, \"\") } for len(stack) \u003e 0 { l := len(stack) node := stack[l-1] path := paths[l-1] stack = stack[:l-1] paths = paths[:l-1] if node.Left == nil \u0026\u0026 node.Right == nil { res = append(res, path+strconv.Itoa(node.Val)) continue } if node.Right != nil { stack = append(stack, node.Right) paths = append(paths, path+strconv.Itoa(node.Val)+\"-\u003e\") } if node.Left != nil { stack = append(stack, node.Left) paths = append(paths, path+strconv.Itoa(node.Val)+\"-\u003e\") } } return res } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:12:0","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"二叉树的递归+回溯 100.相同的树 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isSameTree(p *TreeNode, q *TreeNode) bool { switch { case p == nil \u0026\u0026 q == nil: return true case p == nil || q == nil: fallthrough case p.Val != q.Val: return false } return isSameTree(p.Left, q.Left) \u0026\u0026 isSameTree(p.Right, q.Right) } 257.二叉的所有路径 递归法 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func binaryTreePaths(root *TreeNode) []string { var result []string traversal(root,\u0026result,\"\") return result } func traversal(root *TreeNode,result *[]string,pathStr string){ //判断是否为第一个元素 if len(pathStr)!=0{ pathStr=pathStr+\"-\u003e\"+strconv.Itoa(root.Val) }else{ pathStr=strconv.Itoa(root.Val) } //判断是否为叶子节点 if root.Left==nil\u0026\u0026root.Right==nil{ *result=append(*result,pathStr) return } //左右 if root.Left!=nil{ traversal(root.Left,result,pathStr) } if root.Right!=nil{ traversal(root.Right,result,pathStr) } } 回溯法 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func binaryTreePaths(root *TreeNode) []string { var result []string var path []int traversal(root,\u0026result,\u0026path) return result } func traversal(root *TreeNode,result *[]string,path *[]int){ *path=append(*path,root.Val) //判断是否为叶子节点 if root.Left==nil\u0026\u0026root.Right==nil{ pathStr:=strconv.Itoa((*path)[0]) for i:=1;i\u003clen(*path);i++{ pathStr=pathStr+\"-\u003e\"+strconv.Itoa((*path)[i]) } *result=append(*result,pathStr) return } //左右 if root.Left!=nil{ traversal(root.Left,result,path) *path=(*path)[:len(*path)-1]//回溯到上一个节点（因为traversal会加下一个节点值到path中） } if root.Right!=nil{ traversal(root.Right,result,path) *path=(*path)[:len(*path)-1]//回溯 } } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:13:0","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"左叶子之和 递归法 func sumOfLeftLeaves(root *TreeNode) int { var res int findLeft(root,\u0026res) return res } func findLeft(root *TreeNode,res *int){ //左节点 if root.Left!=nil\u0026\u0026root.Left.Left==nil\u0026\u0026root.Left.Right==nil{ *res=*res+root.Left.Val } if root.Left!=nil{ findLeft(root.Left,res) } if root.Right!=nil{ findLeft(root.Right,res) } } 迭代法 func sumOfLeftLeaves(root *TreeNode) int { var res int queue:=list.New() queue.PushBack(root) for queue.Len()\u003e0{ length:=queue.Len() for i:=0;i\u003clength;i++{ node:=queue.Remove(queue.Front()).(*TreeNode) if node.Left!=nil\u0026\u0026node.Left.Left==nil\u0026\u0026node.Left.Right==nil{ res=res+node.Left.Val } if node.Left!=nil{ queue.PushBack(node.Left) } if node.Right!=nil{ queue.PushBack(node.Right) } } } return res } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:14:0","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"找树左下角的值 给定一个二叉树，在树的最后一行找到最左边的值。 递归法： var maxDeep int // 全局变量 深度 var value int //全局变量 最终值 func findBottomLeftValue(root *TreeNode) int { if root.Left==nil\u0026\u0026root.Right==nil{//需要提前判断一下（不要这个if的话提交结果会出错，但执行代码不会。防止这种情况出现，故先判断是否只有一个节点） return root.Val } findLeftValue (root,maxDeep) return value } func findLeftValue (root *TreeNode,deep int){ //最左边的值在左边 if root.Left==nil\u0026\u0026root.Right==nil{ if deep\u003emaxDeep{ value=root.Val maxDeep=deep } } //递归 if root.Left!=nil{ deep++ findLeftValue(root.Left,deep) deep--//回溯 } if root.Right!=nil{ deep++ findLeftValue(root.Right,deep) deep--//回溯 } } 迭代法： func findBottomLeftValue(root *TreeNode) int { queue:=list.New() var gradation int queue.PushBack(root) for queue.Len()\u003e0{ length:=queue.Len() for i:=0;i\u003clength;i++{ node:=queue.Remove(queue.Front()).(*TreeNode) if i==0{gradation=node.Val} if node.Left!=nil{ queue.PushBack(node.Left) } if node.Right!=nil{ queue.PushBack(node.Right) } } } return gradation } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:15:0","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"路径总和 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和 路径总和 //递归法 /** * definition for a binary tree node. * type treenode struct { * val int * left *treenode * right *treenode * } */ func haspathsum(root *treenode, targetsum int) bool { var flage bool //找没找到的标志 if root==nil{ return flage } pathsum(root,0,targetsum,\u0026flage) return flage } func pathsum(root *treenode, sum int,targetsum int,flage *bool){ sum+=root.val if root.left==nil\u0026\u0026root.right==nil\u0026\u0026sum==targetsum{ *flage=true return } if root.left!=nil\u0026\u0026!(*flage){//左节点不为空且还没找到 pathsum(root.left,sum,targetsum,flage) } if root.right!=nil\u0026\u0026!(*flage){//右节点不为空且没找到 pathsum(root.right,sum,targetsum,flage) } } 113 递归法 /** * definition for a binary tree node. * type treenode struct { * val int * left *treenode * right *treenode * } */ func pathsum(root *treenode, targetsum int) [][]int { var result [][]int//最终结果 if root==nil{ return result } var sumnodes []int//经过路径的节点集合 haspathsum(root,\u0026sumnodes,targetsum,\u0026result) return result } func haspathsum(root *treenode,sumnodes *[]int,targetsum int,result *[][]int){ *sumnodes=append(*sumnodes,root.val) if root.left==nil\u0026\u0026root.right==nil{//叶子节点 fmt.println(*sumnodes) var sum int var number int for k,v:=range *sumnodes{//求该路径节点的和 sum+=v number=k } tempnodes:=make([]int,number+1)//新的nodes接受指针里的值，防止最终指针里的值发生变动，导致最后的结果都是最后一个sumnodes的值 for k,v:=range *sumnodes{ tempnodes[k]=v } if sum==targetsum{ *result=append(*result,tempnodes) } } if root.left!=nil{ haspathsum(root.left,sumnodes,targetsum,result) *sumnodes=(*sumnodes)[:len(*sumnodes)-1]//回溯 } if root.right!=nil{ haspathsum(root.right,sumnodes,targetsum,result) *sumnodes=(*sumnodes)[:len(*sumnodes)-1]//回溯 } } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:16:0","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"从中序、后序遍历序列构造二叉树 106 从中序与后序遍历序列构造二叉树 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buildTree(inorder []int, postorder []int) *TreeNode { if len(inorder)\u003c1||len(postorder)\u003c1{return nil} //先找到根节点（后续遍历的最后一个就是根节点） nodeValue:=postorder[len(postorder)-1] //从中序遍历中找到一分为二的点，左边为左子树，右边为右子树 left:=findRootIndex(inorder,nodeValue) //构造root root:=\u0026TreeNode{Val: nodeValue, Left: buildTree(inorder[:left],postorder[:left]),//将后续遍历一分为二，左边为左子树，右边为右子树 Right: buildTree(inorder[left+1:],postorder[left:len(postorder)-1])} return root } func findRootIndex(inorder []int,target int) (index int){ for i:=0;i\u003clen(inorder);i++{ if target==inorder[i]{ return i } } return -1 } 105 从前序与中序遍历序列构造二叉树 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder)\u003c1||len(inorder)\u003c1{return nil} left:=findRootIndex(preorder[0],inorder) root:=\u0026TreeNode{ Val: preorder[0], Left: buildTree(preorder[1:left+1],inorder[:left]), Right: buildTree(preorder[left+1:],inorder[left+1:])} return root } func findRootIndex(target int,inorder []int) int{ for i:=0;i\u003clen(inorder);i++{ if target==inorder[i]{ return i } } return -1 } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:17:0","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"最大二叉树 给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下： 二叉树的根是数组中的最大元素。 左子树是通过数组中最大值左边部分构造出的最大二叉树。 右子树是通过数组中最大值右边部分构造出的最大二叉树。 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func constructMaximumBinaryTree(nums []int) *TreeNode { if len(nums)\u003c1{return nil} //首选找到最大值 index:=findMax(nums) //其次构造二叉树 root:=\u0026TreeNode{ Val: nums[index], Left:constructMaximumBinaryTree(nums[:index]),//左半边 Right:constructMaximumBinaryTree(nums[index+1:]),//右半边 } return root } func findMax(nums []int) (index int){ for i:=0;i\u003clen(nums);i++{ if nums[i]\u003enums[index]{ index=i } } return } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:18:0","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"合并二叉树 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ //前序遍历（递归遍历，跟105 106差不多的思路） func mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode { var value int var nullNode *TreeNode//空node，便于遍历 nullNode=\u0026TreeNode{ Val:0, Left:nil, Right:nil} switch { case t1==nil\u0026\u0026t2==nil: return nil//终止条件 default : //如果其中一个节点为空，则将该节点置为nullNode，方便下次遍历 if t1==nil{ value=t2.Val t1=nullNode }else if t2==nil{ value=t1.Val t2=nullNode }else { value=t1.Val+t2.Val } } root:=\u0026TreeNode{//构造新的二叉树 Val: value, Left: mergeTrees(t1.Left,t2.Left), Right: mergeTrees(t1.Right,t2.Right)} return root } // 前序遍历简洁版 func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode { if root1 == nil { return root2 } if root2 == nil { return root1 } root1.Val += root2.Val root1.Left = mergeTrees(root1.Left, root2.Left) root1.Right = mergeTrees(root1.Right, root2.Right) return root1 } // 迭代版本 func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode { queue := make([]*TreeNode,0) if root1 == nil{ return root2 } if root2 == nil{ return root1 } queue = append(queue,root1) queue = append(queue,root2) for size:=len(queue);size\u003e0;size=len(queue){ node1 := queue[0] queue = queue[1:] node2 := queue[0] queue = queue[1:] node1.Val += node2.Val // 左子树都不为空 if node1.Left != nil \u0026\u0026 node2.Left != nil{ queue = append(queue,node1.Left) queue = append(queue,node2.Left) } // 右子树都不为空 if node1.Right !=nil \u0026\u0026 node2.Right !=nil{ queue = append(queue,node1.Right) queue = append(queue,node2.Right) } // 树 1 的左子树为 nil，直接接上树 2 的左子树 if node1.Left == nil{ node1.Left = node2.Left } // 树 1 的右子树为 nil，直接接上树 2 的右子树 if node1.Right == nil{ node1.Right = node2.Right } } return root1 } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:19:0","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"二叉搜索树 ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:20:0","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"搜索 给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。 递归法： //递归法 func searchBST(root *TreeNode, val int) *TreeNode { if root==nil||root.Val==val{ return root } if root.Val\u003eval{ return searchBST(root.Left,val) } return searchBST(root.Right,val) } 迭代法： //迭代法 func searchBST(root *TreeNode, val int) *TreeNode { for root!=nil{ if root.Val\u003eval{ root=root.Left }else if root.Val\u003cval{ root=root.Right }else{ break } } return root } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:20:1","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"验证 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 import \"math\" func isValidBST(root *TreeNode) bool { // 二叉搜索树也可以是空树 if root == nil { return true } // 由题目中的数据限制可以得出min和max return check(root,math.MinInt64,math.MaxInt64) } func check(node *TreeNode,min,max int64) bool { if node == nil { return true } if min \u003e= int64(node.Val) || max \u003c= int64(node.Val) { return false } // 分别对左子树和右子树递归判断，如果左子树和右子树都符合则返回true return check(node.Right,int64(node.Val),max) \u0026\u0026 check(node.Left,min,int64(node.Val)) } // 中序遍历解法 func isValidBST(root *TreeNode) bool { // 保存上一个指针 var prev *TreeNode var travel func(node *TreeNode) bool travel = func(node *TreeNode) bool { if node == nil { return true } leftRes := travel(node.Left) // 当前值小于等于前一个节点的值，返回false if prev != nil \u0026\u0026 node.Val \u003c= prev.Val { return false } prev = node rightRes := travel(node.Right) return leftRes \u0026\u0026 rightRes } return travel(root) } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:20:2","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"最小绝对差 给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。 中序遍历，然后计算最小差值 func getMinimumDifference(root *TreeNode) int { var res []int findMIn(root,\u0026res) min:=1000000//一个比较大的值 for i:=1;i\u003clen(res);i++{ tempValue:=res[i]-res[i-1] if tempValue\u003cmin{ min=tempValue } } return min } //中序遍历 func findMIn(root *TreeNode,res *[]int){ if root==nil{return} findMIn(root.Left,res) *res=append(*res,root.Val) findMIn(root.Right,res) } // 中序遍历的同时计算最小值 func getMinimumDifference(root *TreeNode) int { // 保留前一个节点的指针 var prev *TreeNode // 定义一个比较大的值 min := math.MaxInt64 var travel func(node *TreeNode) travel = func(node *TreeNode) { if node == nil { return } travel(node.Left) if prev != nil \u0026\u0026 node.Val - prev.Val \u003c min { min = node.Val - prev.Val } prev = node travel(node.Right) } travel(root) return min } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:20:3","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"众数 给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。 暴力法 func findMode(root *TreeNode) []int { var history map[int]int var maxValue int var maxIndex int var result []int history=make(map[int]int) traversal(root,history) for k,value:=range history{ if value\u003emaxValue{ maxValue=value maxIndex=k } } for k,value:=range history{ if value==history[maxIndex]{ result=append(result,k) } } return result } func traversal(root *TreeNode,history map[int]int){ if root.Left!=nil{ traversal(root.Left,history) } if value,ok:=history[root.Val];ok{ history[root.Val]=value+1 }else{ history[root.Val]=1 } if root.Right!=nil{ traversal(root.Right,history) } } 计数法，不使用额外空间，利用二叉树性质，中序遍历 func findMode(root *TreeNode) []int { res := make([]int, 0) count := 1 max := 1 var prev *TreeNode var travel func(node *TreeNode) travel = func(node *TreeNode) { if node == nil { return } travel(node.Left) if prev != nil \u0026\u0026 prev.Val == node.Val { count++ } else { count = 1 } if count \u003e= max { if count \u003e max \u0026\u0026 len(res) \u003e 0 { res = []int{node.Val} } else { res = append(res, node.Val) } max = count } prev = node travel(node.Right) } travel(root) return res } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:20:4","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"二叉树最近公共祖先 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先（可以是自己） func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { // check if root == nil { return root } // 相等 直接返回root节点即可 if root == p || root == q { return root } // Divide left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) // Conquer // 左右两边都不为空，则根节点为祖先 if left != nil \u0026\u0026 right != nil { return root } if left != nil { return left } if right != nil { return right } return nil } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:20:5","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"二叉搜索树的最近公共祖先 递归法： //利用BSL的性质（前序遍历有序） func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root==nil{return nil} if root.Val\u003ep.Val\u0026\u0026root.Val\u003eq.Val{//当前节点的值大于给定的值，则说明满足条件的在左边 return lowestCommonAncestor(root.Left,p,q) }else if root.Val\u003cp.Val\u0026\u0026root.Val\u003cq.Val{//当前节点的值小于各点的值，则说明满足条件的在右边 return lowestCommonAncestor(root.Right,p,q) }else {return root}//当前节点的值在给定值的中间（或者等于），即为最深的祖先 } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:20:6","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"插入操作 给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。 递归法 func insertIntoBST(root *TreeNode, val int) *TreeNode { if root == nil { root = \u0026TreeNode{Val: val} return root } if root.Val \u003e val { root.Left = insertIntoBST(root.Left, val) } else { root.Right = insertIntoBST(root.Right, val) } return root } 迭代法 func insertIntoBST(root *TreeNode, val int) *TreeNode { if root == nil { return \u0026TreeNode{Val:val} } node := root var pnode *TreeNode for node != nil { if val \u003e node.Val { pnode = node node = node.Right } else { pnode = node node = node.Left } } if val \u003e pnode.Val { pnode.Right = \u0026TreeNode{Val: val} } else { pnode.Left = \u0026TreeNode{Val: val} } return root } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:20:7","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"删除节点 搜索树的节点删除要比节点增加复杂的多。 // 递归版本 func deleteNode(root *TreeNode, key int) *TreeNode { if root==nil{ return nil } if key\u003croot.Val{ root.Left=deleteNode(root.Left,key) return root } if key\u003eroot.Val{ root.Right=deleteNode(root.Right,key) return root } if root.Right==nil{ return root.Left } if root.Left==nil{ return root.Right } minnode:=root.Right for minnode.Left!=nil{ minnode=minnode.Left } root.Val=minnode.Val root.Right=deleteNode1(root.Right) return root } func deleteNode1(root *TreeNode)*TreeNode{ if root.Left==nil{ pRight:=root.Right root.Right=nil return pRight } root.Left=deleteNode1(root.Left) return root } // 迭代版本 func deleteOneNode(target *TreeNode) *TreeNode { if target == nil { return target } if target.Right == nil { return target.Left } cur := target.Right for cur.Left != nil { cur = cur.Left } cur.Left = target.Left return target.Right } func deleteNode(root *TreeNode, key int) *TreeNode { // 特殊情况处理 if root == nil { return root } cur := root var pre *TreeNode for cur != nil { if cur.Val == key { break } pre = cur if cur.Val \u003e key { cur = cur.Left } else { cur = cur.Right } } if pre == nil { return deleteOneNode(cur) } // pre 要知道是删除左孩子还有右孩子 if pre.Left != nil \u0026\u0026 pre.Left.Val == key { pre.Left = deleteOneNode(cur) } if pre.Right != nil \u0026\u0026 pre.Right.Val == key { pre.Right = deleteOneNode(cur) } return root } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:20:8","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"修剪 给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R\u003e=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。 // 递归 func trimBST(root *TreeNode, low int, high int) *TreeNode { if root==nil{ return nil } if root.Val\u003clow{//如果该节点值小于最小值，则该节点更换为该节点的右节点值，继续遍历 right:=trimBST(root.Right,low,high) return right } if root.Val\u003ehigh{//如果该节点的值大于最大值，则该节点更换为该节点的左节点值，继续遍历 left:=trimBST(root.Left,low,high) return left } root.Left=trimBST(root.Left,low,high) root.Right=trimBST(root.Right,low,high) return root } // 迭代 func trimBST(root *TreeNode, low int, high int) *TreeNode { if root == nil { return nil } // 处理 root，让 root 移动到[low, high] 范围内，注意是左闭右闭 for root != nil \u0026\u0026 (root.Val\u003clow||root.Val\u003ehigh){ if root.Val \u003c low{ root = root.Right }else{ root = root.Left } } cur := root // 此时 root 已经在[low, high] 范围内，处理左孩子元素小于 low 的情况（左节点是一定小于 root.Val，因此天然小于 high） for cur != nil{ for cur.Left!=nil \u0026\u0026 cur.Left.Val \u003c low{ cur.Left = cur.Left.Right } cur = cur.Left } cur = root // 此时 root 已经在[low, high] 范围内，处理右孩子大于 high 的情况 for cur != nil{ for cur.Right!=nil \u0026\u0026 cur.Right.Val \u003e high{ cur.Right = cur.Right.Left } cur = cur.Right } return root } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:20:9","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"将有序数组转化为二叉搜索树 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 递归（隐含回溯） func sortedArrayToBST(nums []int) *TreeNode { if len(nums)==0{return nil}//终止条件，最后数组为空则可以返回 root:=\u0026TreeNode{nums[len(nums)/2],nil,nil}//按照BSL的特点，从中间构造节点 root.Left=sortedArrayToBST(nums[:len(nums)/2])//数组的左边为左子树 root.Right=sortedArrayToBST(nums[len(nums)/2+1:])//数字的右边为右子树 return root } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:20:10","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":"把二叉搜索树转化为累加树 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。 弄一个sum暂存其和值 //右中左 func bstToGst(root *TreeNode) *TreeNode { var sum int RightMLeft(root,\u0026sum) return root } func RightMLeft(root *TreeNode,sum *int) *TreeNode { if root==nil{return nil}//终止条件，遇到空节点就返回 RightMLeft(root.Right,sum)//先遍历右边 temp:=*sum//暂存总和值 *sum+=root.Val//将总和值变更 root.Val+=temp//更新节点值 RightMLeft(root.Left,sum)//遍历左节点 return root } ","date":"2022-01-06 08:21:45","objectID":"https://qizhengzou.github.io/algorithm_binarytree/:20:11","tags":["data structure"],"title":"Algorithm_binaryTree","uri":"https://qizhengzou.github.io/algorithm_binarytree/"},{"categories":["Coding"],"content":" 学习代码随想录笔记 栈和队列 需要知道栈和队列的底层实现，不同编程语言不同STL的实现原理都是不尽相同的。 ","date":"2022-01-06 08:20:54","objectID":"https://qizhengzou.github.io/algorithm_stackandqueue/:0:0","tags":["data structure"],"title":"Algorithm_stackAndQueue","uri":"https://qizhengzou.github.io/algorithm_stackandqueue/"},{"categories":["Coding"],"content":"理论基础(c++) 栈其实就是递归的一种实现结构。 栈（本身可以说是一个容器适配器）是以底层容器（数组或者链表）完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。 SGI -- Silicon Graphics [Computer System] Inc. 硅图[计算机系统] 公司. STL -- Standard Template Library 标准模板库。 SGI STL -- SGI的标准模板库。 SGI的全称 -- 硅图[计算机系统] 公司。 我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的低层结构。 deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。 SGI STL中 队列底层实现缺省情况下一样使用deque实现的。 我们也可以指定vector为栈的底层实现，初始化语句如下： std::stack\u003cint, std::vector\u003cint\u003e \u003e third; // 使用vector为底层容器的栈 对应的队列的情况是一样的。 队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, SGI STL中队列一样是以deque为缺省情况下的底部结构。 也可以指定list 为起底层实现，初始化queue的语句如下： std::queue\u003cint, std::list\u003cint\u003e\u003e third; // 定义以list为底层容器的队列 所以STL 队列也不被归类为容器，而被归类为container adapter（ 容器适配器）。 ","date":"2022-01-06 08:20:54","objectID":"https://qizhengzou.github.io/algorithm_stackandqueue/:1:0","tags":["data structure"],"title":"Algorithm_stackAndQueue","uri":"https://qizhengzou.github.io/algorithm_stackandqueue/"},{"categories":["Coding"],"content":"用栈实现队列 使用栈实现队列的下列操作： push(x) – 将一个元素放入队列的尾部。 pop() – 从队列首部移除元素。 peek() – 返回队列首部的元素。 empty() – 返回队列是否为空。 示例: MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // 返回 1 queue.pop(); // 返回 1 queue.empty(); // 返回 false 说明: 你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作） type MyQueue struct { stack []int back []int } /** Initialize your data structure here. */ func Constructor() MyQueue { return MyQueue{ stack: make([]int, 0), back: make([]int, 0), } } /** Push element x to the back of queue. */ func (this *MyQueue) Push(x int) { for len(this.back) != 0 { val := this.back[len(this.back)-1] this.back = this.back[:len(this.back)-1] this.stack = append(this.stack, val) } this.stack = append(this.stack, x) } /** Removes the element from in front of queue and returns that element. */ func (this *MyQueue) Pop() int { for len(this.stack) != 0 { val := this.stack[len(this.stack)-1] this.stack = this.stack[:len(this.stack)-1] this.back = append(this.back, val) } if len(this.back) == 0 { return 0 } val := this.back[len(this.back)-1] this.back = this.back[:len(this.back)-1] return val } /** Get the front element. */ func (this *MyQueue) Peek() int { for len(this.stack) != 0 { val := this.stack[len(this.stack)-1] this.stack = this.stack[:len(this.stack)-1] this.back = append(this.back, val) } if len(this.back) == 0 { return 0 } val := this.back[len(this.back)-1] return val } /** Returns whether the queue is empty. */ func (this *MyQueue) Empty() bool { return len(this.stack) == 0 \u0026\u0026 len(this.back) == 0 } ","date":"2022-01-06 08:20:54","objectID":"https://qizhengzou.github.io/algorithm_stackandqueue/:2:0","tags":["data structure"],"title":"Algorithm_stackAndQueue","uri":"https://qizhengzou.github.io/algorithm_stackandqueue/"},{"categories":["Coding"],"content":"用队列实现栈 使用队列实现栈的下列操作： push(x) -- 元素 x 入栈 pop() -- 移除栈顶元素 top() -- 获取栈顶元素 empty() -- 返回栈是否为空 注意: 你只能使用队列的基本操作– 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。 你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作） 用两个队列实现： type MyStack struct { //创建两个队列 queue1 []int queue2 []int } func Constructor() MyStack { return MyStack{ //初始化 queue1:make([]int,0), queue2:make([]int,0), } } func (this *MyStack) Push(x int) { //先将数据存在queue2中 this.queue2 = append(this.queue2,x) //将queue1中所有元素移到queue2中，再将两个队列进行交换 this.Move() } func (this *MyStack) Move(){ if len(this.queue1) == 0{ //交换，queue1置为queue2,queue2置为空 this.queue1,this.queue2 = this.queue2,this.queue1 }else{ //queue1元素从头开始一个一个追加到queue2中 this.queue2 = append(this.queue2,this.queue1[0]) this.queue1 = this.queue1[1:] //去除第一个元素 this.Move() //重复 } } func (this *MyStack) Pop() int { val := this.queue1[0] this.queue1 = this.queue1[1:] //去除第一个元素 return val } func (this *MyStack) Top() int { return this.queue1[0] //直接返回 } func (this *MyStack) Empty() bool { return len(this.queue1) == 0 } /** * Your MyStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Empty(); */ 用一个队列实现： type MyStack struct { queue []int//创建一个队列 } /** Initialize your data structure here. */ func Constructor() MyStack { return MyStack{ //初始化 queue:make([]int,0), } } /** Push element x onto stack. */ func (this *MyStack) Push(x int) { //添加元素 this.queue=append(this.queue,x) } /** Removes the element on top of the stack and returns that element. */ func (this *MyStack) Pop() int { n:=len(this.queue)-1//判断长度 for n!=0{ //除了最后一个，其余的都重新添加到队列里 val:=this.queue[0] this.queue=this.queue[1:] this.queue=append(this.queue,val) n-- } //弹出元素 val:=this.queue[0] this.queue=this.queue[1:] return val } /** Get the top element. */ func (this *MyStack) Top() int { //利用Pop函数，弹出来的元素重新添加 val:=this.Pop() this.queue=append(this.queue,val) return val } /** Returns whether the stack is empty. */ func (this *MyStack) Empty() bool { return len(this.queue)==0 } /** * Your MyStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Empty(); */ ","date":"2022-01-06 08:20:54","objectID":"https://qizhengzou.github.io/algorithm_stackandqueue/:3:0","tags":["data structure"],"title":"Algorithm_stackAndQueue","uri":"https://qizhengzou.github.io/algorithm_stackandqueue/"},{"categories":["Coding"],"content":"有效的括号 给定一个只包括 ‘('，')'，'{'，'}'，'['，']’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 栈的经典问题。 func isValid(s string) bool { hash := map[byte]byte{')':'(', ']':'[', '}':'{'} stack := make([]byte, 0) if s == \"\" { return true } for i := 0; i \u003c len(s); i++ { if s[i] == '(' || s[i] == '[' || s[i] == '{' { stack = append(stack, s[i]) } else if len(stack) \u003e 0 \u0026\u0026 stack[len(stack)-1] == hash[s[i]] { stack = stack[:len(stack)-1] } else { return false } } return len(stack) == 0 } ","date":"2022-01-06 08:20:54","objectID":"https://qizhengzou.github.io/algorithm_stackandqueue/:4:0","tags":["data structure"],"title":"Algorithm_stackAndQueue","uri":"https://qizhengzou.github.io/algorithm_stackandqueue/"},{"categories":["Coding"],"content":"删除字符串中的所有相邻重复项 给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。 在 S 上反复执行重复项删除操作，直到无法继续删除。 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 示例： 输入：\"abbaca\" 输出：\"ca\" 解释：例如，在 \"abbaca\" 中，我们可以删除 \"bb\" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 \"aaca\"，其中又只有 \"aa\" 可以执行重复项删除操作，所以最后的字符串为 \"ca\"。 提示： 1 \u003c= S.length \u003c= 20000 S 仅由小写英文字母组成 func removeDuplicates(s string) string { var stack []byte for i := 0; i \u003c len(s);i++ { // 栈不空 且 与栈顶元素不等 if len(stack) \u003e 0 \u0026\u0026 stack[len(stack)-1] == s[i] { // 弹出栈顶元素 并 忽略当前元素(s[i]) stack = stack[:len(stack)-1] }else{ // 入栈 stack = append(stack, s[i]) } } return string(stack) } ","date":"2022-01-06 08:20:54","objectID":"https://qizhengzou.github.io/algorithm_stackandqueue/:5:0","tags":["data structure"],"title":"Algorithm_stackAndQueue","uri":"https://qizhengzou.github.io/algorithm_stackandqueue/"},{"categories":["Coding"],"content":"逆波兰表达式求值 根据 逆波兰表示法，求表达式的值。 有效的运算符包括 + , - , * , / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 1： 输入: [\"2\", \"1\", \"+\", \"3\", \" * \"] 输出: 9 解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 逆波兰表达式：是一种后缀表达式，所谓后缀就是指算符写在后面。 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。 逆波兰表达式主要有以下两个优点： 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中 func evalRPN(tokens []string) int { stack := []int{} for _, token := range tokens { val, err := strconv.Atoi(token) if err == nil { stack = append(stack, val) } else { num1, num2 := stack[len(stack)-2], stack[(len(stack))-1] stack = stack[:len(stack)-2] switch token { case \"+\": stack = append(stack, num1+num2) case \"-\": stack = append(stack, num1-num2) case \"*\": stack = append(stack, num1*num2) case \"/\": stack = append(stack, num1/num2) } } } return stack[0] } ","date":"2022-01-06 08:20:54","objectID":"https://qizhengzou.github.io/algorithm_stackandqueue/:6:0","tags":["data structure"],"title":"Algorithm_stackAndQueue","uri":"https://qizhengzou.github.io/algorithm_stackandqueue/"},{"categories":["Coding"],"content":"滑动窗口最大值 给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 每个窗口都有一个最大值，返回滑动窗口中的最大值数组。 进阶：你能在线性时间复杂度内解决此题吗？ // 封装单调队列的方式解题 type MyQueue struct { queue []int } func NewMyQueue() *MyQueue { return \u0026MyQueue{ queue: make([]int, 0), } } func (m *MyQueue) Front() int { return m.queue[0] } func (m *MyQueue) Back() int { return m.queue[len(m.queue)-1] } func (m *MyQueue) Empty() bool { return len(m.queue) == 0 } func (m *MyQueue) Push(val int) { for !m.Empty() \u0026\u0026 val \u003e m.Back() { m.queue = m.queue[:len(m.queue)-1] } m.queue = append(m.queue, val) } func (m *MyQueue) Pop(val int) { if !m.Empty() \u0026\u0026 val == m.Front() { m.queue = m.queue[1:] } } func maxSlidingWindow(nums []int, k int) []int { queue := NewMyQueue() length := len(nums) res := make([]int, 0) // 先将前k个元素放入队列 for i := 0; i \u003c k; i++ { queue.Push(nums[i]) } // 记录前k个元素的最大值 res = append(res, queue.Front()) for i := k; i \u003c length; i++ { // 滑动窗口移除最前面的元素 queue.Pop(nums[i-k]) // 滑动窗口添加最后面的元素 queue.Push(nums[i]) // 记录最大值 res = append(res, queue.Front()) } return res } ","date":"2022-01-06 08:20:54","objectID":"https://qizhengzou.github.io/algorithm_stackandqueue/:7:0","tags":["data structure"],"title":"Algorithm_stackAndQueue","uri":"https://qizhengzou.github.io/algorithm_stackandqueue/"},{"categories":["Coding"],"content":"前K个高频元素 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1: 输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] //方法一：小顶堆 func topKFrequent(nums []int, k int) []int { map_num:=map[int]int{} //记录每个元素出现的次数 for _,item:=range nums{ map_num[item]++ } h:=\u0026IHeap{} heap.Init(h) //所有元素入堆，堆的长度为k for key,value:=range map_num{ heap.Push(h,[2]int{key,value}) if h.Len()\u003ek{ heap.Pop(h) } } res:=make([]int,k) //按顺序返回堆中的元素 for i:=0;i\u003ck;i++{ res[k-i-1]=heap.Pop(h).([2]int)[0] } return res } //构建小顶堆 type IHeap [][2]int func (h IHeap) Len()int { return len(h) } func (h IHeap) Less (i,j int) bool { return h[i][1]\u003ch[j][1] } func (h IHeap) Swap(i,j int) { h[i],h[j]=h[j],h[i] } func (h *IHeap) Push(x interface{}){ *h=append(*h,x.([2]int)) } func (h *IHeap) Pop() interface{}{ old:=*h n:=len(old) x:=old[n-1] *h=old[0:n-1] return x } //方法二:利用O(logn)排序 func topKFrequent(nums []int, k int) []int { ans:=[]int{} map_num:=map[int]int{} for _,item:=range nums { map_num[item]++ } for key,_:=range map_num{ ans=append(ans,key) } //核心思想：排序 //可以不用包函数，自己实现快排 sort.Slice(ans,func (a,b int)bool{ return map_num[ans[a]]\u003emap_num[ans[b]] }) return ans[:k] } ","date":"2022-01-06 08:20:54","objectID":"https://qizhengzou.github.io/algorithm_stackandqueue/:8:0","tags":["data structure"],"title":"Algorithm_stackAndQueue","uri":"https://qizhengzou.github.io/algorithm_stackandqueue/"},{"categories":["Coding"],"content":" 学习代码随想录笔记 双指针法 双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。 ","date":"2022-01-06 08:19:19","objectID":"https://qizhengzou.github.io/algorithm_doublepointer/:0:0","tags":["data structure"],"title":"Algorithm_doublePointer","uri":"https://qizhengzou.github.io/algorithm_doublepointer/"},{"categories":["Coding"],"content":"移除元素 给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 $O(1)$ 额外空间并原地修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。 你不需要考虑数组中超出新长度后面的元素。 func removeElement(nums []int, val int) int { length:=len(nums) res:=0 for i:=0;i\u003clength;i++{ if nums[i]!=val { nums[res]=nums[i] res++ } } return res } ","date":"2022-01-06 08:19:19","objectID":"https://qizhengzou.github.io/algorithm_doublepointer/:1:0","tags":["data structure"],"title":"Algorithm_doublePointer","uri":"https://qizhengzou.github.io/algorithm_doublepointer/"},{"categories":["Coding"],"content":"反转字符串 func reverseString(s []byte) { left:=0 right:=len(s)-1 for left\u003cright{ s[left],s[right]=s[right],s[left] left++ right-- } } ","date":"2022-01-06 08:19:19","objectID":"https://qizhengzou.github.io/algorithm_doublepointer/:2:0","tags":["data structure"],"title":"Algorithm_doublePointer","uri":"https://qizhengzou.github.io/algorithm_doublepointer/"},{"categories":["Coding"],"content":"替换空格 // 遍历添加 func replaceSpace(s string) string { b := []byte(s) result := make([]byte, 0) for i := 0; i \u003c len(b); i++ { if b[i] == ' ' { result = append(result, []byte(\"%20\")...) } else { result = append(result, b[i]) } } return string(result) } // 原地修改 func replaceSpace(s string) string { b := []byte(s) length := len(b) spaceCount := 0 // 计算空格数量 for _, v := range b { if v == ' ' { spaceCount++ } } // 扩展原有切片 resizeCount := spaceCount * 2 tmp := make([]byte, resizeCount) b = append(b, tmp...) i := length - 1 j := len(b) - 1 for i \u003e= 0 { if b[i] != ' ' { b[j] = b[i] i-- j-- } else { b[j] = '0' b[j-1] = '2' b[j-2] = '%' i-- j = j - 3 } } return string(b) } ","date":"2022-01-06 08:19:19","objectID":"https://qizhengzou.github.io/algorithm_doublepointer/:3:0","tags":["data structure"],"title":"Algorithm_doublePointer","uri":"https://qizhengzou.github.io/algorithm_doublepointer/"},{"categories":["Coding"],"content":"翻转字符串里的单词 import ( \"fmt\" ) func reverseWords(s string) string { //1.使用双指针删除冗余的空格 slowIndex, fastIndex := 0, 0 b := []byte(s) //删除头部冗余空格 for len(b) \u003e 0 \u0026\u0026 fastIndex \u003c len(b) \u0026\u0026 b[fastIndex] == ' ' { fastIndex++ } //删除单词间冗余空格 for ; fastIndex \u003c len(b); fastIndex++ { if fastIndex-1 \u003e 0 \u0026\u0026 b[fastIndex-1] == b[fastIndex] \u0026\u0026 b[fastIndex] == ' ' { continue } b[slowIndex] = b[fastIndex] slowIndex++ } //删除尾部冗余空格 if slowIndex-1 \u003e 0 \u0026\u0026 b[slowIndex-1] == ' ' { b = b[:slowIndex-1] } else { b = b[:slowIndex] } //2.反转整个字符串 reverse(\u0026b, 0, len(b)-1) //3.反转单个单词 i单词开始位置，j单词结束位置 i := 0 for i \u003c len(b) { j := i for ; j \u003c len(b) \u0026\u0026 b[j] != ' '; j++ { } reverse(\u0026b, i, j-1) i = j i++ } return string(b) } func reverse(b *[]byte, left, right int) { for left \u003c right { (*b)[left], (*b)[right] = (*b)[right], (*b)[left] left++ right-- } } ","date":"2022-01-06 08:19:19","objectID":"https://qizhengzou.github.io/algorithm_doublepointer/:4:0","tags":["data structure"],"title":"Algorithm_doublePointer","uri":"https://qizhengzou.github.io/algorithm_doublepointer/"},{"categories":["Coding"],"content":"翻转链表 //双指针 func reverseList(head *ListNode) *ListNode { var pre *ListNode cur := head for cur != nil { next := cur.Next cur.Next = pre pre = cur cur = next } return pre } //递归 func reverseList(head *ListNode) *ListNode { return help(nil, head) } func help(pre, head *ListNode)*ListNode{ if head == nil { return pre } next := head.Next head.Next = pre return help(head, next) } ","date":"2022-01-06 08:19:19","objectID":"https://qizhengzou.github.io/algorithm_doublepointer/:5:0","tags":["data structure"],"title":"Algorithm_doublePointer","uri":"https://qizhengzou.github.io/algorithm_doublepointer/"},{"categories":["Coding"],"content":"删除链表的倒数第N个节点 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeNthFromEnd(head *ListNode, n int) *ListNode { dummyHead := \u0026ListNode{} dummyHead.Next = head cur := head prev := dummyHead i := 1 for cur != nil { cur = cur.Next if i \u003e n { prev = prev.Next } i++ } prev.Next = prev.Next.Next return dummyHead.Next } ","date":"2022-01-06 08:19:19","objectID":"https://qizhengzou.github.io/algorithm_doublepointer/:6:0","tags":["data structure"],"title":"Algorithm_doublePointer","uri":"https://qizhengzou.github.io/algorithm_doublepointer/"},{"categories":["Coding"],"content":"链表相交 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 func getIntersectionNode(headA, headB *ListNode) *ListNode { curA := headA curB := headB lenA, lenB := 0, 0 // 求A，B的长度 for curA != nil { curA = curA.Next lenA++ } for curB != nil { curB = curB.Next lenB++ } var step int var fast, slow *ListNode // 请求长度差，并且让更长的链表先走相差的长度 if lenA \u003e lenB { step = lenA - lenB fast, slow = headA, headB } else { step = lenB - lenA fast, slow = headB, headA } for i:=0; i \u003c step; i++ { fast = fast.Next } // 遍历两个链表遇到相同则跳出遍历 for fast != slow { fast = fast.Next slow = slow.Next } return fast } ","date":"2022-01-06 08:19:19","objectID":"https://qizhengzou.github.io/algorithm_doublepointer/:7:0","tags":["data structure"],"title":"Algorithm_doublePointer","uri":"https://qizhengzou.github.io/algorithm_doublepointer/"},{"categories":["Coding"],"content":"环形链表II 题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 func detectCycle(head *ListNode) *ListNode { slow, fast := head, head for fast != nil \u0026\u0026 fast.Next != nil { slow = slow.Next fast = fast.Next.Next if slow == fast { for slow != head { slow = slow.Next head = head.Next } return head } } return nil } ","date":"2022-01-06 08:19:19","objectID":"https://qizhengzou.github.io/algorithm_doublepointer/:8:0","tags":["data structure"],"title":"Algorithm_doublePointer","uri":"https://qizhengzou.github.io/algorithm_doublepointer/"},{"categories":["Coding"],"content":"三数之和 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意： 答案中不可以包含重复的三元组。 示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ] func threeSum(nums []int)[][]int{ sort.Ints(nums) res:=[][]int{} for i:=0;i\u003clen(nums)-2;i++{ n1:=nums[i] if n1\u003e0{ break } if i\u003e0\u0026\u0026n1==nums[i-1]{ continue } l,r:=i+1,len(nums)-1 for l\u003cr{ n2,n3:=nums[l],nums[r] if n1+n2+n3==0{ res=append(res,[]int{n1,n2,n3}) for l\u003cr\u0026\u0026nums[l]==n2{ l++ } for l\u003cr\u0026\u0026nums[r]==n3{ r-- } }else if n1+n2+n3\u003c0{ l++ }else { r-- } } } return res } ","date":"2022-01-06 08:19:19","objectID":"https://qizhengzou.github.io/algorithm_doublepointer/:9:0","tags":["data structure"],"title":"Algorithm_doublePointer","uri":"https://qizhengzou.github.io/algorithm_doublepointer/"},{"categories":["Coding"],"content":"四数之和 题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] func fourSum(nums []int, target int) [][]int { if len(nums) \u003c 4 { return nil } sort.Ints(nums) var res [][]int for i := 0; i \u003c len(nums)-3; i++ { n1 := nums[i] // if n1 \u003e target { // 不能这样写,因为可能是负数 // break // } if i \u003e 0 \u0026\u0026 n1 == nums[i-1] { continue } for j := i + 1; j \u003c len(nums)-2; j++ { n2 := nums[j] if j \u003e i+1 \u0026\u0026 n2 == nums[j-1] { continue } l := j + 1 r := len(nums) - 1 for l \u003c r { n3 := nums[l] n4 := nums[r] sum := n1 + n2 + n3 + n4 if sum \u003c target { l++ } else if sum \u003e target { r-- } else { res = append(res, []int{n1, n2, n3, n4}) for l \u003c r \u0026\u0026 n3 == nums[l+1] { // 去重 l++ } for l \u003c r \u0026\u0026 n4 == nums[r-1] { // 去重 r-- } // 找到答案时,双指针同时靠近 r-- l++ } } } } return res } ","date":"2022-01-06 08:19:19","objectID":"https://qizhengzou.github.io/algorithm_doublepointer/:10:0","tags":["data structure"],"title":"Algorithm_doublePointer","uri":"https://qizhengzou.github.io/algorithm_doublepointer/"},{"categories":["Coding"],"content":"双指针总结 总结 ","date":"2022-01-06 08:19:19","objectID":"https://qizhengzou.github.io/algorithm_doublepointer/:11:0","tags":["data structure"],"title":"Algorithm_doublePointer","uri":"https://qizhengzou.github.io/algorithm_doublepointer/"},{"categories":["Coding"],"content":" 学习代码随想录笔记 字符串 库函数是工具，基础更重要。 ","date":"2022-01-06 08:18:50","objectID":"https://qizhengzou.github.io/algorithm_string/:0:0","tags":["data structure"],"title":"Algorithm_string","uri":"https://qizhengzou.github.io/algorithm_string/"},{"categories":["Coding"],"content":"反转字符串 ","date":"2022-01-06 08:18:50","objectID":"https://qizhengzou.github.io/algorithm_string/:1:0","tags":["data structure"],"title":"Algorithm_string","uri":"https://qizhengzou.github.io/algorithm_string/"},{"categories":["Coding"],"content":"I 和反转链表相同，都用双指针法。 func reverseString(s []byte) { left:=0 right:=len(s)-1 for left\u003cright{ s[left],s[right]=s[right],s[left] left++ right-- } } ","date":"2022-01-06 08:18:50","objectID":"https://qizhengzou.github.io/algorithm_string/:1:1","tags":["data structure"],"title":"Algorithm_string","uri":"https://qizhengzou.github.io/algorithm_string/"},{"categories":["Coding"],"content":"II 给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。 如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 示例: 输入: s = \"abcdefg\", k = 2 输出: \"bacdfeg\" func reverseStr(s string, k int) string { ss := []byte(s) length := len(s) for i := 0; i \u003c length; i += 2 * k { if i + k \u003c= length { reverse(ss[i:i+k]) } else { reverse(ss[i:length]) } } return string(ss) } func reverse(b []byte) { left := 0 right := len(b) - 1 for left \u003c right { b[left], b[right] = b[right], b[left] left++ right-- } } ","date":"2022-01-06 08:18:50","objectID":"https://qizhengzou.github.io/algorithm_string/:1:2","tags":["data structure"],"title":"Algorithm_string","uri":"https://qizhengzou.github.io/algorithm_string/"},{"categories":["Coding"],"content":"替换空格 // 遍历添加 func replaceSpace(s string) string { b := []byte(s) result := make([]byte, 0) for i := 0; i \u003c len(b); i++ { if b[i] == ' ' { result = append(result, []byte(\"%20\")...) } else { result = append(result, b[i]) } } return string(result) } // 原地修改 func replaceSpace(s string) string { b := []byte(s) length := len(b) spaceCount := 0 // 计算空格数量 for _, v := range b { if v == ' ' { spaceCount++ } } // 扩展原有切片 resizeCount := spaceCount * 2 tmp := make([]byte, resizeCount) b = append(b, tmp...) i := length - 1 j := len(b) - 1 for i \u003e= 0 { if b[i] != ' ' { b[j] = b[i] i-- j-- } else { b[j] = '0' b[j-1] = '2' b[j-2] = '%' i-- j = j - 3 } } return string(b) } ","date":"2022-01-06 08:18:50","objectID":"https://qizhengzou.github.io/algorithm_string/:2:0","tags":["data structure"],"title":"Algorithm_string","uri":"https://qizhengzou.github.io/algorithm_string/"},{"categories":["Coding"],"content":"翻转字符串里的单词 给定一个字符串，逐个翻转字符串中的每个单词。 输入: \"the sky is blue\" 输出: \"blue is sky the\" import ( \"fmt\" ) func reverseWords(s string) string { //1.使用双指针删除冗余的空格 slowIndex, fastIndex := 0, 0 b := []byte(s) //删除头部冗余空格 for len(b) \u003e 0 \u0026\u0026 fastIndex \u003c len(b) \u0026\u0026 b[fastIndex] == ' ' { fastIndex++ } //删除单词间冗余空格 for ; fastIndex \u003c len(b); fastIndex++ { if fastIndex-1 \u003e 0 \u0026\u0026 b[fastIndex-1] == b[fastIndex] \u0026\u0026 b[fastIndex] == ' ' { continue } b[slowIndex] = b[fastIndex] slowIndex++ } //删除尾部冗余空格 if slowIndex-1 \u003e 0 \u0026\u0026 b[slowIndex-1] == ' ' { b = b[:slowIndex-1] } else { b = b[:slowIndex] } //2.反转整个字符串 reverse(\u0026b, 0, len(b)-1) //3.反转单个单词 i单词开始位置，j单词结束位置 i := 0 for i \u003c len(b) { j := i for ; j \u003c len(b) \u0026\u0026 b[j] != ' '; j++ { } reverse(\u0026b, i, j-1) i = j i++ } return string(b) } func reverse(b *[]byte, left, right int) { for left \u003c right { (*b)[left], (*b)[right] = (*b)[right], (*b)[left] left++ right-- } } ","date":"2022-01-06 08:18:50","objectID":"https://qizhengzou.github.io/algorithm_string/:3:0","tags":["data structure"],"title":"Algorithm_string","uri":"https://qizhengzou.github.io/algorithm_string/"},{"categories":["Coding"],"content":"左旋转字符串 输入: s = \"abcdefg\", k = 2 输出: \"cdefgab\" func reverseLeftWords(s string, n int) string { b := []byte(s) // 1. 反转前n个字符 // 2. 反转第n到end字符 // 3. 反转整个字符 reverse(b, 0, n-1) reverse(b, n, len(b)-1) reverse(b, 0, len(b)-1) return string(b) } // 切片是引用传递 func reverse(b []byte, left, right int){ for left \u003c right{ b[left], b[right] = b[right],b[left] left++ right-- } } ","date":"2022-01-06 08:18:50","objectID":"https://qizhengzou.github.io/algorithm_string/:4:0","tags":["data structure"],"title":"Algorithm_string","uri":"https://qizhengzou.github.io/algorithm_string/"},{"categories":["Coding"],"content":"实现strStr() 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1: 输入: haystack = “hello”, needle = “ll” 输出: 2 示例 2: 输入: haystack = “aaaaa”, needle = “bba” 输出: -1 说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 ","date":"2022-01-06 08:18:50","objectID":"https://qizhengzou.github.io/algorithm_string/:5:0","tags":["data structure"],"title":"Algorithm_string","uri":"https://qizhengzou.github.io/algorithm_string/"},{"categories":["Coding"],"content":"什么是KMP KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n) [1] 。（来自百度百科） KMP的经典思想就是:当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。 如何记录已经匹配的文本内容，是KMP的重点，也是next数组的任务。 ","date":"2022-01-06 08:18:50","objectID":"https://qizhengzou.github.io/algorithm_string/:5:1","tags":["data structure"],"title":"Algorithm_string","uri":"https://qizhengzou.github.io/algorithm_string/"},{"categories":["Coding"],"content":"什么是前缀表与next数组 next数组就是一个前缀表。 前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。 什么是前缀表：记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。 最长公共前后缀：字符串aa的最长相等前后缀为1。 字符串aaa的最长相等前后缀为2。 等等….. 前缀表要求的就是最长相同前后缀的长度。它能告诉我们上次匹配的位置。 下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀和后缀字符串是子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面从新匹配就可以了。 前缀表与next数组有什么关系： next数组即可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。 ","date":"2022-01-06 08:18:50","objectID":"https://qizhengzou.github.io/algorithm_string/:5:2","tags":["data structure"],"title":"Algorithm_string","uri":"https://qizhengzou.github.io/algorithm_string/"},{"categories":["Coding"],"content":"前缀表统一减一之后的next数组： 时间复杂度分析： 其中n为文本串长度，m为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是$O(n)$，之前还要单独生成next数组，时间复杂度是$O(m)$。所以整个KMP算法的时间复杂度是$O(n+m)$的。 暴力的解法显而易见是$O(n × m)$，所以KMP在字符串匹配中极大的提高的搜索的效率。 为了和力扣题目28.实现strStr保持一致，方便大家理解，以下文章统称haystack为文本串, needle为模式串。 都知道使用KMP算法，一定要构造next数组 构造next数组： 我们定义一个函数getNext来构建next数组，函数参数为指向next数组的指针，和一个字符串。 代码如下： void getNext(int* next, const string\u0026 s) 构造next数组其实就是计算模式串s，前缀表的过程。 主要有如下三步： 初始化 定义两个指针i和j，j指向前缀起始位置，i指向后缀起始位置。 然后还要对next数组进行初始化赋值，如下： int j = -1; next[0] = j; j 为什么要初始化为 -1呢，因为之前说过 前缀表要统一减一的操作仅仅是其中的一种实现，我们这里选择j初始化为-1，下文我还会给出j不初始化为-1的实现代码。 next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j） 所以初始化next[0] = j 。 处理前后缀不相同的情况 因为j初始化为-1，那么i就从1开始，进行s[i] 与 s[j+1]的比较。 所以遍历模式串s的循环下标i 要从 1开始，代码如下： for(int i = 1; i \u003c s.size(); i++) { 如果 s[i] 与 s[j+1]不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退。 怎么回退呢？ next[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。 那么 s[i] 与 s[j+1] 不相同，就要找 j+1前一个元素在next数组里的值（就是next[j]）。 所以，处理前后缀不相同的情况代码如下： while (j \u003e= 0 \u0026\u0026 s[i] != s[j + 1]) { // 前后缀不相同了 j = next[j]; // 向前回退 } 处理前后缀相同的情况 如果s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。 代码如下： if (s[i] == s[j + 1]) { // 找到相同的前后缀 j++; } next[i] = j; 最后整体构建next数组的函数代码如下： void getNext(int* next, const string\u0026 s){ int j = -1; next[0] = j; for(int i = 1; i \u003c s.size(); i++) { // 注意i从1开始 while (j \u003e= 0 \u0026\u0026 s[i] != s[j + 1]) { // 前后缀不相同了 j = next[j]; // 向前回退 } if (s[i] == s[j + 1]) { // 找到相同的前后缀 j++; } next[i] = j; // 将j（前缀的长度）赋给next[i] } } 使用next数组进行匹配 在文本串s里 找是否出现过模式串t。 定义两个下标j 指向模式串起始位置，i指向文本串起始位置。 那么j初始值依然为-1，为什么呢？ 依然因为next数组里记录的起始位置为-1。 i就从0开始，遍历文本串，代码如下： for (int i = 0; i \u003c s.size(); i++) 接下来就是 s[i] 与 t[j + 1] （因为j从-1开始的） 进行比较。 如果 s[i] 与 t[j + 1] 不相同，j就要从next数组里寻找下一个匹配的位置。 代码如下： while(j \u003e= 0 \u0026\u0026 s[i] != t[j + 1]) { j = next[j]; } 如果 s[i] 与 t[j + 1] 相同，那么i 和 j 同时向后移动， 代码如下： if (s[i] == t[j + 1]) { j++; // i的增加在for循环里 } 如何判断在文本串s里出现了模式串t呢，如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了。 本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。 代码如下： if (j == (t.size() - 1) ) { return (i - t.size() + 1); } 那么使用next数组，用模式串匹配文本串的整体代码如下： int j = -1; // 因为next数组里记录的起始位置为-1 for (int i = 0; i \u003c s.size(); i++) { // 注意i就从0开始 while(j \u003e= 0 \u0026\u0026 s[i] != t[j + 1]) { // 不匹配 j = next[j]; // j 寻找之前匹配的位置 } if (s[i] == t[j + 1]) { // 匹配，j和i同时向后移动 j++; // i的增加在for循环里 } if (j == (t.size() - 1) ) { // 文本串s里出现了模式串t return (i - t.size() + 1); } } 此时所有逻辑的代码都已经写出来了，力扣 28.实现strStr 题目的整体代码如下： class Solution { public: void getNext(int* next, const string\u0026 s) { int j = -1; next[0] = j; for(int i = 1; i \u003c s.size(); i++) { // 注意i从1开始 while (j \u003e= 0 \u0026\u0026 s[i] != s[j + 1]) { // 前后缀不相同了 j = next[j]; // 向前回退 } if (s[i] == s[j + 1]) { // 找到相同的前后缀 j++; } next[i] = j; // 将j（前缀的长度）赋给next[i] } } int strStr(string haystack, string needle) { if (needle.size() == 0) { return 0; } int next[needle.size()]; getNext(next, needle); int j = -1; // // 因为next数组里记录的起始位置为-1 for (int i = 0; i \u003c haystack.size(); i++) { // 注意i就从0开始 while(j \u003e= 0 \u0026\u0026 haystack[i] != needle[j + 1]) { // 不匹配 j = next[j]; // j 寻找之前匹配的位置 } if (haystack[i] == needle[j + 1]) { // 匹配，j和i同时向后移动 j++; // i的增加在for循环里 } if (j == (needle.size() - 1) ) { // 文本串s里出现了模式串t return (i - needle.size() + 1); } } return -1; } }; ","date":"2022-01-06 08:18:50","objectID":"https://qizhengzou.github.io/algorithm_string/:5:3","tags":["data structure"],"title":"Algorithm_string","uri":"https://qizhengzou.github.io/algorithm_string/"},{"categories":["Coding"],"content":"前缀表不减一的next数组： 直接使用前缀表可以换一种回退方式，找j=next[j-1] 来进行回退。 主要就是j=next[x]这一步最为关键！ 构建next数组： void getNext(int* next, const string\u0026 s) { int j = 0; next[0] = 0; for(int i = 1; i \u003c s.size(); i++) { while (j \u003e 0 \u0026\u0026 s[i] != s[j]) { // j要保证大于0，因为下面有取j-1作为数组下标的操作 j = next[j - 1]; // 注意这里，是要找前一位的对应的回退位置了 } if (s[i] == s[j]) { j++; } next[i] = j; } } 使用next数组进行匹配： class Solution { public: void getNext(int* next, const string\u0026 s) { int j = 0; next[0] = 0; for(int i = 1; i \u003c s.size(); i++) { while (j \u003e 0 \u0026\u0026 s[i] != s[j]) { j = next[j - 1]; } if (s[i] == s[j]) { j++; } next[i] = j; } } int strStr(string haystack, string needle) { if (needle.size() == 0) { return 0; } int next[needle.size()]; getNext(next, needle); int j = 0; for (int i = 0; i \u003c haystack.size(); i++) { while(j \u003e 0 \u0026\u0026 haystack[i] != needle[j]) { j = next[j - 1]; } if (haystack[i] == needle[j]) { j++; } if (j == needle.size() ) { return (i - needle.size() + 1); } } return -1; } }; ","date":"2022-01-06 08:18:50","objectID":"https://qizhengzou.github.io/algorithm_string/:5:4","tags":["data structure"],"title":"Algorithm_string","uri":"https://qizhengzou.github.io/algorithm_string/"},{"categories":["Coding"],"content":"kmp总结 介绍了什么是KMP，KMP可以解决什么问题，然后分析KMP算法里的next数组，知道了next数组就是前缀表，再分析为什么要是前缀表而不是什么其他表。 接着从给出的模式串中，我们一步一步的推导出了前缀表，得出前缀表无论是统一减一还是不减一得到的next数组仅仅是kmp的实现方式的不同。 其中还分析了KMP算法的时间复杂度，并且和暴力方法做了对比。 然后先用前缀表统一减一得到的next数组，求得文本串s里是否出现过模式串t，并给出了具体分析代码。 又给出了直接用前缀表作为next数组，来做匹配的实现代码。 可以说把KMP的每一个细微的细节都扣了出来，毫无遮掩的展示给大家了 go实现： // 方法一:前缀表使用减1实现 // getNext 构造前缀表next // params: // next 前缀表数组 // s 模式串 func getNext(next []int, s string) { j := -1 // j表示 最长相等前后缀长度 next[0] = j for i := 1; i \u003c len(s); i++ { for j \u003e= 0 \u0026\u0026 s[i] != s[j+1] { j = next[j] // 回退前一位 } if s[i] == s[j+1] { j++ } next[i] = j // next[i]是i（包括i）之前的最长相等前后缀长度 } } func strStr(haystack string, needle string) int { if len(needle) == 0 { return 0 } next := make([]int, len(needle)) getNext(next, needle) j := -1 // 模式串的起始位置 next为-1 因此也为-1 for i := 0; i \u003c len(haystack); i++ { for j \u003e= 0 \u0026\u0026 haystack[i] != needle[j+1] { j = next[j] // 寻找下一个匹配点 } if haystack[i] == needle[j+1] { j++ } if j == len(needle)-1 { // j指向了模式串的末尾 return i - len(needle) + 1 } } return -1 } // 方法二: 前缀表无减一或者右移 // getNext 构造前缀表next // params: // next 前缀表数组 // s 模式串 func getNext(next []int, s string) { j := 0 next[0] = j for i := 1; i \u003c len(s); i++ { for j \u003e 0 \u0026\u0026 s[i] != s[j] { j = next[j-1] } if s[i] == s[j] { j++ } next[i] = j } } func strStr(haystack string, needle string) int { n := len(needle) if n == 0 { return 0 } j := 0 next := make([]int, n) getNext(next, needle) for i := 0; i \u003c len(haystack); i++ { for j \u003e 0 \u0026\u0026 haystack[i] != needle[j] { j = next[j-1] // 回退到j的前一位 } if haystack[i] == needle[j] { j++ } if j == n { return i - n + 1 } } return -1 } ","date":"2022-01-06 08:18:50","objectID":"https://qizhengzou.github.io/algorithm_string/:5:5","tags":["data structure"],"title":"Algorithm_string","uri":"https://qizhengzou.github.io/algorithm_string/"},{"categories":["Coding"],"content":"重复的子字符串 给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。 示例 1: 输入: \"abab\" 输出: True 解释: 可由子字符串 \"ab\" 重复两次构成。 示例 2: 输入: \"aba\" 输出: False 示例 3: 输入: \"abcabcabcabc\" 输出: True 解释: 可由子字符串 \"abc\" 重复四次构成。 (或者子字符串 \"abcabc\" 重复两次构成。) 标准的KMP题目~ 数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。 强烈建议大家把next数组打印出来，看看next数组里的规律，有助于理解KMP算法 代码实现： //前缀表统一减一的实现 func repeatedSubstringPattern(s string) bool { n := len(s) if n == 0 { return false } next := make([]int, n) j := -1 next[0] = j for i := 1; i \u003c n; i++ { for j \u003e= 0 \u0026\u0026 s[i] != s[j+1] { j = next[j] } if s[i] == s[j+1] { j++ } next[i] = j } // next[n-1]+1 最长相同前后缀的长度 if next[n-1] != -1 \u0026\u0026 n%(n-(next[n-1]+1)) == 0 { return true } return false } //前缀表不减一 func repeatedSubstringPattern(s string) bool { n := len(s) if n == 0 { return false } j := 0 next := make([]int, n) next[0] = j for i := 1; i \u003c n; i++ { for j \u003e 0 \u0026\u0026 s[i] != s[j] { j = next[j-1] } if s[i] == s[j] { j++ } next[i] = j } // next[n-1] 最长相同前后缀的长度 if next[n-1] != 0 \u0026\u0026 n%(n-next[n-1]) == 0 { return true } return false } ","date":"2022-01-06 08:18:50","objectID":"https://qizhengzou.github.io/algorithm_string/:6:0","tags":["data structure"],"title":"Algorithm_string","uri":"https://qizhengzou.github.io/algorithm_string/"},{"categories":["Coding"],"content":" 学习代码随想录笔记 哈希表 ","date":"2022-01-06 08:18:30","objectID":"https://qizhengzou.github.io/algorithm_hashtable/:0:0","tags":["data structure"],"title":"Algorithm_hashTable","uri":"https://qizhengzou.github.io/algorithm_hashtable/"},{"categories":["Coding"],"content":"哈希表理论基础 哈希表是根据关键码的值而直接进行访问的数据结构，比如数组、map（映射）、set（集合）。 一般用来快速判断一个元素是否出现在集合里。 比如把字符串映射为索引的例子： 通过哈希函数/hashCode将字符串转化为数值 如果得到的数值大于哈希表的大小了，取模，保证所有字符串映射到哈希表上。 如果字符串数量都大于哈希表的大小了，会出现同一索引不同字符串的情况。也称，哈希碰撞。 解决哈希碰撞： 拉链法 发生冲突的元素用链表存储 要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。 线性探测法 保证tableSize大于dataSize，避免碰撞。 ","date":"2022-01-06 08:18:30","objectID":"https://qizhengzou.github.io/algorithm_hashtable/:1:0","tags":["data structure"],"title":"Algorithm_hashTable","uri":"https://qizhengzou.github.io/algorithm_hashtable/"},{"categories":["Coding"],"content":"有效的字母异位词 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 示例 1: 输入: s = “anagram”, t = “nagaram” 输出: true 示例 2: 输入: s = “rat”, t = “car” 输出: false 说明: 你可以假设字符串只包含小写字母。 func isAnagram(s string, t string) bool { if len(s)!=len(t){ return false } exists := make(map[byte]int) for i:=0;i\u003clen(s);i++{ if v,ok:=exists[s[i]];v\u003e=0\u0026\u0026ok{ exists[s[i]]=v+1 }else{ exists[s[i]]=1 } } for i:=0;i\u003clen(t);i++{ if v,ok:=exists[t[i]];v\u003e=1\u0026\u0026ok{ exists[t[i]]=v-1 }else{ return false } } return true } ","date":"2022-01-06 08:18:30","objectID":"https://qizhengzou.github.io/algorithm_hashtable/:2:0","tags":["data structure"],"title":"Algorithm_hashTable","uri":"https://qizhengzou.github.io/algorithm_hashtable/"},{"categories":["Coding"],"content":"两个数组的交集 使用数组来做哈希的题目，是因为题目都限制了数值的大小。 而这道题目没有限制数值的大小，就无法使用数组来做哈希表了。 func intersection(nums1 []int, nums2 []int) []int { m := make(map[int]int) for _, v := range nums1 { m[v] = 1 } var res []int // 利用count\u003e0，实现重复值只拿一次放入返回结果中 for _, v := range nums2 { if count, ok := m[v]; ok \u0026\u0026 count \u003e 0 { res = append(res, v) m[v]-- } } return res } //优化版，利用set，减少count统计 func intersection(nums1 []int, nums2 []int) []int { set:=make(map[int]struct{},0) res:=make([]int,0) for _,v:=range nums1{ if _,ok:=set[v];!ok{ set[v]=struct{}{} } } for _,v:=range nums2{ //如果存在于上一个数组中，则加入结果集，并清空该set值 if _,ok:=set[v];ok{ res=append(res,v) delete(set, v) } } return res } ","date":"2022-01-06 08:18:30","objectID":"https://qizhengzou.github.io/algorithm_hashtable/:3:0","tags":["data structure"],"title":"Algorithm_hashTable","uri":"https://qizhengzou.github.io/algorithm_hashtable/"},{"categories":["Coding"],"content":"快乐数 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。 如果 n 是快乐数就返回 True ；不是，则返回 False 。 示例： 输入：19 输出：true 解释： 1^2 + 9^2 = 82 8^2 + 2^2 = 68 6^2 + 8^2 = 100 1^2 + 0^2 + 0^2 = 1 func isHappy(n int) bool { m := make(map[int]bool) for n != 1 \u0026\u0026 !m[n] { n, m[n] = getSum(n), true } return n == 1 } func getSum(n int) int { sum := 0 for n \u003e 0 { sum += (n % 10) * (n % 10) n = n / 10 } return sum } ","date":"2022-01-06 08:18:30","objectID":"https://qizhengzou.github.io/algorithm_hashtable/:4:0","tags":["data structure"],"title":"Algorithm_hashTable","uri":"https://qizhengzou.github.io/algorithm_hashtable/"},{"categories":["Coding"],"content":"两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] func twoSum(nums []int, target int) []int { for k1, _ := range nums { for k2 := k1 + 1; k2 \u003c len(nums); k2++ { if target == nums[k1] + nums[k2] { return []int{k1, k2} } } } return []int{} } // 使用map方式解题，降低时间复杂度 func twoSum(nums []int, target int) []int { m := make(map[int]int) for index, val := range nums { if preIndex, ok := m[target-val]; ok { return []int{preIndex, index} } else { m[val] = index } } return []int{} } ","date":"2022-01-06 08:18:30","objectID":"https://qizhengzou.github.io/algorithm_hashtable/:5:0","tags":["data structure"],"title":"Algorithm_hashTable","uri":"https://qizhengzou.github.io/algorithm_hashtable/"},{"categories":["Coding"],"content":"四数相加II 给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。 为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。 例如: 输入: A = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2] 输出: 2 解释: 两个元组如下: (0, 0, 0, 1) -\u003e A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 (1, 1, 0, 0) -\u003e A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 func fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int { m := make(map[int]int) count := 0 for _, v1 := range nums1 { for _, v2 := range nums2 { m[v1+v2]++ } } for _, v3 := range nums3 { for _, v4 := range nums4 { count += m[-v3-v4] } } return count } ","date":"2022-01-06 08:18:30","objectID":"https://qizhengzou.github.io/algorithm_hashtable/:6:0","tags":["data structure"],"title":"Algorithm_hashTable","uri":"https://qizhengzou.github.io/algorithm_hashtable/"},{"categories":["Coding"],"content":"赎金信 给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。 (题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。) 注意： 你可以假设两个字符串均只含有小写字母。 canConstruct(“a”, “b”) -\u003e false canConstruct(“aa”, “ab”) -\u003e false canConstruct(“aa”, “aab”) -\u003e true func canConstruct(ransomNote string, magazine string) bool { record := make([]int, 26) for _, v := range magazine { record[v-'a']++ } for _, v := range ransomNote { record[v-'a']-- if record[v-'a'] \u003c 0 { return false } } return true } ","date":"2022-01-06 08:18:30","objectID":"https://qizhengzou.github.io/algorithm_hashtable/:7:0","tags":["data structure"],"title":"Algorithm_hashTable","uri":"https://qizhengzou.github.io/algorithm_hashtable/"},{"categories":["Coding"],"content":"三数之和 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意： 答案中不可以包含重复的三元组。 示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ] 解法：哈希、双指针（更高效） func threeSum(nums []int)[][]int{ sort.Ints(nums) res:=[][]int{} for i:=0;i\u003clen(nums)-2;i++{ n1:=nums[i] if n1\u003e0{ break } if i\u003e0\u0026\u0026n1==nums[i-1]{ continue } l,r:=i+1,len(nums)-1 for l\u003cr{ n2,n3:=nums[l],nums[r] if n1+n2+n3==0{ res=append(res,[]int{n1,n2,n3}) for l\u003cr\u0026\u0026nums[l]==n2{ l++ } for l\u003cr\u0026\u0026nums[r]==n3{ r-- } }else if n1+n2+n3\u003c0{ l++ }else { r-- } } } return res } ","date":"2022-01-06 08:18:30","objectID":"https://qizhengzou.github.io/algorithm_hashtable/:8:0","tags":["data structure"],"title":"Algorithm_hashTable","uri":"https://qizhengzou.github.io/algorithm_hashtable/"},{"categories":["Coding"],"content":"四数之和 题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] func fourSum(nums []int, target int) [][]int { if len(nums) \u003c 4 { return nil } sort.Ints(nums) var res [][]int for i := 0; i \u003c len(nums)-3; i++ { n1 := nums[i] // if n1 \u003e target { // 不能这样写,因为可能是负数 // break // } if i \u003e 0 \u0026\u0026 n1 == nums[i-1] { continue } for j := i + 1; j \u003c len(nums)-2; j++ { n2 := nums[j] if j \u003e i+1 \u0026\u0026 n2 == nums[j-1] { continue } l := j + 1 r := len(nums) - 1 for l \u003c r { n3 := nums[l] n4 := nums[r] sum := n1 + n2 + n3 + n4 if sum \u003c target { l++ } else if sum \u003e target { r-- } else { res = append(res, []int{n1, n2, n3, n4}) for l \u003c r \u0026\u0026 n3 == nums[l+1] { // 去重 l++ } for l \u003c r \u0026\u0026 n4 == nums[r-1] { // 去重 r-- } // 找到答案时,双指针同时靠近 r-- l++ } } } } return res } ","date":"2022-01-06 08:18:30","objectID":"https://qizhengzou.github.io/algorithm_hashtable/:9:0","tags":["data structure"],"title":"Algorithm_hashTable","uri":"https://qizhengzou.github.io/algorithm_hashtable/"},{"categories":["Coding"],"content":" 学习代码随想录笔记 链表 ","date":"2022-01-06 08:18:06","objectID":"https://qizhengzou.github.io/algorithm_linkedlist/:0:0","tags":["data structure"],"title":"Algorithm_linkedList","uri":"https://qizhengzou.github.io/algorithm_linkedlist/"},{"categories":["Coding"],"content":"链表理论基础 循环链表可以用来解决约瑟夫环问题。 链表和数组对比： 数组 插入删除时间复杂度：$O(n)$ 查询时间复杂度：$O(1)$ 适用场景：数据量固定，频繁查询，较少增删 链表 插入删除时间复杂度：$O(1)$ 查询时间复杂度：$O(n)$ 适用场景：数据量不固定，频繁增删，较少查询 ","date":"2022-01-06 08:18:06","objectID":"https://qizhengzou.github.io/algorithm_linkedlist/:1:0","tags":["data structure"],"title":"Algorithm_linkedList","uri":"https://qizhengzou.github.io/algorithm_linkedlist/"},{"categories":["Coding"],"content":"移除链表元素 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeElements(head *ListNode, val int) *ListNode { dummyHead := \u0026ListNode{} dummyHead.Next = head cur := dummyHead for cur != nil \u0026\u0026 cur.Next != nil { if cur.Next.Val == val { cur.Next = cur.Next.Next } else { cur = cur.Next } } return dummyHead.Next } //如果是c或者c++要在删除后free或者delete掉节点释放内存，java,python,go都会自动回收 另外，移除头节点的话，如果没有虚拟头节点，将头节点往后移一个节点，有虚拟头节点就一般删除节点即可。 ","date":"2022-01-06 08:18:06","objectID":"https://qizhengzou.github.io/algorithm_linkedlist/:2:0","tags":["data structure"],"title":"Algorithm_linkedList","uri":"https://qizhengzou.github.io/algorithm_linkedlist/"},{"categories":["Coding"],"content":"设计链表 设计五个接口： 获取链表第index个节点的数值 在链表的最前面插入一个节点 在链表的最后面插入一个节点 在链表第index个节点前面插入一个节点 删除链表的第index个节点 链表操作的两种方式： 直接使用原来的链表来进行操作。 设置一个虚拟头结点在进行操作。（更方便一点） //循环双链表 type MyLinkedList struct { dummy *Node } type Node struct { Val int Next *Node Pre *Node } //仅保存哑节点，pre-\u003e rear, next-\u003e head /** Initialize your data structure here. */ func Constructor() MyLinkedList { rear := \u0026Node{ Val: -1, Next: nil, Pre: nil, } rear.Next = rear rear.Pre = rear return MyLinkedList{rear} } /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */ func (this *MyLinkedList) Get(index int) int { head := this.dummy.Next //head == this, 遍历完全 for head != this.dummy \u0026\u0026 index \u003e 0 { index-- head = head.Next } //否则, head == this, 索引无效 if 0 != index { return -1 } return head.Val } /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */ func (this *MyLinkedList) AddAtHead(val int) { dummy := this.dummy node := \u0026Node{ Val: val, //head.Next指向原头节点 Next: dummy.Next, //head.Pre 指向哑节点 Pre: dummy, } //更新原头节点 dummy.Next.Pre = node //更新哑节点 dummy.Next = node //以上两步不能反 } /** Append a node of value val to the last element of the linked list. */ func (this *MyLinkedList) AddAtTail(val int) { dummy := this.dummy rear := \u0026Node{ Val: val, //rear.Next = dummy(哑节点) Next: dummy, //rear.Pre = ori_rear Pre: dummy.Pre, } //ori_rear.Next = rear dummy.Pre.Next = rear //update dummy dummy.Pre = rear //以上两步不能反 } /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */ func (this *MyLinkedList) AddAtIndex(index int, val int) { head := this.dummy.Next //head = MyLinkedList[index] for head != this.dummy \u0026\u0026 index \u003e 0 { head = head.Next index-- } if index \u003e 0 { return } node := \u0026Node{ Val: val, //node.Next = MyLinkedList[index] Next: head, //node.Pre = MyLinkedList[index-1] Pre: head.Pre, } //MyLinkedList[index-1].Next = node head.Pre.Next = node //MyLinkedList[index].Pre = node head.Pre = node //以上两步不能反 } /** Delete the index-th node in the linked list, if the index is valid. */ func (this *MyLinkedList) DeleteAtIndex(index int) { //链表为空 if this.dummy.Next == this.dummy { return } head := this.dummy.Next //head = MyLinkedList[index] for head.Next != this.dummy \u0026\u0026 index \u003e 0 { head = head.Next index-- } //验证index有效 if index == 0 { //MyLinkedList[index].Pre = index[index-2] head.Next.Pre = head.Pre //MyLinedList[index-2].Next = index[index] head.Pre.Next = head.Next //以上两步顺序无所谓 } } ","date":"2022-01-06 08:18:06","objectID":"https://qizhengzou.github.io/algorithm_linkedlist/:3:0","tags":["data structure"],"title":"Algorithm_linkedList","uri":"https://qizhengzou.github.io/algorithm_linkedlist/"},{"categories":["Coding"],"content":"翻转链表 //双指针 func reverseList(head *ListNode) *ListNode { var pre *ListNode cur := head for cur != nil { next := cur.Next cur.Next = pre pre = cur cur = next } return pre } //递归 func reverseList(head *ListNode) *ListNode { return help(nil, head) } func help(pre, head *ListNode)*ListNode{ if head == nil { return pre } next := head.Next head.Next = pre return help(head, next) } ","date":"2022-01-06 08:18:06","objectID":"https://qizhengzou.github.io/algorithm_linkedlist/:4:0","tags":["data structure"],"title":"Algorithm_linkedList","uri":"https://qizhengzou.github.io/algorithm_linkedlist/"},{"categories":["Coding"],"content":"两两交换链表中的节点 正常模拟，使用虚拟头节点。 func swapPairs(head *ListNode) *ListNode { dummy := \u0026ListNode{ Next: head, } //head=list[i] //pre=list[i-1] pre := dummy for head != nil \u0026\u0026 head.Next != nil { pre.Next = head.Next next := head.Next.Next head.Next.Next = head head.Next = next //pre=list[(i+2)-1] pre = head //head=list[(i+2)] head = next } return dummy.Next } // 递归版本 func swapPairs(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } next := head.Next head.Next = swapPairs(next.Next) next.Next = head return next } ","date":"2022-01-06 08:18:06","objectID":"https://qizhengzou.github.io/algorithm_linkedlist/:5:0","tags":["data structure"],"title":"Algorithm_linkedList","uri":"https://qizhengzou.github.io/algorithm_linkedlist/"},{"categories":["Coding"],"content":"删除链表的倒数第N个节点 双指针很好做： /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeNthFromEnd(head *ListNode, n int) *ListNode { dummyHead := \u0026ListNode{} dummyHead.Next = head cur := head prev := dummyHead i := 1 for cur != nil { cur = cur.Next if i \u003e n { prev = prev.Next } i++ } prev.Next = prev.Next.Next return dummyHead.Next } ","date":"2022-01-06 08:18:06","objectID":"https://qizhengzou.github.io/algorithm_linkedlist/:6:0","tags":["data structure"],"title":"Algorithm_linkedList","uri":"https://qizhengzou.github.io/algorithm_linkedlist/"},{"categories":["Coding"],"content":"链表相交 func getIntersectionNode(headA, headB *ListNode) *ListNode { curA := headA curB := headB lenA, lenB := 0, 0 // 求A，B的长度 for curA != nil { curA = curA.Next lenA++ } for curB != nil { curB = curB.Next lenB++ } var step int var fast, slow *ListNode // 请求长度差，并且让更长的链表先走相差的长度 if lenA \u003e lenB { step = lenA - lenB fast, slow = headA, headB } else { step = lenB - lenA fast, slow = headB, headA } for i:=0; i \u003c step; i++ { fast = fast.Next } // 遍历两个链表遇到相同则跳出遍历 for fast != slow { fast = fast.Next slow = slow.Next } return fast } ","date":"2022-01-06 08:18:06","objectID":"https://qizhengzou.github.io/algorithm_linkedlist/:7:0","tags":["data structure"],"title":"Algorithm_linkedList","uri":"https://qizhengzou.github.io/algorithm_linkedlist/"},{"categories":["Coding"],"content":"环形链表II 第一次做有点难~ 判断是否有环：快慢指针法 如何确定环的入口：一个简单的数学题 func detectCycle(head *ListNode) *ListNode { slow, fast := head, head for fast != nil \u0026\u0026 fast.Next != nil { slow = slow.Next fast = fast.Next.Next if slow == fast { for slow != head { slow = slow.Next head = head.Next } return head } } return nil } ","date":"2022-01-06 08:18:06","objectID":"https://qizhengzou.github.io/algorithm_linkedlist/:8:0","tags":["data structure"],"title":"Algorithm_linkedList","uri":"https://qizhengzou.github.io/algorithm_linkedlist/"},{"categories":["Coding"],"content":" 学习代码随想录笔记 数组 ","date":"2022-01-06 08:17:33","objectID":"https://qizhengzou.github.io/algorithm_array/:0:0","tags":["data structure"],"title":"Algorithm_array","uri":"https://qizhengzou.github.io/algorithm_array/"},{"categories":["Coding"],"content":"数组基础 数组是存放在连续内存空间上的相同类型数据的集合。 因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。 数组元素无法删除，只能覆盖。 ","date":"2022-01-06 08:17:33","objectID":"https://qizhengzou.github.io/algorithm_array/:1:0","tags":["data structure"],"title":"Algorithm_array","uri":"https://qizhengzou.github.io/algorithm_array/"},{"categories":["Coding"],"content":"二分查找 有序数组、无重复元素便可想到用二分法查找。注意区间左闭右闭还是左闭右开。 简单实现： func search(nums []int, target int) int { left := 0 right := len(nums) - 1 for left \u003c= right { middle := left + (right - left)/2 if nums[middle] \u003e target { right = middle - 1 }else if nums[middle] \u003c target { left = middle + 1 }else{ return middle; } } return -1 } ","date":"2022-01-06 08:17:33","objectID":"https://qizhengzou.github.io/algorithm_array/:2:0","tags":["data structure"],"title":"Algorithm_array","uri":"https://qizhengzou.github.io/algorithm_array/"},{"categories":["Coding"],"content":"移除元素 双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。 func removeElement(nums []int, val int) int { length:=len(nums) res:=0 for i:=0;i\u003clength;i++{ if nums[i]!=val { nums[res]=nums[i] res++ } } return res } func removeElement(nums []int, val int) int { //自己第一次写的解 num := 0 for i, v := range nums { if v == val { num++ } else { nums[i-num] = v } } return len(nums)-num } ","date":"2022-01-06 08:17:33","objectID":"https://qizhengzou.github.io/algorithm_array/:3:0","tags":["data structure"],"title":"Algorithm_array","uri":"https://qizhengzou.github.io/algorithm_array/"},{"categories":["Coding"],"content":"有序数组的平方 双指针法： func sortedSquares(nums []int) []int { n := len(nums) i, j, k := 0, n-1, n-1 ans := make([]int, n) for i \u003c= j { lm, rm := nums[i]*nums[i], nums[j]*nums[j] if lm \u003e rm { ans[k] = lm i++ } else { ans[k] = rm j-- } k-- } return ans } ","date":"2022-01-06 08:17:33","objectID":"https://qizhengzou.github.io/algorithm_array/:4:0","tags":["data structure"],"title":"Algorithm_array","uri":"https://qizhengzou.github.io/algorithm_array/"},{"categories":["Coding"],"content":"长度最小的子数组 滑动窗口 func minSubArrayLen(target int, nums []int) int { i := 0 l := len(nums) // 数组长度 sum := 0 // 子数组之和 result := l + 1 // 初始化返回长度为l+1，目的是为了判断“不存在符合条件的子数组，返回0”的情况 for j := 0; j \u003c l; j++ { sum += nums[j] for sum \u003e= target { subLength := j - i + 1 if subLength \u003c result { result = subLength } sum -= nums[i] i++ } } if result == l+1 { return 0 } else { return result } } ","date":"2022-01-06 08:17:33","objectID":"https://qizhengzou.github.io/algorithm_array/:5:0","tags":["data structure"],"title":"Algorithm_array","uri":"https://qizhengzou.github.io/algorithm_array/"},{"categories":["Coding"],"content":"螺旋矩阵II 模拟行为： func generateMatrix(n int) [][]int { top, bottom := 0, n-1 left, right := 0, n-1 num := 1 tar := n * n matrix := make([][]int, n) for i := 0; i \u003c n; i++ { matrix[i] = make([]int, n) } for num \u003c= tar { for i := left; i \u003c= right; i++ { matrix[top][i] = num num++ } top++ for i := top; i \u003c= bottom; i++ { matrix[i][right] = num num++ } right-- for i := right; i \u003e= left; i-- { matrix[bottom][i] = num num++ } bottom-- for i := bottom; i \u003e= top; i-- { matrix[i][left] = num num++ } left++ } return matrix } ","date":"2022-01-06 08:17:33","objectID":"https://qizhengzou.github.io/algorithm_array/:6:0","tags":["data structure"],"title":"Algorithm_array","uri":"https://qizhengzou.github.io/algorithm_array/"},{"categories":["Coding"],"content":"总结 ","date":"2022-01-06 08:17:33","objectID":"https://qizhengzou.github.io/algorithm_array/:7:0","tags":["data structure"],"title":"Algorithm_array","uri":"https://qizhengzou.github.io/algorithm_array/"},{"categories":["Coding"],"content":"算法性能分析 ","date":"2022-01-02 19:28:23","objectID":"https://qizhengzou.github.io/performance_analysis/:0:0","tags":["data structure"],"title":"Performance_analysis","uri":"https://qizhengzou.github.io/performance_analysis/"},{"categories":["Coding"],"content":"时间复杂度 时间复杂度是定性描述算法运行时间的函数。 实际情况中会因为数据用例、数据规模不同而变化，一般讨论一般情况。 时间复杂度$O(log(n))$并不以某一个确定的数为底数，因为可以通过乘以某个对数常数达到换底数的效果。 递归算法的时间复杂度：递归次数*每次递归的时间复杂度（操作的次数） ","date":"2022-01-02 19:28:23","objectID":"https://qizhengzou.github.io/performance_analysis/:1:0","tags":["data structure"],"title":"Performance_analysis","uri":"https://qizhengzou.github.io/performance_analysis/"},{"categories":["Coding"],"content":"空间复杂度分析 空间复杂度：程序运行时占用内存的大小，受很多因素的影响，比如编译器的内存对齐，编程语言容器的底层实现等 递归算法的空间复杂度：递归深度*每次递归的空间复杂度 递归所需的空间都被压到调用栈里，一次递归结束，这个栈就是就是把本次递归的数据弹出去。所以这个栈最大的长度就是递归的深度。 ","date":"2022-01-02 19:28:23","objectID":"https://qizhengzou.github.io/performance_analysis/:2:0","tags":["data structure"],"title":"Performance_analysis","uri":"https://qizhengzou.github.io/performance_analysis/"},{"categories":["Coding"],"content":"代码的内存消耗 每种语言都有着自己的内存管理方式。 ","date":"2022-01-02 19:28:23","objectID":"https://qizhengzou.github.io/performance_analysis/:3:0","tags":["data structure"],"title":"Performance_analysis","uri":"https://qizhengzou.github.io/performance_analysis/"},{"categories":["Coding"],"content":"内存对齐 为什么会有内存对齐？ 平台原因：不是所有的硬件平台都能访问任意内存地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。为了同一个程序可以在多平台运行，需要内存对齐。 硬件原因：经过内存对齐后，CPU访问内存的速度大大提升 CPU读取内存不是一次读取单个字节，而是一块一块的来读取内存，块的大小可以是2，4，8，16个字节，具体取多少个字节取决于硬件。 只要可以跨平台的编程语言都需要做内存对齐，不做内存对齐会使运行速度下降，因为寻址访存次数多了。现在的编译器一般都会做内存对齐的优化操作，也就是说当考虑程序真正占用的内存大小的时候，也需要认识到内存对齐的影响。 ","date":"2022-01-02 19:28:23","objectID":"https://qizhengzou.github.io/performance_analysis/:3:1","tags":["data structure"],"title":"Performance_analysis","uri":"https://qizhengzou.github.io/performance_analysis/"},{"categories":["Coding"],"content":"go语言的内存管理 ","date":"2022-01-02 19:28:23","objectID":"https://qizhengzou.github.io/performance_analysis/:3:2","tags":["data structure"],"title":"Performance_analysis","uri":"https://qizhengzou.github.io/performance_analysis/"},{"categories":["Coding"],"content":"编程相关 ","date":"2022-01-02 18:57:57","objectID":"https://qizhengzou.github.io/programming_literacy/:0:0","tags":["data structure"],"title":"Programming_literacy","uri":"https://qizhengzou.github.io/programming_literacy/"},{"categories":["Coding"],"content":"代码风格与规范 go其实没有什么要说的。。 ","date":"2022-01-02 18:57:57","objectID":"https://qizhengzou.github.io/programming_literacy/:1:0","tags":["data structure"],"title":"Programming_literacy","uri":"https://qizhengzou.github.io/programming_literacy/"},{"categories":["Coding"],"content":"变量命名 主要以团队风格为主； 主流有如下三种变量规则： 小驼峰、大驼峰(帕斯卡命名法)命名法（java,go） 下划线命名法(python,linux下的c/c++编程) 匈牙利命名法 该命名规范，要求前缀字母用变量类型的缩写，其余部分用变量的英文或英文的缩写，单词第一个字母大写。（很少用，在windows下的c/c++编程有时会用,没有IDE的时代挺好） int iMyAge; // \"i\": int char cMyName[10]; // \"c\": char float fManHeight; // \"f\": float ","date":"2022-01-02 18:57:57","objectID":"https://qizhengzou.github.io/programming_literacy/:1:1","tags":["data structure"],"title":"Programming_literacy","uri":"https://qizhengzou.github.io/programming_literacy/"},{"categories":["Coding"],"content":"核心代码模式和ACM模式 核心代码模式： 把要处理的数据都已经放入容器里，可以直接写逻辑 ACM输入模式呢： 自己构造输入数据格式，把要需要处理的容器填充好，不会给你任何代码，包括include哪些函数都要自己写，最后也要自己控制返回数据的格式。 ","date":"2022-01-02 18:57:57","objectID":"https://qizhengzou.github.io/programming_literacy/:1:2","tags":["data structure"],"title":"Programming_literacy","uri":"https://qizhengzou.github.io/programming_literacy/"},{"categories":["School courses"],"content":" 2021哈工大深圳堵宏伟分布式系统课程笔记 topics Understanding lecture notes and tutorial questions. ","date":"2022-01-01 15:21:52","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/:0:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_14","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/"},{"categories":["School courses"],"content":"1.Introduction A distributed system is defined as one in which components at networked computers communicate and coordinate their actions only by passing messages. The motivation of constructing a distributed system is resource sharing and collaborative computing Distributed system features. Concurrency No global clock Independent failure Distributed system challenges. Heterogeneity Openness Security Scalability Failure handling Concurrency Transparency Quality of Service ","date":"2022-01-01 15:21:52","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/:1:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_14","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/"},{"categories":["School courses"],"content":"2.System Model Difficulties for and threats to distributed systems Widely varying mode of use Wide range of system environments Internal threats External threats Physical Model Three generations of distributed systems and the emergence of ultra-large-scale (ULS) distributed systems. Architectural Model An architectural model of a distributed system simplifies and abstracts the functions of the individual components of a distributed system Entities that are communicating in the distributed system 进程、线程、传感器节点或者说对象、组件、网页服务 Types of communication paradigms: Interprocess communication Remote invocation Indirect communication Group communication Broadcast (message sent to everyone) Multicast (message sent to specific group) Used for: Replication of services Replication of data Service discovery Event notification Publish-subscribe-systems Communication through propagation of events Generally associated with publish/subscribe systems Sender process publishes events Receiver process subscribes to events and receives only the ones it is interested in Message queues Architectural styles: client-server：it scales poorly Decomposed a typical client-server application into three logical parts the interface part. the application logic part, and. the data part. Thin client implementation Provides a minimal user interface layer, and leave everything else to the server. Fat client implementation Include all of the user interface and application logic in the client. Rely only on the server to store and provide access to data. Implementations in between will split up the interface or application logic parts over the clients and server in different ways. peer-to-peer Is composed of a large number of peer processes running on separate computers. All processes have client and server roles. Patterns of communication between them depends entirely on application requirements. Storage, processing and communication loads for accessing objects are distributed across computers and network links. Each object is replicated in several computers to further distribute the load and to provide resilience in the event of disconnection of individual computers. Need to place and retrieve individual computers is more complex then in client-server architecture. placement one:Servers partition a set of objects in which the service is based and distribute them between themselves. placement two:Server maintain replicated copies of them on several hosts. Vertical distribution (Multi-Tier) and horizontal distribution of c/s systems in Architectural patterns Middleware:Is a layer of software whose purpose is to mask heterogeneity and to provide a convenient programming model to application programmers. Vertical Distribution (Multi-Tier): An extension of the client-server architecture. Distributes the traditional server functionality over multiple servers. Horizontal Distribution: Involves replicating a server’s functionality over multiple computers. Typical example: replicated Web server Each server machine contains a complete copy of all hosted Web pages. Client requests are passed on to the servers in a round robin fashion. Is used to improve scalability (by reducing the load on individual servers) and reliability (by providing redundancy) Fundamental Model Characteristics of synchronous distributed systems and asynchronous distributed system(Interaction model) Two variants of the interaction model: Synchronous distributed systems The following bounds are defined: The time to execute each step of a process has known lower and upper bounds Each message transmitted over a channel is received within a known bounded time. Each process has a local clock whose drift rate from real time has known bound. Asynchronous distributed system: There are no bounds on: Process execution speed Message transmission delays Clock drift rate Failure model Security model ","date":"2022-01-01 15:21:52","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/:2:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_14","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/"},{"categories":["School courses"],"content":"3.Physical Clock Synchronization Adjustment changes slope of system time: Linear compensating function （线性补偿函数） ","date":"2022-01-01 15:21:52","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/:3:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_14","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/"},{"categories":["School courses"],"content":"3.1Cristian’s algorithm: synchronize clocks with a UTC server ","date":"2022-01-01 15:21:52","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/:3:1","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_14","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/"},{"categories":["School courses"],"content":"3.2Berkeley Algorithm: synchronize a set of clocks as close as possible ","date":"2022-01-01 15:21:52","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/:3:2","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_14","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/"},{"categories":["School courses"],"content":"4.NTP Symmetric mode 如何计算偏移量、准确值、延迟、传输时间。 used to synchronize between the time servers (peer-peer) There can be a non-negligible delay between the arrival of one message and the dispatch of the next Delay = total transmission time of the two messages $$d_i = (T_i – T_{i-3} ) – (T_{i-1}– T_{i-2})$$ Offset of clock A relative to clock B: Offset of clock A: $o_i =((T_{i-2} – T_{i-3} ) + ( T_{i-1} – T_i))/2$ Accuracy bound: $d_i /2$ ","date":"2022-01-01 15:21:52","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/:4:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_14","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/"},{"categories":["School courses"],"content":"5.Logical Clock Synchronization: Event ordering: happened before (-\u003e), concurrent (||) Lamport’s algorithm: single timestamp clock synchronization \u0026 features If a -\u003e b then V(a) \u003c V(b) The reverse is not always true Timestamp vector synchronization and features a -\u003e b iff V(a) \u003c V(b) a || b iff neither V(a) ≤ V(b) nor V(b) ≤ V(a) Application of timestamp vectors: causal ordered multicast ","date":"2022-01-01 15:21:52","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/:5:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_14","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/"},{"categories":["School courses"],"content":"6.Interprocess Communication (IPC) Socket operations and Socket types Socket/bind listen, accept, connect Read/write functionalities close/shutdown Programming by using sockets ","date":"2022-01-01 15:21:52","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/:6:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_14","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/"},{"categories":["School courses"],"content":"7.Remote Invocation (RPC) Interface Definition of a client-server system Client program development Server program development Client-server interactions in RPC ","date":"2022-01-01 15:21:52","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/:7:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_14","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/"},{"categories":["School courses"],"content":"8.Group Communication ","date":"2022-01-01 15:21:52","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/:8:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_14","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/"},{"categories":["School courses"],"content":"9.Mutual Exclusion \u0026 Election Algorithm Mutual Exclusion Centralized Algorithm Token Ring Algorithm Ricart \u0026 Agrawala algorithm Distributed Mutual Exclusion Election Bully Algorithm Ring election Algorithm Robert \u0026 Chang Algorithm ","date":"2022-01-01 15:21:52","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/:9:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_14","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/"},{"categories":["School courses"],"content":"10.Data Centric Consistency Models consistency—description Strict—Absolute time ordering of all shared accesses matters. Linearizability—All processes must see all shared accesses in the same order. Accesses are furthermore ordered according to a (nonunigue) global timestamp Sequential—All processes see all shared accesses in the same order. Accesses are not ordered in time Causal—All processes see causally-related shared accesses in the same order. FIFO—All processes see writes from each other in the order they were used. Writes from different processes may not always be seen in that order Consistency models not using synchronization operations. Weak—Shared data can be counted on to be consistent only after a synchronization is done Release—Shared data are made consistent when a critical region is exited Entry—Shared data pertaining to a critical region are made consistent when a critical region is entered. Models with synchronization operations. ","date":"2022-01-01 15:21:52","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/:10:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_14","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/"},{"categories":["School courses"],"content":"11.Client Centric Consistency 4 rules of client centric consistency. What is to be propagated? How is it to be propagated? Consistency Protocols Primary-based protocols Replicated write protocols Cache-coherence protocols ","date":"2022-01-01 15:21:52","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/:11:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_14","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/"},{"categories":["School courses"],"content":"12.Internetworking CIDR - Classless InterDomain Routing NAT - Network Address Translation DHCP - Dynamic Host Configuration Protocol ARP - Address Resolution Problem OSPF - Interior Gateway Routing Protocol BGP - Exterior Gateway Routing Protocol ","date":"2022-01-01 15:21:52","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/:12:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_14","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/"},{"categories":["School courses"],"content":"13.Name Services（本有题目，被删了） DNS Name Servers Recursive query \u0026 Iterative query DNS Records IP-address to Name: Reverse Mapping ","date":"2022-01-01 15:21:52","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/:13:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_14","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/"},{"categories":["School courses"],"content":"14.Unix File System Internal File Structure : file attributes and data index Unix Directory File Directory structure and name resolution Superblock Internal Structure for File Accesses Mount and Unmount ","date":"2022-01-01 15:21:52","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/:14:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_14","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/"},{"categories":["School courses"],"content":"15.Distributed File System Distributed File System Components Differences between DFS and stand-alone FS Google FS and NFS ","date":"2022-01-01 15:21:52","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/:15:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_14","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/"},{"categories":["School courses"],"content":"16.Transaction Processing System（一定会考） Definitions of Atomic Transactions RM-ODP properties How to achieve atomicity of transactions? Failure Recovery (guarantee nothing-or-all) Intention list approach Shadow version approach Concurrency Control (guarantee serializability) 2-Phase Locking Timestamp Ordering Optimistic Method ","date":"2022-01-01 15:21:52","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/:16:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_14","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/"},{"categories":["School courses"],"content":"17.Web Searching Search Engines Architecture Spider Indexer Database Search Engine Web Data Mining: Digraph FAN - WebPage Ranking Inverted File: indexing for search ","date":"2022-01-01 15:21:52","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/:17:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_14","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_14/"},{"categories":["School courses' list"],"content":" DHW_01(intro) topics motivation definition features challanges conclusino DHW_02(system modules) physical model architectural model fundamental model DHW_03(physical time) DHW_04(logic time) DHW_05(mutual exclusion and election algorithms) mutual exclusion election algorithms DHW_06(socket and RPC) socket communication remote procedure call(RPC) DHW_07(internetworking) DHW_08(name services) DHW_09(group communication) Implementing Group Communication Mechanisms Reliability of multicasts Message ordering IP multicast routing DHW_10(Consistency and Replication) DHW_11(Unix File Systems and Distributed File Systems) DHW_12(Transaction Processing Systems) DHW_13(Web Searching Technologies) DHW_14(DistributedSystem_HongweiDu_catalogue) ","date":"2022-01-01 15:21:52","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_catalogue/:0:0","tags":["catalogue"],"title":"DistributedSystem_HongweiDu_catalogue","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_catalogue/"},{"categories":["School courses"],"content":" 2021哈工大深圳堵宏伟分布式系统课程笔记 Web Searching Technologies Some helpful web sites： A history of search engines: http://www.wiley.com/legacy/compbooks/sonnenreich/webdev/history.html Open source search engines written in Java: http://java-source.net/open-source/search-engines Robots: http://www.robotstxt.org/wc/robots.html Search Engines Architecture： Spiders (Web Crawler)： Automatically Retrieve web pages Start with an URL, retrieving the web page Find all URLs on the web page and recursively retrieve not-yet searched URLs Algorithmic Issues Efficiency and Quality: how to quickly gather as many useful web pages as possible? How to choose the next URL? How to avoid overloaded sub-networks? Indexer： Select terms (keywords) to index a document need co-operation from authors of webpage through Meta tags (next to Title tag in html files) to indicate specific terms to index Algorithmic issues: How to choose terms/phrases to index documents, such that user queries can be returned accurately and efficiently How to index documents encoded in different types (multimedia data retrieval) Database： Structured data (see Bigtable for Google) Bigtable: A Distributed Storage System for Structured Data, CACM, Jun 2008 Parallel search and distributed storage Algorithmic issues: Data partitioning and distributed storage: store petabytes of data across thousands of servers Real-time data retrieval and update (short latency) Fault-tolerance (data redundancy) Search Engine： Return the most relevant documents for queries Algorithmic Issues: Parallel search (e.g., map-reduce techniques) Relevance analysis Major Products of Search Engines： Alta vista Google Goto Lycos Yahoo … Search Engine Sizes (Dec 11, 2001)： Estimated total web pages ~ 2 billion Shaded area for GG and INKTOMI are pages indexed but not visited Difficulties for Internet Information Retrieval： Diversified Users (from layman to computer nerds). Can we develop an evolving system that adapts to user? Ambiguity of language expression This is an important issue due to varieties of data on the Internet How do we collect and apply user profiling techniques to resolve it? False Information Phising, Spam, Misleading Advertisement Spider Architecture： Spider Programming: start with HTTP…： Spiders use HTTP protocol to retrieve data… public class HttpClientGet { public static void main(String[] args) throws Exception { String serverUrl = \"www.cs.cityu.edu.hk\"; Socket s = new Socket(serverUrl, 80); BufferedReader in = new BufferedReader(new InputStreamReader(s.getInputStream())); PrintStream out = new PrintStream(s.getOutputStream()); out.println(\"GET /~jia/index.html HTTP/1.0\"); out.println(); // “GET” must be followed by a blank line. String line; while ((line = in.readLine()) != null) { System.out.println(\"\u003e \" + line); } s.close(); } } A Simple HTTP Server: public class HttpServer { public static void main(String argv[]) throws Exception { ServerSocket serverSock = new ServerSocket(8632); // open server socket at port while (true) { Socket new_s = serverSock.accept(); serveRequest(new_s); client.close(); } } public static void serveRequest(Socket s) throws Exception { PrintStream out = new PrintStream(s.getOutputStream()); BufferedReader in = new BufferedReader(new InputStreamReader(s.getInputStream())); String httpCmd = in.readLine(); // The HTTP Request is httpCmd; String[] httpArgs = httpCmd.split(\" \"); if (httpArgs.length \u003c 2 || !httpArgs[0].equalsIgnoreCase(\"GET\")) { out.println(\"400 Bad Request.\"); return; } String fContent = readFileContent(httpArgs[1]); if (fContent == null) out.println(\"404 File Not Found\"); else out.println(fContent); } Spider in Action!: Initialize the queue with URLs of known pages Repeat doing: Take an URL from queue Fetch the web page and store/index the relevant information in the page Extract URLs from the page and add them to the queue Assumption: The web is well linked. A Simple Spider: public class SimpleSpider { private Queue linkQueue=new LinkedList(); private LinkEx","date":"2022-01-01 15:21:48","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_13/:0:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_13","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_13/"},{"categories":["School courses"],"content":" 2021哈工大深圳堵宏伟分布式系统课程笔记 Transaction Processing Systems事务处理系统 File operations and Transaction operations： Definitions of Atomic Transactions ： Atomic Transaction: a sequence of data access operations that are atomic in the sense of: All-or-Nothing Serializability The ACID properties of a transaction in RM-ODP: Atomicity Consistency Isolation Durability What makes Database inconsistent?： Concurrent accesses of transactions Failures of servers Two well-known problems caused by concurrency: Lost update problem Inconsistent Retrieval Problem： Problem Caused by Server Failures： Transaction: transfer(A, B, 100) bal = A.Read(); A.Write(bal - 100); “bad” \u003c-server crash point bal = B.Read(); B.Write(bal + 100); Transactional File Operations: Transactions provide a programming environment: Concurrency transparency Failure transparency Transactional file service operations: TID = OpenTrans () (Commit, Abort) = CloseTrans (TID) AbortTrans (TID) TWrite(TID, FID, i, Data) TRead(TID, FID, i, buf) FID = TCreate(TID, filename, type) TDelete(TID, FID) ...... An Example of Using Transactions : Transaction: transfer (A, B, 100) tid = OpenTrans(); Tread(tid, A, bal) Twrite(tid, accountA, bal-100) Tread(tid, accountB, bal) Twrite(tid, accountB, bal+100) CloseTrans(tid); How to achieve atomicity of transactions?: Failure Recovery (guarantee nothing-or-all) Intention list approach Shadow version approach Concurrency Control (guarantee serializability) 2-Phase Locking Timestamp Ordering Optimistic Method Failure Recovery of Transactions : An execution of a transaction has Two Phases: Tentative phase, the execution transaction body Commit phase, making tentative values permanent Making transactions failure recoverable: Keep the tentative values of data on disk that can survive failures Restore data items at the restart from a failure (recovery operation should be idempotent) Make the commit phase repeatable Intention List Approach (failure recovery) : Example of intention list: tid = OpenTrans; TWrite(tid, fd1, len1, data1); TWrite(tid, fd2, len2, data2); Close(tid) Intention List: tid, status, {\"Twrite, fd, pos1, len1, data1\", \"Twrite, fd, pos2, len2, data2\"} Implementation of Intention List: Transaction operations by using intention list: Twrite writes data to the intention list. Tread reads data from the intention list if it is present. CloseTrans performs operations in the intention list onto database files (or the recovery file). Recovery manager: a program (part of the server) which is called when the server restarts from a failure. Recovery file: a file used by the recovery manager to restore the database to a consistency state. Each entry of the file, for one transaction, contains the information: Tid transaction status intention list Example of recovery: Transactions T and U: T: transfer (A, B, $20) U: transfer (C, B, $22) Recovery: remove tentative data created by U (p5 \u0026 p6) and commit the data updated by T (p1 \u0026 p2) to database. Shadow Version Approach (failure recovery) : When a transaction modifies a file or data item, it creates a shadow (tentative) version of the file. The subsequent Twrite/Tread are performed on the shadow version. At closeTrans, it detects version conflict with other concurrent transactions (done by concurrency control). If no conflict, the shadow version is merged with other concurrent versions already committed; otherwise it is aborted. Implementation of Shadow Version Approach: A copy of the file index block is created at the first Twrite of a transaction. Each Twrite operation creates shadow pages. The index entries of modified pages are made pointing to the shadow pages. The original file index block is replaced by the new one at the commit of the transaction (it’s an idempotent operation). Serializability (Serially Equivalent) : Two transactions may conflict with each other when they access the same data item(s). Only write operations may cause inconsistency. Def. Serializability: T  U (T completes before U start","date":"2022-01-01 15:21:45","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_12/:0:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_12","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_12/"},{"categories":["School courses"],"content":" 2021哈工大深圳堵宏伟分布式系统课程笔记 ","date":"2022-01-01 15:21:34","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_11/:0:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_11","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_11/"},{"categories":["School courses"],"content":"Unix File Systems文件系统 File Systems： File system provides the most fundamental service for building any information systems. file storage, management and retrieve service. We look at two file operations: fp = open (“cs4274/exam”, r, 0); r = read (fp, n, buf); Hard disk Structure： Head, cylinder, sector Data stored in the same cylinder first to reduce the head movement Disk operation in units of sectors An IBM hard disk configuration: 10 heads 40 tracks-per-disk (cylinders) 32 sectors-per-track 512 bytes/sector Data Block and Block Number： File system uses block as a data unit for disk operation Usually a block size is 1K (\u003e= sector size) Disk block is referenced by its block # Block # to Physical Address Translation sectors = blk_num  (#sects-per-blk) cyld_num = sectors  (#sects-per-cyld) head_num = (sectors mod (#sects-per-cyld)) / (#sects-per-track) sect_num = sectors mod (#sects-per-track) Internal File Structure : Each file has an i-node: file attributes and data index: File attributes: owner, access permissions, access times, file size 12 bytes Data index: 13 indices: 10 direct indices, 1 indirect index, 1 double indirect index, 1 triple indirect index 13 * 4 =52 bytes The size of an inode = 64 bytes. An inode is referenced by its inode # Diagram of data index in inode : Unix Directory File : Directory files are ordinary files consisting of entries mapping names to i-node #, e.g., directory file /etc After BSD4.3, file names are of variable length (upto 255 bytes). Each entry has the entry-length, name \u0026 inode #. Directory structure and name resolution: Directories are in a tree structure. Resolve pathname recursively to i-node number, component by component from the root (or relative) directory, e.g. /home/lec/jia/unix-fs.doc a) Starting from inode # 3 of “/” -\u003e load inode of “/” b) Read content of directory file “/”: 1368 bin@ 1478 lib/ 233756 rpool/ 2484 boot/ 1486 mnt/ 1489 sbin/ 1369 dev/ 154559 net/ 1494 system/ 2818 devices/ 6 export/ 2429 platform/ 5 var/ 27376 home/ …………………. c) Map “home” -\u003e inode # 27376 -\u003e load inode 27376 d) Read directory file “/home”: 94171 bsft08/ 93753 course/ 231 lec/ 94363 ms10/ 55531 bsft09/ 94125 cslab/ 94239 misc/ 91159 ms11/ …… e) Map “lec” -\u003e inode # 231 -\u003e load inode 231 d) Repeat the above steps until map “unix-fs.doc” -\u003e inode # Disk Management (inode # -\u003e i-nodes): Super block 超级块: Each file system has a super block which contains: The size of the file system The number of free blocks in the system An array of cached free block numbers The index of the next free block number A pointer to the start of i-nodes area The number of free i-nodes in the system A list of cached free i-node numbers The index of the next free i-node numbers The super block (usually one disk block) of the root file system must be loaded into memory when system is up. Calculate an inode address by inode number : blk_num = (inode_num -1) / #inodes-per-blk + st-addr-inodes byte_offset = ((inode_num -1) mod (#inodes-per-blk))*inode-size N.B. In UNIX, inode-size = 64, #inodes-per-blk = 16 Summary on address translations: pathname -\u003e inode # -\u003e inode address (block # \u0026 offset) -\u003e inode -\u003e data block # -\u003e disk address -\u003e data Internal Structure for File Accesses : Pseudo-code for open operation : int open (path-name, op) { i = resolve(path-name); if inode(i) in inode-table then inode-table(i).count++; else load inode(i) into inode-table; create an entry in file-table, file-entry(i); file-entry(i).count = 1; file-entry(i).op = op; file-entry(i).offset = 0; file-entry(i).inode-ptr = \u0026(inode-table(i)); fd = get the next entry in file-descript-table, fdt; fdt[fd] = \u0026(file-entry(i)); return fd; } Pseudo-code for read operation : Steps of reading a file data: read (fp, n, buf) fp -\u003e pointer to the entry in file-table, getting offset pointer to the entry in inode-table get the block # of the data convert the block # to head, cylinder, sector ask disk controller to read in data and copy the n bytes into buf Global File ","date":"2022-01-01 15:21:34","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_11/:1:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_11","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_11/"},{"categories":["School courses"],"content":"Distributed File Systems DFS Goals: Location transparency: a uniform file name space that does not contain file physical location information. Concurrency transparency: a user’s file operations will not be interfered by another user. Failure transparency: when part of the system fails, the rest of the system can still provide file services. Heterogeneity: interoperable among different operating systems and communication protocols. Scalability: the system performance will not deteriorate as the system size grows. Distributed File System Components : Flat file service: offer a simple set of general operations to access attributes and data of files, indexed by UFIDs. Directory service: map text names to UFIDs. Client module: allow access to file \u0026 directory service under a single application programming interface. Distributed File System Interface: Flat file service operations: read(UFID,i n) -\u003e Data If1≤i≤Length(File), read a sequence of up to n items from a file starting at item i and returns it in Data. throws BadlPosition, write(UFID, i, Data) If1≤i≤Length(File)+I, write a sequence of Data to a file. starting at item i. throws BadPosition create( \u003e UFID Create a new file with length 0 and return its UFID. delete(UFID) Remove the file from the file store. gettributes(UFID) \u003e Attr Return attributes of the file. setlttributes(UFID, Attr) Set file attributes. Directory service operations: Constructing a Hierarchical FS at Client Module: A hierarchical file naming system can be constructed by the client module by using file \u0026 directory services. The root of the directory tree is a directory with a well-known UFID. A pathname resolution function is provided in the client module. Differences between DFS and stand-alone FS : Separation of file service and directory service: The file service is made more general and the design of directory service can be more flexible. It off loads directory service from file server. Stateless servers and emulations in the client module: File server is made very light weighted, leaving most of work to the client module. Server can recover from failure efficiently, with no need to restore client’s states. Client module emulates the traditional FS interface. Repeatable operations File operations are idempotent, allowing the use of at-least-once RPC semantics. Operation create is exceptional (but no side-effect to users). Capabilities and Access Control : Clients interacts with dir-server and file-server via RPCs. There is a security loophole, allowing unauthorized user to use other’s ID to access files illegally. Capability (in the form of a UFID) is a digital key used to identify and access file by clients in distributed FS. A capability includes information of file location (groupID), FID, and access control. Directory server generates the capability of a file based on to client’s ID and access permission. Capabilities is used for access control to the file. A capability must have an encrypted field to prevent it from being modified or mis-used by others. The encryption key is usually shared between the directory server and file server. File Representation : An index block (similar to i-node in UNIX) is used for each file to point to data blocks (or another layer of index blocks). Locating an index block is done by using UFID. The UFIDs can be organized to B-tree structure for efficient search. The mappings from UFIDs to the corresponding index-blocks are stored in disk, and the mappings can be too big to be in memory at once. Server’s location (file group ID) is embedded in UFID. The client needs to know server’s location before making RPC for file access. This can be done by the following RPC to any server: PortID = GetServerPort(FileGroupID) Space Leaks: Some files whose directory links have been removed may remain in disk and never be accessed, due to the separation of directory servers from file servers. The problem is ignored, or prevented in most of the systems. A “life-time” method aims to sol","date":"2022-01-01 15:21:34","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_11/:2:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_11","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_11/"},{"categories":["School courses"],"content":" 2021秋哈工大深圳罗文坚 信息安全概论课程PPT 摘抄 信息安全管理 ","date":"2021-12-21 19:38:13","objectID":"https://qizhengzou.github.io/isc_base_10/:0:0","tags":["information security conspectus"],"title":"ISC_base_10","uri":"https://qizhengzou.github.io/isc_base_10/"},{"categories":["School courses"],"content":"10.1 概述 当今社会已经进入到信息化社会，其信息安全是建立在信息社会的基础设施及信息服务系统之间的互联、互通、互操作意义上的安全需求上。 安全需求可以分为安全技术需求和安全管理需求两个方面。 管理在信息安全中的重要性高于安全技术层面，“三分技术，七分管理”的理念在业界中已经得到共识 信息安全管理体系ISMS： 信息安全管理体系ISMS（Information Security Management System）是从管理学惯用的过程模型PDCA（Plan、Do、Check、Act）发展演化而来。 ISMS: 信息安全管理体系（ISMS）是一个系统化、过程化的管理体系，体系的建立不可能一蹴而就，需要全面、系统、科学的风险评估、制度保证和有效监督机制。 ISMS应该体现预防控制为主的思想，强调遵守国家有关信息安全的法律法规，强调全过程的动态调整，从而确保整个安全体系在有效管理控制下，不断改进完善以适应新的安全需求。 在建立信息安全管理体系的各环节中，安全需求的提出是ISMS的前提，运作实施、监视评审和维护改进是重要步骤，而可管理的信息安全是最终的目标。 在各环节中，风险评估管理、标准规范管理以及制度法规管理这三项工作直接影到响整个信息安全管理体系是否能够有效实行，因此也具有非常重要的地位。 风险评估： 风险评估（Risk Assessment）是指对信息资产所面临的威胁、存在的弱点、可能导致的安全事件以及三者综合作用所带来的风险进行评估。 作为风险管理的基础，风险评估是组织确定信息安全需求的一个重要手段。 风险评估管理就是指在信息安全管理体系的各环节中，合理地利用风险评估技术对信息系统及资产进行安全性分析及风险管理，为规划设计完善信息安全解决方案提供基础资料，属于信息安全管理体系的规划环节。 标准规范管理： 标准规范管理可理解为在规划实施信息安全解决方案时，各项工作遵循国际或国家相关标准规范，有完善的检查机制。 国际标准可以分为互操作标准、技术与工程标准、信息安全管理与控制标准三类。 互操作标准主要是非标准组织研发的算法和协议经过自发的选择过程，成为了所谓的“事实标准”，如AES、RSA、SSL以及通用脆弱性描述标准CVE等。 技术与工程标准主要指由标准化组织制定的用于规范信息安全产品、技术和工程的标准，如信息产品通用评测准则（ISO 15408）、安全系统工程能力成熟度模型（SSE-CMM）、美国信息安全白皮书（TCSEC）等。 信息安全管理与控制标准是指由标准化组织制定的用于指导和管理信息安全解决方案实施过程的标准规范，如信息安全管理体系标准（BS-7799）、信息安全管理标准（ISO 13335）以及信息和相关技术控制目标（COBIT）等 制度法规管理： 制度法规管理是指宣传国家及各部门制定的相关制度法规，并监督有关人员是否遵守这些制度法规。 每个组织部门（如企事业单位、公司以及各种团体等）都有信息安全规章制度。有关人员严格遵守这些规章制度，对于一个组织部门的信息安全来说十分重要，而完善的规章制度和建全的监管机制更是必不可少。 除了有关的组织部门自己制定的相关规章制度之外，国家的有关信息安全法律法规更是有关人员需要遵守的。 目前在计算机系统、互联网以及其它信息领域中，国家均制定了相关法律法规进行约束管理，如果触犯，势必受到相应的惩罚。 立法现状： 1973年， 瑞典率先在世界上制定第一部含有计算机犯罪处罚内容的《瑞典国家数据保护法》。 根据英国学者巴雷特的归纳，各国对计算机犯罪的立法，主要采取了两种方案： 一种是制定计算机犯罪的专项立法，如美国、英国等； 一种是通过修订法典，增加规定有关计算机犯罪的内容，如法国、俄罗斯等。 目前我国现行法律法规中，与信息安全有关的已有近百部。 涉及网络与信息系统安全、信息内容安全、信息安全系统与产品、保密及密码管理、计算机病毒与危害性程序防治、金融等特定领域的信息安全、信息安全犯罪制裁等多个领域，初步形成了我国信息安全的法律体系。 道德规范： 道德规范也是信息领域从业人员及广大用户应该遵守的。 包括计算机从业人员道德规范、网络用户道德规范以及服务商道德规范等。 信息安全道德规范的基本出发点： 一切个人信息行为必须服从于信息社会的整体利益，即个体利益服从整体利益； 对于运营商来说，信息网络的规划和运行应以服务于社会成员整体为目的。 信息安全管理是一个十分复杂的综合管理体系，规章制度、法律法规和道德规范是管理的基础，标准规范是信息系统实施和安全运行的保证，风险管理是建设信息安全管理体系的重要手段。 ","date":"2021-12-21 19:38:13","objectID":"https://qizhengzou.github.io/isc_base_10/:1:0","tags":["information security conspectus"],"title":"ISC_base_10","uri":"https://qizhengzou.github.io/isc_base_10/"},{"categories":["School courses"],"content":"10.2 信息安全风险管理 信息安全风险管理是信息安全管理的重要部分。 是规划、建设、实施及完善信息安全管理体系的基础和主要目标。 其核心内容包括风险评估和风险控制两个部分。 风险管理的概念来源于商业领域，主要指对商业行为或目的投资的风险进行分析、评估与管理，力求以最小的风险获得最大的收益。 ","date":"2021-12-21 19:38:13","objectID":"https://qizhengzou.github.io/isc_base_10/:2:0","tags":["information security conspectus"],"title":"ISC_base_10","uri":"https://qizhengzou.github.io/isc_base_10/"},{"categories":["School courses"],"content":"10.2.1 风险评估 风险评估主要包括风险分析和风险评价。 风险分析是指全面地识别风险来源及类型； 风险评价是指依据风险标准估算风险水平，确定风险的严重性。 一般认为，与信息安全风险有关的因素主要包括威胁、脆弱性、资产、安全控制等。 威胁（Threat），主要指可能导致资产或组织受到损害的安全事件的潜在因素。 脆弱性（Vulnerability），一般指资产中存在的可能被潜在威胁所利用的缺陷或薄弱点，如操作系统漏洞等。 资产（Assets），是指对组织具有价值的信息资源，是安全策略保护的对象。 安全控制（Security Control），是指用于消除或减低安全风险所采取的某种安全行为，包括措施、程序及机制等。 信息安全风险因素及相互关系： 风险因素之间相互作用、相互影响；安全风险随各因素的变化呈现动态调整演变趋势。 风险可以描述成关于威胁发生概率和发生时的破坏程度的函数，用数学符号描述如下： $R_{i}\\left(A_{i}, T_{i}, V_{i}\\right)=P\\left(T_{i}\\right) \\times F\\left(T_{i}\\right)$ 𝑨_𝒊表示资产，𝑽_𝒊表示𝑨_𝒊存在的脆弱性，𝑻_𝒊表示针对资产𝑨_𝒊的脆弱性𝑽_𝒊的威胁； 𝑹_𝒊 (𝑨_𝒊,𝑻_𝒊,𝑽_𝒊)表示因为存在威胁𝑻_𝒊 而使资产𝑨_𝒊具有的风险； 〖𝑷(𝑻〗_𝒊)表示威胁𝑻_𝒊发生的概率，〖𝑭(𝑻〗_𝒊)表示威胁𝑻_𝒊发生时的破坏程度。 由于某组织部门可能存在很多资产和相应的脆弱性，故该组织的资产总风险可以描述如下： $R_{\\text {总 } }=\\sum_{i=1}^{n} R_{i}(A, T, V)=\\sum_{i=1}^{n} P\\left(T_{i}\\right) \\times F\\left(T_{i}\\right)$ 上述关于风险的数学表达式，只是给出了风险评估的概念性描述。 风险评估的任务： 风险评估的任务： 识别组织面临的各种风险，了解总体的安全状况； 分析计算风险概率，预估可能带来的负面影响； 评价组织承受风险的能力，确定各项安全建设的优先等级； 推荐风险控制策略，为安全需求提供依据。 风险评估的操作范围可以是整个组织，也可以是组织中的某一部门，或者独立的信息系统、特定系统组件和服务等。 针对不同的情况，选择适当的风险评估方法对有效地完成评估工作来说十分重要。常见的风险评估方法有基线评估方法、详细评估方法和组合评估方法等。 基线评估： 基线评估是有关组织根据其实际情况（所在行业、业务环境与性质等），对信息系统进行安全基线检查（将现有的安全措施与安全基线规定的措施进行比较，计算之间的差距），得出基本的安全需求，给出风险控制方案。 所谓的基线就是在诸多标准规范中确定的一组安全控制措施或者惯例，这些措施和惯例可以满足特定环境下的信息系统的基本安全需求，使信息系统达到一定的安全防护水平。 组织可以采用国际标准和国家标准（如BS 7799-1、ISO 13335-4）、行业标准或推荐（例如德国联邦安全局IT基线保护手册）以及来自其他具有相似商务目标和规模的组织的惯例作为安全基线。 基线评估的优点是需要的资源少、周期短、操作简单，是经济有效的风险评估途径。也有缺点，比如基线水准的高低难以设定。如果过高，可能导致资源浪费和限制过度；如果过低，可能难以达到所需的安全要求。 详细评估： 详细评估是指组织对信息资产进行详细识别和评价，对可能引起风险的威胁和脆弱性进行充分地评估，根据全面系统的风险评估结果来确定安全需求及控制方案。 这种评估途径集中体现了风险管理的思想，全面系统地评估资产风险，在充分了解信息安全具体情况下，力争将风险降低到可接受的水平。 详细评估的优点在于组织可以通过详细的风险评估对信息安全风险有较全面的认识，能够准确确定目前的安全水平和安全需求。 详细的风险评估可能是一个非常耗费资源的过程，包括时间、精力和技术。因此，组织应该仔细设定待评估的信息资产范围，以减少工作量。 组合评估： 组合评估要求首先对所有的系统进行一次初步的风险评估，依据各信息资产的实际价值和可能面临的风险，划分出不同的评估范围，对于具有较高重要性的资产部分采取详细风险评估，而其它部分采用基线风险评估。 组合评估将基线和详细风险评估的优势结合起来，既节省了评估所耗费的资源，又能确保获得一个全面系统的评估结果，而且组织的资源和资金能够应用到最能发挥作用的地方，具有高风险的信息系统能够被优先关注。 组合评估的缺点是，如果初步的高级风险评估不够准确，可能导致某些本需要详细评估的系统被忽略。 ","date":"2021-12-21 19:38:13","objectID":"https://qizhengzou.github.io/isc_base_10/:2:1","tags":["information security conspectus"],"title":"ISC_base_10","uri":"https://qizhengzou.github.io/isc_base_10/"},{"categories":["School courses"],"content":"10.2.2 风险控制 风险控制是信息安全风险管理在风险评估完成之后的另一项重要工作。 风险控制的任务是对风险评估结论及建议中的各项安全措施进行分析评估，确定优先级以及具体实施的步骤。 风险控制的目标是将安全风险降低到一个可接受的范围内。 消除所有风险往往是不切实际的，甚至也是近乎不可能的。 安全管理人员有责任运用最小成本来实现最合适的控制，使潜在安全风险对该组织造成的负面影响最小化。 风险控制手段： 风险控制通常采用如下三种手段来降低安全风险： 风险承受是指运行的信息系统具有良好的健壮性，可以接受潜在的风险并稳定运行，或采取简单的安全措施，就可以把风险降低到一个可接受的级别。 风险规避是指通过消除风险出现的必要条件（如识别出风险后，放弃系统某项功能或关闭系统）来规避风险。 风险转移是指通过使用其它措施来补偿损失，从而转移风险，如购买保险等。 一般来说，风险控制措施是以消除安全风险产生条件、切断风险形成的路线为基本手段，最终阻止风险的发生或将风险降低到可接受水平。 安全风险系统判断过程：风险控制具体做法： 风险控制具体做法： 当存在系统脆弱性时，减少或修补系统脆弱性，降低脆弱性被攻击利用的可能性； 当系统脆弱性可利用时，运用层次化保护、结构化设计以及管理控制等手段，防止脆弱性被利用或降低被利用后的危害程度； 当攻击成本小于攻击可能的获利时，运用保护措施，通过提高攻击者成本来降低攻击者的攻击动机，如加强访问控制，限制系统用户的访问对象和行为，降低攻击获利； 当风险预期损失较大时，优化系统设计、加强容错容灾以及运用非技术类保护措施来限制攻击的范围，从而将风险降低到可接受范围。 具体的风险控制措施：NIST SP800系列标准： 实施风险控制措施是一个系统化工程，美国NIST制定的NIST SP800系列标准中给出了较详细的具体实施流程，包括七个步骤。 第一步 对实施控制措施的优先级进行排序，分配资源时，对标有不可接受的高等级的风险项应该给予较高的优先级； 第二步 评估所建议的安全选项，风险评估结论中建议的控制措施对于具体的单位及其信息系统可能不是最适合或最可行的，因此要对所建议的控制措施的可行性和有效性进行分析，选择出最适当的控制措施； 第三步 进行成本效益分析，为决策管理层提供风险控制措施的成本效益分析报告； 第四步 在成本效益分析的基础上，确定即将实施的成本有效性最好的安全措施； 第五步 遴选出那些拥有合适的专长和技能，可实现所选控制措施的人员（内部人员或外部合同商），并赋以相应责任； 第六步 制定控制措施的实现计划，计划内容主要包括风险评估报告给出的风险、风险级别以及所建议的安全措施，实施控制的优先级队列、预期安全控制列表、实现预期安全控制时所需的资源、负责人员清单、开始日期、完成日期以及维护要求等； 第七步 分析计算出残余风险，风险控制可以降低风险级别，但不会根除风险，因此安全措施实施后仍然存在的残余风险。 ","date":"2021-12-21 19:38:13","objectID":"https://qizhengzou.github.io/isc_base_10/:2:2","tags":["information security conspectus"],"title":"ISC_base_10","uri":"https://qizhengzou.github.io/isc_base_10/"},{"categories":["School courses"],"content":"10.3 信息安全标准 ","date":"2021-12-21 19:38:13","objectID":"https://qizhengzou.github.io/isc_base_10/:3:0","tags":["information security conspectus"],"title":"ISC_base_10","uri":"https://qizhengzou.github.io/isc_base_10/"},{"categories":["School courses"],"content":"10.3.1 信息安全标准概述 技术与工程、互操作、信息安全管理与控制三类标准。 技术与工程标准最多也最详细，它们有效地推动了信息安全产品的开发及国际化，如CC、SSE-CMM等标准。 互操作标准多数为所谓的“事实标准”，这些标准对信息安全领域的发展同样做出了巨大的贡献，如RSA、DES、CVE等标准。 信息安全管理与控制标准的意义在于可以更具体有效地指导信息安全具体实践，其中BS 7799就是这类标准的代表，其卓越成绩也已得到业界共识。 重要标准： 1996年，通用标准CC（Common Criteria）是在TESEC、ITSEC、CTCPEC、FC等信息安全标准的基础上演变形成的。 1996年，ISO/IEC TR 13335，早前GMITS（Guidelines for the Management of IT Security），新版称作MICTS（Management of Information and Communications Technology Security）。 SSE-CMM （System Security Engineering Capability Maturity Model）模型是由美国国家安全局NSA领导开发的专门用于系统安全工程的能力成熟度模型。 CVE（Common Vulnerabilities \u0026 Exposures），即通用漏洞及披露，是IDnA（Intrusion Detection and Assessment）的行业标准。 1995年，BS 7799是英国标准协会BSI（British Standards Institute）针对信息安全管理而制定的标准，2000年被采纳为ISO/IEC 17799。 1996年，COBIT（Control Objectives for Information and related Technology），目前国际上通用的信息系统审计标准。 ","date":"2021-12-21 19:38:13","objectID":"https://qizhengzou.github.io/isc_base_10/:3:1","tags":["information security conspectus"],"title":"ISC_base_10","uri":"https://qizhengzou.github.io/isc_base_10/"},{"categories":["School courses"],"content":"10.3.2 信息技术安全性评估通用准则（CC） 信息安全产品标准CC： CC标准是“The Common Criteria for Information Technology security Evaluation”的缩写，《信息技术安全性通用评估标准》，在美国和欧洲等推出的测评准则上发展起来的。 CC文档结构： CC标准提倡安全工程的思想，通过信息安全产品的开发、评价、使用全过程的各个环节的综合考虑来确保产品的安全性。 第1部分“简介和一般模型”，介绍CC中的有关术语、基本概念和一般模型以及与评估有关的一些框架，附录部分主要介绍“保护轮廓”和“安全目标”的基本内容； 第2部分“安全功能要求”，这部分以“类、子类、组件”的方式提出安全功能要求，对每一个“类”的具体描述除正文之外，在提示性附录中还有进一步的解释； 第3部分“安全保证要求”，定义了评估保证级别，介绍了“保护轮廓”和“安全目标”的评估，并同样以“类、子类、组件”的方式提出安全保证要求。 CC标准的内容： CC标准的内容主要包括： 安全需求的定义； 需求定义的用法； 安全可信度级别； 安全产品的开发和产品安全性评价等几个方面。 安全需求的定义 CC标准对安全需求的表示形式给出了一套定义方法，并将安全需求分成产品安全功能方面的需求和安全保证措施方面的需求两个独立的范畴来定义。 安全功能需求主要用于描述产品应该提供的安全功能。 安全保证需求，即安全保证措施方面的需求，主要用于描述产品的安全可信度以及为获取一定的可信度应该采取的措施。 安全需求的定义： 在CC标准中，安全需求以类、族、组件的形式进行定义，给出了对安全需求进行分组归类的方法。对全部安全需求进行分析，根据不同的侧重点，划分成若干大组，每个大组就称为一个类。 需求定义的用法： 安全需求定义中的“类、族、组件”体现的是分类方法，安全需求由组件体现，选择需求组件等同选择安全需求。 CC标准定义了三种类型的组织结构用于描述产品安全需求，分别是安全组件包、保护轮廓定义和安全对象定义。 安全组件包是把多个安全需求组件组合在一起所得到的组件集合。 保护轮廓定义是一份安全需求说明书，是针对某一类安全环境确立相应的安全目标，进而定义为实现这些安全目标所需要的安全需求，保护轮廓定义的主要内容包括定义简述、产品说明、安全环境、安全目标、安全需求、应用注释和理论依据等。 安全对象定义是一份安全需求与概要设计说明书，不同的是安全对象定义的安全需求是为某一特定的安全产品而定义的，具体的安全需求可通过引用一个或多个保护轮廓定义来定义，也可从头定义。安全对象定义的组成部分主要包括定义简述、产品说明、安全环境、安全目标、安全需求、产品概要说明、保护轮廓定义的引用声明和理论依据等。 安全可信度级别：安全产品的开发： CC标准体现了软件工程与安全工程相结合思想。 信息安全产品必须按照软件工程和安全工程的方法进行开发才能较好地获得预期的安全可信度。 安全产品从需求分析到产品的最终实现，整个开发过程可依次分为应用环境分析、明确产品安全环境、确立安全目标、形成产品安全需求、安全产品概要设计、安全产品实现等几个阶段。 各个阶段顺序进行，前一个阶段的工作结果是后一个阶段的工作基础。有时前面阶段的工作也需要根据后面阶段工作的反馈内容进行完善拓展，形成循环往复的过程。 开发出来的产品经过安全性评价和可用性鉴定后，再投入实际使用。 产品安全性评价： CC标准在评价安全产品时，把待评价的安全产品及其相关指南文档资料作为评价对象。 CC定义了三种评价类型，分别为安全功能需求评价、安全保证需求评价和安全产品评价。 第一项评价的目的是证明安全功能需求是完全的、一致的和技术良好的，能用作可评价的安全产品的需求表示； 第二项评价的目的是证明安全保证需求是完全的、一致的和技术良好的，可作为相应安全产品评价的基础。如果安全保证需求中含有安全功能需求一致性的声明，还要证明安全保证需求能完全满足安全功能需求。 最后一项安全产品评价的目的是要证明被评价的安全产品能够满足安全保证的安全需求。 ","date":"2021-12-21 19:38:13","objectID":"https://qizhengzou.github.io/isc_base_10/:3:2","tags":["information security conspectus"],"title":"ISC_base_10","uri":"https://qizhengzou.github.io/isc_base_10/"},{"categories":["School courses"],"content":"10.3.3 信息安全管理体系标准 信息安全管理体系标准BS7799： BS7799是英国标准协会（British Standards Institute，BSI）针对信息安全管理而制定的一个标准，共分为两个部分。 第一部分BS7799-1是《信息安全管理实施细则》，也就是国际标准化组织的ISO/IEC 17799标准的部分，主要提供给负责信息安全系统开发的人员参考使用，其中分11个标题，定义了133项安全控制（最佳惯例）。 第二部分BS7799-2是《信息安全管理体系规范》（即ISO/IEC 27001），其中详细说明了建立、实施和维护信息安全管理体系的要求，可用来指导相关人员去应用ISO/IEC 17799，其最终目的是建立适合企业所需的信息安全管理体系。 信息安全管理实施细则11个方面定义： 在BS 7799-1《信息安全管理实施细则》中，从11个方面定义了133项控制措施。 这11个方面分别是： 安全策略 组织信息安全 资产管理 人力资源安全 物理和环境安全 通信和操作管理 访问控制 信息系统获取、开发和维护 信息安全事件管理 业务连续性管理 符合性 建立信息安全管理体系六个基本步骤： 步骤一、定义信息安全策略 信息安全策略是组织信息安全的最高方针，需要根据组织内各个部门的实际情况，分别制订不同的信息安全策略。 步骤二、定义ISMS的范围 ISMS的范围描述了需要进行信息安全管理的领域轮廓，组织根据自己的实际情况，在整个范围或个别部门构架ISMS。 步骤三、进行信息安全风险评估 信息安全风险评估的复杂程度将取决于风险的复杂程度和受保护资产的敏感程度，所采用的评估措施应该与组织对信息资产风险的保护需求相一致。 步骤四、信息安全风险管理 根据风险评估的结果进行相应的风险管理。 步骤五、确定控制目标和选择控制措施 控制目标的确定和控制措施的选择原则是费用不超过风险所造成的损失。 步骤六、准备信息安全适用性声明 信息安全适用性声明纪录了组织内相关的风险控制目标和针对每种风险所采取的各种控制措施。 ","date":"2021-12-21 19:38:13","objectID":"https://qizhengzou.github.io/isc_base_10/:3:3","tags":["information security conspectus"],"title":"ISC_base_10","uri":"https://qizhengzou.github.io/isc_base_10/"},{"categories":["School courses"],"content":"10.3.4 中国的有关信息安全标准 中国的有关信息安全标准： 1985年，发布了第一个标准GB4943“信息技术设备的安全”，并于1994年发布了第一批信息安全技术标准。 截止2008年11月，国家共发布有关信息安全技术、产品、测评和管理的国家标准69项（不包括密码与保密标准）。 同时，公安部、国家保密局、国家密码管理委员会等相继制定、颁布了一批信息安全的行业标准，为推动信息安全技术在各行业的应用和普及发挥了积极的作用。 国家信息安全标准体系： 基础标准主要定义或描述信息安全领域的安全术语、体系结构、模型、框架等内容。 技术与机制标准主要包括标识与鉴别、授权与访问控制、实体管理、物理安全等内容。 管理标准主要包括管理基础、管理要素、管理支撑技术、工程与服务等内容。 测评标准主要分为基础标准、产品标准、系统标准三部分，每一部分均针对其对象提出了安全级别标准及相应的测试方法。 密码技术标准主要包括基础标准、技术标准和管理标准三部分。 基础标准描述了密码术语、密码算法配用和秘钥配用； 技术标准涉及密码协议、密码管理、密码检测评估、密码算法、密码芯片、密码产品、密码管理应用接口以及密码应用服务系统等内容； 管理标准涉及密码产品的开发、生产及使用等内容。 保密技术标准主要分为技术标准和管理标准两部分。 技术标准包括电磁泄露发射防护与检测、涉密信息系统技术要求和测评、保密产品技术要求和测评、涉密信息消除和介质销毁以及其他技术标准等内容； 管理标准包括电子文件管理、涉密信息管理和实验室要求三部分内容。 GB17895-1999 计算机信息系统安全保护等级划分准则： 在我国众多的信息安全标准中，公安部主持制定、国家质量技术监督局发布的中华人民共和国国家标准GB17895-1999《计算机信息系统安全保护等级划分准则》被认为我国信息安全标准的奠基石。 该准则将信息系统安全分为5个等级：自主保护级、系统审计保护级、安全标记保护级、结构化保护级和访问验证保护级。 五个安全等级： 第一级，用户自主保护级：本级的计算机信息系统可信计算基通过隔离用户与数据，使用户具备自主安全保护的能力。它具有多种形式的控制能力，对用户实施访问控制，即为用户提供可行的手段，保护用户和用户组信息，避免其他用户对数据的非法读写与破坏。 第二级，系统审计保护级：与用户自主保护级相比，本级的计算机信息系统可信计算基实施了粒度更细的自主访问控制，它通过登录规程、审计安全性相关事件和隔离资源，使用户对自己的行为负责。 第三级，安全标记保护级：本级的计算机信息系统可信计算基具有系统审计保护级所有功能。此外，还提供有关安全策略模型、数据标记以及主体对客体强制访问控制的非形式化描述，具有准确地标记输出信息的能力，消除通过测试发现的任何错误。 第四级，结构化保护级：本级的计算机信息系统可信计算基建立于一个明确定义的形式化安全策略模型之上，它要求将第三级系统中的自主和强制访问控制扩展到所有主体与客体。此外，还要考虑隐蔽通道。 第五级，访问验证保护级：本级的计算机信息系统可信计算基满足访问监控器需求。访问监控器仲裁主体对客体的全部访问。 ","date":"2021-12-21 19:38:13","objectID":"https://qizhengzou.github.io/isc_base_10/:3:4","tags":["information security conspectus"],"title":"ISC_base_10","uri":"https://qizhengzou.github.io/isc_base_10/"},{"categories":["School courses"],"content":"10.4 信息安全法律法规及道德规范 ","date":"2021-12-21 19:38:13","objectID":"https://qizhengzou.github.io/isc_base_10/:4:0","tags":["information security conspectus"],"title":"ISC_base_10","uri":"https://qizhengzou.github.io/isc_base_10/"},{"categories":["School courses"],"content":"10.4.1 信息犯罪 信息资源是当今社会的重要资产，围绕信息资源的犯罪已成为影响社会安定的重要因素。 信息犯罪是以信息技术为犯罪手段，故意实施的有社会危害性的，依据法律规定，应当予以刑罚处罚的行为。 目前多数的信息犯罪均属于计算机及网络犯罪。 公安部给出的定义：“所谓计算机犯罪，就是在信息活动领域中，以计算机信息系统或计算机信息知识作为手段，或者针对计算机信息系统，对国家、团体或个人造成危害，依据法律规定，应当予以刑罚处罚的行为”。 学界认为，“网络犯罪就是行为主体以计算机或计算机网络为犯罪工具或攻击对象，故意实施的危害计算机网络安全的，触犯有关法律规范的行为。” 信息犯罪分类 信息犯罪一般可以分为两类：一类是以信息资源为侵害对象，另一类是以非信息资源的主体为侵害对象。 以信息资源为犯罪对象的犯罪常见的有： 信息破坏：犯罪主体出于某种动机，利用非法手段进入未授权的系统或对他人的信息资源进行非法控制，具体行为表现为故意利用损坏、删除、修改、增加、干扰等手段，对信息系统内部的硬件、软件以及传输的信息进行破坏，从而导致网络信息丢失、篡改、更换等，严重的可引起系统或网络的瘫痪。 信息窃取：此类犯罪是指未经信息所有者同意，擅自秘密窃取或非法使用其信息的犯罪行为。 信息滥用：这类犯罪是指由使用者违规操作，在信息系统中输入或者传播非法数据信息，毁灭、篡改、取代、涂改数据库中储存的信息，给他人造成损害的犯罪行为。 信息犯罪危害性： 妨害国家安全和社会稳定的信息犯罪：犯罪主体利用网络信息造谣、诽谤或者发表、传播有害信息，煽动颠覆国家政权、推翻社会制度、分裂国家及破坏国家统一等。 妨害社会秩序和市场秩序的信息犯罪：犯罪主体利用信息网络从事虚假宣传、非法经营及其它非法活动，对社会秩序和正规的市场秩序造成恶劣影响。例如，一些犯罪分子利用网上购物的无纸化和实物不可见的特点，发布虚假商品出售信息，在骗取购物者钱财之后便销声匿迹，致使许多消费者上当受骗。此种行为严重破坏了市场经济秩序和社会秩序。 妨害他人人身、财产权利的信息犯罪：犯罪主体利用信息网络侮辱诽谤他人或者骗取他人财产（包含信息财产）。例如，通过信息网络，以窃取及公布他人隐私、编造各种丑闻以及窃取他人信用卡信息等方法为手段，以达到损害他人的隐私权、名誉权和骗取他人财产的目的。 信息犯罪的显著特点： 智能化：以计算机及网络犯罪为例，犯罪者大多是掌握计算机和网络技术的专业人才。 多样性：信息技术手段的多样性，必然造就信息犯罪行为的多样性。 隐蔽性强：犯罪分子可能只需要向计算机输入错误指令或简单篡改软件程序，作案时间短，甚至可以设计犯罪程序在一段时间后才运行发作，致使一般人很难觉察到。 侦查取证困难：以计算机犯罪为例，实施犯罪一般为异地作案，而且所有证据均为电子数据，犯罪分子可能在实施犯罪后，直接毁灭电子犯罪现场，致使侦查工作和罪证采集相当困难。 犯罪后果严重：信息安全专家普遍认为，信息犯罪危害性的大小，取决于信息资源的社会作用。作用越大，信息犯罪的后果越严重。 ","date":"2021-12-21 19:38:13","objectID":"https://qizhengzou.github.io/isc_base_10/:4:1","tags":["information security conspectus"],"title":"ISC_base_10","uri":"https://qizhengzou.github.io/isc_base_10/"},{"categories":["School courses"],"content":"10.4.2 信息安全道德规范 信息安全道德规范应该基于三个原则，即整体原则、兼容原则和互惠原则。 整体原则是指一切信息活动必须服从于社会、国家等团体的整体利益。个体利益服从整体利益，不得以损害团体整体利益为代价谋取个人利益。 兼容原则是指社会的各主体间的信息活动方式应符合某种公认的规范和标准，个人的具体行为应该被他人及整个社会所接受，最终实现信息活动的规范化和信息交流的无障碍化。 互惠原则是指任何一个使用者必须认识到，每个个体均是信息资源使用者和享受者，也是信息资源的生产者和提供者，在拥有享用信息资源的权利同时，也应承担信息社会对其成员所要求的责任。信息交流是双向的，主体间的关系是交互式的，权利和义务是相辅相成的。 美国Computer Ethics Institute的十条戒律： 不应用计算机去伤害别人； 不应干扰别人的计算机工作； 不应窥探别人的文件； 不应用计算机进行偷窃； 不应用计算机作伪证； 不应使用或拷贝你没有付钱的软件； 不应未经许可而使用别人的计算机资源； 不应盗用别人智力成果； 应该考虑你所编的程序的社会后果； 应该以深思熟虑和慎重的方式来使用计算机。 ACM提倡的伦理道德和职业规范： 美国的计算机协会（The Association of Computing Machinery） 为社会和人类做出贡献； 避免伤害他人； 要诚实可靠； 要公正并且不采取歧视性行为； 尊重包括版权和专利在内的财产权； 尊重知识产权； 尊重他人的隐私； 保守秘密。 南加利福尼亚大学网络伦理声明: 南加利福尼亚大学网络伦理声明指出了六种不道德网络行为： 有意地造成网络交通混乱或擅自闯入网络及其相联的系统； 商业性地或欺骗性地利用大学计算机资源； 偷窃资料、设备或智力成果； 未经许可接近他人的文件； 在公共用户场合做出引起混乱或造成破坏的行动； 伪造电子函件信息。 etc ","date":"2021-12-21 19:38:13","objectID":"https://qizhengzou.github.io/isc_base_10/:4:2","tags":["information security conspectus"],"title":"ISC_base_10","uri":"https://qizhengzou.github.io/isc_base_10/"},{"categories":["School courses"],"content":"10.4.3 信息安全法律规范 信息安全法律法规： 建立完善信息安全法律体系是当今重要课题。 一方面法律法规是震慑和惩罚信息犯罪的重要工具， 另一方面法律法规也是合法实施各项信息安全技术的理论依据。 1973 年，瑞典《瑞典国家数据保护法》。 美国的《信息自由法》、《计算机欺诈和滥用法》、《计算机安全法》、《国家信息基础设施保护法》、《通信净化法》、《个人隐私法》、《儿童网上保护法》、《爱国者法案》、《联邦信息安全管理法案》、《关键基础设施标识、优先级和保护》以及《涉密国家安全信息》等法律法规。 德国的《信息和通讯服务规范法》、法国的《互联网络宪章》、英国的《三R互联网络安全规则》、俄罗斯的《联邦信息、信息化和信息保护法》、日本的《电讯事业法》等， 欧洲理事会也出台了《网络犯罪公约》。 我国信息安全法律： 1994年2月，颁布的《中华人民共和国计算机信息系统安全保护条例》，赋予公安机关行使对计算机信息系统的安全保护工作的监督管理职权。 1995年2月，颁布的《中华人民共和国人民警察法》，明确了公安机关具有监督管理计算机信息系统安全的职责。 我国有关信息安全的立法原则是重点保护、预防为主、责任明确、严格管理和促进社会发展。 我国的信息安全法律法规可分为四类： 通用性法律法规 惩戒信息犯罪的法律 针对信息网络安全的特别规定 规范信息安全技术及管理方面的规定 通用性法律法规： 如宪法、国家安全法、国家秘密法等，这些法律没有针对信息安全的规定，但约束的对象包括危害信息安全行为。 例如： 中华人民共和国宪法的第四十条规定“中华人民共和国公民的通信自由和通信秘密受法律的保护。除因国家安全或者追查刑事犯罪的需要，由公安机关或者检察机关依照法律规定的程序对通信进行检查外，任何组织或者个人不得以任何理由侵犯公民的通信自由和通信秘密。” 中华人民共和国国家安全法的第十条规定“国家安全机关因侦察危害国家安全行为的需要，根据国家有关规定，经过严格的批准手续，可以采取技术侦察措施”。第十一条规定“国家安全机关为维护国家安全的需要，可以查验组织和个人的电子通信工具、器材等设备、设施”；第二十一条规定“任何个人和组织都不得非法持有、使用窃听、窃照等专用间谍器材”。 中华人民共和国保守国家秘密法的第三条规定“一切国家机关、武装力量、政党、社会团体、企业事业单位和公民都有保守国家秘密的义务”。 惩戒信息犯罪的法律： 这类法律包括《中华人民共和国刑法》、《全国人大常委会关于维护互联网安全的决定》等。这类法律中的有关法律条文可以作为规范和惩罚网络犯罪的法律规定。 中华人民共和国刑法的第二百一十九条规定“有下列侵犯商业秘密行为之一，给商业秘密的权利人造成重大损失的，处三年以下有期徒刑或者拘役，并处或者单处罚金；造成特别严重后果的，处三年以上七年以下有期徒刑，并处罚金”。侵犯商业秘密行为包括： 以盗窃、利诱、胁迫或者其他不正当手段获取权利人的商业秘密的； 披露、使用或者允许他人使用以前项手段获取的权利人的商业秘密的； 违反约定或者违反权利人有关保守商业秘密的要求，披露、使用或者允许他人使用其所掌握的商业秘密的。 针对信息网络安全的特别规定： 这类法律规定主要有《中华人民共和国计算机信息系统安全保护条例》、《中华人民共和国计算机信息网络国际联网管理暂行规定》、《中华人民共和国计算机软件保护条例》等。 这些法律规定的立法目的是保护信息系统、网络以及软件等信息资源，从法律上明确哪些行为构成违反法律法规，并可能被追究相关民事或刑事责任。 规范信息安全技术及管理方面的规定： 这类法律主要有《商用密码管理条例》、《计算机信息系统安全专用产品检测和销售许可证管理办法》、《计算机病毒防治管理办法》等。 商用密码管理条例的第三条规定“商用密码技术属于国家秘密。国家对商用密码产品的科研、生产、销售和使用实行专控管理。” 商用密码管理条例的第七条规定“商用密码产品由国家密码管理机构指定的单位生产。未经指定，任何单位或者个人不得生产商用密码产品。” 信息安全法律法规体系组成： 我国信息安全法律法规体系主要由六个部分组成： 法律，例如：《中华人民共和国宪法》。 行政法规，例如： 《中华人民共和国计算机信息系统安全保护条例》。 部门规章和规范性文件， 例如，公安部的《计算机信息系统安全专用产品检测和销售许可证管理办法》。 地方性法规， 例如，《湖南省信息化条例》。 地方政府规章，例如，《四川省计算机信息系统安全保护管理办法》。 司法解释，例如，《关于审理扰乱电信市场管理秩序案件具体应用法律若干问题的解释》。 ","date":"2021-12-21 19:38:13","objectID":"https://qizhengzou.github.io/isc_base_10/:4:3","tags":["information security conspectus"],"title":"ISC_base_10","uri":"https://qizhengzou.github.io/isc_base_10/"},{"categories":["School courses"],"content":" 2021秋哈工大深圳罗文坚 信息安全概论课程PPT 摘抄 内容安全 ","date":"2021-12-21 19:37:20","objectID":"https://qizhengzou.github.io/isc_base_09/:0:0","tags":["information security conspectus"],"title":"ISC_base_09","uri":"https://qizhengzou.github.io/isc_base_09/"},{"categories":["School courses"],"content":"9.1 概述 信息内容安全有两方面内容: 一方面是指针对合法的信息内容加以安全保护，如对合法的音像制品及软件的版权保护； 内容保护 数字水印 版权控制 另一方面是指针对非法的信息内容实施监管，如对网络暴力色情信息的过滤等。 内容监管 内容识别 内容过滤 ","date":"2021-12-21 19:37:20","objectID":"https://qizhengzou.github.io/isc_base_09/:1:0","tags":["information security conspectus"],"title":"ISC_base_09","uri":"https://qizhengzou.github.io/isc_base_09/"},{"categories":["School courses"],"content":"9.1.1 内容保护 互联网的发展与普及使电子出版物的传播和交易变得便捷，侵权盗版活动也呈日益猖獗之势。 为了打击盗版犯罪： 一方面，要通过立法来加强对知识产权的保护； 另一方面，要有先进的技术手段来保障法律的实施。 内容保护技术大多数都是基于密码学和隐写术发展起来的: 如数据锁定、隐写标记、数字水印和数字版权管理DRM等技术，其中最具有发展前景和实用价值的是数字水印和数字版权管理。 信息隐藏和信息加密的区别： 信息隐藏和信息加密都是为了保护秘密信息的存储和传输，使之免遭敌手的破坏和攻击，但两者之间有着显著的区别。 信息加密是利用对称密钥密码或公开密钥密码把明文变换成密文；信息加密所保护的是信息的内容。 信息隐藏是将秘密信息嵌入到表面上看起来无害的宿主信息中，攻击者无法直观地判断他所监视的信息中是否含有秘密信息。 换句话说，含有隐匿信息的宿主信息不会引起别人的注意和怀疑，同时隐匿信息又能够为版权者提供一定的版权保护。 内容保护技术： 数据锁定是指出版商把多个软件或电子出版物集成到一张光盘上出售，盘上所有的内容均被分别进行加密锁定，不同的用户买到的均是相同的光盘，每个用户只需付款买他所需内容的相应密钥，即可利用该密钥对所需内容解除锁定，而其余不需要的内容仍处于锁定状态，用户是无法使用的。 在Internet上，数据锁定技术可以用于FTP服务器或Web站点上的数据保护，付费用户可以利用特定的密钥对所需要的内容解除锁定。 隐匿标记是指利用文字或图像的格式（如间距、颜色等）特征隐藏特定信息。 例如，在文本文件中，字与字间、行与行间均有一定的空白间隔，把这些空白间隔精心改变后可以隐藏某种编码的标记信息以识别版权所有者，而文件中的文字内容不需作任何改动。 数字水印是镶嵌在数据中，并且不影响合法使用的具有可鉴别性的数据。它一般应当具有不可察觉性、抗擦除性、稳健性和可解码性。 为了保护版权，可以在数字视频内容中嵌入水印信号。 如果制定某种标准，可以使数字视频播放机能够鉴别到水印，一旦发现在可写光盘上有“不许拷贝”的水印，表明这是一张经非法拷贝的光盘，因而拒绝播放。还可以使数字视频拷贝机检测水印信息，如果发现“不许拷贝”的水印，就不去拷贝相应内容。 数字版权管理DRM（Digital Rights Management）技术是专门用来保护数字化版权的产品。 DRM的核心是数据加密和权限管理，同时也包含了上述提到的几种技术。DRM特别适合基于互联网应用的数字版权保护，目前已经成为数字媒体的主要版权保护手段。 ","date":"2021-12-21 19:37:20","objectID":"https://qizhengzou.github.io/isc_base_09/:1:1","tags":["information security conspectus"],"title":"ISC_base_09","uri":"https://qizhengzou.github.io/isc_base_09/"},{"categories":["School courses"],"content":"9.1.2 内容监管 在对合法信息进行有效的内容保护同时，针对虚假信息（如疫情期间的各种谣言）的监管，针对大量的充斥暴力色情等非法内容的媒体信息（特别是网络媒体信息）的内容监管，也是十分必要。 面向网络信息内容的监管主要涉及两类： 一类是静态信息，主要是存在于各个网站中的数据信息，例如挂马网站的有关网页、色情网站上的有害内容以及钓鱼网站上的虚假信息等； 另一类是动态信息，主要是在网络中流动的数据信息，例如网络中传输的垃圾邮件、色情及虚假网页信息等。 无论是有害的网站静态信息，还是正在网络上传输的动态有害信息，都会对社会造成极大危害，因此，必须对它们进行有效监管。 内容监管技术： 针对静态信息的内容监管技术主要包括网站数据获取技术、内容分析技术、控管技术等。 控管技术是指对违法的网站实施有效的控制管理，将其危害性减少到最低程度，主要涉及阻断对有害网站的访问以及报警等技术。 对于动态信息进行内容监管所采取的技术主要包括网络数据获取技术、内容分析技术、控管技术等 网络数据获取技术是指通过在网络关键路径上设置数据采集点，以监听捕获通过该路径的所有网络报文数据。 有关内容分析技术和控管技术部分基本上与对静态信息采取的处理技术相同。 ","date":"2021-12-21 19:37:20","objectID":"https://qizhengzou.github.io/isc_base_09/:1:2","tags":["information security conspectus"],"title":"ISC_base_09","uri":"https://qizhengzou.github.io/isc_base_09/"},{"categories":["School courses"],"content":"9.2 版权保护 版权（又称著作权）保护是内容保护的重要部分，其最终目的不是“如何防止使用”，而是“如何控制使用”，版权保护的实质是一种控制版权作品使用的机制。 数字版权保护技术DRM (Digital Rights Management )就是以一定安全算法实现对数字内容的保护。 DRM目的是从技术上防止数字内容的非法复制， 或者在一定程度上使非法复制变得很困难，用户必须在得到授权后才能使用数字内容。 DRM涉及的主要技术包括数字标识技术、安全和加密技术以及安全存储技术等。 DRM技术方法主要有两类，一类是采用数字水印技术，另一类是以数据加密和防拷贝为核心的DRM 技术。 ","date":"2021-12-21 19:37:20","objectID":"https://qizhengzou.github.io/isc_base_09/:2:0","tags":["information security conspectus"],"title":"ISC_base_09","uri":"https://qizhengzou.github.io/isc_base_09/"},{"categories":["School courses"],"content":"9.2.1 DRM概述 DRM技术自产生以来，得到了工业界和学术界的普遍关注，被视为是数字内容交易和传播的关键技术。 国际上许多著名的计算机公司和研究机构纷纷推出了各自的产品和系统。 例如，Microsoft WMRM、IBM EMMS、Real Networks Helix DRM以及Adobe Content Server等。 国内的DRM技术发展同样很快，特别是在电子书以及电子图书馆方面，如北大方正Apabi 数字版权保护技术、书生的SEP技术、超星的PDG等。 Microsoft的Windows XP操作系统和Office XP等系列软件中也使用了DRM技术。 DRM工作原理： DRM系统结构分为服务器和客户端两部分。 主要版权保护产品： 目前DRM所保护的内容主要分为三类 包括电子书、音视频文件和电子文档。 Adobe 公司的ACS（Adobe Content Server）软件 方正的Apabi数字版权保护软件，主要由Maker、Rights Server、Retail Server和Reader四部分组成。 Microsoft公司于1999年8月发布了Windows Media DRM。 最新版本的Windows Media DRM 10 系列包括了服务器和软件开发包SDKs。 RMS（Rights Management Services），Microsoft公司 适用于电子文档保护的数字内容管理系统。 ","date":"2021-12-21 19:37:20","objectID":"https://qizhengzou.github.io/isc_base_09/:2:1","tags":["information security conspectus"],"title":"ISC_base_09","uri":"https://qizhengzou.github.io/isc_base_09/"},{"categories":["School courses"],"content":"9.2.2 数字水印 原始的水印Watermark是指在制作纸张过程中通过改变纸浆纤维密度的方法而形成的，“夹”在纸中而不是在纸的表面，迎光透视时可以清晰看到的有明暗纹理的图像或文字。 人民币、购物卷以及有价证劵等，以防止造假。 数字水印（digital watermark）也是用来证明一个数字产品的拥有权、真实性。 数字水印是通过一些算法嵌入在数字产品中的数字信息，如产品的序列号、公司图像标志以及有特殊意义的文本等。 数字水印分为可见数字水印和不可见数字水印。 可见水印主要用于声明对产品的所有权、著作权和来源，起到广告宣传或使用约束的作用。例如，电视台播放节目时的台标既起到广告宣传，又可声明所有权。 不可见数字水印应用的层次更高，制作难度更大，应用面也更广。 数字水印原理： 一个数字水印（后简称为水印）方案一般包括三个基本方面：水印的形成、水印的嵌入和水印的检测。 水印的形成主要是指选择有意义的数据，以特定形式生成水印信息，如有意义的文字、序列号、数字图像（商标、印鉴等）或者数字音频片段的编码。 一般来说，水印信息可以根据需要制作成可直接阅读的明文信息，也可以是经过加密处理后的密文。 水印的嵌入： 水印的嵌入与密码体系的加密环节类似，一般分为输入、嵌入处理和输出三部分。 嵌入处理完成的主要任务是对输入原始文件进行分析，选择嵌入点，在整个过程中可能需要密码参与。 水印的检测： 水印的检测分为两部分：检测水印是否存在，提取水印信息。 水印的检测方式主要分为盲水印检测和非盲水印检测。 盲水印检测主要指不需要原始数据（原始宿主文件和水印信息）参与，直接进行检测水印信号是否存在； 非盲水印检测是在原始数据参与下进行水印检测。 水印提取及比较主要针对不可见水印，一般可见水印可以直接由视觉识别。 数字水印的特征： 数字水印的使用一般要以不破坏原始作品的欣赏价值和使用价值为原则，因此数字水印应具有以下基本特征： 隐蔽性（不可见水印）：指水印与原始数据紧密结合并隐藏在其中，不影响原始数据正常使用的特性。 鲁棒性：指嵌入的水印信息能够抵抗针对数字作品的各种恶意或非恶意的操作，即经过了各种攻击后是否还能提取水印信息。 安全性：未授权者不能伪造水印或检测出水印。密码技术对水印的嵌入过程进行置乱加强安全性，从而避免没有密钥的使用者恢复和修改水印。 易用性：指水印的嵌入和提取算法是否简单易用，主要指水印嵌入算法和水印提取算法的实用性和执行效率等。 数字水印算法： 数字水印技术研究已经取得 很大的进步，出现了很多优秀的数字水印算法。 面向文本的水印算法 面向图像的水印算法 面向音视频的水印算法 NEC算法 生理模型算法 面向文本的水印算法： 纯文本文档，指ASCII码文档或计算机源代码文档。 不存在可插入标记的可辨认空间，很难嵌入秘密信息，需要保护和认证的正式文档很少采用纯文本格式。 格式化的文档，一般指除了文本信息之外，有很多用来标记文字格式和版面布局的冗余信息，并可使用相关软件进行处理的文件。 如Word文件、PDF文件等。 对于这类文档，可以把水印信息嵌入到这类文档的格式化编排中。例如，行、字间距，字体，文字大小和颜色等不足以被人眼发现的微小变化都可以用来进行信息的隐藏。 基于文档结构微调的文本水印算法：主要指通过文本文档空间域的变换来嵌入数据。文档的空间域不仅包括文本的字符、行、段落的结构布局，也包括了字符的颜色和形状。 基于语法的文本水印算法：一类是按照语法规则对载体文本中的词汇进行替换来隐藏水印信息，另一类是按照语法规则对载体文本中的标点符号来进行修改隐藏水印信息。 基于语义的文本水印算法：将一段正常的语言文字修改为包含特定词语（如同义词）的语言文字，在这个修改过程中水印信息被嵌入到文本内。 基于汉字特点的文本水印算法：常见的基于汉字特点的文本水印有针对汉字的笔画特征（如倾斜角度）进行修改以嵌入水印信息，还有针对汉字的结构组合特征进行修改以嵌入水印信息，如将汉字看做二值图像，利用汉字结构中各部分的连通性嵌入水印信息。 面向图像的水印算法： 空域数字图像水印算法主要是在图像的像素上直接进行的，通过修改图像的像素值嵌入数字水印的。 经典的最低有效位LSB（Least Significant Bits）空域水印算法是以人类视觉系统不易感知为准则，在原始载体数据的最不重要的位置上嵌入数字水印信息。该算法的优势是可嵌入的水印容量大，不足是嵌入的水印信息很容易被移除。 变换域数字水印算法是在图像的变换域进行水印嵌入的。即，将原始图像经过正交变换，将水印嵌入到图像的变换系数中。 常用的变换有离散傅里叶变换、离散余弦变换、离散小波变换等。 在变换域中嵌入的数字水印能量可以扩展到空间域的所有像素上，有利于实现水印的不可感知性，还可增强水印的鲁棒性。 面向音视频的水印算法： 根据音频水印载体类型，音频水印技术可分为基于原始音频和基于压缩音频两种。 基于原始音频方法是在未经编码压缩的音频信号中直接嵌入水印。 基于压缩音频方法指音频信号在压缩编码过程中嵌入水印信息，输出的是含水印的压缩编码的音频信号。 视频可以认为是由一系列连续的静止图像在时间域上构成的序列，因此视频水印技术与图像水印技术在应用模式和设计方案上具有相似之处。 数字视频水印主要包括基于原始视频的水印、基于视频编码的水印和基于压缩视频的水印。 NEC算法： NEC算法是由NEC实验室的Cox等人提出，在数字水印算法中占有重要地位。 水印信号应该嵌入到最容易让人察觉到变化的源数据部分。 在频谱空间中，这种重要部分就是低频分量。这样，攻击者在破坏水印的过程中，不可避免地会引起图象质量的严重下降。 水印信号应该由具有高斯分布的独立同分布随机实数序列构成。这使得水印抵抗多拷贝联合攻击的能力大大增强。 具体的实现方法：首先以密钥为种子来产生伪随机序列，该序列具有高斯N(0, 1)分布。密钥可以由作者的标识码和图像的哈希值组成，对整幅图像做离散余弦变换，用伪随机高斯序列来叠加该图像的1000个最大的DCT系数（除直流分量外）。 NEC算法具有较强的鲁棒性、安全性、透明性等。 生理模型算法： 人的生理模型包括人类视觉系统HVS（Human Visual System）和人类听觉系统HAS（Human auditory System）等。 生理模型算法的基本思想是利用人类视觉的掩蔽现象，从HVS模型导出的可觉察差异JND（Just Noticeable Difference）。 利用JND描述来确定图像的各个部分所能容忍的数字水印信号的最大强度。 人类视觉对物体的亮度和纹理具有不同程度的感知性，可以调节嵌入水印信号的强度。 亮度掩蔽特性：背景越亮，所嵌入水印的可见性越低； 纹理掩蔽特性：纹理越复杂，所嵌入水印的可见性越低 ","date":"2021-12-21 19:37:20","objectID":"https://qizhengzou.github.io/isc_base_09/:2:2","tags":["information security conspectus"],"title":"ISC_base_09","uri":"https://qizhengzou.github.io/isc_base_09/"},{"categories":["School courses"],"content":"9.3 内容监管 内容监管是内容安全的另一重要方面，如果监管不善，会对社会造成极大的影响，其重要性不言而喻。 内容监管涉及到很多领域，其中基于网络的信息已经成为内容监管的首要目标。 一般来说病毒、木马、色情、反动、严重的虚假欺骗以及垃圾邮件等有害的网络信息都需要进行监管。 ","date":"2021-12-21 19:37:20","objectID":"https://qizhengzou.github.io/isc_base_09/:3:0","tags":["information security conspectus"],"title":"ISC_base_09","uri":"https://qizhengzou.github.io/isc_base_09/"},{"categories":["School courses"],"content":"9.3.1 网络信息内容监管 内容监管首先需要解决的就是如何制定监管的总体策略。 总体策略主要包括监管的对象、监管的内容、对违规内容如何处理等。 首先是如何界定违规内容（那些需要禁止的信息），既能够禁止违规内容，又不会殃及到合法应用。 其次是对于可能存在一些违规信息的网站如何处理。 一种方法是通过防火墙禁止对该网站的全部访问，这样比较安全，但也会禁止掉其他有用内容； 另一种方法是允许网站部分访问，只是对那些有害网页信息进行拦截，但此种方法存在拦截失败的可能性。 内容监管系统模型： 内容监管系统模型可以分为监管策略和监管处理两部分 内容监管策略： 内容监管需求是制定内容监管策略的依据。 内容监管策略是内容监管需求的形式化表示。 内容监管策略包括： 数据获取策略，主要确定监管对象的范围、采用何种方式获取需要检测的数据； 敏感特征定义，是指用于判断网络信息内容是否违规的特征值，如敏感字符串、图片等； 违规定义，是指依据网络信息内容中包含敏感特征值的情况判断是否违规的规则； 违规处理策略，是指对于违规载体（网站或网络连接）的处理方法，如禁止对该网站的访问、拦截有关网络连接等。 数据获取： 数据获取技术分为主动式和被动式两种形式。 主动式数据获取是指通过访问有关网络连接而获得其数据内容。网络爬虫是典型的主动式数据获取技术。 网络爬虫是如何工作的： 被动式数据获取是指在网络的特定位置设置探针，获取流经该位置的所有数据。 被动式数据获取需要解决两个方面的问题： 探针位置的选择： 对出入数据报文的采集。 网络适配器必须工作在混杂模式下，这样才能保证所有接收到的数据报文被提交给协议栈。 网络报文处理流程： 数据调整： 数据调整主要指针对数据获取模块（主要是协议栈）提交的应用层数据进行筛选、组合、解码以及文本还原等工作；数据调整的输出结果用于敏感特征搜索等 敏感特征搜索： 敏感特征搜索实际上就是依据实现定义好的敏感特征策略，在待查内容中识别所包含的敏感特征值，搜索的结果可以作为违规判定的依据。 敏感特征值可以是文本字符串、图像特征、音频特征等，它们分别用于不同信息载体的内容的敏感特征识别。 基于文本内容的识别已经比较成熟并达到可实用化，而图像、音频特征的识别还存在着一些问题，难以实现全面有效的程序自动监管，更多时候需要人的介入。 基于文本内容的敏感特征又分为敏感字符串和敏感表达式两种形式。但无论哪种形式，均以串匹配为核心技术。 串匹配又称为模式匹配，分为单模式匹配和多模式匹配。 BF（Brute-Force）算法、KMP（Knuth Morris Pratt）算法、BM（Boyer-Moore）及BMH（Boyer Moor Horspool）算法均为经典的单模式匹配算法。 常见的多模式匹配算法有AC（Aho-Corasick）算法、ACBM（Aho-Corasick Boyer-Moore）算法、Manber-Wu算法等。 这些多模式匹配算法的主要特点是通过一次扫描母串可以寻找到其包含的所有子串Patterns，其搜索速度与子串的数目无关，主要取决于对母串的扫描速度。 违规判定及处理： 违规判定程序的设计思想： 将敏感特征搜索结果与违规定义相比较，判断该网络信息内容是否违规。 违规定义是说明违规内容应具有的特征，即敏感特征。 每个敏感特征由敏感特征值和特征值敏感度（某特征值对违规的影响程度，也可以看作权重）两个属性来描述。 敏感特征的搜索结果具有敏感特征值的广度（包含相异敏感特征值的数量）和敏感特征值的深度（包含同一个特征值的数量）两个指标。 违规判断算法针对上述内容进行计算，根据计算结果是否符合某个事先制定的标准来判断是否违规。 违规处理目前主要采用的方法与入侵检测相似。 报警，就是通知有关人员违规事件的具体情况； 封锁IP，一般是指利用防火墙等网络设备阻断对有关IP地址的访问； 拦截连接，是指针对某个特定访问连接实施阻断。向通讯双方发送RST数据包阻断TCP连接就是常用的拦截方法。 ","date":"2021-12-21 19:37:20","objectID":"https://qizhengzou.github.io/isc_base_09/:3:1","tags":["information security conspectus"],"title":"ISC_base_09","uri":"https://qizhengzou.github.io/isc_base_09/"},{"categories":["School courses"],"content":"9.3.2 垃圾邮件处理 垃圾邮件（Spam），目前还没有一个非常严格的定义。 一般来说，凡是未经用户许可，就强行发送到用户邮箱中的任何电子邮件都属于垃圾邮件。 垃圾邮件，可以分为良性和恶性两种。 良性垃圾邮件是指各种宣传广告等对收件人影响不大的信息邮件。 恶性垃圾邮件是指具有破坏性的电子邮件。 垃圾邮件处理： 目前主要采用的技术有过滤、验证查询和挑战。 过滤（Filter）技术，是相对来说最简单、又最直接的垃圾邮件处理技术，主要用于邮件接收系统来辨别和处理垃圾邮件。 验证查询技术，主要指通过密码验证及查询等方法来判断邮件是否为垃圾邮件。 包括反向查询、雅虎的DKIM（Domain Keys Identified Mail）技术、Microsoft的SenderID技术、IBM的FairUCE（Fair use of Unsolicited Commercial Email）技术以及邮件指纹技术等。 基于挑战的反垃圾技术，是指通过延缓邮件处理过程，来阻碍发送大量邮件。 基于过滤技术的反垃圾邮件系统： ","date":"2021-12-21 19:37:20","objectID":"https://qizhengzou.github.io/isc_base_09/:3:2","tags":["information security conspectus"],"title":"ISC_base_09","uri":"https://qizhengzou.github.io/isc_base_09/"},{"categories":["School courses' list"],"content":" base来自2021年秋哈工大深圳密码学基础授课老师：蒋琳 base_01 课程简介 base_02 古典密码学 代换密码 置换密码 小结 base_03 分组密码 对称加密分类 分组密码设计准则 分组密码设计方法 数据加密标准（DEA） AES 分组密码操作模式 base_04 数学原理 base_05 序列密码 概述 序列密码生成 伪随机序列 base_06 公钥加密（RSA，DH, ElGamal 与椭圆曲线） 公钥密码体制 RSA RSA安全性 DH密钥交换协议 EIGamal加密 椭圆曲线加密 base_07 Hash,MAC,DS 哈希函数应用 两个简易的哈希函数 哈希函数要求 哈希函数结构 MD5 SHA512 Message Authentication Code MAC 消息验证码 Digital Signature DS 数字签名 PKI 公钥基础设施 ","date":"2021-12-16 15:27:36","objectID":"https://qizhengzou.github.io/cry_catalogue/:0:0","tags":["catalogue"],"title":"Cry_catalogue","uri":"https://qizhengzou.github.io/cry_catalogue/"},{"categories":["School courses"],"content":" 笔记来自2021年秋哈工大深圳密码学基础授课老师：蒋琳 Hash,MAC,DS ","date":"2021-12-16 15:24:07","objectID":"https://qizhengzou.github.io/cry_base_07/:0:0","tags":["cryptography"],"title":"Cry_base_07","uri":"https://qizhengzou.github.io/cry_base_07/"},{"categories":["School courses"],"content":"哈希函数应用 消息验证 完整性 口令验证 MAC（与加密配合） 数字签名（与加密配合） ","date":"2021-12-16 15:24:07","objectID":"https://qizhengzou.github.io/cry_base_07/:1:0","tags":["cryptography"],"title":"Cry_base_07","uri":"https://qizhengzou.github.io/cry_base_07/"},{"categories":["School courses"],"content":"两个简易哈希函数 全文XOR 每块异或之后左移一位 ","date":"2021-12-16 15:24:07","objectID":"https://qizhengzou.github.io/cry_base_07/:2:0","tags":["cryptography"],"title":"Cry_base_07","uri":"https://qizhengzou.github.io/cry_base_07/"},{"categories":["School courses"],"content":"哈希函数要求（哈希函数容易收到生日攻击） 不定长明文-\u003e定长哈希 单向性（抗原像攻击） 弱抗碰撞性（抗第二原像攻击）：给定原文和哈希，寻找碰撞 强抗碰撞性：任意寻找两个碰撞原文 ","date":"2021-12-16 15:24:07","objectID":"https://qizhengzou.github.io/cry_base_07/:3:0","tags":["cryptography"],"title":"Cry_base_07","uri":"https://qizhengzou.github.io/cry_base_07/"},{"categories":["School courses"],"content":"哈希函数结构 Merkle-Damgard 结构 两大流派： ","date":"2021-12-16 15:24:07","objectID":"https://qizhengzou.github.io/cry_base_07/:4:0","tags":["cryptography"],"title":"Cry_base_07","uri":"https://qizhengzou.github.io/cry_base_07/"},{"categories":["School courses"],"content":"MD5 总结构： MD5运算： ","date":"2021-12-16 15:24:07","objectID":"https://qizhengzou.github.io/cry_base_07/:5:0","tags":["cryptography"],"title":"Cry_base_07","uri":"https://qizhengzou.github.io/cry_base_07/"},{"categories":["School courses"],"content":"SHA512 总结构（与MD5基本一致） 填充： ","date":"2021-12-16 15:24:07","objectID":"https://qizhengzou.github.io/cry_base_07/:6:0","tags":["cryptography"],"title":"Cry_base_07","uri":"https://qizhengzou.github.io/cry_base_07/"},{"categories":["School courses"],"content":"Message Authentication Code MAC 消息验证码 目的：检测消息的改动 一种结构: 本质：一种与密钥有关的哈希函数 ","date":"2021-12-16 15:24:07","objectID":"https://qizhengzou.github.io/cry_base_07/:7:0","tags":["cryptography"],"title":"Cry_base_07","uri":"https://qizhengzou.github.io/cry_base_07/"},{"categories":["School courses"],"content":"Digital Signature DS 数字签名 性质 身份验证（来自公私钥加密） 数据完整性（来自hash） 不可否认性（来自DS） RSA签名 速度慢 可伪造 ElGamal签名 密钥生成 p大素数 g本原根 x密钥 $y=g^xmod p$公钥 签名 $\\operatorname{sig}(\\mathrm{m}, \\mathrm{k})=(\\mathrm{r}, \\mathrm{s}), \\mathrm{k} \\in \\mathrm{Z}_{\\mathrm{p}-1}^{*}$ is random $\\mathrm{r}=\\mathrm{g}^{\\mathrm{k} } \\bmod \\mathrm{p}$ $s=k^{-1}(H(m)-x r) \\bmod (p-1)$ Schnorr签名（略） DSS（略） ","date":"2021-12-16 15:24:07","objectID":"https://qizhengzou.github.io/cry_base_07/:8:0","tags":["cryptography"],"title":"Cry_base_07","uri":"https://qizhengzou.github.io/cry_base_07/"},{"categories":["School courses"],"content":"PKI 公钥基础设施 结构如下: ","date":"2021-12-16 15:24:07","objectID":"https://qizhengzou.github.io/cry_base_07/:9:0","tags":["cryptography"],"title":"Cry_base_07","uri":"https://qizhengzou.github.io/cry_base_07/"},{"categories":["School courses"],"content":" 笔记来自2021年秋哈工大深圳密码学基础授课老师：蒋琳 公钥加密（RSA，DH, ElGamal 与椭圆曲线） ","date":"2021-12-16 15:24:04","objectID":"https://qizhengzou.github.io/cry_base_06/:0:0","tags":["cryptography"],"title":"Cry_base_06","uri":"https://qizhengzou.github.io/cry_base_06/"},{"categories":["School courses"],"content":"公钥密码体制 非对称密码：免去密钥分发、密钥管理简单 原则 单向函数 陷门单向函数 ","date":"2021-12-16 15:24:04","objectID":"https://qizhengzou.github.io/cry_base_06/:1:0","tags":["cryptography"],"title":"Cry_base_06","uri":"https://qizhengzou.github.io/cry_base_06/"},{"categories":["School courses"],"content":"RSA 密钥生成 选择两个大素数p,q 随机选择公钥e,$\\text { sub to } 1\u003c\\mathrm{e}\u003c\\phi(\\mathrm{n}), \\operatorname{gcd}(\\mathrm{e}, \\phi(\\mathrm{n}))=1$ 加密：C=$m^e mod n (m \u003c n)$ 解密：m=$C^d mod n (C \u003c n)$ ","date":"2021-12-16 15:24:04","objectID":"https://qizhengzou.github.io/cry_base_06/:2:0","tags":["cryptography"],"title":"Cry_base_06","uri":"https://qizhengzou.github.io/cry_base_06/"},{"categories":["School courses"],"content":"RSA安全性 共模攻击 低指数攻击 CCA选择密文攻击（因为RSA是确定性加密算法） ","date":"2021-12-16 15:24:04","objectID":"https://qizhengzou.github.io/cry_base_06/:3:0","tags":["cryptography"],"title":"Cry_base_06","uri":"https://qizhengzou.github.io/cry_base_06/"},{"categories":["School courses"],"content":"DH密钥交换协议 目的：双方在网络中交换信息以生成双方共享的会话密钥 原理 本原根g，双方密钥x,y 公开交换$g^x,g^y$ 公钥$g^{xy}$ 出现中间人攻击问题 ","date":"2021-12-16 15:24:04","objectID":"https://qizhengzou.github.io/cry_base_06/:4:0","tags":["cryptography"],"title":"Cry_base_06","uri":"https://qizhengzou.github.io/cry_base_06/"},{"categories":["School courses"],"content":"ElGamal加密 密钥生成 选择大素数p，本原根$e_1$，选择整数d 生成$e_2 = e^d_1 mod p$ 作为公钥， 作为私钥 公钥加密 $ C_1 = e^r_1 mod p$ $ C_2=(e^r_2*P)mod p$ 私钥解密 $ P=C_2*(C^p_1)^{-1}mod p$ ","date":"2021-12-16 15:24:04","objectID":"https://qizhengzou.github.io/cry_base_06/:5:0","tags":["cryptography"],"title":"Cry_base_06","uri":"https://qizhengzou.github.io/cry_base_06/"},{"categories":["School courses"],"content":"椭圆曲线加密 椭圆曲线定义:$E(a,b):y^2=x^3+ax+b$ 运算定义： $P=(x,y) -p=(x,-y)$ $R=P+Q$ $P+P=2P$ $P+(-P)=O$ $P=(x_p,y_p),Q=(x_q,y_q)$ $R=P+Q=(x_r,y_r)$ $\\begin{aligned}\u0026-x_{r}=\\lambda^{2}+\\lambda-x_{p}-x_{q}-a \\\u0026-y_{r}=-\\lambda\\left(x_{r}-x_{p}\\right)-x_{r}-y_{p}\\end{aligned}$ 可以看到，对于P，nP非常复杂，也就是说已知nP求解出P是困难的，基于此对ElGamal做改进如下: 密钥生成 选择椭圆曲线$E_p(a,b),e_1=(x,y),d$ 生成$e_2=de_1$ $e_2,e_1$作为公钥，d作为私钥 公钥加密： $C_1=re_1$ $C_2=p+re_2$ 私钥解密： $P=C_2-dC_1$ ","date":"2021-12-16 15:24:04","objectID":"https://qizhengzou.github.io/cry_base_06/:6:0","tags":["cryptography"],"title":"Cry_base_06","uri":"https://qizhengzou.github.io/cry_base_06/"},{"categories":["School courses"],"content":" 笔记来自2021年秋哈工大深圳密码学基础授课老师：蒋琳 序列密码 ","date":"2021-12-16 15:24:00","objectID":"https://qizhengzou.github.io/cry_base_05/:0:0","tags":["cryptography"],"title":"Cry_base_05","uri":"https://qizhengzou.github.io/cry_base_05/"},{"categories":["School courses"],"content":"概述 序列密码，也称流密码，是对称密码中的一种 序列密码的因一次一密应运而生的 思想：用短的种子密钥来获取长的密钥序列，其独立于明文消息和密文消息。 结构： e. 密钥流是密钥和固定大小的以往密文位的函数 ","date":"2021-12-16 15:24:00","objectID":"https://qizhengzou.github.io/cry_base_05/:1:0","tags":["cryptography"],"title":"Cry_base_05","uri":"https://qizhengzou.github.io/cry_base_05/"},{"categories":["School courses"],"content":"序列密码生成 密钥序列生成：安全性至关重要 密钥生成器一般由两部分构成：驱动子系统、非线性组合子系统 内部由有限状态自动机构成 ","date":"2021-12-16 15:24:00","objectID":"https://qizhengzou.github.io/cry_base_05/:2:0","tags":["cryptography"],"title":"Cry_base_05","uri":"https://qizhengzou.github.io/cry_base_05/"},{"categories":["School courses"],"content":"伪随机序列 m序列：最大长度线性反馈移位寄存器序列的简称。k位数据最大重复周期$2^k-1$（0不是有效数据） 线性反馈寄存器的特征多项式：以此产生m序列 产生m序列的充要条件：特征多项式为“本原多项式” 特性 均衡性 短游程特性 自相关特性 应用 测试噪声源 加密通信 加扰以及平衡 ","date":"2021-12-16 15:24:00","objectID":"https://qizhengzou.github.io/cry_base_05/:3:0","tags":["cryptography"],"title":"Cry_base_05","uri":"https://qizhengzou.github.io/cry_base_05/"},{"categories":["School courses"],"content":" 笔记来自2021年秋哈工大深圳密码学基础授课老师：蒋琳 数学原理 ","date":"2021-12-16 15:23:56","objectID":"https://qizhengzou.github.io/cry_base_04/:0:0","tags":["cryptography"],"title":"Cry_base_04","uri":"https://qizhengzou.github.io/cry_base_04/"},{"categories":["School courses"],"content":"模运算 费马小定理 拓展欧几里得算法 中国剩余定理 ","date":"2021-12-16 15:23:56","objectID":"https://qizhengzou.github.io/cry_base_04/:1:0","tags":["cryptography"],"title":"Cry_base_04","uri":"https://qizhengzou.github.io/cry_base_04/"},{"categories":["School courses"],"content":"群环域 $Z_n$ 伽罗瓦域Galois FIeld GF(p) ","date":"2021-12-16 15:23:56","objectID":"https://qizhengzou.github.io/cry_base_04/:2:0","tags":["cryptography"],"title":"Cry_base_04","uri":"https://qizhengzou.github.io/cry_base_04/"},{"categories":["School courses"],"content":"多项式运算 GF(2)上的多项式 质多项式 快速运算 ","date":"2021-12-16 15:23:56","objectID":"https://qizhengzou.github.io/cry_base_04/:3:0","tags":["cryptography"],"title":"Cry_base_04","uri":"https://qizhengzou.github.io/cry_base_04/"},{"categories":["School courses"],"content":"素数Prime 素数判定 欧拉函数 ","date":"2021-12-16 15:23:56","objectID":"https://qizhengzou.github.io/cry_base_04/:4:0","tags":["cryptography"],"title":"Cry_base_04","uri":"https://qizhengzou.github.io/cry_base_04/"},{"categories":["School courses"],"content":"素数性质 费马小定理 欧拉定理 ","date":"2021-12-16 15:23:56","objectID":"https://qizhengzou.github.io/cry_base_04/:5:0","tags":["cryptography"],"title":"Cry_base_04","uri":"https://qizhengzou.github.io/cry_base_04/"},{"categories":["School courses"],"content":"素数生成 费马检测 Miller-Rabin检测n是否为素数 ","date":"2021-12-16 15:23:56","objectID":"https://qizhengzou.github.io/cry_base_04/:6:0","tags":["cryptography"],"title":"Cry_base_04","uri":"https://qizhengzou.github.io/cry_base_04/"},{"categories":["School courses"],"content":"因式分解 性质 暴力分解 费马定理 ","date":"2021-12-16 15:23:56","objectID":"https://qizhengzou.github.io/cry_base_04/:7:0","tags":["cryptography"],"title":"Cry_base_04","uri":"https://qizhengzou.github.io/cry_base_04/"},{"categories":["School courses"],"content":"二次同余Quadtratic Congruence 定义 欧拉定理 ","date":"2021-12-16 15:23:56","objectID":"https://qizhengzou.github.io/cry_base_04/:8:0","tags":["cryptography"],"title":"Cry_base_04","uri":"https://qizhengzou.github.io/cry_base_04/"},{"categories":["School courses"],"content":"指数对数 Exponentiation and Logarithm 快速指数运算 暴力对数运算 本原根primitive root ","date":"2021-12-16 15:23:56","objectID":"https://qizhengzou.github.io/cry_base_04/:9:0","tags":["cryptography"],"title":"Cry_base_04","uri":"https://qizhengzou.github.io/cry_base_04/"},{"categories":["School courses"],"content":" 笔记来自2021年秋哈工大深圳密码学基础授课老师：蒋琳 分组密码 ","date":"2021-12-16 15:23:53","objectID":"https://qizhengzou.github.io/cry_base_03/:0:0","tags":["cryptography"],"title":"Cry_base_03","uri":"https://qizhengzou.github.io/cry_base_03/"},{"categories":["School courses"],"content":"对称加密分类 分组密码/块密码（Block Cipher） 一次加密一个分组（Playfair） 序列密码/流密码（Stream Cipher） 一次加密一个比特或一个字节（一次一密Vernam Cipher） ","date":"2021-12-16 15:23:53","objectID":"https://qizhengzou.github.io/cry_base_03/:1:0","tags":["cryptography"],"title":"Cry_base_03","uri":"https://qizhengzou.github.io/cry_base_03/"},{"categories":["School courses"],"content":"分组密码设计准则 阻止分析出密钥和明文 混淆：密文和密钥之间的统计关系复杂 一般只用来序列加密 操作：代换 密文和密钥之间的统计关系变得尽可能复杂，以使攻击者无法得到密钥 即使攻击者能得到密文的一些统计关系，由于密钥和密文之间的统计关系复杂化，攻击者也无法得到密钥 使用复杂的代换算法可以得到预期的混淆效果，而简单的线性代换函数得到的混淆效果则不太理想 扩散：明文统计特性散布到密文中 序列加密和分组加密都可以使用 操作：置换 将明文的统计特性散布到密文中去，使明文的每位影响密文中多位的值 等价于密文中每位均受明文中多位的影响，即从密文中不能获得明文的统计特性 ","date":"2021-12-16 15:23:53","objectID":"https://qizhengzou.github.io/cry_base_03/:2:0","tags":["cryptography"],"title":"Cry_base_03","uri":"https://qizhengzou.github.io/cry_base_03/"},{"categories":["School courses"],"content":"分组密码设计方法 乘积密码 Shannon提出了乘积密码的思想：顺序地执行两个或多个代换和置换，使得最后结果的密码强度高于每个基本密码系统产生的结果 费斯妥网络(Feistel Network)、SP网络(Substitution Permutation Net) 迭代 每轮使用S盒和P盒以及其它一些方法，执行多轮 费斯妥网络(Feistel Network) A very intelligent and interesting cipher that has been used for decades. A Feistel cipher can have three types of components: self-invertible,invertible, and noninvertible. SP网络(Substitution Permutation Net) Only invertible components. A component in the encryption cipher has the corresponding component in the decryption cipher. ","date":"2021-12-16 15:23:53","objectID":"https://qizhengzou.github.io/cry_base_03/:3:0","tags":["cryptography"],"title":"Cry_base_03","uri":"https://qizhengzou.github.io/cry_base_03/"},{"categories":["School courses"],"content":"数据加密标准（DES） 简化版DES算法原理 两部分：加密和密钥生成 密钥生成： 加密： DES算法产生及原理 原理概述： 单轮结构： DES算法安全性分析 差分分析：CPA 线性分析：KPA 弱密钥问题 线性B盒 ","date":"2021-12-16 15:23:53","objectID":"https://qizhengzou.github.io/cry_base_03/:4:0","tags":["cryptography"],"title":"Cry_base_03","uri":"https://qizhengzou.github.io/cry_base_03/"},{"categories":["School courses"],"content":"AES 简化AES和AES参数 简化AES 总体流程： 加密流程： S盒代换、行置换、列混淆、轮密钥加 密钥拓展： ","date":"2021-12-16 15:23:53","objectID":"https://qizhengzou.github.io/cry_base_03/:5:0","tags":["cryptography"],"title":"Cry_base_03","uri":"https://qizhengzou.github.io/cry_base_03/"},{"categories":["School courses"],"content":"分组密码操作模式 分组密码在加密时，明文分组长度固定，而实际应用中待加密消息的数据量不固定，数据格式可能多种多样。 电码本ECB 加密：每次加密密钥相同 适用：短消息加密 容易暴露明文数据的格式和统计特征 不会产生错误转播Error Propagation效应 密码分组链接CBC 加密：输入是明文和前一次密文的异或 会出现传播错误 能隐蔽明文的数据模式 要注意IV的使用，不能IV+1和chained IV， 他们都不能解决CPA攻击 密码反馈CFB 可以进一步将DES转化为流密码 加密：输入是移位寄存器，加密的也是移位寄存器，最后与明文异或 错误传播 能检测出篡改，还能够隐蔽明文数据图样 输出反馈OFB 可以进一步将DES转化为流密码 加密：OFB直接将寄存器加密结构作为反馈（所以是输出反馈），而CFB是密文作为反馈（密码反馈） 克服了错误传播问题，难以检测密文篡改 不具有自同步功能，需要与系统保持严格的同步 计数器CTR 加密：OFB移位寄存器换成计数器 ","date":"2021-12-16 15:23:53","objectID":"https://qizhengzou.github.io/cry_base_03/:6:0","tags":["cryptography"],"title":"Cry_base_03","uri":"https://qizhengzou.github.io/cry_base_03/"},{"categories":["School courses"],"content":" 笔记来自2021年秋哈工大深圳密码学基础授课老师：蒋琳 古典密码学 ","date":"2021-12-16 15:23:51","objectID":"https://qizhengzou.github.io/cry_base_02/:0:0","tags":["cryptography"],"title":"Cry_base_02","uri":"https://qizhengzou.github.io/cry_base_02/"},{"categories":["School courses"],"content":"代换密码 将明文中的每个字符代换成密文中的另一个字符，代换后的各字符位置不变。 单字母单表密码 加法密码：caesar cipher $c_i=(m_i+k)mod26$ $m_i=(c_i-k)mod26$ 加乘密码：affine cipher $C_i=(aM_i+b)mod26$ $M_i=a^{-1}(C_i-b)mod26$ 利用拓展欧几里得算法求逆元 𝑎在乘法群ℤ𝑛中有乘法逆的前提是gcd 𝑛, 𝑎 = 1，即𝑛与𝑎互质 利用欧几里得算法（辗转相除法）求最大公约数 混合密码：mixed alphabetic cipher 混合字母表密码 给定每个字母之间的映射，按照该映射关系进行加密 单字母多表密码 周期多表代换：有限个周期性重复的固定代换表 周期多表代换：维吉尼亚密码 周期多表代换：转轮密码机（1870-1943） 有限个周期重复的固定代换表 无限多表代换：one-time pad（OTP）一次一密 密钥和明文一样长，且密钥不能重复使用 多字母密码 字母代换：playfair普莱菲尔密码 挑选个单词作为密钥 按照接下來的方式将字母一一填入5X5的矩阵 将明文分成两个字符一组(但若一组字母相同，则中间插入一个“x”) 加密规则: 若两字符在同一行，则各以边字符取代。 若两字符在同一列，则各以下方字符取代。 其他情況，则换成此二字符对角的两字符。 解密规则: 若两字符在同一行，则各以左边字符取代。 若两字符在同一列，则各以上方字符取代。 其他情况,则换成此二字符对角的两字符。 字母代换：Hill密码 代换密码安全性分析 都无法避免统计规律 ","date":"2021-12-16 15:23:51","objectID":"https://qizhengzou.github.io/cry_base_02/:1:0","tags":["cryptography"],"title":"Cry_base_02","uri":"https://qizhengzou.github.io/cry_base_02/"},{"categories":["School courses"],"content":"置换密码 将明文中的各字符位置次序重新排列，但不改变字符本身。 栅栏密码 列移位密码 按固定列数排列 根据密钥按列移动 按列读出 ","date":"2021-12-16 15:23:51","objectID":"https://qizhengzou.github.io/cry_base_02/:2:0","tags":["cryptography"],"title":"Cry_base_02","uri":"https://qizhengzou.github.io/cry_base_02/"},{"categories":["School courses"],"content":"小结 ","date":"2021-12-16 15:23:51","objectID":"https://qizhengzou.github.io/cry_base_02/:3:0","tags":["cryptography"],"title":"Cry_base_02","uri":"https://qizhengzou.github.io/cry_base_02/"},{"categories":["School courses"],"content":" 笔记来自2021年秋哈工大深圳密码学基础授课老师：蒋琳 课程简介 不包含内容 计算机安全，例如病毒 网络安全，例如网络攻击 安全网络协议，例如安全传输层协议 公钥密码使得发送端和接收端无密钥传输的保密通信成为可能。 对称加密(Symmetric encryption)：加密和解密由同一个密钥来控制，也叫“单钥加密” 。 非对称加密(Asymmetric encryption)：用作加密的密钥不同于用作解密的密钥，而且解密密钥不能根据加密密钥计算出来，也叫“公钥加密” 密码算法分类：密码术： 密码编码学 古典密码学 隐写 替换（代换） 凯撒密码 维吉尼亚密码 Hill cipher 置换 栅栏密码 现代密码学 对称密码 分组密码 DES AES 序列密码 RC4 消息认证 MAC Hash 非对称密码 公钥密码学 REA加密 EIGamal签名 椭圆曲线密码学 基于身份密码学 高级密码法 属性加密 谓词加密 环签名 秘密分享 密码分析学 ","date":"2021-12-16 14:32:42","objectID":"https://qizhengzou.github.io/cry_base_01/:0:0","tags":["cryptography"],"title":"Cry_base_01","uri":"https://qizhengzou.github.io/cry_base_01/"},{"categories":["School courses"],"content":" 2021哈工大深圳堵宏伟分布式系统课程笔记 Consistency and Replication一致性和复制 Replication of data: Why? To enhance reliability To improve performance in a large scale system Replicas must be consistent Modifications have to be carried out on all copies Problems with network performance It is needed to handling concurrency… 1.2.3-\u003eDifferent consistency models A consistency model is a set of rules that process obeys accessing data Object Replication : How can we protect objects against multiple clients access Synchronization… A distributed remote object shared by different clients. a) A remote object capable of handling concurrent invocations on its own. b) A remote object for which an object adapter is required to handle concurrent invocations Replicas need more synchronization to ensure that concurrent invocations lead to consistent results A distributed system for replication-aware distributed objects. A distributed system responsible for replica management (simpler for application developers), it ensures that concurrent invocation are passed to the replicas in the correct order Replication and Scaling: Replication and caching are widely used in scaling technique, but Keeping replicas up to date needs networks use Update needs to be atomic ( transaction) Replicas need to be synchronized (time consuming) 1.2.3-\u003eLoose Consistency In this case copies are not always the same everywhere. Data-Centric Consistency Models: The general organization of a logical data store, physically distributed and replicated across multiple machines. Each process that can access data has its own local copy Write operations are propagated to the other copies Strict Consistency: Any read on a data item x returns a value corresponding to the result of the most recent write on x two operations in the same time interval are said to conflict if they operate on the same data and one of them is a write operation Behavior of two processes, operating on the same data item. A strictly consistent store. A store that is not strictly consistent. Strict consistency is the ideal model but it is impossible to implement in a distributed system It is based on absolute global time. Linearizability and Sequential Consistency (1): Sequential Consistency it is a weaker consistency model than strict consistency The result of any execution is the same as if the read and write operations by all processes on the data store were executed in some sequential order and the operations of each individual process appear in this sequence in the order specified by its program All processes see the same interleaving of operations A sequentially consistent data store. A data store that is not sequentially consistent. No reference to the timing of the operations Linearizability and Sequential Consistency (2) Linearizability is weaker than strict consistency but stronger than sequential consistency The result of any execution is the same as if the read and write operations by all processes on the data store were executed in some sequential order and the operations of each individual process appear in this sequence in the order specified by its program. In addition, if tsOP1(x) \u003c tsOP2(y), then operation OP1(x) should precede OP2(y) in this sequence. Operations receive a timestamp using a global clock, but with finite precision Example : three concurrently executing processes; (x, y, z) are data store items Various (90) interleaved execution sequences are possible Linearizability and Sequential Consistency (3): Not all signature pattern are allowed : 000000 not permitted, 001001 not permitted Constraints: Program order must be maintained Data coherence must be respected Data coherence : any read must return the most recently written value of the data (relatively to the single data item, without regard to other data) Causal Consistency (1): When there is a read followed by a write, the two events are potentially causally related Operation not causally related are said concurrent Necessary condition: Writes that","date":"2021-12-03 14:36:30","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_10/:0:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_10","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_10/"},{"categories":["School courses"],"content":" 2021哈工大深圳堵宏伟分布式系统课程笔记 Group Communication群组通信 Modes of communication： One-to-One Unicast 1\u003c–\u003e1 Point-to-point Anycast 1-\u003enearest 1 of several identical nodes Introduced with IPv6; used with BGP routing protocol One-to-many Multicast 1-\u003emany Group communication Broadcast 1-\u003eall Groups: Groups allow us to deal with a collection of processes as one abstraction Send message to one entity Deliver to entire group Groups are dynamic Created and destroyed Processes can join or leave May belong to 0 or more groups Primitives join_group, leave_group, send_to_group, query_membership(sometimes) Design Issues: Closed vs. Open Closed: only group members can sent messages Peer vs. Hierarchical Peer: each member communicates with the entire group Hierarchical: go through coordinator(s) Root coordinator: forwards message to appropriate subgroup coordinators Managing membership \u0026 group creation/deletion Distributed vs. centralized Leaving \u0026 joining must be synchronous Fault tolerance (容错性） Reliable message delivery? What about missing members? Failure considerations: The same things bite us with unicast communication Crash failure Process stops communicating Omission failure (typically due to network) Send omission: A process fails to send messages Receive omission: A process fails to receive messages Byzantine failure Some messages are faulty Partition failure The network may get segmented, dividing the group into two or more unreachable sub-groups ","date":"2021-12-03 14:36:23","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_09/:0:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_09","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_09/"},{"categories":["School courses"],"content":"Implementing Group Communication Mechanisms组播 Hardware multicast: If we have hardware support for multicast Group members listen on network address Broadcast: Diffusion group: send to all clients \u0026 then filter Software filters incoming multicast address May use auxiliary address (not in the network address header) to identify group Hardware multicast \u0026 broadcast: Ethernet supports both multicast \u0026 broadcast Limited to local area networks Software implementation: multiple unicasts: Sender knows group members Software implementation: hierarchical： Multiple unicasts via group coordinator Coordinator knows group members Coordinator iterates through group members May support a hierarchy of coordinators ","date":"2021-12-03 14:36:23","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_09/:1:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_09","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_09/"},{"categories":["School courses"],"content":"Reliability of multicasts 组播可靠性 Atomic multicast： Atomicity （原子性） Message sent to a group arrives at all group members If it fails to arrive at any member, no member will process it Problems Unreliable network Each message should be acknowledged Acknowledgements can be lost Message sender might die Achieving atomicity： General idea Ensure that every recipient acknowledges receipt of the message Only then allow the application to process the message If we give up on a recipient then no recipient can process that received message Easier said than done! What if a recipient dies after acknowledging the message? Is it obligated to restart? If it restarts, will it know to process the message? What if the sender (or coordinator) dies partway through the protocol? Achieving atomicity–example 1： Retry through network failures \u0026 system downtime Sender \u0026 receivers maintain a persistent log Each message has a unique ID so we can discard duplicates Sender Send message to all group members Write message to log Wait for acknowledgement from each group member Write acknowledgement to log If timeout on waiting for an acknowledgement, retransmit to group member Receiver Log received non-duplicate message to persistent log Send acknowledgement NEVER GIVE UP! Assume that dead senders or receivers will be rebooted and will restart where they left off Achieving atomicity–example 2： Redefine the group If some members failed to receive the message: Remove the failed members from the group Then allow existing members to process the message But still need to account for the death of the sender Surviving group members may need to take over to ensure all current group members receive the message This is the approach used in virtual synchrony Reliable multicast： All non-faulty group members will receive the message Assume sender \u0026 recipients will remain alive Network may have glitches Try to retransmit undelivered messages … but eventually give up It’s OK if some group members don’t get the message Acknowledgements Send message to each group member Wait for acknowledgement from each group member Retransmit to non-responding members Subject to feedback implosion Optimizing Acknowledgements： Easiest thing is to wait for an ACK before sending the next message But that incurs a round-trip delay Optimizations Pipelining Send multiple messages –receive ACKs asynchronously Set timeout –retransmit message for missing ACKs Cumulative ACKs Wait a little while before sending an ACK If you receive others, then send one ACK for everything Piggybacked ACKs Send an ACK along with a return message Negative ACKs Use a sequence # on each message Receiver requests retransmission of a missed message More efficient but requires sender to buffer messages indefinitely TCP does the first three of these…but now we have to do this for each recipient Unreliable multicast (best effort)： Basic multicast Hope it gets there ","date":"2021-12-03 14:36:23","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_09/:2:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_09","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_09/"},{"categories":["School courses"],"content":"Message ordering 消息顺序 Good Ordering： Bad Ordering： Good Ordering： Bad Ordering： Sending vs. Receiving vs. Delivering： Multicast receiver algorithm decides when to deliver a message to the process. A received message may be: Delivered immediately (put on a delivery queue that the process reads) Placed on a hold-back queue (because we need to wait for an earlier message) Rejected/discarded (duplicate or earlier message that we no longer want) Sending, delivering, holding back： Global time ordering： All messages are delivered in exact order sent Assumes two events never happen at the exact same time! Difficult (impossible) to achieve Not viable Total ordering （全序）： Consistent ordering at all receivers All messages are delivered at all group members in the same order They are sorted in the same order in the delivery queue If a process sends m before m’ then any other process that delivers m’ will have delivered m. If a process delivers m’ before m” then every other process will have delivered m’ before m”. Implementation: Attach unique totally sequenced message ID Receiver delivers a message to the application only if it has received all messages with a smaller ID Causal ordering： Also known as partial ordering 偏序 Messages sequenced by Lamport or Vector timestamps If multicast(G, m)→multicast(G, m) then every process that delivers m’ will have delivered m If message m’ is causally dependent on message m, all processes must deliver m before m’. Causal ordering example： Causal ordering –implementation： Implementation: Pa receives a message from Pb Each process keeps a precedence vector(similar to vector timestamp) Vector is updated on multicast send and receive events Each entry = # of latest message from the corresponding group member that causally precedes the event Causal Ordering: Example： P2 receives message m0 from P0 with V=(1,0,0) (1) Is this in FIFO order from P0? Compare current V on P2: V2=(0,0,0) with received V from P2, V2=(1,0,0) Yes: V2[0] = 0, received V1[0] = 1 ⇒ sequential (2) Is V0[i] ≤ V2[i] for all other i? Yes. (0 ≤ 0), (0 ≤ 0). Deliver m0. Update precedence vector from (0, 0, 0) to (1, 0, 0) Now check hold-back queue. Can we deliver m1? (1) Is the held-back message m1 in FIFO order from P0? Compare current V on P2: V2=(1,0,0) with held-back V from P0, V1=(1,1,0) Yes: (current V2[1] = 0) vs. (received V1[1] = 1) ⇒ sequential (2) Is V0[i] ≤ V2[i] for all other i? Now yes. (V0[0] = 1) ≤ (V2[0] = 1) and element 2: (V0[2] = 0) ≤ (V2[2] = 0) Deliver m1. Causal ordering can be implemented more efficiently than total ordering: No need for a global sequencer. Expect reliable delivery but we may not need to send immediate acknowledgements. Sync ordering： Messages can arrive in any order Special message type Synchronization primitive Ensure all pending messages are delivered before any additional (post-sync) messages are accepted Single Source FIFO (SSF) ordering： Messages from the same source are delivered in the order they were sent. Message m must be delivered before message m’ iff m was sent before m’ from the same host If a process issues a multicast of m followed by m’, then every process that delivers m’ will have already delivered m. Unordered multicast： Messages can be delivered in different order to different members Order per-source does not matter. Multicasting considerations： ","date":"2021-12-03 14:36:23","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_09/:3:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_09","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_09/"},{"categories":["School courses"],"content":"IP multicast routing IP multicast routing： Deliver messages to a subset of nodes Send to a multicast address How do we identify the recipients? Enumerate them in the header? What if we don’t know? What if we have thousands of recipients? Use a special address to identify a group of receivers A copy of the packet is delivered to all receivers associated with that group IPv4: Class D multicast IP address 32-bit address that starts with 1110 (224.0.0.0/4 = 224.0.0.0 – 239.255.255.255 ) IPv6: 128-bit address with high-order bits 8 bits all 1 Host group = set of machines listening to a particular multicast address A copy of the message is delivered to all receivers associated with that group IP multicasting： Can span multiple physical networks Dynamic membership Machine can join or leave at any time No restriction on number of hosts in a group Machine does not need to be a member to send messages Efficient: Packets are replicated only when necessary Like IP, no delivery guarantees IP multicast addresses： Addresses chosen arbitrarily for an application Well-known addresses assigned by IANA Internet Assigned Numbers Authority IPv4 addresses: http://www.iana.org/assignments/multicast-addresses/multicast-addresses.xml IPv6 addresses: https://www.iana.org/assignments/ipv6-multicast-addresses/ipv6-multicast-addresses.xhtml Similar to ports – service-based allocation For ports, we have: FTP: port 21, SMTP: port 25, HTTP: port 80 For multicast, we have: 224.0.0.1: all systems on this subnet 224.0.0.2: all multicast routers on subnet 224.0.23.173: Philips Health 224.0.23.52: Amex Market Data 224.0.12.0-63: Microsoft \u0026 MSNBC FF02:0:0:0:0:0:0:9: RIP routers IGMP 因特网组管理协议: Internet Group Management Protocol (IGMP) Operates between a host and its attached router Goal: allow a router to determine to which of its networks to forward IP multicast traffic IP protocol (IP protocol number 2) Three message types Membership_query Sent by a router to all hosts on an interface to determine the set of all multicast groups that have been joined by the hosts on that interface Membership_report Host response to a query or an initial join or a group Leave_group Host indicates that it is no longer interested Optional: router infers this if the host does not respond to a query Multicast Forwarding: IGMP allows a host to subscribe to receive a multicast stream What about the source? There is no protocol for the source! It just sends one message to a class D address Routers have to do the work IGMP \u0026 Wide-Area Multicast Routing: Multicast Forwarding: IGMP: Internet Group Management Protocol Designed for routers to talk with hosts on directly connected networks PIM: Protocol Independent Multicast 独立组播协议 Multicast Routing Protocol for delivering packets across routers Topology discovery is handled by other protocols Two forms: Dense Mode (PIM-DM) 密集模式 Sparse Mode (PIM-SM) 稀疏模式 Flooding: Dense Mode Multicast (PIM-DM): Relay multicast packet to all connected routers Use a spanning tree and reverse path forwarding (RPF) to avoid loops Feedback \u0026 cut off if there are no interested receivers on a link A router sends a prune message. Periodically, routers send messages to refresh the prune state Flooding is initiated by the sender’s router Reverse path forwarding (RPF): avoid routing loops（逆向路径转发） Packet is duplicated \u0026 forwarded ONLY IF it was received via the link that is the shortest path to the sender Shortest path is found by checking the router’s forwarding table to the source address Flooding: Dense Mode Multicast: Advantage: Simple Good if the packet is desired in most locations Disadvantage: wasteful on the network, wasteful extra state \u0026 packet duplication on routers Sparse Mode Multicast (PIM-SM): Initiated by the routers at each receiver Each router needs to ask for a multicast feed with a PIM Join message Initiated by a router at the destination that gets an IGMP join Rendezvous Point: meeting place between receivers \u0026 source Join messages propagate to a def","date":"2021-12-03 14:36:23","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_09/:4:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_09","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_09/"},{"categories":["School courses"],"content":" 2021哈工大深圳堵宏伟分布式系统课程笔记 Name Services 命名服务 Name, address, route： The name indicates what we seek Human readable Universal Resource Names (URNs) An address indicates where it is IP address, port A route tells how to get there Internet routing Name and IP-address Not 1 to 1 Mapping： One host may map to more than one name One server machine may be the web server (www.foo.com), mail server (mail.foo.com), etc. One host may have more than one IP address IP addresses are per network interface A machine may have multiple network interfaces (e.g., a gateway) Names don’t necessarily reflect geographical locations Name Hierarchy： Naming in Internet is Hierarchical Better scalability (decreasing centralization) Better name space management Example: weather.yahoo.com belongs to yahoo.com which belongs to .com Regulated by global non-profit organizations First, get a domain name; then you are free to assign subnames in that domain How to get a domain name (see later) Top-level Domains： Country Code Domains .uk, .de, .jp, .us, .tv,… Generic Domains .aero, .biz, .com, .coop, .edu, .gov, .info, .int, .mil, .museum, .name, .net, .org, and .pro Infrastructure Domain (Address and Routing Parameter Area domain) .arpa How to get a domain name? The Internet Corporation for Assigned Names and Numbers (ICANN) is an internationally organized, non-profit corporation that has responsibility for generic and country code Top-Level Domain name system management, IP address space allocation, protocol identifier assignment, and root server system management functions ICANN authorizes other companies to register domains Name Services: What is the name service: A name server maintains a database of bindings between human-readable names and attributes of objects (locations, addresses, etc). Why difficult: In open distributed systems, name database is distributed and managed by different servers, and those servers are required to cooperate to resolve names. Requirements: openness scalability fault tolerance (availability) DNS: Domain Name System: Distributed database implemented in hierarchy of many name servers DNS services: host name resolution mail host location (e.g., find the mail server for hwdu@hitsz.edu.cn) reverse resolution well-known services (e.g., telnet, FTP, HTTP, etc) The add/delete of a name is done by an authoritative administrator manually editing the name database. DNS Name Servers： Why not centralize DNS? single point of failure traffic volume distant centralized database maintenance It doesn’t scale! DNS based on RFC 1034 by Mockapertris in 1987: fully distributed and hierarchical structure no server has all name-to-IP address mappings Name server: a process running on a host that processes DNS requests Local name server: each ISP, company, department, has a local name server DNS queries always first go to local name server Authoritative name server: perform name/address translation for a specific domain or zone database for name / address mapping are maintained by administrators name servers are organized in a hierarchical structure as hierarchy of the name space. Name Server Zone Structure： root com lucent gov ustreas irs www edu mil net org us cn hk fr Structure based on administrative hierarchy. Zone: all subtrees within the same administration authority Name Servers (NS) root zone db: http://www.iana.org/domains/root/db: root com lucent gov ustreas customs irs www edu iit Root NS Lucent NS UStreas NS IRS NS Name Servers (NS): NSs are duplicated for reliability. Each domain must have a primary and a secondary name server. Each host knows the IP address of the local NS. Each NS knows the IP addresses of root NSs. A query is forwarded directly to the root NS if it cannot be resolved by a local name server. Information of root NSs (downloaded to local NS as root.cache) at http://www.internic.net/zones/named.root DNS: Root name servers: Root NS is contacted by local name servers when they cannot resolve names It knows the authoritative name ","date":"2021-12-03 14:36:19","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_08/:0:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_08","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_08/"},{"categories":["School courses"],"content":" 2021哈工大深圳堵宏伟分布式系统课程笔记 Internetworking网际路由 Internet Structure: Network of Networks： Internet is in a hierarchical structure National/ International Backbone Providers (NBP) e.g. BBN/GTE, Sprint, AT\u0026T, IBM, UUNet interconnect (peer) with each other privately, or at public Network Access Point (NAPs) Regional ISPs connect into NBPs Local ISP connect into regional ISPs Internet Protocol (IP)： The IP protocol, defined in RFC 791 (1981) at Layer 3, specifies: Internet packet format Internet addressing Internet routing Internet Packets： An IP packet, called IP datagram, consists of two parts:Header+Data Area Header Contains source and destination address Fixed-size fields Data Area (Payload) Variable size up to 64K No minimum size IPv4 datagram format: IP Address Details: An IPv4 address has 32 bits (4 bytes) – written like 192.0.2.53 It consists of two parts: prefix identifies network and suffix identifies host It was announced in Jan 2011 that all IPv4 addresses were allocated out. An IPv6 address is 128 bits, written in hexadecimal. It looks like 2001:0db8::53. The mark “::” means all zeros in between. So 2001:0db8::53 is 2001:0db8:0000:0000:0000:0000:0000:53 Global authority assigns unique prefix to network (ICANN) Internet Corporation for Assigned Names and Numbers http://www.icann.org/ Local administrator assigns unique suffix to host IPv4 Addresses： The Classful Addressing: Classes and Network Sizes： Network size is determined by number of bits for hosts Class A large Class B medium Class C small Are there enough addresses? Unfortunately No! 32 bits  4 billion unique addresses. but addresses are assigned in chunks, most of them are not used (particularly class D addresses for multicast). techniques, such as CIDR, NAT, and DHCP are introduced to relief the shortage of IP addresses. Expanding the address space! IPv6 128 bit addresses Difficult to deploy (require changes to the core of the Internet) The transition from IPv4 to IPv6 is very slow IP address allocation by Geographical Regions： To simplify routing tables, since 1993, IP address allocation follows the geographical regions: 194.0.0.0 to 195.255.255.255 for Europe 198.0.0.0 to 199.255.255.255 for North America 200.0.0.0 to 201.255.255.255 for Central \u0026 South America 202.0.0.0 to 203.255.255.255 for Asia Pacific Routing table size can be greatly reduced, e.g., routers outside Europe can have a single table entry for range: 194.0.0.0 - 195.255.255.255 to be routed to the nearest Europe gateway. Subnets and Subnet Masks： Subnets allow a big organization (e.g., university), who received a class A or B network address, to further divide its hosts into subnets (LANs): The host portion of address is further partitioned into subnet number and host number. Each LAN is assigned a subnet number (subnet address). To route an IP packet, its dest-IP addr is AND-ed with the subnet-mask, obtaining a subnet number. It is forwarded to the router of the dest-subnet: The dest-subnet router routes the packet to dest-host using host #. Routing Using Subnets：Cslab Subnet Interconnction： Routing Table in CSlab： CSlab has 22 LANs connected to a single router. The router is connected to CSC’s router. The routing table is very small, only contains 22 VLANs and an entry pointing to CSC router 144.214.138.21 (0.0.0.0 for default routing). CIDR-Classless InterDomain Routing： The classful addressing inefficient in use of address space, resulting in address space exhaustion e.g., it has to allocate a class B net address (for up to 65K hosts) to a network with only 1K host. CIDR: subdivide a network addr (class A, B or C) into any length to make efficient use of IP addr space (this subdividing is visible to entire Internet). network portion of address of arbitrary length address format: a.b.c.d/x, where x is # of bits for network address Example of CIDR subdividing a class B net address: 194.24.0.0 CIDR Routing Each entry in CIDR routing table contains a base address and a subnet mask (same as routin","date":"2021-12-03 14:36:03","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_07/:0:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_07","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_07/"},{"categories":["School courses"],"content":" 2021哈工大深圳堵宏伟分布式系统课程笔记 ","date":"2021-12-03 14:35:58","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_06/:0:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_06","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_06/"},{"categories":["School courses"],"content":"Socket Communication套接字通信（直接通信) Clients and Servers： A distributed system can be generally modeled by clients and servers (processes). Clients and servers are usually on different machines and they interact with each other via message passing. To offer a service, a server must get a transport address for a particular service well-defined location Transport Address: A server (process) is associated with a transport address so that clients can communicate with it. IP addresses identify machines Not able to identify sending or receiving process Transport layer uses port number to identify process machine address (IP address) -\u003e building address transport address (port number) -\u003e apartment number A client obtains the transport address via either: hard coded database (/etc/services, directory server) Transport Layer Protocols: Transport Layer supports communications between processes. Two categories of protocols: connection-oriented protocols connectionless protocols Connection-oriented Protocols: establish connection [negotiate protocol] exchange data terminate connection virtual circuit (stream) service provides illusion of having a dedicated circuit messages guaranteed to arrive in-order applications use connection ID, instead of address in each message e.g., TCP – Transport Control Protocol Connectionless Protocols: no call setup send/receive data (each packet addressed) no termination Datagram service client is not sure if messages are received by destination no state has to be maintained at client or server cheaper but less reliable than virtual circuit service e.g., UDP – User Datagram Protocol Sockets: Transport Layer Communication: A popular abstraction for transport layer communication Developed at Berkeley in 1982 Goals: Communication between processes should not depend on whether they are on the same machine Uniform all data exchanges (accesses) as file accesses Application can select particular style of communication Virtual circuit, datagram, message-based, in-order delivery Support different protocols and naming conventions (not just for TCP/IP or UDP/IP) Programming operations:Socket Operations: List of socket operations: socket bind listen, accept, connect read/write, send/recv, sendto/recvfrom, sendmsg/recvmsg close/shutdown Creat a socket: socket system call: int s = socket(domain, type, protocol); parameters: domain: identifies address family AF_INET: IPC on the Internet, AF_UNIX: IPC within a computer AF_NS: IPC on Xeroxs Network Systems type: type of service required by application SOCK_STREAM: virtual circuit SOCK_DGRAM: datagram SOCK_RAW: raw IP access protocol: specify a protocol. To support user self defined protocols. Default value is 0, i.e., system defined protocol. return: an integer as the socket number (file descriptor) Bind socket to an address: bind system call: int error = bind(s, addr, addrlen); parameters: s: socket descriptor returned by socket() addr: address structure (struct sockaddr *) addrlen: length of address structure return: error code Binding a file name to a UNIX socket(intra-machine communication): /usr/include/sys/un.h struct sockaddr_un { sa_family_t sun_family; /* AF_UNIX */ char sun_path[108]; /* path name */ }; struct sockaddr_un addr; strcpy(addr.sun_path, “/tmp/foo”); addr.sun_family = AF_UNIX; bind (s, \u0026addr, strlen(addr.sun_path) + sizeof addr.sun_family); Demo of UNIX Stream Sockets: www/C/socket/unix/receiver.c main(argc, argv) int argc; char *argv[]; { struct sockaddr_un myname; int s, new_s; char buf[256], rdata[256]; s = socket(AF_UNIX, SOCK_STREAM, 0); myname.sun_family = AF_UNIX; strcpy(myname.sun_path, \"/tmp/123\"); bind(s, \u0026myname, strlen(myname.sun_path) + sizeof(myname.sun_family)) listen(s, 5); new_s = accept(s, NULL, NULL); while (1) { read(new_s, buf, sizeof(buf)); strcpy(rdata, “Echoed msg: \"); strcat(rdata, buf); write(new_s, rdata, strlen(rdata)) } } www/C/socket/unix/sender.c main(argc, argv) int argc; char *argv[]; { struct sockaddr_un hisname; int s; char","date":"2021-12-03 14:35:58","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_06/:1:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_06","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_06/"},{"categories":["School courses"],"content":"RPC远程过程调用 An Example of Local Procedure Call： /* save a string to file msg.dat */ savemsg(char *msg) { FILE *fp; fp = fopen(\"msg.dat\", \"w+\"); fprintf(fp, \"%s\\n\", msg); fclose (fp); } main() { char *str = \"This is an example of LPC.\"; savemsg(str); } Moving the local procedure to a remote machine: server: savemsg_1(char **argp; struct svc_req *rqstp) { FILE *fp; fp = fopen(\"msg.dat\", \"w+\"); fprintf(fp, \"%s\\n\", *argp); fclose (fp); } client: main() { char *str = \"This is an example of RPC.\"; char *remote_host = \"sus1.cs.cityu.edu.hk\"; CLIENT *clnt; clnt = clnt_create(remote_host, MSGPROG, MSGVER, \"netpath\"); if (clnt == (CLIENT *) NULL) { clnt_pcreateerror(host); exit(1); } savemsg_1(\u0026str, clnt); } Remote Procedure Call: 1984: Birrell \u0026 Nelson Mechanism to call procedures on other machines Process on machine A can call a procedure on machine B A is suspended Execution continues on B When B returns, control passed back to A Goal: Make a remote procedure call looking the same as a local call to programmers. RPC implementation: The RPC compiler auto-generates stub/skeleton routines to make an RPC to the user as if it is a local call. What stub routines do: marshalling / unmarshalling parameters and return values handling different data formats between different machines detecting and handling failures of client/server processes and the networks Compilation in SUN RPC:Demo of RPC: Interface file msg.x: program MSGPROG { version MSGVER{ int SAVEMSG(string)= 1; string READMSG(int)= 2; } = 2; } = 345678; Generate stub routines by: rpcgen –a msg.x Compile program by: cc –o object xxx.c ","date":"2021-12-03 14:35:58","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_06/:2:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_06","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_06/"},{"categories":["School courses"],"content":"Steps in s RPC Client calls stub (push parameters onto stack) Clnt_stub marshals parameters to message \u0026 makes an OS call (client blocked) Network message sent to server Deliver message to server stub \u0026 unblock server Svr-stub unmarshals parameters \u0026 calls service routine (local call) Return to the stub from service routine Svr_stub marshals return-value \u0026 requests OS to send out message Transfer message over network Deliver message to client (unblock client) Clnt_stub unmarshals return-value \u0026 returns to client program… ","date":"2021-12-03 14:35:58","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_06/:2:1","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_06","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_06/"},{"categories":["School courses"],"content":"Writing the programs Programmers need to write two pieces of programs: Client program Specify server’s location Parameters and return value of RPC are pointers Service routines Generally the same as local procedures, except the parameters and parameter types ","date":"2021-12-03 14:35:58","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_06/:2:2","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_06","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_06/"},{"categories":["School courses"],"content":" 2021哈工大深圳堵宏伟分布式系统课程笔记 Mutual Exclusion \u0026 Election Algorithms(互斥算法 \u0026 选举算法) ","date":"2021-12-03 14:35:53","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_05/:0:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_05","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_05/"},{"categories":["School courses"],"content":"Mutual Exclusion Process Synchronization: Techniques to coordinate execution among processes One process may have to wait for another Shared resource (e.g. critical section) may require exclusive access Requirements of Mutual Exclusion Algorithms: A mutual exclusion algorithm should satisfy the following properties: Safety Property: The safety property states that at any instant, only one process can execute the critical section. Liveness Property: This property states the absence of deadlock and starvation. Fairness: Fairness in the context of mutual exclusion means that each process gets a fair chance to execute the critical section. Centralized Systems: Achieve Mutual exclusion via: Test \u0026 set in hardware Semaphores Messages(inter-process) Condition variables Distributed Mutual Exclusion: Assume there is agreement on how a resource is identified Pass identifier with requests e.g., lock(“printer”), lock(“table:employees”),lock(“table:employees;row:15”) …and every process can identify itself uniquely Goal: Create an algorithm to allow a process to obtain exclusive access to a resource that is available on the network Centralized algorithm（集中式算法）: Mimic single processor system One process elected as coordinator Request resource Wait for response Receive grant Access resource Release resource If another process claimed resource: Coordinator does not reply until release Maintain queue Service requests in FIFO order Benefits Fair: All requests processed in order Easy to implement, understand, verify Processes do not need to know group members – just the coordinator Problems Process cannot distinguish being blocked from a dead coordinator – single point of failure Centralized server can be a bottleneck Token Ring algorithm（令牌环算法）: Assume known group of processes Some ordering can be imposed on group (unique process IDs) Construct logical ring in software Process communicates with its neighbor Initialization Process 0 creates a token for resource R Token circulates around ring From Pi to P(i+1)mod N When process acquires token Checks to see if it needs to enter critical section If no, send ring to neighbor If yes, access resource Hold token until done …… Token Ring algorithm summary: Only one process at a time has token Mutual exclusion guaranteed Order well-defined (but not necessarily first-come, first-served) Starvation cannot occur Lack of FCFS ordering may be undesirable sometimes Problems Token loss (e.g., process died) It will have to be regenerated Detecting loss may be a problem(is the token lost or in just use by someone?) Process loss: what if you can’t talk to your neighbor? Ricart \u0026 Agrawala algorithm: Distributed algorithm using reliable multicast and logical clocks Process wants to enter critical section: Compose message containing: Identifier (machine ID, process ID) Name of resource Timestamp (totally-ordered Lamport） Send request to all processes in group Wait until everyone gives permission Enter critical section / use resource When process receives request: If receiver not interested: Send OK to sender If receiver is in critical section Do not reply; add request to queue If receiver just sent a request as well: Compare timestamps: received \u0026 sent messages Earliest wins If receiver is loser, send OK If receiver is winner, do not reply, queue When done with critical section Send OK to all queued requests Example for Ricart \u0026 Agrawala algorithm: Ricart \u0026 Agrawala algorithm: N points of failure A lot of messaging traffic Demonstrates that a fully distributed algorithm is possible Lamport’s Mutual Exclusion: Each process maintains request queue Contains mutual exclusion requests Requesting critical section Process Pi sends request(i, Ti) to all nodes(Ti:Lamport time) Places request on its own queue When a process Pj receives a request, it returns a timestamped ack Entering critical section (accessing resource): Pi received a message (ack or release) from every other process with a timestamp larger than Ti Pi’s reques","date":"2021-12-03 14:35:53","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_05/:1:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_05","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_05/"},{"categories":["School courses"],"content":"Election Algorithms Elections： Need one process to act as coordinator Processes have no distinguishing characteristics Each process has a unique ID to identify itself Bully algorithm （霸道选举算法)： Select process with largest ID as coordinator When process P detects dead coordinator: Send election message to all processes with higher IDs. If nobody responds, P wins and takes over. If any process responds, P’s job is done. Optional: Let all nodes with lower IDs know an election is taking place. If process receives an election message Send OK message back Hold election (unless it is already holding one) A process announces victory by sending all processes a message telling them that it is the new coordinator If a dead process recovers, it holds an election to find the coordinator. Ring algorithm （环选举算法）： Ring arrangement of processes If any process detects failure of coordinator Construct election message with process ID and send to next process If successor is down, skip over Repeat until a running process is located Upon receiving an election message Process forwards the message, adding its process ID to the body Eventually message returns to originator Process sees its ID on list Circulates (or multicasts) a coordinator message announcing coordinator E.g. lowest numbered process P2 receives the election message that it initiated P2 now picks a leader (e.g., lowest or highest ID) P2 announces the new coordinator to the group Chang \u0026 Roberts Ring Algorithm： Optimize the ring Message always contains one process ID Avoid multiple circulating elections If a process sends a message, it marks its state as a participant Upon receiving an election message: If PID(message) \u003e PID(process) forward the message – higher ID will always win over a lower one If PID(message) \u003c PID(process) replace PID in message with PID(process) forward the new message – we have a higher ID number; use it If PID(message) \u003c PID(process) AND process is participant discard the message – we’re already circulating our ID If PID(message) == PID(process) the process is now the leader – message circulated: announce winner Network Partitioning: Split Brain （脑裂）： ","date":"2021-12-03 14:35:53","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_05/:2:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_05","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_05/"},{"categories":["School courses"],"content":" 2021哈工大深圳堵宏伟分布式系统课程笔记 Logical Time Motivation of logical clocks: Cannot synchronize physical clocks perfectly in distributed systems. [Lamport 1978] Main function of computer clocks – order events If two processes don’t interact, there is no need to sync clocks. This observation leads to “causality” Causality（因果性）: Order events with happened-before (-\u003e) relation a \u003e b a could have affected the outcome of b a || b a and b take place in different processes that don’t exchange data Their relative ordering does not matter (they are concurrent) Definition of happened-before: Definition of “” relationship: If a and b take place in the same process a comes before b, then a -\u003e b If a and b take place in the different processes a is a “send” and b is the corresponding “receive”, then a -\u003e b Transitive: if a -\u003e b and b -\u003e c, then a -\u003e c Partial ordering – unordered events are concurrent Logical Clocks: A logical clock is a monotonically increasing software counter. It need not relate to a physical clock. Corrections to a clock must be made by adding, not subtracting Rule for assigning “time” values to events if a -\u003e b then clock(a) \u003c clock(b) Event counting example: Three processes: P0, P1, P2, events a, b, c, … A local event counter in each process. Processes occasionally communicate with each other, where inconsistency occurs, … Lamport’s algorithm, 1978: Each process Pi has a logical clock Li. Clock synchronization algorithm: Li is initialized to 0; Update Li: LC1: Li is incremented by 1 for each new event happened in Pi LC2: when Pi sends message m, it attaches t = Li to m LC3: when Pj receives (m,t) it sets Lj := max{Lj, t} , and then applies LC1 to increment Lj for event receive(m) Problem: Identical timestamps: Concurrent events (e.g., a, g) may have the same timestamp Make timestamps unique: Append the process ID (or system ID) to the clock value after the decimal point: e.g. if P1, P2 both have L1 = L2 = 40, make L1 = 40.1, L2 = 40.2 Problem: Detecting causal relations: If a -\u003e b, then L(a) \u003c L(b), however: If L(a) \u003c L(b), we cannot conclude that a -\u003e b It is not very useful in distributed systems. Solution: use vector clocks Vector of Timestamps: Suppose there are a group of people and each needs to keep track of events happened to others. Requirement: Given two events, you need to tell whether they are sequential or concurrent. Solution: you need to have a vector of timestamps, one element for each member. Vector clocks （向量时钟）: Each process Pi keeps a clock Vi which is a vector of N integers Initialization: for 1 ≤ i ≤ N and 1 ≤ k ≤ N, Vi[k] := 0 Update Vi : VC1: when there is a new event in Pi, it sets Vi[i] := Vi[i] +1 VC2: when Pi sends a message m out, it attaches t = Vi to m VC3: when Pj receives (m,t), for 1 ≤ k ≤ N, it sets Vj[k] := max{Vj[k], t[k]}, then applies VC1 to increment Vj[j] for event receive(m,t) Note: Vi[j] is a timestamp indicating that Pi knows all events that happened in Pj upto this time. example: Detecting “-\u003e” or “||” events by time vectors: Define V = V’ iff V[i] = V’[i] for i = 1, …, N V ≤ V’ iff V[i] ≤ V’[i] for i = 1, …, N V \u003c V’ iff V ≤ V’ and V ≠ V’ V(e) = timestamp vector of an event e For any two events a and b, a -\u003e b iff V(a) \u003c V(b), a ≠ b a || b iff neither V(a) ≤ V(b) nor V(b) ≤ V(a) an example: Summary on vector timestamps: No need to synchronize physical clocks Able to order causal events Able to identify concurrent events (but cannot order them) An Application of Timestamp Vectors: causally-ordered multicast: Multicast: a sender sends a message to a group of receivers. Every message must be received by all group members. Causally ordered multicast: if m1 -\u003e m2, m1 must be received before m2 by all receivers. Algorithm of Causally-Ordered Multicast: Each group member keeps a timestamp vector of n components (n group members), all initialized to 0. When Pi multicasts a message m, it increments i-th component of its time vector Vi and attaches Vi to m. When Pj with Vj receives (m, Vi) f","date":"2021-12-03 14:35:49","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_04/:0:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_04","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_04/"},{"categories":["School courses"],"content":" 2021哈工大深圳堵宏伟分布式系统课程笔记 Physical Time Why Timestamps in Systems? Precise performance measurements Guarantee “up-to-date” or recentness of data Temporal ordering of events produced by concurrent processes Synchronization between senders and receivers of messages Coordination of joint activities Serialization of concurrent accesses to shared objects …… Physical time: Solar time 1 sec = 1 day / 86400 Problem: days are of different lengths (due to tidal friction, etc.) mean solar second: averaged over many days Greenwich Mean Time (GMT) The mean solar time at Royal Observatory in Greenwich, London Greenwich located at longitude 0, the line that divides east and west Coordinated Universal Time (UTC): International atomic time (TAI) 国际原子时间 1 sec = time for Cesium-133 atom to make 9,192,631,770 state transitions. TAI time is simply the number of Cesium-133 transitions since midnight on Jan 1, 1958. Accuracy: better than 1 second in six million years Problem: Atomic clocks do not keep in step with solar time Coordinated Universal Time (UTC) 通用协调时间 Based on the atomic time (TAI) and introduced from 1 Jan 1972 A leap second is occasionally inserted or deleted to keep in step with solar time when the difference btw a solar-day and a TAI-day is over 800ms Computer Clocks: CMOS clock circuit driven by a quartz oscillator battery backup to continue measuring time when power is off The circuit has a counter（计数器） and a register（寄存器）. The counter decrements by 1 for each oscillation; an interrupt（中断） is generated when it reaches 0 and the number in the register is loaded to the counter. Then, it repeats… OS catches interrupt signals to maintain a computer clock e.g., 60 or 100 interrupts per second Programmable Interrupt Controller (PIC) Interrupt service routine increments the “clock” by 1 for each interrupt Clock drift and clock skew: Clock Drift 时钟漂移 Clocks tick at different rates Ordinary quartz clocks drift by ~ 1sec in 11-12 days. (10-6 secs/sec). High precision quartz clocks drift rate is ~ 10-7 or 10-8 secs/sec Create ever-widening gap in perceived time Clock Skew (offset) 时钟偏移 Difference between two clocks at one point in time Perfect clock: Drift with a slow computer clock: Drift with a fast computer clock: Dealing with drift: No good to set a clock backward Illusion of time moving backwards can confuse message ordering and software development environments Go for gradual clock correction If fast: Make clock run slower until it synchronizes If slow: Make clock run faster until it synchronizes Linear compensating function: OS can do this: Change the frequency of clock interrupts e.g.: if the system generates an interrupt every 17 ms but clock is too slow: generates an interrupt at (e.g.) 15 ms Adjustment changes slope of system time: Linear compensating function （线性补偿函数） Resynchronization: After synchronization period is reached Resynchronize periodically, or The skew is beyond a threshold Keep track of adjustments and apply continuously UNIX adjtime system call: int adjtime(struct timeval *delta, struct timeval *old-delta) adjusts the system’s notion of the current time, advancing or retarding it, by the amount of time specified in the struct timeval pointed to by delta. “old-delta”, output parameter, returns time left uncorrected since last call of “adjtime” Getting UTC from Top Sources: Attach GPS receiver to each computer ± 1 ms of UTC Attach WWV (http://tf.nist.gov) radio receiver Obtain time broadcasts from Boulder or DC ± 3 ms of UTC (depending on distance) Attach GOES receiver (Geostationary Operational Environmental Satellites, http://www.goes.noaa.gov/) ± 0.1 ms of UTC Not practical for every machine Cost, size, convenience, environment Getting UTC for Client Computers: Synchronize clock of a client to a time server that with a more accurate clock, or connected to UTC time source Also called external clock synchronization Synchronizing Clocks by using RPC: Simplest synchronization technique Make an RPC to obtain time from the","date":"2021-12-03 14:35:44","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_03/:0:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_03","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_03/"},{"categories":["School courses"],"content":" 2021哈工大深圳堵宏伟分布式系统课程笔记 System Modules Descriptive models for distributed system design: Physical model Most explicit description of a system. Capture hardware composition in terms of computers and their interconnecting networks. Architectural model Describes a systems in terms of computational and communication task performed by computational elements. Fundamental model Abstract perspective in order to study the individual aspects of a system. Three models are introduced: interaction model, failure model, and the security model. Difficulties for and threats to distributed systems: Widely varying mode of use Component parts of the system are subject to wide variations in workload, e.g. some web pages are accessed several million times a day. Some parts of the systems might be disconnected or poorly connected, e.g. mobile computers. Some applications have special requirements such as high communication bandwidth and low latency, e.g. multimedia applications. Wide range of system environments Distributed systems accommodate heterogeneous hardware, operating systems, networks. Networks may differ widely in performance (wireless networks vs. LAN) Internal threats External threats ","date":"2021-12-03 14:35:38","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_02/:0:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_02","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_02/"},{"categories":["School courses"],"content":"Physical model （物理模型） Introduction to physical model A physical model is a representation of the underlying hardware elements of a distributed system that abstracts from specific details of the computer and networking technologies employed. Baseline physical model（基线物理模型） Hardware and software components located at networked computers communicate and coordinate their actions by passing messages. Very simple physical model of a distributed system. Three generations of distributed systems Early distributed systems Emerged in the late 1970s and early 1980s because of the usage of local area networking technologies. System typically consisted of 10 to 100 nodes connected by a LAN, with limited Internet connectivity and supported services (e.g., shared local printer, file servers). Internet-scale distributed systems Emerged in the 1990s because of the growth of the Internet. Physical model of the internet-scale distributed system: Three generations of distributed systems Early distributed systems Emerged in the late 1970s and early 1980s because of the usage of local area networking technologies. System typically consisted of 10 to 100 nodes connected by a LAN, with limited Internet connectivity and supported services (e.g., shared local printer, file servers). Internet-scale distributed systems Emerged in the 1990s because of the growth of the Internet. Infrastructure became global. Contemporary distributed systems Emergence of mobile computing leads to nodes that are location-independent Need to added capabilities such as service discovery and support for spontaneous interoperation Emergence of cloud computing and ubiquitous computing Distributed system of systems Emergence of ultra-large-scale (ULS) distributed systems Complex systems consisting of a series of subsystems that are systems in their own right and that come together to perform particular task or tasks Example: environmental management system for flood prediction Consists of sensor networks deployed to monitor the state of various environmental parameters Coupled with systems that predict the like hood for floods (running complex simulations) Additionally early warning systems to key stakeholders via mobile phones ","date":"2021-12-03 14:35:38","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_02/:1:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_02","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_02/"},{"categories":["School courses"],"content":"Architectural model （体系结构模型） An architectural model of a distributed system simplifies and abstracts the functions of the individual components of a distributed system and: Organization of components across the network of computers. Their interrelationship, i.e., communicate with each other. ","date":"2021-12-03 14:35:38","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_02/:2:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_02","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_02/"},{"categories":["School courses"],"content":"Architectural elements What are the entities that are communicating in the distributed system? How do they communicate, or, more specifically, what communicationparadigm is used? What (potentially changing) roles and responsibilities do they have in the overall architecture? How are they mapped on the physical distributed infrastructure (what is their placement)? Communicating entities System-oriented perspective In distributed systems the entities that communicate are typically processes. Exceptions: In primitive environments such as sensor networks, operating systems does not provide any abstractions, therefore nodes communicate. In most environments processes are supplemented by threads, so threads are more the endpoints of communications. Problem-oriented perspective Objects Computation consists of a number of interacting objects representing units of decomposition for the problem domain. Objects are accessed via interfaces. Components Resemble objects in that they offer problem-oriented abstractions, also accessed via interfaces. Specify not only their interfaces but also the assumptions they make in terms of other components/interfaces that must be present for a component to fulfil its function. Web services Software application which is identified via URI Supports direct interactions with other software agents Communication paradigms Types of communication paradigms: Interprocess communication Remote invocation Indirect communication Interprocess communication: Low-level support for communication between processes in distributed systems including message parsing-primitives. Direct access to the API offered by Internet protocols (socket programming) and support for multicast communication. Remote invocation: Covering a range of techniques based on a two-way exchange between communicating entities. Resulting in the calling of a remote operation, procedure or method Request-reply protocols: more a pattern imposed on an underlying message-parsing service to support client-server computing Remote procedure calls: procedures in processes on remote computers can be called as if they are procedures in the local address space Remote method invocation: a calling object can invoke a method in a remote object Indirect communication: Group communication Delivery of messages to a set of recipients. Abstraction of a group which is represented in the system by a group identifier Recipients elect to receive message send to a group. Publish-subscribe-systems A large number of producers (publisher) distribute information items of interest (events) to a similarly large number of consumers (subscribers) Message queues Message queues offer a point-to-point service whereby producer processes can send messages to a specified queue and consumer processes can receive messages from the queue or being notified. Group communication: Two kinds of group communication: Broadcast (message sent to everyone) Multicast (message sent to specific group) Used for: Replication of services Replication of data Service discovery Event notification Publish-subscribe-systems(or event-based communication): Communication through propagation of events Generally associated with publish/subscribe systems Sender process publishes events Receiver process subscribes to events and receives only the ones it is interested in Roles and responsibilities Architectural styles: Client-Server Peer-to-peer Client-Server: Clients invoke individual servers: Fundamental issue with client-server: Client-server offers a direct, relatively simple approach to the sharing of data and other resources But it scales poorly The centralization of service provision and management implied by placing a service at a single address does not scale well beyond the capacity of the computer that hosts the service and the bandwidth of its connections Even though, there a several variations of the client-server architecture to respond to this problem but none of the really solve it. There is a need to dis","date":"2021-12-03 14:35:38","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_02/:2:1","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_02","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_02/"},{"categories":["School courses"],"content":"Architectural patterns Concept of layering: Vertical organization of services into a service layers. Distributed services can be provided by one or more server processes, interacting with each other and with client processes in order to maintain a consistent system-wide view of the service’s resources. Example Network time service is implemented on the Internet based on the Network Time Protocol (NTP) by server processes running on hosts throughout the Internet that supply current time to any client that request it. Software and hardware service layers: Platform: Lowest level hardware and software layers for distributed systems and applications Characteristics provide services to the layers above them implemented independently in each computer Bringing the system’s programming interface up to a level that facilitates communication and coordination between processes Examples x86/Windows, intel x86/Solaris, PowerPC/Mac OS X, Intel x86/Linux Middleware: Is a layer of software whose purpose is to mask heterogeneity and to provide a convenient programming model to application programmers. is represented by processes or objects in a set of computers that interact with each other to implement communication and resource-sharing support. Is concerned with providing useful building blocks for the construction of software components that can work with one another Limitations of middleware Many distributed applications rely entirely on services provided by middleware to support their needs for communication and data sharing Example, application that is suited to the client-server model such a database of names and addresses rely on middleware that provides only remote method invocation. Vertical Distribution (Multi-Tier): An extension of the client-server architecture. Distributes the traditional server functionality over multiple servers. Communication in a multi-tier system: Horizontal Distribution: Involves replicating a server’s functionality over multiple computers. Typical example: replicated Web server Each server machine contains a complete copy of all hosted Web pages. Client requests are passed on to the servers in a round robin fashion. Is used to improve scalability (by reducing the load on individual servers) and reliability (by providing redundancy) Thin and fat client implementations: Decomposed a typical client-server application into three logical parts the interface part. the application logic part, and. the data part. Thin client implementation Provides a minimal user interface layer, and leave everything else to the server. Fat client implementation Include all of the user interface and application logic in the client. Rely only on the server to store and provide access to data. Implementations in between will split up the interface or application logic parts over the clients and server in different ways. ","date":"2021-12-03 14:35:38","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_02/:2:2","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_02","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_02/"},{"categories":["School courses"],"content":"Fundamental model（基础模型） Requirements on the fundamental model: Questions that should be addressed by a system model What are the main entities of the system? How do they interact? What are the characteristics that affect their individual and collective behavior? Aspects of distributed systems that are considered are Interaction Failure Security ","date":"2021-12-03 14:35:38","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_02/:3:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_02","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_02/"},{"categories":["School courses"],"content":"Interaction model （交互模型） Performance of communication channels: Latency Delay between the start of a message’s transmission from one process and the beginning of its receipt by another It includes: Time taken for the first string of bits transmitted through a network to reach its destination. Delay in accessing the network. Time taken by the operating system communication services at both the sending and the receiving processes. Bandwidth total amount of information that can be transmitted over a computer network in a given time. Jitter Variation in the time taken to deliver a series of messages. Two variants of the interaction model: Synchronous distributed systems The following bounds are defined: The time to execute each step of a process has known lower and upper bounds Each message transmitted over a channel is received within a known bounded time. Each process has a local clock whose drift rate from real time has known bound. Asynchronous distributed system: There are no bounds on: Process execution speed Message transmission delays Clock drift rate Event ordering: ","date":"2021-12-03 14:35:38","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_02/:3:1","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_02","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_02/"},{"categories":["School courses"],"content":"Failure model （故障模型） Introducing the failure model: The failure model defines ways in which failure may occur in order to provide an understanding of the effects of failure. Taxonomy of failures of processes and communication channels (Hadzilacos \u0026 Toueg, 1994) Omission failures. Arbitrary failures. Timing failures. Processes and channels: Omission failures: Class of failure—Affects—Description Fail-stop—Process—Process halts and remains halted. Other processes maydetect this state. Crash—Process—Process halts and remains halted. Other processes may not be able to detect this state. Omission—Channel—A message inserted in an outgoing message buffer never arrives at the other end’s incoming message buffer. Send-omission—Process—A process completes a send, but the message is not put in its outgoing message buffer. Receive-omission—Process—A message is put in a process ‘s incoming messagebuffer, but that process does not receive it. Arbitrary—Process or Process/channel—exhibits arbitrary behaviour: it may(Byzantine)channelsend/transmit arbitrary messages at arbitrary times,commit omissions; a process may stop or take anincorrect step . Arbitrary failures: Often called Byzantine failure. This is the worst possible failure semantics, in which any type of error may occur. Example of an arbitrary failure of a process. A process arbitrarily omits intended processes steps or takes unintendedprocessing steps. Example of an arbitrary failure of a communication channel Message content may be corrupted, nonexistent messages may be delivered or real messages may be delivered more than once. Solutions: checksum to detect corrupted messages and message sequence numbers to detect nonexistent and duplicated messages. Timing failures: Class of Failure—Affects—Description Clock—Process—Process’s local clock exceeds the bounds on its rate of drift from real time. Performance—Process—Process exceeds the bounds on the interval between two steps. Performance—Channel—A message ‘s transmission takes longer than the stated bound. Result response being unavaible to clients ","date":"2021-12-03 14:35:38","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_02/:3:2","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_02","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_02/"},{"categories":["School courses"],"content":"Security model （安全模型） Introducing the security model: The security of a distributed system can be archived by securing the processes and the channels used for their interactions and by protecting the objects that they encapsulate against unauthorized access. ","date":"2021-12-03 14:35:38","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_02/:3:3","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_02","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_02/"},{"categories":["School courses"],"content":"Summary Three generations of distributed systems and the emergence of ultra-large-scale(ULS) distributed systems. Types of communication paradigms: Interprocess communication Remote invocation Indirect communication Architectural styles: client-server and peer-to-peer Vertical distribution (Multi-Tier) and horizontal distribution of c/s systems Characteristics of synchronous distributed systems and asynchronous distributed system Omission failures, arbitrary failures, timing failure in distributed systems ","date":"2021-12-03 14:35:38","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_02/:4:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_02","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_02/"},{"categories":["School courses"],"content":" 2021哈工大深圳堵宏伟分布式系统课程笔记 Intr HongweiDu(堵宏伟) ","date":"2021-12-03 14:35:31","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/:0:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_01","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/"},{"categories":["School courses"],"content":"Topics Introduction Distributed Systems models Distributed Time and Clock Synchronization Socket Communication Remote Method Invocation(RMI) Group Communication Mutual exclusion \u0026 election algorithms Replication …… ","date":"2021-12-03 14:35:31","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/:1:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_01","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/"},{"categories":["School courses"],"content":"Motivation Resource sharing Computers connected by the network and share resources. Hardware sharing, software sharing, data sharing, service sharing.media stream sharing. Collaborative computing Parallel computing, distributed computing ","date":"2021-12-03 14:35:31","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/:2:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_01","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/"},{"categories":["School courses"],"content":"Definition A distributed system is defined as one in which components at networked computers communicate and coordinate their actions only by passing messages. ","date":"2021-12-03 14:35:31","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/:3:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_01","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/"},{"categories":["School courses"],"content":"Features The distributed system features: Concurrency Multi-process and multi-threads concurrently execute, share resources. No global clock Program coordination depend on message passing. Independent failure Some processes failure, can not be known by other processes. ","date":"2021-12-03 14:35:31","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/:4:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_01","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/"},{"categories":["School courses"],"content":"Challenges ","date":"2021-12-03 14:35:31","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/:5:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_01","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/"},{"categories":["School courses"],"content":"Heterogeneity Middleware Apply to a software layer that provides a program abstraction as well as masking the heterogeneity of the underlying layers (networks, hardware, operating systems and programming languages). Example: Java RMI Mobile code Program code that can transferred from one computer to another and run at the destination. Example: Java Applet.The Java virtual machine (JVM) provide a way of making code executable on a variety of host computers. ","date":"2021-12-03 14:35:31","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/:5:1","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_01","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/"},{"categories":["School courses"],"content":"Openness Computer System Openness Determines whether the system can be extended and reimplemented in various ways. For example: UNIX. Distributed System Openness The degree to which new resource-sharing services can be added and be made available for use by a variety of client programs. RFC (‘Request For Comments’) ","date":"2021-12-03 14:35:31","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/:5:2","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_01","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/"},{"categories":["School courses"],"content":"Security Confidentiality(机密性） Protection against disclosure to unauthorized individuals. Integrity （完整性） Protection against alteration or corruption. e.g. Checksum (校验和） Availability（可用性） Protection against interference with the means to access the resources. ","date":"2021-12-03 14:35:31","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/:5:3","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_01","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/"},{"categories":["School courses"],"content":"Scalability(可拓展性) Controlling the cost of physical resources As the demand for a resource grows, it should be possible to extend the system, at reasonable cost, to meet it. Controlling the performance loss Consider the management of a set of data whose size is proportional to the number of users or resources in the system. Preventing software resources running out IPv4, IPv6….. Avoiding performance bottlenecks In general, algorithms should be decentralized to avoid having performance bottlenecks. ","date":"2021-12-03 14:35:31","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/:5:4","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_01","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/"},{"categories":["School courses"],"content":"Failure handling Detecting failures Some failure can be detected. Masking failures Some failure that have been detected can be hidden or made less severe. Tolerating failures Most of the services in the Internet do exhibit failures. Recovering from failures Recovery involves the design of software so that the state of permanent data can be recovered or ‘roll back’ after a server has crashed. Redundancy Services can be made to tolerate failures by the use of redundant components. ","date":"2021-12-03 14:35:31","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/:5:5","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_01","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/"},{"categories":["School courses"],"content":"Concurrency Consistent Multi-thread concurrent access the sharing resource. Performance ","date":"2021-12-03 14:35:31","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/:5:6","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_01","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/"},{"categories":["School courses"],"content":"Transparency Access transparency: enables local and remote resources to be accessed using identical operations. Location transparency: enables resources to be accessed without knowledge of their physical or network location (for example, which building or IP address). Concurrency transparency: enables several processes to operate concurrently using shared resources without interference between them. Replication transparency: enables multiple instances of resources to be used to increase reliability and performance without knowledge of the replicas by users or application programmers. Failure transparency: enables the concealment of faults, allowing users and application programs to complete their tasks despite the failure of hardware or software components. Mobility transparency: allows the movement of resources and clients within a system without affecting the operation of users or programs. Performance transparency: allows the system to be reconfigured to improve performance as loads vary. Scaling transparency: allows the system and applications to expand in scale without change to the system structure or the application algorithms. ","date":"2021-12-03 14:35:31","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/:5:7","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_01","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/"},{"categories":["School courses"],"content":"Quality of Service Reliability Security Performance Adaptability ","date":"2021-12-03 14:35:31","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/:5:8","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_01","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/"},{"categories":["School courses"],"content":"Conclusion Distributed system is everywhere. The motivation of constructing a distributed system is resource sharing and collaborative computing Distributed system features. Concurrency No global clock Independent failure Distributed system challenges. Heterogeneity Openness Security Scalability Failure handling Concurrency Transparency Quality of Service ","date":"2021-12-03 14:35:31","objectID":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/:6:0","tags":["distributed system"],"title":"DistributedSystem_HongweiDu_01","uri":"https://qizhengzou.github.io/distributedsystem_hongweidu_01/"},{"categories":["Advanced learning"],"content":"日志系统：一条SQL更新语句是如何执行的? mysql\u003e create table T(ID int primary key, c int); mysql\u003e update T set c=c+1 where ID=2; 查询语句的那一套流程，更新语句也是同样会走一遍。 执行语句前要先连接数据库，这是连接器的工作。 在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。 分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用 ID 这个索引。然后，执行器负责具体执行，找到这一行，然后更新。 与查询流程不一样的是，更新流程还涉及两个重要的日志模块，redo log（重做日志）和 binlog（归档日志）。redo log 和 binlog 在设计上有很多有意思的地方。 ","date":"2021-12-01 23:43:29","objectID":"https://qizhengzou.github.io/mysql_advanced_02/:0:0","tags":["mysql"],"title":"Mysql_advanced_02","uri":"https://qizhengzou.github.io/mysql_advanced_02/"},{"categories":["Advanced learning"],"content":"重要的日志模块：redo log 如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。 WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘 具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。 InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB。从头开始写，写到末尾就又回到开头循环写。 write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。 write pos 和 checkpoint 之间的还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示日志满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。 有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。 redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。 ","date":"2021-12-01 23:43:29","objectID":"https://qizhengzou.github.io/mysql_advanced_02/:1:0","tags":["mysql"],"title":"Mysql_advanced_02","uri":"https://qizhengzou.github.io/mysql_advanced_02/"},{"categories":["Advanced learning"],"content":"重要的日志模块 MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面的 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。 最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。 两种日志的不同： redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。 redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1”。 redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程： 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。 注：redo log 的写入拆成了两个步骤：prepare 和 commit，这就是\"两阶段提交”。 sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。 ","date":"2021-12-01 23:43:29","objectID":"https://qizhengzou.github.io/mysql_advanced_02/:2:0","tags":["mysql"],"title":"Mysql_advanced_02","uri":"https://qizhengzou.github.io/mysql_advanced_02/"},{"categories":["Advanced learning"],"content":"两阶段提交 两阶段提交是为了让两份日志之间的逻辑一致。 binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。 当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做： 首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库； 然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。 为什么日志需要“两阶段提交”？ 由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。这两种方式的问题： 先写 redo log 后写 binlog。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。 先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。 即，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。 不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用 binlog来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。 ","date":"2021-12-01 23:43:29","objectID":"https://qizhengzou.github.io/mysql_advanced_02/:3:0","tags":["mysql"],"title":"Mysql_advanced_02","uri":"https://qizhengzou.github.io/mysql_advanced_02/"},{"categories":["Advanced learning"],"content":"一天一备份和一周一备份的区别 一天一备份“最长恢复时间”更短。 频繁全量备份需要消耗更多存储空间，所以这个 RTO 是成本换来的，就需要你根据业务重要性来评估了。 参考 ","date":"2021-12-01 23:43:29","objectID":"https://qizhengzou.github.io/mysql_advanced_02/:4:0","tags":["mysql"],"title":"Mysql_advanced_02","uri":"https://qizhengzou.github.io/mysql_advanced_02/"},{"categories":["Advanced learning"],"content":" mysql\u003e select * from T where ID=10； 一条简单的查询语句，MYSQL内部发生了什么？ 大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。 Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。 存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。可以在 create table 语句中使用 engine=memory, 来指定使用内存引擎创建表。 不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分。 ","date":"2021-12-01 21:31:10","objectID":"https://qizhengzou.github.io/mysql_advanced_01/:0:0","tags":["mysql"],"title":"Mysql_advanced_01","uri":"https://qizhengzou.github.io/mysql_advanced_01/"},{"categories":["Advanced learning"],"content":"连接器 连接器负责跟客户端建立连接、获取权限、维持和管理连接。 mysql -h$ip -P$port -u$user -p 如果把密码直接写在-p后面容易导致密码泄露 连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码： 如果用户名或密码不对，你就会收到一个\"Access denied for user\"的错误，然后客户端程序结束执行。 如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限（注意修改权限后下次登录才生效）。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。 连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到该连接的command是sleep的。show processlist 是显示用户正在运行的线程，需要注意的是，除了 root 用户能看到所有正在运行的线程外，其他用户都只能看到自己正在运行的线程，看不到其它用户正在运行的线程。除非单独个这个用户赋予了PROCESS 权限。 客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。 mysql\u003e show variables like 'wait_timeout'; ","date":"2021-12-01 21:31:10","objectID":"https://qizhengzou.github.io/mysql_advanced_01/:1:0","tags":["mysql"],"title":"Mysql_advanced_01","uri":"https://qizhengzou.github.io/mysql_advanced_01/"},{"categories":["Advanced learning"],"content":"长连接和短连接： 长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。（推荐，因为建立连接的过程通常是比较复杂的） 短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。 但是全部使用长连接后，有些时候 MySQL 占用内存涨得特别快，这是因为 **MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。**所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。 解决方法： 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。 如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。 mysql_reset_connection：重置连接以清除会话状态。（将句柄都给置空，并且清理掉了预处理语句、结果集） mysql_reset_connection()的作用类似于mysql_change_user()或自动重新连接，除了未关闭并重新打开连接且未完成重新身份验证外。 与连接有关的状态受到以下影响： 回滚所有活动的事务，并重置自动提交模式。 所有 table 锁均已释放。 所有TEMPORARYtable 均已关闭(并删除)。 会话系统变量将重新初始化为相应的全局系统变量的值，包括由诸如SET NAMES之类的语句隐式设置的系统变量。 用户变量设置丢失。 准备好的语句被释放。 HANDLER个变量已关闭。 LAST_INSERT_ID()的值重置为 0. 用GET_LOCK()获取的锁被释放。 Return Values 零成功。如果发生错误，则为非零值。 ","date":"2021-12-01 21:31:10","objectID":"https://qizhengzou.github.io/mysql_advanced_01/:1:1","tags":["mysql"],"title":"Mysql_advanced_01","uri":"https://qizhengzou.github.io/mysql_advanced_01/"},{"categories":["Advanced learning"],"content":"查询缓存 MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。 如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。 查询缓存的弊端： 查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。 可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定： mysql\u003e select SQL_CACHE * from T where ID=10； MySQL 8.0 版本直接将查询缓存的整块功能删掉了。 ","date":"2021-12-01 21:31:10","objectID":"https://qizhengzou.github.io/mysql_advanced_01/:1:2","tags":["mysql"],"title":"Mysql_advanced_01","uri":"https://qizhengzou.github.io/mysql_advanced_01/"},{"categories":["Advanced learning"],"content":"分析器 分析器对 SQL 语句做解析让mysql知道你要做什么： 词法分析 你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。 MySQL 从你输入的\"select\"这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID” 语法分析 根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。 如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如你的查询语句 select 少打了开头的字母“s”。 ","date":"2021-12-01 21:31:10","objectID":"https://qizhengzou.github.io/mysql_advanced_01/:1:3","tags":["mysql"],"title":"Mysql_advanced_01","uri":"https://qizhengzou.github.io/mysql_advanced_01/"},{"categories":["Advanced learning"],"content":"优化器 执行前，需经过优化器的处理： 优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join： mysql\u003e select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20; 既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。 也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。 逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。 ","date":"2021-12-01 21:31:10","objectID":"https://qizhengzou.github.io/mysql_advanced_01/:1:4","tags":["mysql"],"title":"Mysql_advanced_01","uri":"https://qizhengzou.github.io/mysql_advanced_01/"},{"categories":["Advanced learning"],"content":"执行器 执行语句： 先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。 mysql\u003e select * from T where ID=10; ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T' 如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。 比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的： 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中； 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。 对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。 你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。 在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。 参考 ","date":"2021-12-01 21:31:10","objectID":"https://qizhengzou.github.io/mysql_advanced_01/:1:5","tags":["mysql"],"title":"Mysql_advanced_01","uri":"https://qizhengzou.github.io/mysql_advanced_01/"},{"categories":["Advanced learning"],"content":"程序运行过程 实现一个简单内核 ","date":"2021-12-01 11:22:00","objectID":"https://qizhengzou.github.io/operatingsystem_advanced_02/:0:0","tags":["operating system"],"title":"OperatingSystem_advanced_02","uri":"https://qizhengzou.github.io/operatingsystem_advanced_02/"},{"categories":["Advanced learning"],"content":"程序编译过程 使用 GCC 相关的工具链。那么使用命令：gcc HelloWorld.c -o HelloWorld 或者 gcc ./HelloWorld.c -o ./HelloWorld ，就可以编译这段代码。其实，GCC 只是完成编译工作的驱动程序，它会根据编译流程分别调用预处理程序（-\u003eHelloWorld.i）、编译程序（-\u003eHelloWorld.s）、汇编程序（-\u003eHelloWorld.o）、链接程序(将HelloWorld.o与其他的库进行链接形成可执行文件)来完成具体工作。 gcc HelloWorld.c -E -o HelloWorld.i 预处理：加入头文件，替换宏。 gcc HelloWorld.c -S -c -o HelloWorld.s 编译：包含预处理，将 C 程序转换成汇编程序。 gcc HelloWorld.c -c -o HelloWorld.o 汇编：包含预处理和编译，将汇编程序转换成可链接的二进制程序。 gcc HelloWorld.c -o HelloWorld 链接：包含以上所有操作，将可链接的二进制程序和其它别的库链接在一起，形成可执行的程序文件。 ","date":"2021-12-01 11:22:00","objectID":"https://qizhengzou.github.io/operatingsystem_advanced_02/:1:0","tags":["operating system"],"title":"OperatingSystem_advanced_02","uri":"https://qizhengzou.github.io/operatingsystem_advanced_02/"},{"categories":["Advanced learning"],"content":"程序装载执行 图灵机： 一个抽象的模型：有一条无限长的纸带，纸带上有无限个小格子，小格子中写有相关的信息，纸带上有一个读头，读头能根据纸带小格子里的信息做相关的操作并能来回移动。 根据冯诺依曼体系结构构成的计算机，必须具有如下功能： 把程序和数据装入到计算机中； 必须具有长期记住程序、数据的中间结果及最终运算结果； 完成各种算术、逻辑运算和数据传送等数据加工处理； 根据需要控制程序走向，并能根据指令控制机器的各部件协调操作； 能够按照要求将处理的数据结果显示给用户。 为了完成上述的功能，计算机必须具备五大基本组成部件： 装载数据和程序的输入设备； 记住程序和数据的存储器； 完成数据加工处理的运算器； 控制程序执行的控制器； 显示处理结果的输出设备。 反汇编指令objdump细节可参考 现代电子计算机正是通过内存中的信息（指令和数据）做出相应的操作，并通过内存地址的变化，达到程序读取数据，控制程序流程（顺序、跳转对应该图灵机的读头来回移动）的功能。和图灵机的核心思想相比，没有根本性的变化。只要配合一些 I/O 设备，让用户输入并显示计算结果给用户，就是一台现代意义的电子计算机。 ","date":"2021-12-01 11:22:00","objectID":"https://qizhengzou.github.io/operatingsystem_advanced_02/:2:0","tags":["operating system"],"title":"OperatingSystem_advanced_02","uri":"https://qizhengzou.github.io/operatingsystem_advanced_02/"},{"categories":["Advanced learning"],"content":"HELLO OS ","date":"2021-12-01 11:22:00","objectID":"https://qizhengzou.github.io/operatingsystem_advanced_02/:3:0","tags":["operating system"],"title":"OperatingSystem_advanced_02","uri":"https://qizhengzou.github.io/operatingsystem_advanced_02/"},{"categories":["Advanced learning"],"content":"PC 机的引导流程 写操作系统要用汇编和 C 语言，尽管这个 Hello OS 很小，但也要用到两种编程语言。其实，现有的商业操作系统都是用这两种语言开发出来的。 hello os的引导流程： PC机加电 PC机BIOS固件 加载可引导设备中的GRUB(GrandUnified Boot Loader引导内核加载程序) GRUB引导 加载硬盘分区的hello os 文件 hello os PC机BIOS固件： PC 机 BIOS 固件是固化在 PC 机主板上的 ROM 芯片中的，掉电也能保存，PC 机上电后的第一条指令就是 BIOS 固件中的，它负责检测和初始化 CPU、内存及主板平台，然后加载引导设备（大概率是硬盘）中的第一个扇区数据（这个扇区一共512字节，前446字节内容存放grub（bootloader）的关键引导程序，接着64字节放置硬盘分区表DPT（Disk Partition Table），一共可以有四个主分区，占64个字节，这也是为什么主分区最多只有四个的原因，最后2个字节是固定的标志0x55AA。）到 0x7c00 地址开始的内存空间，再接着跳转到 0x7c00 处执行指令，在我们这里的情况下就是 GRUB 引导程序。 当BIOS把引导程序加载到内存后就把控制权交给grub，而后grub的剩余代码将完成其它代码的加载和搬移以及文件系统初始化查找等工作，最终加载内核映像文件，从而把控制权交给真正的内核运行。（参考） ","date":"2021-12-01 11:22:00","objectID":"https://qizhengzou.github.io/operatingsystem_advanced_02/:3:1","tags":["operating system"],"title":"OperatingSystem_advanced_02","uri":"https://qizhengzou.github.io/operatingsystem_advanced_02/"},{"categories":["Advanced learning"],"content":"Hello OS 引导汇编代码 为什么不直接开始用c写操作系统？ C 作为通用的高级语言，不能直接操作特定的硬件，而且 C 语言的函数调用、函数传参，都需要用栈。 栈简单来说就是一块内存空间，其中数据满足后进先出的特性，它由 CPU 特定的栈寄存器指向，所以我们要先用汇编代码处理好这些 C 语言的工作环境。 用汇编定义的 GRUB 的多引导协议头，其实就是一定格式的数据，我们的 Hello OS 是用 GRUB 引导的，当然要遵循 GRUB 的多引导协议标准，让 GRUB 能识别我们的 Hello OS。之所以有两个引导头，是为了兼容 GRUB1 和 GRUB2。 关掉中断，设定 CPU 的工作模式。 初始化cpu的寄存器和c语言的运行环境，最后调用c语言的mian函数 GDT_START 开始的，是 CPU 工作模式所需要的数据。 ","date":"2021-12-01 11:22:00","objectID":"https://qizhengzou.github.io/operatingsystem_advanced_02/:3:2","tags":["operating system"],"title":"OperatingSystem_advanced_02","uri":"https://qizhengzou.github.io/operatingsystem_advanced_02/"},{"categories":["Advanced learning"],"content":"HELLO OS的主函数 main函数是用 C 语言写的在（main.c）中，最终它们分别由 nasm(NASM是一个为可移植性与模块化而设计的一个80x86的汇编器。它支持相当多的目标文件格式，包括Linux和'‘NetBSD/FreeBSD’',‘‘a.out’',‘‘ELF’',‘‘COFF’',微软16位的'‘OBJ'‘和'‘Win32’'。它还可以输出纯二进制文件。它的语法设计得相当的简洁易懂，和Intel语法相似但更简单。它持'‘Pentium’',‘‘P6’',‘‘MMX’',‘‘3DNow!'', ‘‘SSE’’ and ‘‘SSE2'‘指令集。参考) 和 GCC 编译成可链接模块，由 LD 链接器链接在一起，形成可执行的程序文件。 main.c #include \"vgastr.h\"void main() { printf(\"Hello OS!\"); return; } vgastr.h：控制计算机屏幕VGABIOS固件程序显示特定字符（自己实现） ","date":"2021-12-01 11:22:00","objectID":"https://qizhengzou.github.io/operatingsystem_advanced_02/:3:3","tags":["operating system"],"title":"OperatingSystem_advanced_02","uri":"https://qizhengzou.github.io/operatingsystem_advanced_02/"},{"categories":["Advanced learning"],"content":"控制计算机屏幕 计算机屏幕显示往往是显卡的输出，显卡有很多形式：集成在主板的叫集显，做在 CPU 芯片内的叫核显，独立存在通过 PCIE 接口（PCIe是PCI Express的简写，是新一代的总线接口，是由20多家业界主导公司共同起草并完成的新技术规范，采用点对点的串行连接，可以将数据传输率提高到一个很高的频率，以此提供更高的带宽。参考）连接的叫独显，性能依次上升，价格也是。 独显 3D 图形显示往往要涉及顶点处理、多边形的生成和变换、纹理、着色、打光、栅格化等。而这些任务的计算量超级大，所以独显往往有自己的 RAM、多达几百个运算核心的处理器。因此独显不仅仅是可以显示图像，而且可以执行大规模并行计算，比如“挖矿”。 要在屏幕上显示字符，就要编程操作显卡。 无论PC上是什么显卡，它们都支持一种叫 VESA 的标准，这种标准下有两种工作模式：字符模式和图形模式。显卡们为了兼容这种标准，不得不自己提供一种叫 VGABIOS 的固件程序。 显卡的字符模式的工作细节: 它把屏幕分成 24 行，每行 80 个字符，把这（24*80）个位置映射到以 0xb8000 地址开始的内存中，每两个字节对应一个字符，其中一个字节是字符的 ASCII 码，另一个字节为字符的颜色值。 注：C 语言字符串是以 0 结尾的，其字符编码通常是 utf8，而 utf8 编码对 ASCII 字符是兼容的，即英文字符的 ASCII 编码和 utf8 编码是相等的 在vgastr.h里实现： void _strwrite(char* string) { char* p_strdst = (char*)(0xb8000);//指向显存的开始地址 while (*string) //将字符串里每个字符依次定入到 0xb8000 地址开始的显存中。 { *p_strdst = *string++; p_strdst += 2; //为了跳过字符的颜色信息的空间。 } return; } void printf(char* fmt, ...) { _strwrite(fmt); return; } ","date":"2021-12-01 11:22:00","objectID":"https://qizhengzou.github.io/operatingsystem_advanced_02/:3:4","tags":["operating system"],"title":"OperatingSystem_advanced_02","uri":"https://qizhengzou.github.io/operatingsystem_advanced_02/"},{"categories":["Advanced learning"],"content":"编译和安装 Hello OS 不像HELLO OS,一个成熟的商业操作系统多达几万个代码模块文件，几千万行的代码量。需要一个工具来控制这个巨大的编译过程—-make make工具 在软件开发中，make 是一个工具程序，它读取一个叫“makefile”(makefile是一种用于编译的脚本语言)的文件，也是一种文本文件，这个文件中写好了构建软件的规则，它能根据这些规则自动化构建软件。 makefile 文件中规则是这样的：首先有一个或者多个构建目标称为“target”；目标后面紧跟着用于构建该目标所需要的文件，目标下面是构建该目标所需要的命令及参数。与此同时，它也检查文件的依赖关系，如果需要的话，它会调用一些外部软件来完成任务。 第一次构建目标后，下一次执行 make 时，它会根据该目标所依赖的文件是否更新决定是否编译该目标，如果所依赖的文件没有更新且该目标又存在，那么它便不会构建该目标。这种特性非常有利于编译程序源代码。 任何一个 Linux 发行版中都默认自带这个 make 程序，所以不需要额外的安装工作，我们直接使用即可。 一个有关makefile的例子： CC = gcc #定义一个宏CC 等于gcc CFLAGS = -c #定义一个宏 CFLAGS 等于-c OBJS_FILE = file.o file1.o file2.o file3.o file4.o #定义一个宏 .PHONY : all everything #定义两个伪目标all、everything all:everything #伪目标all依赖于伪目标everything everything :$(OBJS_FILE) #伪目标everything依赖于OBJS_FILE，而OBJS_FILE是宏会被 #替换成file.o file1.o file2.o file3.o file4.o %.o : %.c $(CC) $(CFLAGS) -o $@ $\u003c makefile 中可以定义宏，方法是在一个字符串后跟一个“=”或者“:=”符号，引用宏时要用“$(宏名)”，宏最终会在宏出现的地方替换成相应的字符串，例如：$(CC) 会被替换成 gcc，$( OBJS_FILE) 会被替换成 file.o file1.o file2.o file3.o file4.o。 .PHONY 在 makefile 中表示定义伪目标。所谓伪目标，就是它不代表一个真正的文件名，在执行 make 时可以指定这个目标来执行其所在规则定义的命令。但是伪目标可以依赖于另一个伪目标或者文件，例如：all 依赖于 everything，everything 最终依赖于 file.c file1.c file2.c file3.c file4.c。 通用规则：“%.o : %.c”。其中的“%”表示通配符，表示所有以“.o”结尾的文件依赖于所有以“.c”结尾的文件。 针对这些依赖关系，分别会执行：$(CC) $(CFLAGS) -o $@ $\u003c 命令，当然最终会转换为：gcc –c –o xxxx.o xxxx.c，这里的“xxxx”表示一个具体的文件名。 ","date":"2021-12-01 11:22:00","objectID":"https://qizhengzou.github.io/operatingsystem_advanced_02/:3:5","tags":["operating system"],"title":"OperatingSystem_advanced_02","uri":"https://qizhengzou.github.io/operatingsystem_advanced_02/"},{"categories":["Advanced learning"],"content":"编译 makefile进行make后产生三个文件：entry.asm(汇编程序文件) main.c vgastr.c entry.asm经nasm汇编器汇编为entry.o(二进制文件) main.c和vgastr.c经gcc编译为main.o和vgastr.o 三个二进制文件经LD链接为HELLO OS.elf(Executable Linkable Format，二进制可执行文件的一种形式) HELLO OS.elf经objcopy命令格式转化为 HELLO OS.bin(objcopy 把一种目标文件中的内容复制到另一种类型的目标文件中) ","date":"2021-12-01 11:22:00","objectID":"https://qizhengzou.github.io/operatingsystem_advanced_02/:3:6","tags":["operating system"],"title":"OperatingSystem_advanced_02","uri":"https://qizhengzou.github.io/operatingsystem_advanced_02/"},{"categories":["Advanced learning"],"content":"安装HELLO OS 前面得到了 Hello OS.bin 文件，但是我们还要让 GRUB 能够找到它，才能在计算机启动时加载它，即—安装。 GRUB 在启动时会加载一个 grub.cfg 的文本文件，根据其中的内容执行相应的操作，其中一部分内容就是启动项。GRUB 首先会显示启动项到屏幕，然后让我们选择启动项，最后 GRUB 根据启动项对应的信息，加载 OS 文件到内存。 HELLO OS启动项： menuentry 'HelloOS' { insmod part_msdos #GRUB加载分区模块识别分区 insmod ext2 #GRUB加载ext文件系统模块识别ext文件系统 set root='hd0,msdos4' #注意boot目录挂载的分区，这是我机器上的情况，命令df /boot/可查看 multiboot2 /boot/HelloOS.bin #GRUB以multiboot2协议加载HelloOS.bin boot #GRUB启动HelloOS.bin } df /boot/后也可能是： 文件系统 1K-块 已用 可用 已用% 挂载点 /dev/sda4 48752308 8087584 38158536 18% / 其中的“sda4”就是硬盘的第四个分区（硬件分区选择 MBR），但是 GRUB 的 menuentry 中不能写 sda4，而是要写“hd0,msdos4”，这是 GRUB 的命名方式，hd0 表示第一块硬盘，结合起来就是第一块硬盘的第四个分区。 MBR与GPT（参考）: MBR，它的全称是主引导记录(Master Boot Record)，它最早是在1983年的IBM PC DOS 2.0中提出的，这种模式下会在系统驱动器的一个特殊的位置建立一个用于保存操作系统BootLoader和驱动器逻辑分区的扇区。它只能最大支持2TB的磁盘，超过之后就无法识别，而在Windows下也只能创建最多4个分区。 GPT，他是指的GUID分区表，也就是GUID意为全局唯一标识符，会生成一个唯一的识别码来进行引导创建，在功能上则没有MBR那么多的限制，支持2TB以上的磁盘，并且在Windows下支持最高128个分区的建立。 如果你的电脑硬件比较老旧的话，或者安装的系统版本也比较老旧的话，那就为了兼容性更好，选择MBR，而反之的话，就选择标准更新更加没有限制的GPT。 把上面启动项的代码插入到你的 Linux 机器上的 /boot/grub/grub.cfg 文件末尾，然后把 Hello OS.bin 文件复制到 /boot/ 目录下，一定注意这里是追加不是覆盖。最后重启计算机，你就可以看到 Hello OS 的启动选项了。选择 Hello OS，按下 Enter 键（或者重启按 ESC 键），这样就可以成功启动我们自己的 Hello OS 了。 ","date":"2021-12-01 11:22:00","objectID":"https://qizhengzou.github.io/operatingsystem_advanced_02/:3:7","tags":["operating system"],"title":"OperatingSystem_advanced_02","uri":"https://qizhengzou.github.io/operatingsystem_advanced_02/"},{"categories":["Advanced learning"],"content":"HELLO OS回顾 首先，我们了解了从按下 PC 机电源开关开始，PC 机的引导过程。它从 CPU 上电，到加载 BIOS 固件，再由 BIOS 固件对计算机进行自检和默认的初始化，并加载 GRUB 引导程序，最后由 GRUB 加载具体的操作系统。 其次，用汇编语言和 C 语言实现我们的 Hello OS。 第一步，用汇编程序初始化 CPU 的寄存器、设置 CPU 的工作模式和栈，最重要的是加入了 GRUB 引导协议头； 第二步，切换到 C 语言，用 C 语言写好了主函数和控制显卡输出的函数，其间还了解了显卡的一些工作细节。 最后，就是编译和安装 Hello OS 了。我们用了 make 工具编译整个代码，其实 make 会根据一些规则调用具体的 nasm、gcc、ld 等编译器，然后形成 Hello OS.bin 文件，你把这个文件写复制到 boot 分区，写好 GRUB 启动项，这样就好了。 参考 ","date":"2021-12-01 11:22:00","objectID":"https://qizhengzou.github.io/operatingsystem_advanced_02/:3:8","tags":["operating system"],"title":"OperatingSystem_advanced_02","uri":"https://qizhengzou.github.io/operatingsystem_advanced_02/"},{"categories":["Advanced learning"],"content":"内存为什么会泄漏、服务进程为什么会 dang 掉、文件为什么打不开等一系列“基础”问题 MySQL 的 I/O 性能还能不能再提升？网络服务为什么会掉线？Redis 中经典的 Reactor 设计模式靠什么技术支撑？Node.js 的 I/O 模型长什么模样…… 如果你是后端工程师，在做高性能服务端编程的时候，内存、进程、线程、I/O 相关的知识就会经常用到。还有，在做一些前端层面的性能调优时，操作系统相关的一些知识更是必不可少。 除了 Web 开发，做高性能计算超级计算机的时候，操作系统内核相关的开发能力也至关重要。其实，即使单纯的操作系统内核相关的开发能力，对于工程师来说也是绕不过的基本功。 对于运维、测试，你要维护和测试的任何产品，其实是基于操作系统的。比如给服务配置多大的内存、多大的缓存空间？怎样根据操作系统给出的信息，判断服务器的问题出现在哪里。随着你对操作系统的深入理解和掌握，你才能透过现象看本质，排查监控思路也会更开阔。 ","date":"2021-12-01 11:08:12","objectID":"https://qizhengzou.github.io/operatingsystem_advanced_01/:0:0","tags":["operating system"],"title":"OperatingSystem_advanced_01","uri":"https://qizhengzou.github.io/operatingsystem_advanced_01/"},{"categories":["Advanced learning"],"content":"学习过程 从了解计算机的资源开始，如 CPU、MMU、内存和 Cache。其次要为这个操作系统设计基本法，即各种同步机制，如信号量与自旋锁。 接着进行授权，从固件程序的手中抢过计算机并进行初始化，其中包含初始化 CPU、内存、中断、显示等。 然后，开始建设中枢的各级部门，它们分别是内存管理部门、进程管理部门、I/O 管理部门、文件管理部门、通信管理部门。 最后将这些部门组合在一起，就形成了计算机操作系统。 最终实现一个基于 x86 平台的 64 位多进程的操作系统——Cosmos。 参考 ","date":"2021-12-01 11:08:12","objectID":"https://qizhengzou.github.io/operatingsystem_advanced_01/:1:0","tags":["operating system"],"title":"OperatingSystem_advanced_01","uri":"https://qizhengzou.github.io/operatingsystem_advanced_01/"},{"categories":["School courses"],"content":" 王道考研操作系统笔记 设备管理 ","date":"2021-11-30 18:26:58","objectID":"https://qizhengzou.github.io/operatingsystem_base_05/:0:0","tags":["operating system"],"title":"OperatingSystem_base_05","uri":"https://qizhengzou.github.io/operatingsystem_base_05/"},{"categories":["School courses"],"content":"I/O 管理概述 ","date":"2021-11-30 18:26:58","objectID":"https://qizhengzou.github.io/operatingsystem_base_05/:1:0","tags":["operating system"],"title":"OperatingSystem_base_05","uri":"https://qizhengzou.github.io/operatingsystem_base_05/"},{"categories":["School courses"],"content":"I/O设备的分类与管理的任务 I/O设备的分类 (1)按设备的使用特性分类：按设备的使用特性可以将设备分为存储设备、人机交互设备和网络通信设备。 存储设备。它是计算机用来保存各种信息的设备，如磁盘、磁带等。 人机交互设备。它是计算机与计算机用户之间交互的设备，用于向CPU传输信息或输出经过CPU加工处理的信息，如键盘是输入设备，显示器和打印机是输出设备。 网络通信设备。 用于与远程设备通信的设备，如各种网络接口、调制解调器等。 (2)按信息交换单位分类：按信息交换单位可以将设备分为字符设备和块设备。 字符设备。处理信息的基本单位是字符，如键盘、打印机和显示器是字符设备。 块设备。处理信息的基本单位是字符块。一般字符块的大小为512B~4KB, 如磁盘是块设备。 (3)按传输速率分类：按设备传输速度的高低可以将I/O设备分为低速设备、中速设备和高速设备。 低速设备。它是指其传输速率仅为每秒几个字节至数百个字节的一类设备， 如键盘、鼠标等。 中速设备。 它是指其传输速率在每秒数千字节至数万字节的一类设备，如行式打印机、激光打印机等。 高速设备。它是指其传输速率在每秒数十万个字节至数十兆字节的一类设备，如磁带机、磁盘等。 (4)按设备的共享属性分类：按设备的共享属性可以将设备分为独占设备、共享设备和虛拟设备。 独占设备。它是指在同一时刻只有一个进程可以使用的设备，属于临界资源。一旦系统将这类设备分配给某个进程后，便由该进程独占，直至用完释放。多数低速设备都属于独占设备，比如打印机。 共享设备。 它是指允许多个进程访问的设备，比如磁盘就是非常典型的共享设备，它允许若千个进程交替地读写信息，当然在一个时刻，一台设备只允许一个进程访问。 虚拟设备。它是指通过虚拟技术让一个独占设备在逻辑上被多个进程同时使用的设备，比如采用虛拟技术后的打印机，进程可以同时发送打印信息给打印机，就像有多个打印机一样。 I/O 管理的任务和功能 设备管理的主要任务是完成用户提出的I/O请求，为用户分配IO设备，提高I/O设备的利用率，方便用户使用IO设备。为了完成上述任务，设备管理应该具备以下功能。 (1)设备分配 按照设备类型和相应的分配算法决定将IO设备分配给哪一个进程。如果在I0设备和CPU之间还存在着设备控制器和通道，那么还必须分配相应的设备控制器和通道，以保证IO设备与CPU之间有传递信息的通路。凡未分配到所需设备的进程应放在一个等待队列。为了实现设备分配，系统中应设置一些数据结构，用于记录设备的状态。 (2)设备处理 设备处理程序用以实现CPU和设备控制器之间的通信。进行IO操作时，由CPU向设备控制器发出I/O指令，启动设备进行IO操作;当I/O操作完成时能对设备发来的中断请求作出及时的响应和处理。 (3)缓冲管理 设置缓冲区的目的是为了缓和CPU与I/O设备速度不匹配的矛盾。缓冲管理程序负责完成缓冲区的分配、释放及有关的管理工作。 (4)设备独立性 设备独立性又称为设备无关性，是指应用程序独立于物理设备。用户在编制应用程序时,要尽量避免直接使用实际设备名。若程序中使用了实际设备名，则当该设备没有连续在系统中或者该设备发生故障时，用户程序无法运行，若要运行此程序，则需要修改程序。如果用户程序不涉及实际设备而使用逻辑设备，那么它所要求的输入输出便与物理设备无关。设备独立性可以提高用户程序的可适应性。 ","date":"2021-11-30 18:26:58","objectID":"https://qizhengzou.github.io/operatingsystem_base_05/:1:1","tags":["operating system"],"title":"OperatingSystem_base_05","uri":"https://qizhengzou.github.io/operatingsystem_base_05/"},{"categories":["School courses"],"content":"I/O 控制方式 设备一般由机械部分和电子部分组成，设备的电子部分通常称为设备控制器。设备控制器处于CPU与I/O设备之间，其接收来自CPU的命令，并控制I/O设备工作，使处理器从繁杂的设备控制事务中解脱出来。设备控制器是一个可编址设备，当它仅控制一个设备时，它只有一个设备地址;当它可连接多个设备时，它应具有多个设备地址。 设备控制器应具备以下功能: ①接收和识别来自CPU的各种指令; ②实现CPU与设备控制器、设备控制器与设备之间的数据交换; ③记录设备的状态供CPU查询; ④识别所控制的每个设备的地址; ⑤对CPU输出的数据或设备向CPU输入的数据进行缓冲; ⑥对输入/输出数据进行差错控制。 大多数设备控制器由设备控制器与处理器的接口、设备控制器与设备的接口及IO逻辑3 部分组成，如图5-1所示。 I/O控制方式通常有以下4种:程序直接控制方式、中断控制方式、DMA控制方式和通道控制方式。 程序直接控制方式 在早期的计算机系统中，没有中断系统，所以CPU和I/O设备进行通信、传输数据时,由于CPU的速度远远快于I/O设备，因此CPU需要不断地测试IO设备。这种控制方式又称为轮询或忙等。 如图5-2a所示，以数据输入为例，当用户进程需要输入数据时，由处理器向设备控制器发出一条I/O指令启动设备进行输入。在设备输入数据期间，处理器通过循环执行测试指令不断地检测设备状态寄存器的值，当状态寄存器的值显示设备输入完成时，处理器将数据寄存器中的数据取出并送入内存指定单元，然后再启动设备去读下一个数据。反之，当用户进程需要向设备输出数据时，也必须同样发出启动命令启动设备输出并等待输出操作完成。 优点。程序直接控制方式的工作过程非常简单。 缺点。 CPU的利用率相当低。因为I/O设备的速度太慢，跟不上CPU,致使CPU的绝大部分时间都在测试I/O设备是否已经完成数据传输，从而造成CPU的极大浪费。 中断控制方式 为了减少程序直接控制方式中的CPU等待时间，提高CPU与设备的并行工作程度，现代计算机系统中广泛采用中断控制方式对I/O设备进行控制。如图5-2b所示，以数据输入为例，当用户进程需要数据时，由CPU向设备控制器发出启动指令启动外设输入数据。在输入数据的同时，CPU可以做其他工作。当输入完成时，设备控制器向CPU发出一个中断信号,CPU接收到中断信号之后,转去执行设备中断处理程序。设备中断处理程序将输入数据寄存器中的数据传送到某一特定内存单元中，供要求输入的进程使用，然后再启动设备去读下一个数据。 优点。与程序直接控制方式相比，有了中断的硬件支持后，CPU和IO设备间可以并行工作了，CPU只需收到中断信号后处理即可，大大提高了CPU利用率。举一个简单的例子来说，从终端输入一个字符的时间约为100ms， 而将字符送入终端缓冲区的时间小于0.1ms。若采用程序I/O方式，CPU约有99. 9ms的时间处于忙等待中。采用中断驱动方式后，CPU可利用这99.9ms的时间去做其他事情，而仅用0.1ms的时间来处理由控制器发来的中断请求。可见，中断驱动方式可以成百倍地提高CPU的利用率。 缺点。这种控制方式仍然存在一些问题，例如每台设备每输入/输出一个数据，都要求中断CPU,这样在一次数据传送过程中的中断次数过多，从而耗费了大量CPU时间。 中断处理程序的处理过程(仅指I/O完成时发出的中断)如下。 1)唤醒被阻塞的驱动(程序)进程:可能用signal操作或发送信号来唤醒被阻塞的驱动(程序)进程。 2)保护被中断进程的CPU环境:将处理器状态字PSW和程序计数器PC压入栈中加以保存，其他需要被压入栈中保护的还有CPU的寄存器等，这些都是由硬件完成的。 3)转入想要的设备处理程序:测试中断源以确定引起中断的设备号。 4)中断处理:针对该设备调用相应的中断处理程序。 5)恢复被中断进程的现场:把当时压入栈保护的寄存器等数据弹出，恢复当时的CPU执行的上下文。 ★注:这里的I/O中断和计算机组成原理中介绍的中断并非一回事， 计算机组成原理中介绍的中断是广义的中断，包含所有原因引起的中断,这里的中断仅指由输入/输出引起的中断。 DMA控制方式 DMA控制方式的基本思想是在外设和内存之间开辟直接的数据交换通路。在DMA控制方式中，设备控制器具有更强的功能，在其控制下，设备和内存之间可以成批地进行数据交换，而不用CPU干预。这样既大大减轻了CPU的负担，也使I/O数据传输速度大大提高。这种方式一般用于块设备的数据传输。 如图5-2c所示，仍然以数据输入为例，当用户进程需要数据时，CPU将准备存放输入数据的内存起始地址以及要传送的字节数分别送入DMA控制器中的内存地址寄存器和传送字节计数器中，并启动设备开始进行数据输入。在输入数据的同时，CPU可以去做其他事情。输入设备不断地挪用CPU工作周期，将数据寄存器中的数据源源不断地写入内存，直到要求传送的数据全部传输完毕。DMA控制器在传输完毕时向CPU发送一个中断信号，CPU收到中断信号后转中断处理程序执行，中断结束后返回被中断程序。 DMA控制方式的特点为:数据传输的基本单位是数据块;数据是单向传输，且从设备直接送入内存或者相反;仅在传送一个或多 个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的。 DMA控制方式与中断控制方式的主要区别是:中断控制方式在每个数据传送完成后中断CPU,而DMA控制方式则是在所要求传送的一批数据 全部传送结束时才中断CPU;中断控制方式的数据传送是在中断处理时由CPU控制完成，而DMA控制方式则是在DMA控制器的控制下完成。 DMA控制器的组成如图5-3所示。 DMA控制器中主要包括4类寄存器，用于主机和控制器之间成块数据的交换。 1)命令/状态寄存器(CR): 用于接收从CPU发来的IO命令或有关控制信息，或设备的状态。 2)内存地址寄存器(MAR):用于存放数据从设备传送到内存或从内存到设备的内存地址。 3)数据寄存器(DR):用于暂存从设备到内存或从内存到设备的数据。 4)数据计数器(DC);存放本次要传送的字数。 优点。 DMA控制方式下，设备和CPU可以并行工作，同时设备与内存的数据交换速度加快，并且不需要CPU干预。 缺点。 DMA控制方式仍然存在一定局限性，如数据传送的方向、存放输入数据的内存起始地址及传送数据的长度等都由CPU控制，并且每台设备都需要一个DMA控制器，当设备增加时，多个DMA控制器的使用也不经济。 通道控制方式 通道控制方式与DMA控制方式类似，也是一种以内存为中心，实现设备与内存直接交换数据的控制方式。与DMA控制方式相比，通道所需要的CPU干预更少，而且可以做到一个通道控制多台设备，从而进一步减轻了CPU负担。通道本质上是一个简单的处理器，它独立于CPU,有运算和控制逻辑，有自己的指令系统，也在程序控制下工作，专门负责输入、输出控制，具有执行I/O指令的能力，并通过执行通道I/O程序来控制IO操作。与CPU不同的是，通道的指令类型单一,这是由于通道硬件比较简单，其所能执行的命令主要局限于与I/O操作有关的指令;再就是通道没有自己的内存，通道所执行的通道程序是放在主机的内存中的，换言之，是通道与CPU共享内存。根据信息交换方式的不同，通道可以被分成字节多路通道、数组选择通道和数组多路通道。 字节多路通道 字节多路通道用于连接多个慢速的和中速的设备，这些设备的数据传送以字节为单位。每传送一个字节要等待较长时间，如终端设备等。因此，通道可以以字节交叉方式轮流为多个外设服务，以提高通道的利用率。这种通道的数据宽度一般为单字节。 图5-4给出了字节多路通道的工作原理。 数组选择通道 字节多路通道不适于连接高速设备，这推动了按数组方式进行数据传送的数组选择通道的形成。这种通道虽然可以连接多台高速设备，但由于它只含有一个分配型子通道，在一段时间内只能执行一道通道程序，控制一台设备进行数据传送，致使当某台设备占用了该通道后，便一直由它独占，即使是它无数据传送，通道被闲置，也不允许其他设备使用该通道，直至该设备传送完毕释放该通道。可见，这种通道的利用率很低。 数组多路通道 数组选择通道虽有很高的传输速率，但它却每次只允许一个设备传输数据。数组多路通道是将数组选择通道传输速率高和字节多路通道能使各子通道(设备)分时并行操作的优点相结合而形成的一种新通道。它含有多个非分配型子通道，因而这种通道既具有很高的数据传输速率，又能获得令人满意的通道利用率。也正因此，才使该通道能广泛地用于连接多台高、中速的外围设备，其数据传送是按数组方式进行的。 I/O通道方式是对DMA方式的发展，它进一步使CPU参与到数据传输的控制减少，即把对一个数据块的读(或写)为单位的干预，减少为对一组数据块的读(或写)及有关的控制和管理为单位的干预。同时，又可实现CPU、通道和I/O设备的并行操作，从而更有效地提高整个系统的资源利用率，如图5-5所示。 在通道控制方式中，CPU只需发出启动指令，指出要求通道执行的操作和使用的I/O设备，该指令就可以启动通道并使该通道从内存中调出相应的通道程序执行。以数据输入为例，当用户进程需要数据时，CPU发出启动指令指明要执行的I/O操作、所使用的设备和通道。当对应通道接收到CPU发来的启动指令后，把存放在内存中的通道程序读出，并执行通道程序，控制设备将数据传送到内存中指定的区域。在设备进行输入的同时，CPU可以去做其他工作。当数据传送结束时，设备控制器向CPU发送一个中断请求。CPU收到中断请求后转中断处理程序执行，中断结束后返回被中断程序。 优点。通道控","date":"2021-11-30 18:26:58","objectID":"https://qizhengzou.github.io/operatingsystem_base_05/:1:2","tags":["operating system"],"title":"OperatingSystem_base_05","uri":"https://qizhengzou.github.io/operatingsystem_base_05/"},{"categories":["School courses"],"content":"I/O软件层次结构 I/O软件设计的基本思想是将设备管理软件组织成一种层次结构。其中低层软件与硬件相关，用来屏蔽硬件的具体细节;而高层软件则为用户提供一个友好的、清晰而统一的接口。I/O设备管理软件一般分为4层:中断处理程序、设备驱动程序、设备独立性软件和用户层软件。 层次结构概述 图5-6总结了I/O软件的层次结构及每一层的主要功能。 图5-6中的箭头表示I/O控制流，例如，当用户程序要从文件中读一个数据块时，需要通过操作系统来执行此操作。设备独立性软件首先在高速缓存中查找此数据块，若未找到，则调用设备驱动程序向硬件发出相应的请求，用户进程随即阻塞直到数据块被读出。当磁盘操作完成时，硬件产生一个中断，并转入中断处理程序。中断处理程序检查中断的原因，并从设备中获取所需的信息，然后唤醒睡眠的进程以结束此次I/O请求，使用户进程继续执行。 中断处理程序 中断处理是控制输入/输出设备和内存与CPU之间的数据传送的主要方式。中断与硬件相关，I/O设备的中断服务程序的代码与任何进程无关。当完成I/O操作时，设备便向CPU发送一个中断信号，CPU响应中断后便转入中断处理程序。中断过程如下: ①唤醒被阻塞的驱动程序进程; ②保护被中断进程的CPU环境; ③分析中断原因; ④进行中断处理; ⑤恢复被中断进程的现场。 这里的中断是指所有中断，而非设备中断一种，因此对于设备中断的处理不仅仅在这一层，而是经过其他层次处理后转入这层，向CPU发送中断信号转入中断处理程序的。 设备驱动程序 所有与设备相关的代码放在设备驱动程序中，由于设备驱动程序与设备密切相关，因此应为每一类设备配置一个驱动程序。 设备驱动程序的任务是接受来自上层的设备独立性软件的抽象请求，将这些请求转换成设备控制器可以接受的具体命令，再将这些命令发送给设备控制器，并监督这些命令正确执行。若请求到来时设备驱动程序是空闲的，则立即开始执行这个请求;若设备驱动程序正在执行一个请求，则将新到来的请求插入等待队列中。设备驱动程序是操作系统中唯一知道设备控制器中设置了多少个寄存器以及这些寄存器有何用途的程序。 设备驱动程序的处理过程: ①将抽象要求转换为具体要求; ②检查I/O请求的合法性; ③读出和检查设备的状态;④传送必要参数; ⑤设置工作方式; ⑥启动IO设备。 设备独立性软件 虽然I/O软件中的一部分(如设备驱动程序)与设备相关，但大部分软件是与设备无关的。至于设备驱动程序与设备独立性软件之间的界限，则随操作系统的不同而不同，具体划分原则取决于系统的设计者怎样权衡系统与设备的独立性、设备驱动程序的运行效率等诸多因素。对于一些按照设备独立方式实现的功能，出于效率和其他方面的考虑，也可以由设备驱动程序实现。 设备独立性软件的基本任务是:实现一般设备都需要的I0功能，并向用户空间软件提供一个统一的接口。设备独立性软件通常应实现的功能包括设备驱动程序的统一接口，设备命名，设备保护，提供与设备无关的逻辑块，缓冲、存储设备的块分配，独占设备的分配和释放，出错处理。 用户层软件 一般来说，大部分I/O软件都包含在操作系统中，但仍有一部分是由与用户程序链接在一起的库函数，甚至运行于内核之外的程序构成的。通常的系统调用包括I/O系统调用，是由库函数实现的。SPOOLing 系统也处于这一层上。 ","date":"2021-11-30 18:26:58","objectID":"https://qizhengzou.github.io/operatingsystem_base_05/:1:3","tags":["operating system"],"title":"OperatingSystem_base_05","uri":"https://qizhengzou.github.io/operatingsystem_base_05/"},{"categories":["School courses"],"content":"I/O核心子系统 I/O核心子系统是设备控制的各类方法，其提供的服务主要有I/O调度、高速缓存与缓冲区、设备分配与回收、假脱机技术等。 ","date":"2021-11-30 18:26:58","objectID":"https://qizhengzou.github.io/operatingsystem_base_05/:2:0","tags":["operating system"],"title":"OperatingSystem_base_05","uri":"https://qizhengzou.github.io/operatingsystem_base_05/"},{"categories":["School courses"],"content":"I/O 调度概念 I/O调度就是确定一个好的顺序来执行I/O请求。应用程序所发布系统调用的顺序不一定总是最佳选择，所以需要通过IO调度来改善系统的整体性能，使进程间公平地共享设备访问，减少I/O完成所需要的平均等待时间。 操作系统通过为每个设备维护一个请求队列来实现调度。当一个应用程序执行阻塞I/O系统调用时，该请求就被加到相应设备的队列上。I/O调度重新安排队列顺序以改善系统总体效率和应用程序的平均响应时间。 I/O子系统改善计算机效率的方法包括I/O调度和使用主存或磁盘上的存储空间技术，如缓冲、高速缓存和假脱机等。 ","date":"2021-11-30 18:26:58","objectID":"https://qizhengzou.github.io/operatingsystem_base_05/:2:1","tags":["operating system"],"title":"OperatingSystem_base_05","uri":"https://qizhengzou.github.io/operatingsystem_base_05/"},{"categories":["School courses"],"content":"高速缓存与缓冲区 提高处理器与外设并行程度的另一项技术就是缓冲技术。 缓冲的引入 虽然中断、DMA和通道控制技术使得系统中设备和设备、设备和CPU得以并行运行，但是设备和CPU处理速度不匹配的问题是客观存在的，这个问题制约了计算机系统性能的进一步提高。例如，当用户进程一边计算一边输出数据时，若没有设置缓冲，则进程输出数据时，必然会因打印机的打印速度大大低于CPU输出数据的速度，而使CPU停下来等待;反之，在用户进程进行计算时，打印机又会因无数据输出而空闲等待。若设置一个缓冲区，则用户进程可以将数据先输出到缓冲区中，然后继续执行;打印机则可以从缓冲区取出数据慢慢打印，而不会影响用户进程的运行。因此，缓冲区的引入缓和了CPU与设备速度不匹配的矛盾，提高了设备和CPU的并行操作程度，提高了系统吞吐量和设备利用率。此外，引入缓冲后可以降低设备对CPU的中断频率,放宽对中断响应时间的限制。例如，假设某设备在没有设置缓冲区之前每传输一个字节中断CPU-I次，若在设备控制器中增设一个100B的缓冲区，则设备控制器要等到存放100个字符的缓冲区装满以后才发出一次中断，从而使设备控制器对CPU的中断频率降低到原来的1/100。 缓冲的实现方法有两种: 一种是采用硬件缓冲器实现，但由于其成本太高，除一些关键部位外，一般情况下不采用; 另一种是在内存划出一块存储区，专门用来临时存放输入/输出数据，这个区域称为缓冲区。 缓冲的分类 根据系统设置的缓冲区个数，缓冲技术可以分为单缓冲、双缓冲、循环缓冲和缓冲池。 (1)单缓冲 单缓冲是操作系统提供的一种 最简单的缓冲形式，其工作方式如图5-7a所示。当用户进程发出一个I/O请求时，操作系统便在内存中为它分配一个缓冲区。由于只设置了一个缓冲区，设备和处理器交换数据时，应先把要交换的数据写入缓冲区，然后由需要数据的设备或处理器从缓冲区取走数据，因此设备与处理器对缓冲区的操作是串行的。 在块设备输入时，先从磁盘把一块数据输 入到缓冲区，假设所用时间为t;然后由操作系统将缓冲区的数据传送到用户区,假设所用时间为m;接下来，CPU对这一块数据进行计算,假设计算时间为c;则系统对每一块数据的处理时 间为max(c, t)+m (通常m远小于t或c)。若没有缓冲区，数据将直接进入用户区,则每块数据的处理时间为tc。在块设备输出时，先将要输入的数据从用户区复制到缓冲区，然后再将缓冲区中的数据写到设备。在字符设备输入时，缓冲区用于暂存用户输入的一行数据。在输入时，用户进程阻塞以等待一行数据输入完毕;在输出时，用户进程将一行数据送入缓冲区后继续执行计算。当用户进程已有第二行数据要输出时，若第二行数据尚未输出完毕，则用户进程阻塞。 (2)双缓冲 引入双缓冲(见图5-7b)可以提高处理器与设备的并行操作程度。在块设备输入时，输入设备先将第一个缓冲区装满数据，在输入设备装填第二个缓冲区的同时，操作系统可以将第一个缓冲区的数据传送到用户区供处理器进行计算;当第一个缓冲区中的数据处理完后，若第二个缓冲区已经装满，则处理器又可以处理第二个缓冲区的数据，而输入设备又可以装填第一个缓冲区。显然，双缓冲的使用提高了处理器和输入设备并行操作的程度。只有当两个缓冲区都为空，进程还要提取数据时，该进程阻塞。采用双缓冲时，系统处理一块数据的时间可以估计为max(c,t)。若c \u003c t,则可使块设备连续输入;若c \u003e t,则可使处理器连续计算。 在字符设备输入时，若采用行输入方式和双缓冲，则用户在输入完第一行后， CPU执行第一行中的命令，而用户可以继续向第二个缓冲区中输入下一行数据，因此用户进程一般不会阻塞。 (3)循环缓冲 双缓冲方案在设备输入/输出速度与处理器处理数据速度基本匹配时能获得较好的效果，但若两者速度相差甚远，双缓冲的效果则不够理想。为此引入了循环缓冲技术，如图5-7c所示。 循环缓冲包含多个大小相等的缓冲区，每个缓冲区中有一个链接指针指向下一个缓冲区，最后一个缓冲区的指针指向第一个缓冲区， 这样多个缓冲区构成一个环形。 循环缓冲用于输入/输出时，还需要有两个指针in和out。对于输入而言，首先要从设备接收数据到缓冲区中，in指针指向可以输入数据的第一个空缓冲区; 当用户进程需要数据时，从循环缓冲中取出一个装满数据的缓冲区，提取数据，out指针指向可以提取数据的第一个满缓冲区。显然，对输出而言正好相反，进程将处理过的需要输出的数据送到空缓冲区中，而当设备空闲时，从满缓冲区中取出数据由设备输出。 (4)缓冲池 循环缓冲一般适用于特定的I/O 进程和计算进程，因而当系统中进程很多时将会有许多这样的缓冲，这不仅要消耗大量的内存空间，而且利用率不高。目前，计算机系统中广泛使用缓冲池，缓冲池由多个缓冲区组成，其中的缓冲区可供多个进程共享，并且既能用于输入又能用于输出，如图5-8 所示。缓冲池中的缓冲区按其使用状况可以形成以下3个队列。 空缓冲队列。 装满输入数据的缓冲队列(输入队列)。 装满输出数据的缓冲队列(输出队列)。 除上述3个队列之外，还应具有以下4种工作缓冲区。 用于收容输入数据的工作缓冲区。 用于提取输入数据的工作缓冲区。 用于收容输出数据的工作缓冲区。 用于提取输出数据的工作缓冲区。 当输入进程需要输入数据时，便从空缓冲队列的队首摘下一个空缓冲区，把其作为收容输入数据的工作缓冲区，然后把数据输入其中，装满后再将它挂到输入队列队尾。当计算进程需要输入数据时，便从输入队列取得一个缓冲区作为提取输入数据的工作缓冲区，计算进程从中提取数据，数据用完后再将其挂到空缓冲队列队尾。当计算进程需要输出数据时，便从空缓冲队列的队首取得一个空缓冲区，作为收容输出数据的工作缓冲区，当其中装满输出数据后，再将其挂到输出队列队尾。当要输出时，由输出进程从输出队列中取得一个装满输出数据的缓冲区，作为提取输出数据的工作缓冲区，当数据提取完后，再将其挂到空缓冲队列的末尾。 高速缓存与缓冲区 高速缓存是可以保存数据备份的高速存储器。访问高速缓存要比访问原始数据更高效,速度更快。虽然高速缓存和缓冲区均介于一个高速设备和一个低速 设备之间，但高速缓存并不等价于缓冲区，它们之间有着很大的区别。 两者存放的数据不同。 高速缓存上放的是低速设备上的某些数据的一个备份，也就是说，高速缓存，上有的数据，低速设备.上必然有;而缓冲区中放的则是低速设备传递给高速设备的数据，这些数据从低速设备传递到缓冲区中，然后再从缓冲区送到高速设备，而在低速设备中却不一定有备份。 两者的目的不同。引入高速缓存是为了存放低速设备上经常要被访问到的数据的备份，这样一来，高速设备就不需要每次都访问低速设备，但是如果要访问的数据不在高速缓存中，那么高速设备还是需要访问低速设备;而缓冲区是为了缓和高速设备和低速设备间速度不匹配的矛盾，高速设备和低速设备间通信每次都要经过缓冲区，高速设备不会直接去访问低速设备。 ","date":"2021-11-30 18:26:58","objectID":"https://qizhengzou.github.io/operatingsystem_base_05/:2:2","tags":["operating system"],"title":"OperatingSystem_base_05","uri":"https://qizhengzou.github.io/operatingsystem_base_05/"},{"categories":["School courses"],"content":"设备分配与回收 设备分配是设备管理的功能之一，当进程向系统提出I/O请求之后，设备分配程序将按照一定的分配策略为其分配所需设备，同时还要分配相应的设备控制器和通道，以保证CPU和设备之间的通信。 设备管理中的数据结构 为了实现对I/O设备的管理和控制，需要对每台设备、通道、设备控制器的有关情况进行记录。设备分配依据的主要数据结构有设备控制表(DCT)、 设备控制器控制表(COCT),通道控制表(CHCT)和系统设备表(SDT)。不仅设备要控制表，控制器也要控制表，而且控制控制器的通道也要控制表，同时，作为最终资源的设备也要有个表，就是系统设备表。 DCT。系统为每一个设备配置-张设备控制表，用于记录设备的特性以及IO控制器的连接情况。设备控制表中包含的项目如图5-9所示。其中，设备状态用来指示设备当前状态(忙/闲)，设备等待队列指针指向等待使用该设备的进程组成的等待队列，控制器控制表(COCT)指针指向与该设备相连接的设备控制器。 COCT。每个控制器都配有这样一张控制器控制表，用于反映设备控制器的使用状态以及和通道的连接情况等。 CHCT。每个通道同样配有这样一张通道控制表， 用于反映通道的状态等。 SDT。整个系统只有一张系统设备表，它记录了已连接到系统中的所有物理设备的情况，每个物理设备占用一个表目。SDT的每个表目包括设备类型、设备标识符、设备控制表指针等信息。其中，设备控制表(DCT)指针指向该设备对应的设备控制表。 设备分配策略 在计算机系统中，请求设备为其服务的进程数往往多于设备数，这样就出现了多个进程对某类设备的竞争问题。为了保证系统有条不紊地工作，系统在进行设备分配时应考虑以下问题。 (1)设备的使用性质 在分配设备时，系统应考虑设备的使用性质。例如，有的设备在–段时间内只能给一个进程使用，而有的设备可以被多个进程共享。按照设备自身的使用性质，设备分配可以采用以下3种不同的方式。 独享设备。又称为独占设备，应采用独享分配方式，即在将一个设备分配给某进程后便一直由其独占，直至该进程完成或释放设备后，系统才能再将设备分配给其他进程，如打印机就不能被多个进程共享，而应采取独享分配方式。实际上，大多数低速设备都适合采用这种分配方式:其主要缺点是I/O设备通常得不到充分利用。 共享分配。对于共享设备，系统可将其同时分配给多个进程使用，如磁盘是一种共享设备，因此可以被分配给多个进程使用。共享分配方式显著提高了设备利用率，但对设备的访问需要进行合理调度。 虚拟分配。虚拟分配是针对虚拟设备而言的，当进程申请独享设备时，系统给它分配共享设备.上的一部分存储空间;当进程要与设备交换信息时，系统就把要交换的信息存放在这部分存储空间中;在适当的时候，将设备上的信息传输到存储空间中或将存储空间中的信息传送到设备。 (2)设备分配算法 设备分配除了与设备的使用性质相关外，还与系统所采用的分配算法有关。设备分配中主要采用先来先服务和优先级高者优先两种算法。 先来先服务。 根据请求的时间顺序构成队列，总是把设备优先分配给队首进程。 优先级高者优先。按照优先级的高低进行设备分配，若优先级相同，则按照先来先服务算法进行分配。 (3)设备分配的安全性 所谓设备分配的安全性，是指在设备分配中应保证不发生进程的死锁。在进行设备分配时，可采用静态分配方式和动态分配方式。静态分配是指在用户作业开始执行之前，由系统一次性分配该作业所需要的所有设备、设备控制器和通道，一旦分配，则一直占用，直至作业撤销。静态分配虽然不会出现死锁，但设备使用效率较低。 动态分配是在进程执行过程中根据执行需要进行设备分配。在进程需要设备时申请，用完后立即释放。动态分配方式有利于提高设备的利用率，但如果分配算法不当，则可能造成死锁。 设备的动态分配方式分为安全分配和不安全分配。 在安全分配方式中，每当进程发出IO请求后就进入阻塞状态，直到IO完成才被唤醒。这种分配方式摒弃了“请求和保持条件”。不会发生死锁，但进程推进缓慢。 在不安全分配方式中，允许进程发出I/O请求后仍然运行，且可以继续发出I/0请求，因此可能出现一个进程同时操作多个设备的情况，从而使得进程推进迅速，但有可能发生死锁，所以需要在分配设备前进行安全性检测。 设备独立性 设备独立性是指应用程序独立于具体使用的物理设备，它可以提高设备分配的灵活性和设备的利用率。为了提高操作系统的可适应性和可扩展性，现代操作系统毫无例外地实现了设备独立性(又称设备无关性)。 为了实现设备独立性，引入了逻辑设备和物理设备这两个概念，而系统中需要设置一张逻辑设备表(LUT),其中每个表项中都有逻辑设备名、物理设备名和设备驱动程字入口地址。在应用程序中，使用逻辑设备名来请求使用某类设备，而系统为这个进程分配的逻辑设备对应一个物理设备和设备驱动程序入口地址，这些信息都被放在逻辑设备表的一项中，以后该进程通过逻辑设备名来请求I/0操作时，就可以找到对应的物理设备和驱动程序入口地址。 设备独立性带来的好处有:设备分配时的灵活性和易于实现I/0重定向。为了实现设备独立性，必须在设备驱动程序之上设置一层设备独立性软件，用来执行所有I/O设备的公用操作，并向用户层软件提供统一接口。 关键是系统中必须设置一张逻辑设备表用来进行逻辑设备到物理设备的映射，其中每个表目中包含了逻辑设备名、物理设备名和设备驱动程序入口地址3项;当应用程序用逻辑设备名请求分配I/0设备时，系统必须为它分配相应的物理设备，并在LUT中建立一个表目，以后进程利用该逻辑设备名请求I/0操作时，便可从LUT中得到物理设备名和驱动程序入口地址。 操作系统实现设备独立性的方法包括设置设备独立性软件、配置逻辑设备表以及实现逻辑设备到物理设备的映射。 设备分配程序 (1)单通路I/O系统的设备分配 当某一进程提出I/O 请求后，系统的设备分配程序可以按照下述步骤进行设备分配:分配设备-\u003e分配设备控制器-\u003e分配通道。在分配时，如遇到对应设备忙的情况，则将进程插入到对应的等待队列中。 (2)多通路I/0系统的设备分配 为了提高系统灵活性，通常采用多通路I/0系统结构，即一个设备与多个设备控制器相连，设备控制器也与多个通道相连。当进程提出I0请求时，系统可选择将该类设备中的任何一台设备分配给该进程，步骤如下。 1)根据设备类型，检索系统设备控制表，找到第一个空闲设备，并检测分配的安全性，如安全，则分配;反之，插入该类设备的等待队列。 2)设备分配后，检索设备控制器控制表，找到第一个与已分配设备相连的空闲设备控制器，若无空闲，则返回步骤1)查找下一个空闲设备。 3)设备控制器分配后，同样查找与其相连的通道，找到第–个空闲通道，若无空闲通道，则返回步骤2)查找下一个空闲设备控制器。若有空闲通道，则此次设备分配成功，将相应的设备、设备控制器和通道分配给进程，并启动IO设备，开始信息传输。 设备的回收 当进程使用完对应的I/O设备后，释放所占有设备、设备控制器及通道，系统进行回收，修改对应的数据结构，以便下次分配时使用。 ","date":"2021-11-30 18:26:58","objectID":"https://qizhengzou.github.io/operatingsystem_base_05/:2:3","tags":["operating system"],"title":"OperatingSystem_base_05","uri":"https://qizhengzou.github.io/operatingsystem_base_05/"},{"categories":["School courses"],"content":"假脱机技术(SPOOLing) 系统中独占设备的数量有限，往往不能满足系统中多个进程的需要,从而成为系统的\"瓶颈”，使许多进程因等待而阻塞。另外，分配到独占设备的进程，在整个运行期间往往占有但不经常使用设备，使设备利用率偏低。为克服这种缺点，人们通过共享设备来虚拟独占设备，将独占设备改造成共享设备，从而提高了设备利用率和系统的效率，该技术称为假脱机(SPOOLing)技术。 SPOOLing的意思是同时外设联机操作(Simultaneous Peripheral Operating On-Line)，又称为假脱机输入/输出操作。SPOOLing 技术实际上是-种外设同时联机操作技术，也称为排队转储技术。SPOOLing 系统不同于脱机方式，其系统组成如图5-10所示。 SPOOLing技术是低速输入/输出设备与主机交换的一种技术， 其核心思想是以联机的方 式得到脱机的效果。低速设备经通道和设在主机内存的缓冲存储器与高速设备相连，该高速 设备通常是辅存。为了存放从低速设备上输入的信息，在内存中形成缓冲区，在高速设备上 形成输出井和输入井，传递时信息从低速设各传入缓冲区，再传到高速设备的输入井，再从 高速设备的输出井传到缓冲区，再传到低速设备。 SPOOLing 系统的组成 (1)输入井和输出井 输入井和输出井是在磁盘上开辟出来的两个存储区域。输入井模拟脱机输入时的磁盘，用于收容I/0设备输入的数据。输出井模拟脱机输出时的磁盘，用于收容用户程序的输出数据。 (2)输入缓冲区和输出缓冲区 输入缓冲区和输出缓冲区是在内存中开辟的两个缓冲区。输入缓冲区用于暂存由输入设备传递过来的数据，然后再传送到输入井。输出缓冲区用于暂存从输出井传递过来的数据,然后再传送到输出设备。 (3)输入进程和输出进程 输入进程模拟脱机输入时的外围控制机，将用户要求的数据从输入设备通过输入缓冲区再传递到输入井。当需要输入数据时，CPU直接将数据从输入井读入内存。输出进程模拟脱机输出时的外围控制机，把用户要求输出的数据先从内存送到输出井,等输出设备空闲时，再将输出井中的数据经过输出缓冲区送到输出设备上。 SPOOLing系统在输入和输出之间增加了“输入井”和“输出井”的排队转储环节，以消除用户的“联机”等待时间。在系统收到作业输入请求信号后，输入进程负责将信息从输入设备中读入输入缓冲区。当缓冲区满时，将信息从缓冲区写到磁盘的输入井中，反复循环，直到一个作业输入完毕。当输入进程读到一个硬件结束标志之后，系统把最后一批信息写入磁盘输入井并调用中断处理程序结束该次输入。然后系统为该作业建立作业控制块，从而使输入井中的作业进入作业等待队列，等待作业调度程序选中后进入内存运行。系统在管理输入井过程中可以“不断”读进输入的作业，直到输入结束或输入井满而暂停。输出过程与此类似。 将一台独享打印机改造为可供多个用户共享的打印机,是应用SPOOLing技术的典型实例。具体做法是:系统对于用户的打印输出，并不真正把打印机分配给该用户进程，而是先在输出井中申请一个空闲盘块区，并将要打印的数据送入其中;然后为用户申请并填写请求打印表，将该表挂到请求打印队列上。若打印机空闲，输出程序从请求打印队首取表，将要打印的数据从输出井传送到内存缓冲区，再进行打印，直到打印队列为空。 SPOOLing技术的特点 提高了IO速度。从对低速I0设备进行的操作变为对输入井或输出井的操作，如同脱机操作一样，提高了IO速度，缓和了CPU与低速I/O设备速度不匹配的矛盾。 设备并没有分配给任何进程。在输入井或输出井中，分配给进程的是一个存储区和 建立一张IO请求表。 实现了虚拟设备功能。多个进程同时使用一个独享设备，而对每一进程而言，都认为自已独占这一设备，从而实现了设备的虛拟分配。不过，该设备是逻辑上的设备。 SPOOLing除了是一种速度匹配技术外，也是一种虚拟设备技术。它用一种物理设备模拟另一类物理设备，使各作业在执行期间只使用虚拟的设备，而不直接使用物理的独占设备。这种技术可使独占的设备变成可共享的设备，使得设备的利用率和系统效率都能得到提高。 ","date":"2021-11-30 18:26:58","objectID":"https://qizhengzou.github.io/operatingsystem_base_05/:2:4","tags":["operating system"],"title":"OperatingSystem_base_05","uri":"https://qizhengzou.github.io/operatingsystem_base_05/"},{"categories":["School courses"],"content":"习题 ","date":"2021-11-30 18:26:58","objectID":"https://qizhengzou.github.io/operatingsystem_base_05/:3:0","tags":["operating system"],"title":"OperatingSystem_base_05","uri":"https://qizhengzou.github.io/operatingsystem_base_05/"},{"categories":["School courses"],"content":" 王道考研操作系统笔记 文件管理 ","date":"2021-11-30 18:26:50","objectID":"https://qizhengzou.github.io/operatingsystem_base_04/:0:0","tags":["operating system"],"title":"OperatingSystem_base_04","uri":"https://qizhengzou.github.io/operatingsystem_base_04/"},{"categories":["School courses"],"content":"文件系统基础 ","date":"2021-11-30 18:26:50","objectID":"https://qizhengzou.github.io/operatingsystem_base_04/:1:0","tags":["operating system"],"title":"OperatingSystem_base_04","uri":"https://qizhengzou.github.io/operatingsystem_base_04/"},{"categories":["School courses"],"content":"文件的概念 文件的概念 数据处理是计算机的主要功能之一， 与数据处理相关的数据管理和数据保存是必不可少的，甚至是较为重要的环节。在计算机中，大量的数据和信息是通过文件存储和管理的。在用户进行的输入、输出中，以文件为基本单位。文件系统负责管理文件，并为用户提供对文件进行存取、共享及保护的方法。文件是具有文件名的一组相关元素的集合，在文件系统中是一个最大的数据单位，它描述了一个对象集，每个文件都有一个文件名，用户通过文件名来访问文件。在此对文件的组成结构进行自底向上的介绍。 数据项。数据项是文件系统中最低级的数据组织形式，可分为以下两种类型。基本数据项:用于描述一个对象的某种属性的一个值，如姓名、日期或证件号等，是数据中可命名的最小逻辑数据单位，即原子数据。组合数据项:由多个基本数据项组成。 记录。 记录是一组相关的数据项的集合，用于描述一个对象在某方面的属性，如一个考生报名记录包括考生姓名、出生日期、报考学校代号、身份证号等-系列域。 文件。 文件是指由创建者所定义的一组相关信息的集合，逻辑上可分为有结构文件和无结构文件两种。在有结构文件中，文件由一组相似记录组成，如报考某学校的所有考生的报考信息记录，又称记录式文件;而无结构文件则被看成是一个字符流，如一个二进制文件或字符文件，又称流式文件。文件表示的范围很广，系统或用户可以将具有一定功能的程序或数据集合命名为-个文 件。例如，一个命名的源程序、目标程序、一批数据以及系统程序都可以看作文件。在有的操作系统中，设备也被看作一种特殊的文件。这样，系统可以对设备和文件实施统一管理，既简化了系统设计，又方便了用户。 文件的属性 文件有一定的属性，根据系统的不同而有所不同，但通常都包括如下属性。 名称。 文件名唯一，以容易读取的形式保存。 标识符。 系统内文件的唯一标签， 通常为数字，对用户来说是透明的。 文件类型。 被支持不同类型的文件系统所使用。 文件位置。指向文件的指针。 文件的大小、 建立时间、用户标识等。 文件的分类 为了便于管理和控制文件，通常将文件分为若干类型。文件分类方法有很多，这里介绍常见的几种。 (1)按照用途分类可以将文件分为如下3类。 系统文件。 由系统软件构成的文件。大多数系统文件只允许用户调用执行，而不允许用户去读或修改。 库文件。 由系统提供给用户使用的各种标准过程、函数和应用程序文件。这类文件允许用户调用执行，但同样不允许用户修改。 用户文件。 用户委托文件系统保存的文件，如源程序、目标程序、原始数据等。这类文件只能由文件所有者或所有者授权用户使用(就算是用户文件，也不可任意访问，这点切记，只有授权用户或文件所有者才可以访问)。 (2)按保护级别分类可以将文件分为以下4类。 只读文件。 只读文件允许所有者或授权用户对文件进行读操作，但不允许写(注意:仍然是授权用户或所有者才可以读，不是任意用户都可以读，下 面的情况相同)。 读写文件。该文件允许所有者或授权用户对文件进行读写，但禁止未核准用户读写。 执行文件。 该文件允许核准用户调用执行，但不允许对文件进行读写(要明确读、写、执行是不同的操作，不要误认为读和执行相同)。不保护文件。不保护文件是指不加任何访问限制的文件。 (3)按信息流向分类可以将文件分为以下3类。 输入文件。如对于读卡机或键盘上的文件，只能进行读入，所以这类文件为输入文件。 输出文件。如对于打印机上的文件，只能进行写出，因此这类文件为输出文件。 输入/输出文件。如对于磁盘、磁带上的文件，既可以读又可以写，所以这类文件是输入/输出文件。 (4)按数据形式分类 源文件。 由源程序和数据构成的文件。通常，由终端或输入设备输入的源程序和数据所形成的文件都属于源文件。源文件一般由ASCII码或者汉字组成。 目标文件。 源文件经过编译以后，但尚未链接的目标代码形成的文件。目标文件属于二进制文件。 可执行文件。编译后的目标代码经链接程序链接后形成的可以运行的文件。 文件的操作 (1)基本的文件操作 创建文件。创建新文件时，系统先要为其分配必要的外存空间，并在目录中建立一个目录项。 删除文件。删除文件时应先删除文件的目录项，使之成为空项，然后回收文件所占的存储空间。 读文件。系统将文件名和文件内存目标地址给文件调用程序，同时查找目录，根据文件的外存地址设置一个读指针，当进行读操作时更新读指针。 写文件。 系统将文件名和文件内存地址传递给文件调用程序，同时查找目录，根据外存地址设置写指针，当进行写操作时更新写指针。 截断文件。当文件内容不再需要或者需要全部更新时，可以将文件删除重新创建;或者保持文件所有属性不变，删除文件内容，即将其长度设为0并释放其空间。 设置文件的读/写位置。通过设置文件的读/写位置，可以使每次对文件操作时不必从文件始端开始，而可以从某个特定位置开始。 (2)文件的打开和关闭操作 打开文件。 系统将文件的属性从外存复制到内存，并设定一个编号(或索引)返回给用户。以后当用户要对该文件进行操作时，只需利用编号(或索引号)向系统提出请求即可。这样避免了系统对文件的再次检索，既节约了检索开销，又提高了对文件的操作速度。每个打开文件都有如下关联信息: ①文件指针。系统跟踪上次读写位置作为当前文件位置指针,这种指针对打开文件的某个进程来说是唯一的， 因此，必须与磁盘文件属性分开保存。 ②文件打开计数。文件关闭时，操作系统必须重用其打开文件表(包含所有打开文件信息的表)条目，否则表内空间会不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条日之前，必须等待最后一个进程关闭文件。该计数器跟踪打开和关闭的数量，当该计数为0时，系统关闭文件，删除该条目。 ③文件磁盘位置。绝大多数文件操作都要求系统修改文件数据。该信息保存在内存中,以免为每个操作都从磁盘中读取。 ④访问权限。每个进程打开文件都需要有一个访问模式(创建、只读、读写、添加等)。该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的IO请求。 关闭文件。 系统将打开的文件的编号(或索引号)删除，并销毁其文件控制块。若文件被修改，则需要将修改保存到外存。 ","date":"2021-11-30 18:26:50","objectID":"https://qizhengzou.github.io/operatingsystem_base_04/:1:1","tags":["operating system"],"title":"OperatingSystem_base_04","uri":"https://qizhengzou.github.io/operatingsystem_base_04/"},{"categories":["School courses"],"content":"文件的逻辑结构：顺序文件、索引文件、索引顺序文件。 文件的逻辑结构和物理结构 文件的逻辑结构是从用户观点来看所观察到的文件的组织形式，是用户可以直接处理的数据及其结构，因其独立于文件的物理特性，故又称为文件组织;而从计算机的角度出发，文件在外存上的存放组织形式称为文件的物理结构。 文件的逻辑结构与存储设备的特性无关，而物理结构与存储设备特性的关系很大。 从逻辑结构上看，文件可以分为两种形式: 一种是有结构的记录式文件;另一种是无结构的流式文件。而记录式文件的逻辑结构通常有顺序、索引和索引顺序。 从物理结构，上看，文件的组织形式有连续分配、链接分配和索引分配。 通常，有结构的文件由若千个记录组成，因此称为记录式文件。记录是一些相关数据项的集合，而数据项是数据组织中可以命名的最小逻辑单位，例如，每个职工情况记录由姓名、性别、出生年月、工资等数据项组成。一个单位的职工情况记录就组成了一个文件。总之, 数据项组成记录，记录组成文件。记录式文件又可以分为等长记录文件和变长记录文件。等长记录文件中的所有记录的长度相等，变长记录文件中的各记录长度可以不相等。无结构文件是由若干个字符组成，可以看作一个字符流，称为流式文件。可以将流式文件看作记录式文件的特例。在UNIX系统中，所有文件都被视为流式文件，系统不对文件进行格式处理。 文件存储设备通常划分为大小相等的物理块，物理块是分配及传输信息的基本单位。物理块的大小与设备有关，但与逻辑记录的大小无关，因此一个物理块中可以存放若千个逻辑记录，一个逻辑记录也可以存放在若干个物理块中。为了有效地利用外存设备和便于系统管理，一般也把文件信息划分为与物理存储块大小相等的逻辑块。记录式文件(即有结构文件)的逻辑结构通常分为顺序、索引和索引顺序结构。 顺序文件 顺序结构又称为连续结构，是一种最简单的文件结构，其将一个逻辑文件的信息连续存放。以顺序结构存放的文件称为顺序文件或连续文件。 按照记录是否定长，顺序文件分为定长记录顺序文件和变长记录顺序文件。按照文件中记录是否按照关键字排序，顺序文件又分为串结构和顺序结构:串结构中各记录之间的顺序与关键字无关，而顺序结构中所有记录按照关键字顺序排序。 顺序文件的主要优点是顺序存取时速度较快;若文件为定长记录文件，还可以根据文件起始地址及记录长度进行随机访问。但因为文件存储要求连续的存储空间，所以会产生碎片,同时也不利于文件的动态扩充。 索引文件 索引结构为一个逻辑文件的信息建立一个索引表。 索引表中的表目存放文件记录的长度和所在逻辑文件的起始位置，因此逻辑文件中不再保存记录的长度信息。索引表本身是一个定长文件，每个逻辑块可以是变长的，索引表和逻辑文件两者构成了索引文件。 索引文件的优点是可以进行随机访问，也易于进行文件的增删。但索引表的使用增加了存储空间的开销，另外，索引表的查找策略对文件系统的效率影响很大。 索引顺序文件 索引顺序文件是顺序文件和索引文件两种形式的结合。索引顺序文件将顺序文件中的所有记录分为若千个组，为顺序文件建立一张索 引表，并为每组中的第一个记录在索引表建立一个索引项，其中含有该记录的关键字和指向该记录的指针。索引表中包含关键字和指针两个数据项，索引表中索引项按照关键字顺序排列。索引顺序文件的逻辑文件(主文件)是一个顺序文件，每个分组内部的关键字不必有序排列，但是组与组之间的关键字是有序排列的。 索引顺序文件大大提高了顺序存取的速度，但是，仍然需要配置一个索引表， 增加了存储开销。 直接文件和散列(Hash)文件 建立关键字和相应记录物理地址之间的对应关系，这样就可以直接通过关键字的值找到记录的物理地址，也就是说，关键字的值决定了记录的物理地址，这种结构的文件称为直接文件。这种映射结构不同于顺序文件或索引文件，没有顺序的特性。 散列文件是一种典型的直接文件。通过散列函数对关键字进行转换，转换结果直接决定记录的物理地址。散列文件有很高的存取速度，但是会因不同关键字的散列函数值相同而引起冲突。 ","date":"2021-11-30 18:26:50","objectID":"https://qizhengzou.github.io/operatingsystem_base_04/:1:2","tags":["operating system"],"title":"OperatingSystem_base_04","uri":"https://qizhengzou.github.io/operatingsystem_base_04/"},{"categories":["School courses"],"content":"目录结构：文件控制块和索引结点、单级目录结构和两级目录结构、树形目录结构、图形目录结构。 文件目录 计算机系统中的文件种类繁多、数量庞大，为了有效管理这些文件，以方便用户查找所需文件，应对它们进行适当的组织。 文件的组织可以通过目录来实现。文件说明的集合称为文件目录。目录最基本的功能就是通过文件名存取文件。一般来说，目录应具有如下几个功能。 实现 “按名存取”。用户只需提供文件名，就可以对文件进行操作。这既是目录管理最基本的功能，也是文件系统向用户提供的最基本的服务。提高检索速度。这就需要在设计文件系统时合理地设计目录结构。对于大型文件系统来说，这是一个很重要的设计目标。 允许文件同名。 为了便于用户按照自己的习惯来命名和使用文件，文件系统应该允许对不同的文件使用相同的名称。这时，文件系统可以通过不同工作目录来对此加以区别。 允许文件共享。在多用户系统中，应该允许多个用户共享一个文件，这样就可以节省文件的存储空间，也可以方便用户共享文件资源。当然，还需要采用相应的安全措施，以保证不同权限的用户只能取得相应的文件操作权限，防止越权行为。 通常，文件目录也作为一个文件来处理，称为目录文件。由于文件系统中一般有很多文件，文件目录也很大，因此文件目录并不放在主存中，而是放在外存中。 文件控制块和索引结点 (1)文件控制块 从文件管理的角度看，文件由文件控制块(File Control Block, FCB) 和文件体两部分组成。文件体即文件本身，而文件控制块(又称为文件说明)则是保存文件属性信息的数据结构，它包含的具体内容因操作系统而异，但至少应包含以下信息。 文件名。 该信息用于标识一个文件的符号名。每个文件必须具有唯一的名字，这样用户可以按照文件名进行文件操作。 文件的结构。 该信息用于说明文件的逻辑结构是记录式文件还是流式文件，若为记录式文件还需进一步说明记录是否定长、记录长度及个数;说明文件的物理结构是顺序文件、索引顺序文件还是索引文件。 文件的物理位置。 该信息用于指示文件在外存上的存储位置，包括存放文件的设备名，文件在外存的存储地址以及文件长度等。文件物理地址的形式取决于物理结构，如对于连续文件应给出文件第一块的物理地址及所占块数，对于索引顺序文件只需给出第一块的物理地址，而索引文件则应给出索引表地址。 存取控制信息。 该信息用于指示文件的存取权限，包括文件拥有者(也称为文件主)的存储权限以及文件主同组用户的权限和其他一般用户的权限。 管理信息。 该信息包括文件建立的日期及时间、上次存取文件的日期和时间以及当前文件使用状态的信息。 (2)索引结点 在检索目录文件的过程中，只用到了文件名，仅当找到匹配目录项时，才需要从该目录项中读出该文件的物理地址。也就是说，在检索目录时，文件的其他描述信息是不会被用到的，因而也不需要调入内存。因此，有些系统采用了文件名与文件描述信息分开的方法，将文件描述信息单独形成一个索引结点，简称i结点。文件目录中的每个目录项仅由文件名和指向该文件i结点的指针构成。 一个文件控制块的大小为64B,盘块大小是1KB，则在每个盘块中可以存放16个文件控制块。而在采用索引结点的系统中一个目录项仅占16B,其中14B是文件名，2B是i结点指针。这样，在1KB的盘块中就可以存放64个目录项，可以使文件查找时平均启动磁盘的次数减少到原来的1/4，大大节省了系统开销。存放在磁盘上的索引结点称为磁盘索引结点。每个文件都有唯一的磁盘索引结点， 其主要包括以下内容。 文件主标识符。 拥有该文件的个人或小组的标识符。 文件类型。 包括普通文件、目录文件或特别文件。 文件存取权限。 各类用户对该文件的存取权限。 文件物理地址。每个索引结点以直接或间接方式给出数据文件所在盘块的编号。 文件长度。 以字节为单位的文件长度。 文件链接计数。 表明在本文件系统中所有指向该文件的文件名的指针数。 文件存取时间。本文件最近被存取的时间、最近被修改的时间以及索引结点最近被修改的时间。 当文件被打开时，磁盘索引结点被复制到内存的索引结点中，以便使用。存放在内存中的索引结点称为内存索引结点，其增加了以下内容。 索引结点编号。用于标识内存索引结点。 状态。指示i结点是否上锁或被修改。 访问计数。正在访问该文件的进程数。 逻辑设备号。文件所属文件系统的逻辑设备号。 链接指针。 设置分别指向空闲链表和散列队列的指针。 单级目录结构 单级目录结构(或称为一级目录结构)是最简单的目录结构。在整个文件系统中，单级目录结构只建立一张目录表，每个文件占据其中的一个表目，如图4-1所示。 当建立一个新文件时，首先应确定该文件名在目录中是否唯一，若与已有文件名没有冲突，则从目录表中找出一个空表目，将新文件的相关信息填入其中。在删除文件时，系统先从目录表中找到该文件的目录项，从中找到该文件的物理地址，对文件占用的存储空间进行回收，然后再清除它所占用的目录项。当对文件进行访问时，系统先根据文件名去查找目录表以确定该文件是否存在，若文件存在，则找出文件的物理地址，进而完成对文件的操作。单级目录结构的优点是易于实现，管理简单，但是存在以下缺点。 不允许文件重名 (这个很显然)。单级目录下的文件，不允许和另一个文件有相同的名字。但对于多用户系统来说，这又是很难避免的。即使是单用户环境，当文件数量很大时,也很难弄清到底有哪些文件，这就导致文件系统极难管理。 文件查找速度慢。 对稍具规模的文件系统来说，由于其拥有大量的目录项，因此查找一个指定的目录项可能花费较长的时间。 二级目录结构 二级目录结构将文件目录分成主文件目录和用户文件目录。系统为每个用户建立一个单独的用户文件目录(User File Directory, UFD)， 其中的表项登记了该用户建立的所有文件及其说明信息。主文件目录(Master File Directory, MFD)则记录系统中各个用户文件目录的情况，每个用户占一个表目，表目中包括用户名及相应用户目录所在的存储位置等。这样就形成了二级目录结构。当用户要访问一个文件时，系统先根据用户名在主文件目录中查找该用户的文件目录，然后根据文件名在其用户文件目录中找出相应的目录项，从中得到该文件的物理地址，进而完成对文件的访问。 当用户要建立一个文件时，若为新用户，即主文件目录表中无此用户的相应登记项，则系统为其在主目录中分配一个表目，并为其分配存放用户文件目录的存储空间，同时在用户文件目录中为新文件分配一个表目，然后在表目中填入有关信息。文件删除时，只需在用户文件目录中删除该文件的目录项。若删除后该用户目录表为空，则表明该用户已脱离了系统，从而可以将主文件目录表中该用户的对应项删除。 二级目录结构可以解决文件重名问题，并可以获得较高的查找速度，但二级目录结构缺乏灵活性，特别是当用户需要在某些任务.上进行合作和访问其他文件时会产生很多问题。 树形目录结构 为了便于系统和用户更灵活、方便地组织管理和使用各类文件，将二级目录的层次关系加以推广，便形成了多级目录结构，又称为树形目录结构。 在树形目录结构中，第一级目录称为根目录(树根)，目录树中的非叶子结点均为目录文件(又称为子目录)，叶子结点为文件。系统会为每个文件赋予唯一的标识符(内部标识符)，该标识符对用户是透明的。 树形目录结构中引入了以下概念。 路径名。 在树形目录结构中，往往使用路径名来唯一标识文件。 文件的路径名是一个字符串，该字符串由从根目录出发到所找文件的通路上的所有目录名与数据文件名用分隔符“\\”连接而成。从根目录出发的路径称为绝对路径，从当前目录开始直到文件为止的路径称为相对路径。 当前目录。当树形目录的层次较多时，如果每次都要使用完整的路径名来查找文件,会使用户感到不便，系统本身也需要花费很多时间进行目录搜索。为此应采取有效措施解决这一问题。考虑到一个进程在-段时间内所访问的文件通常具有局部性，因此可在这段时间内指定某个目录作为当前目录(或称为工作目录)。进程对各文件的访问都是相对于当前目录进行的，此时文件使用的路径名为相对路径。系统允许文件路径往上走，并用“.”表示给定目录(文件)的父目录。 树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是在树形目录中查找一个文件，需要按照路径名逐级访问中间结点，增加了磁盘访问次数，进而影响了查询速度。 图形目录结构 树形目录结构便于实现文件分类，但是不便于实现文件共享，为此，在树形目录结构的基础上增加了一些指向同一结点的有向边，使整个目录成为一个有向无环图。这就是图形目录结构，引入这种结构的目的是实现文件共享。当某用户要求删除一个共享结点时，系统不能将其简单地删除，否则会导致其他用户访问时找不到结点。为此，可以为每个共享结点设置一个共享计数器，每当增加对该结点的共享链时，计数器加1;每当有用户提出删除该结点时，计数器减1。仅当共享计数器为0时，.才真正删除该结点，否则仅删除提出刪除请求用户的共享链。图形目录结构方便实现文件的共享，但使系统的管理变得复杂。 ","date":"2021-11-30 18:26:50","objectID":"https://qizhengzou.github.io/operatingsystem_base_04/:1:3","tags":["operating system"],"title":"OperatingSystem_base_04","uri":"https://qizhengzou.github.io/operatingsystem_base_04/"},{"categories":["School courses"],"content":"文件共享 实现文件共享是文件系统的重要功能。文件共享是指不同的用户可以使用同一个文件。文件共享可以节省大量的外存空间和主存空间，减少输入/输出操作，为用户间的合作提供便利条件。文件共享并不意味着用户可以不加限制地随意使用文件，那样文件的安全性和保密性将无法保证。也就是说，文件共享应该是有条件的，是要加以控制的。因此，文件共享要解决两个问题: 一是如何实现文件共享;二是对各类需要共享的用户进行存取控制。 共享动机 一来多用户操作系统中不同的用户间需要共享一些文件来共同完成任务; 二来网络上不同的计算机之间需要进行通信，需要远程文件系统的共享功能的支持。 基于索引结点的共享方式(硬链接) 传统树形目录文件的共享是由不同用户通过将各自文件的FCB设置成相同的物理地址来实现的，即不同的目录项指向同样的几个物理块。而当其中一个目录项进行了添加物理块的操作(在文件中增加了新的内容)后，另一个目录项中却并没有增加，所以新增的物理块不能被两个目录项所共享。 那么索引结点如何实现文件共享呢? 先前已经介绍过了，索引结点是把FCB中的文件描述信息单独构成一个数据结构，也就是说，物理块的信息在索引结点中。此时，目录项中只有文件名和指向索引结点的指针，两个不同的目录项只需要指向相同的索引结点即可实现共享，即一个共享文件只有一个索引结点。如果不同文件名的目录项需要共享该文件，只需目录项中的指针都指向该索引结点即可。 在索引结点中再增加一个计数值来统计指向该索引结点的目录项的个数，这样一来就需要在删除该文件时可以先判断计数值，只有计数值为1时才删除该索引结点，若计数值大于1,则把计数值减1即可。这种方法能够实现文件的异名共享，但当文件被多个用户共享时，文件拥有者不能删除文件。 利用符号链实现文件共享(软链接) 如图4-6所示，该方法是创建一个称为链接的新目录项。例如，为了使得用户B能共享用户C的一个文件，可以由系统为用户B建立一个指向该文件的新目录项，并放在用户B的目录下，在新目录项中包含了被共享文件的路径名，可以是绝对路径或者相对路径。当需要访问一个文件时，就搜索目录表，如果目录项标记为链接，那么就可以获取真正文件(或目录)的名称，再搜索目录。链接可以通过使用目录项格式(或通过特殊类型)而加以标记，其实际上是具有名称的间接指针。在遍历目录树时，系统忽略这些链接以维护系统的无环结构。在利用符号链方式实现文件共享时，只有文件拥有者才拥有指向其索引结点的指针;而共享该文件的其他用户只有该文件的路径名，并不拥有指向其索引结点的指针。这样就不会发生在文件拥有者删除共享文件后留下悬空指针的情况。当文件拥有者把一个共享文件删除后，其他用户试图通过符号链去访问一个已被删除的共享文件时，会因系统找不到该文件而使访问失败，于是再将符号链删除，此时不会产生任何影响。符号链方式有一个很大的优点，就是它能够用于链接(通过计算机网络)世界上任何地方的计算机中的文件，此时只需提供该文件所在机器的网络地址以及该机器中的文件路径即可。 这种方法解决了基于索引结点共享方法中文件拥有者不能删除共享文件的问题，但是当其他用户要访问共享文件时，需要逐层查找目录，开销较大。 ","date":"2021-11-30 18:26:50","objectID":"https://qizhengzou.github.io/operatingsystem_base_04/:1:4","tags":["operating system"],"title":"OperatingSystem_base_04","uri":"https://qizhengzou.github.io/operatingsystem_base_04/"},{"categories":["School courses"],"content":"文件保护：访问类型、访问控制。 文件保护用来防止文件受到物理破坏和非法访问。 访问类型 对文件的保护可以从限制对文件的访问类型出发，可以加以控制的访问类型有读、写、执行、添加、删除、列表清单(列出文件名和文件属性)等。此外，还可以对文件的重命名、复制、编辑等加以控制。 访问控制 访问控制就是对不同的用户访问同一个文件采取不同的访问类型。根据用户的权限不同，可以把用户划分为拥有者、工作组用户、其他用户等。然后对不同的用户组采取不同的访问类型，以防文件被非法访问。 访问控制通常有4种方法:访问控制矩阵、访问控制表、用户权限表以及口令与密码。 访问控制矩阵、访问控制表和用户权限表这3种方法比较类似，它们都是采用某种数据结构记录每个用户或用户组对于每个文件的操作权限，在访问文件时通过检查这些数据结构来看用户是否具有相应的权限来对文件进行保护。而口令与密码是另外一种访问控制方法。 口令指用户在建立一个文件时提供一个口令，系统为其建立FCB时附上相应口令，用户请求访问时必须提供相应口令。这种方法的开销较小，但是口令直接存储在系统内部，不够安全。密码指用户对文件进行加密，文件被访问时需要使用密钥。这种方法的保密性强，节省存储空间，但编码和译码要花费一定时间。 ","date":"2021-11-30 18:26:50","objectID":"https://qizhengzou.github.io/operatingsystem_base_04/:1:5","tags":["operating system"],"title":"OperatingSystem_base_04","uri":"https://qizhengzou.github.io/operatingsystem_base_04/"},{"categories":["School courses"],"content":"文件系统实现 ","date":"2021-11-30 18:26:50","objectID":"https://qizhengzou.github.io/operatingsystem_base_04/:2:0","tags":["operating system"],"title":"OperatingSystem_base_04","uri":"https://qizhengzou.github.io/operatingsystem_base_04/"},{"categories":["School courses"],"content":"文件系统层次结构 文件系统是指操作系统中与文件管理有关的软件和数据的集合。从系统角度看，文件系统是对文件的存储空间进行组织和分配，负责文件的存储并对存入文件进行保护和检索的系统。具体来说，它负责为用户建立、撤销、读写、修改和复制文件。从用户角度看，文件系统主要实现了按名存取。也就是说，当用户要求系统保存一个已命名文件时，文件系统根据一定的格式将用户的文件存放到文件存储器中适当的地方;当用户要求使用文件时，系统根据用户所给的文件名能够从文件存储器中找到所要的文件。如图4-7所示，文件系统一种合理的层次结构可分为用户接口、文件目录系统、存取控制验证、逻辑文件系统与文件信息缓冲区和物理文件系统。 用户接口。 操作系统通常使用图形桌面作为一个接口，当然还有Windows下的黑黑的cmd以及Linux, Mac. 上好用的命令窗口，都是用户接口。这个用户是广义的概念，不仅仅指代程序员。比如查看文件F的内容，那么通过接口操作，向操作系统发出命令，这就是第一层，最抽象的也是最顶层的面对用户的接口，连接的是现实世界与虚拟世界。 文件目录系统。 操作系统得到命令后要干的事情是查找目录，得到文件F的索引信息，这个索引信息可以通过FCB，也可以通过索引结点。前面讨论过抽出文件名得到的i结点，按名存取时找到i结点指针。一个文件有一个FCB或一个i结点(索引结点)，这便是在第二层:文件目录系统做的事情。 存取控制验证。 找到FCB后，不是所有人都有资格见到F文件，还需要考察你的资质。好像你前面费了一番心思到了一个景区，想去看看，得验证你是不是有票，票即资格。FCB.上有你是不是可以访问此文件的权限信息，这便是存取控制验证。现在假定的任务是读,也即取，写入是存。存取这个名称也是可以再掰开体会的。 逻辑文件系统与文件信息缓冲区。这个也很好理解。确定你可以进入后，开始真正地帮你找具体的物理地址。我们应该建立起这样一种概念:操作系统通常先是管逻辑地址，再去根据相应的策略得到物理地址。这个部分的功能是:获得相应文件的逻辑地址，而具体的物理地址需要在物理文件系统中获取。 物理文件系统。 这是底层的实现，分为两部分内容:辅存的分配管理和设备的管理。在UNIX下，设备也是文件。具体的以后再展开。 ","date":"2021-11-30 18:26:50","objectID":"https://qizhengzou.github.io/operatingsystem_base_04/:2:1","tags":["operating system"],"title":"OperatingSystem_base_04","uri":"https://qizhengzou.github.io/operatingsystem_base_04/"},{"categories":["School courses"],"content":"目录实现 线性表 最为简单的目录实现方法是使用存储文件名和数据块指针的线性表(数组、链表等)。创建新文件时，必须首先搜索目录表以确定没有同名的文件存在，接着在目录表后增加一个目录项。若要删除文件，根据给定的文件名搜索目录表，接着释放分配给它的空间。采用链表结构可以减少删除文件的时间，其优点在于实现简单，不过由于线性表需要采用顺序方法查找特定的项，故运行比较费时。 散列表 散列表根据文件名得到一个值，并返回一个指向线性表中元素的指针。这种方法大大缩短了查找目录的时间，插入和删除也比较简单，不过需要一些措 施来避免冲突(两个不同名文件的散列函数值相同)。这种方法的特点是散列表长度固定以及散列函数对表长的依赖性。 ","date":"2021-11-30 18:26:50","objectID":"https://qizhengzou.github.io/operatingsystem_base_04/:2:2","tags":["operating system"],"title":"OperatingSystem_base_04","uri":"https://qizhengzou.github.io/operatingsystem_base_04/"},{"categories":["School courses"],"content":"文件实现 文件的实现主要是指文件在存储器上的实现，即文件物理结构的实现，包括外存分配方式与文件存储空间的管理。 外存分配方式 文件的物理结构是指一个文件在外存上的存储组织形式，与外存分配方式有关。外存分配方式指的是如何为文件分配磁盘块。采用不同的分配方式将形成不同的文件物理结构。 一般来说，外存的分配采用两种方式:静态分配和动态分配。静态分配是在文件建立时一次性分配所需的全部空间;而动态分配则是根据动态增长的文件长度进行分配，甚至可以一次分配一个物理块。在分配区域大小上，也可以采用不同方法。可以为文件分配一个完整的区域以装下整个文件，这就是文件的连续分配。但文件存储空间的分配通常以块或簇(几个连续物理块称为簇，一般是固定大小) 为单位。常用的外存分配方法有连续分配、链接分配和索引分配。 (1)连续分配 连续分配是最简单的磁盘空间分配策略，该方法要求为文件分配连续的磁盘区域，如图4-8所示。在这种分配算法中，用户必须在分配前说明待创建文件所需的存储空间大小，然后系统查找空闲区的管理表格，查看是否有足够大的空闲区供其使用。如果有，就给文件分配所需的存储空间;如果没有，该文件就不能建立，用户进程必须等待。 采用连续分配方式时，可把逻辑文件中的记录顺序地存储到相邻的物理盘块中，这样所形成的文件结构称为顺序文件结构，此时的物理文件称为顺序文件。这种分配方式保证了逻辑文件中的记录顺序与存储器中文件占用盘块的顺序一致。 连续分配的优点是查找速度比其他方法快(只需要起始块号和文件大小)，目录中关于文件物理存储位置的信息也比较简单。其主要缺点是容易产生碎片，需要定期进行存储空间的紧缩。很显然，这种分配方法不适合文件随时间动态增长和减少的情况，也不适合用户事先不知道文件大小的情况。 (2)链接分配 对于文件长度需要动态增减以及用户事先不知道文件大小的情况，往往采用链接分配。这种分配策略有以下两种实现方案。 隐式链接。 该实现方案用于链接物理块的指针隐式地放在每个物理块中，目录项中有指向索引顺序文件的第一块盘块和最后-块盘块的指针，此外每个盘块中都含有指向下一盘块的指针，如图4-9所示。若要访问某一个盘块，需要从第一个盘块开始一个个盘块都读出指针来，所以存在随机访问效率低的问题;由于其中任何一个盘块的指针错误都会导致后面的盘块的位置丢失，因此这种实现方案可靠性较差。 显式链接。 该实现方案用于链接物理块的指针显式存放在内存的一张链接表中，每个磁盘设置一张链接表， 如图4-10所示。这个表又称为文件分配表(File Allocation Table,FAT)，MS-DOS、Windows和OS/2等操作系统都用了FAT。由于还是链接方式，因此在FAT中找一个记录的对应物理块地址时还是需要一个个找下去，不能随机查找。但是与隐式链接相比，该方案是在内存中而非在磁盘中查找，所以能节省不少时间。 链接分配的优点是简单(只需起始位置)，文件创建与增长容易实现。其缺点是不能随机访问盘块，链接指针会占用一些存储空间，而且存在可靠性问题。 (3)索引分配 链接分配方式虽然解决了连续分配方式中存在的问题，但又出现了新的问题。首先，当要求随机访问文件中的一个记录时，需要按照链接指针依次进行查找，这样查找十分缓慢。其次，链接指针要占用一定数量的磁盘空间。为了解决这些问题，引入了索引分配方式。在索引分配方式中，系统为每个文件分配一个索引块，索引块中存放索引表，索引表中的每个表项对应分配给该文件的一个物理块，如图4-11所示。 索引分配方式不仅支持直接访问，而且不会产生外部碎片，文件长度受限制的问题也得到了解决。其缺点是由于索引块的分配，增加了系统存储空间的开销。对于索引分配方式，索引块的大小选择是一个很重要的问题。为了节约磁盘空间，希望索引块越小越好，但索引块太小则无法支持大文件，所以要采用一些技术来解决这个问题。另外，存取文件需要两次访问外存一首 先读取索引块的内容,其次再访问具体的磁盘块，因而降低了文件的存取速度。 为了更有效地使用索引表，避免访问索引文件时两次访问外存，可以在访问文件时先将索引表调入内存中，这样，文件的存取就只需要访问一次外存 了。当文件很大时，文件的索引表会很大。如果索引表的大小超过了一个物理块，可以将索引表本身作为一个文件，再为其建立一个“索引表”，这个“索引表”作为文件索引的索引，从而构成了二级索引。第一级索引表的表目指向第二级索引，第二级索引表的表目指向文件信息所在的物理块号。依次类推，可逐级建立索引，进而构成多级索引。 索引分配支持直接访问，而且没有外部碎片，但是索引块本身会占用空间。 1)单级索引分配。单级索引分配方法就是将每个文件所对应的盘块号集中放在一起，为每个文件分配一个索引块(表),再把分配给该文件的所有盘块号都记录在该索引块中，因而该索引块就是一个包含多个盘块号的数组。 图4-12为test 文件分配的盘块，依次是9、16、 1、10。建立一个索引块，其盘块号为19，则在目录文件中该表项的块序号为19， 并在19号盘块中建立其分配盘块号的索引。图4-12中表示test文件分配的第1个盘块号为9,第2个盘块号为16,依次类推(-1表示结束)。 2)两级索引分配。当文件较大，一个索引块放不下文件的块序列时，可以对索引块再建立索引，这样构成二级索引，如图4-13所示，test 文件的目录项的索引地址为主索引的块号，主索引中的各块号是第二级索引的块号，第二级索引中的块号才构成文件的块号序列。 若盘块的大小为4KB，每个表项大小为4B，采用单级索引时允许的最大文件长度为Nx4KB= 4MB (其中N=4KB/4B=1K);而采用两级索引时所允许的最大文件长度为NxNx4KB=4GB，可见采用多级索引时可以大大提高文件的最大长度。这种思维可以推广到三级以及三级以上的索引分配，统称为多级索引分配。 3)混合索引分配。所谓混合索引分配，是指将多种索引分配方式相结合而形成的一种分配方式。例如，系统既采用了直接地址，又采用了单级索引分配方式或两级索引分配方式，甚至多级索引分配方式。图4-14所示的是一种混合索引分配方式，假设每个盘块大小为4KB,描述盘块的盘块号需要4B。 直接地址。 为了提高文件的检索速度，在索引结点中可设置10个直接地址项。这里每项中存放的是该文件所在盘块的盘块号，当文件不大于40KB时，便可以直接从索引结点中读出该文件的全部盘块号( 10x4KB- 40KB)。 一次间接地址。对于较大的文件，索引结点提供了一次间接地址，其实质就是一级索引分配方式。在一次间接地址中可以存放1K个盘块号，因此允许文件长达4MB (1Kx4KB- 4MB)。若既采用直接地址，又采用一次间接地址，允许文件长达4MB+40KB。 二次间接地址。当文件很大时，系统应采用二级间接地址。该方式实质上是两级索引分配方式，此时系统是在二次间接地址块中记入所有一次间接地址块的盘号。在采用二级间接地址方式时，文件最大长度可达到4GB (1Kx1K*4KB=4GB)。 如果同时采用直接地址、一次间接地址和二次间接地址，允许文件长达4GB+4MB+40KB. 这种思想可以推广到三级间接地址等。当采用三级间接地址时，所允许的最大文件长度为4TB+4GB+4MB+40KB。 文件存储空间管理 为了实现空闲存储空间的管理，系统应该记录空闲存储空间的情况，以便实施存储空间的分配。下面介绍几种常用的空闲存储空间管理方法。 (1)空闲文件表法 文件存储设备上的一个连续空闲区可以看作一个空闲文件(又称为空白文件或自由文件)。空闲文件表方法为所有空闲文件单独建立一个目录,每个空闲文件在这个目录中占一个表目。表目的内容包括第一个空闲块号、物理块号和空闲块数目，见表4-1。 当某用户请求分配存储空间时，系统依次扫描空闲文件目录，直到找到一个满足要求的空闲文件为止。当用户撤销一个文件时，系统回收该文件所占用的空间。这时也需要顺序扫描空闲文件目录，寻找一个空表目，并将释放空间的第一个物理块 号及它所占的块数填到这个表目中。 这种空闲文件目录方法类似于内存动态分区的管理。当请求的块数正好等于某个目录表目中的空闲块数时，就把这些块全部分配给该文件并把该表目标记为空。若该项中的块数多于请求的块数，则把多余的块号留在表中，并修改该表目中的各项。同样，在释放过程中, 若被释放的物理块号与某一目录项中的物理块号相邻，则还要进行空闲文件的合并。 仅当文件存储空间中只有少量空闲文件时，这种方法才有较好的效果。若存储空间中有大量的小空闲文件，则空闲文件目录将变得很大，其效率将大为降低。这种管理方法仅适用于连续文件。 (2)空闲块链表法; 空闲块链表法是将文件存储设备上的所有空闲块链接在-起， 形成一条空闲块链，并设置一个头指针指向空闲块链的第一个物理块。 当用户建立文件时，就按需要从链首依次取下几个空闲块分配给文件。当撤销文件时，回收其存储空间，并将回收的空闲块依次链入空闲块链表中。 也可以将链表中的空闲盘块改为空闲盘区(每个空闲盘区包含若干个连续的空闲盘块)，这样的链称为空闲盘区链。其中，在每个盘区上除了含有用于指示下一个空闲盘区的指针外，还应含有能指明本盘区大小的信息。分配盘区的方法与内存的动态分区分配类似，通常采用首次适应算法。在回收盘区时，同样也要将回收区与相邻接的空闲盘区合并。 (3)位示图法 位示图法是为文件存储器建立一张位示图(尽管称其为图，其实就是一连串的二进制位)，以反映整个存储空间的分配情况。在位示图中，每一个二进制位都对应一个物理块，若某位为1,表示对应的物理块已分配;若为0，表示对应的物理块空闲。当请求分配存储","date":"2021-11-30 18:26:50","objectID":"https://qizhengzou.github.io/operatingsystem_base_04/:2:3","tags":["operating system"],"title":"OperatingSystem_base_04","uri":"https://qizhengzou.github.io/operatingsystem_base_04/"},{"categories":["School courses"],"content":"磁盘组织与管理 ","date":"2021-11-30 18:26:50","objectID":"https://qizhengzou.github.io/operatingsystem_base_04/:3:0","tags":["operating system"],"title":"OperatingSystem_base_04","uri":"https://qizhengzou.github.io/operatingsystem_base_04/"},{"categories":["School courses"],"content":"磁盘的结构 磁盘的物理结构 磁盘是典型的直接存取设备，这种设备允许文件系统直接存取磁盘上的任意物理块。磁盘机一般由若干磁 盘片组成，可沿一个固定方向高速旋转。每个盘面对应一个磁头，磁臂可以沿着半径方向移动。磁盘上的一系列同心圆称为磁道，磁道沿径向又分成大小相等的多个扇区，盘片上与盘片中心有一定距离的所有磁道组成了一个柱面，如图4-17所示。因此，磁盘上的每个物理块可以用柱面号、磁头号和扇区号表示。 磁盘结构中的信息 磁盘结构中的常用信息如下。 引导控制块。 通常为分区的第一块,若该分区没有操作系统，则为空。 分区控制块。 其中包括分区的详细信息，如分区的块数、块的大小、空闲块的数目和指针等。 目录结构。采用目录文件组织。 文件控制块。其中包括文件的信息，如文件名、拥有者、文件大小和数据块位置等。 磁盘的访问时间Ta 磁盘的访问时间T。表示为访问时间=寻道时间+旋转延迟+传输时间 (1)寻道时间Ts 磁盘接收到读指令后，磁头从当前位置移动到目标磁道位置，所需时间为寻道时间Ts。该时间是启动磁臂的时间s与磁头移动n条磁道所花费时间的总和，m为每移动一个磁道所需时间，即Ts = m * n + s 式中，m为常数，与磁盘驱动器的速度有关，通常题目会给出。若题目没有给出磁臂的启动时间，则忽略不计(为了简化计算，总是被忽略)。 (2)旋转延迟T, 旋转磁盘、定位数据所在的扇区所需的时间为旋转延迟Tr。设磁盘的旋转速度为r,则T-(1/r)/2=1/(2r) 这里T,的物理意义就是磁盘旋转半周的时间，通常题目的问法是“每个磁道读取1个随机分布的扇区”，正因为这个“随机”，所以取旋转长度的平均期望值，也就是半周，所以平均旋转延迟就是磁盘旋转半周的时间。 (3)传输时间Tt 从磁盘上读取数据的时间为传输时间T。传输时间取决于每次读写的字节数b和磁盘的旋转速度，即T=b/(rN)式中，r为转速; N为一个磁道上的字节数。 ","date":"2021-11-30 18:26:50","objectID":"https://qizhengzou.github.io/operatingsystem_base_04/:3:1","tags":["operating system"],"title":"OperatingSystem_base_04","uri":"https://qizhengzou.github.io/operatingsystem_base_04/"},{"categories":["School courses"],"content":"磁盘调度算法 磁盘是可以被多个进程共享的设备。当有多个进程都请求访问磁盘时，应采用一种适当的调度算法，以使各进程对磁盘的平均访问时间(主要是寻道时间)最短。下面介绍几种磁盘调度算法。 先来先服务(FCFS) 算法 FCFS算法是一种最简单的磁盘调度算法。该算法按进程请求访问磁盘的先后次序进行调度。该算法的特点是合理、简单，但未对寻道进行优化。 最短寻道时间优先(SSTF) 算法 SSTF算法选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象。该算法的寻道性能比FCFS算法好，但不能保证平均寻道时间最短，并且可能会使某些进程的请求总被其他进程的请求抢占而长期得不到服务(这种现象称为“饥饿”)。 扫描算法(SCAN)或电梯调度算法 SCAN算法在磁头当前移动方向上选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象。由于这种算法中磁头移动的规律颇似电梯的运行，故也称为电梯调度算法。SCAN算法具有较好的寻道性能，又避免了“饥饿”现象，但其对两端磁道请求比较不公平(通常两端请求都是最后得到服务)。 循环扫描(C-SCAN)算法 C-SCAN算法是对SCAN算法的改良，它规定磁头单向移动，例如，自里向外移动，当磁头移到最外磁道时立即返回到最里磁道，如此循环进行扫描。该算法消除了对两端磁道请求的不公平。 ","date":"2021-11-30 18:26:50","objectID":"https://qizhengzou.github.io/operatingsystem_base_04/:3:2","tags":["operating system"],"title":"OperatingSystem_base_04","uri":"https://qizhengzou.github.io/operatingsystem_base_04/"},{"categories":["School courses"],"content":"磁盘的管理 磁盘格式化 一个新的磁盘只是一个含有磁性记录材料的空白盘。在磁盘能存储数据前，它必须分成扇区以便磁盘控制器能进行读和写操作，这个过程称为低级格式化。低级格式化为磁盘的每个扇区采用独特的数据结构。每个扇区的数据结构通常由头部、数据区域(通常为512B)和尾部组成。头部和尾部包含了一些磁盘控制器所使用的信息。为了使用磁盘存储文件，操作系统还需要将自己的数据结构记录在磁盘上。 1)将磁盘分为由一个或多个柱面组成的分区(就是常见的C盘、D盘等分区)。 2)对物理分区进行逻辑格式化(创建文件系统)，操作系统将初始的文件系统数据结构存储到磁盘上，这些数据结构包括空闲和已经分配的空间以及一个初始为空的目录。 引导块 计算机启动时需要运行一个初始化程序(自举程序)，它初始化CPU、寄存器、设备控制器和内存等，接着启动操作系统。为此，该自举程序应找到磁盘上的操作系统内核，装入内存，并转到初始地址，从而开始操作系统的运行。自举程序通常保存在ROM中,为了避免改变自举代码需要改变ROM硬件的问题，只在ROM中保留很小的自举装入程序，而将功能完整的自举程序保存在磁盘的启动块上，启动块位于磁盘的固定位。拥有启动分区的磁盘称为启动磁盘或系统磁盘。 坏扇区 由于硬件有移动部件且容错能力差，因此容易导致一个或多个扇区损坏。根据所使用的磁盘和控制器，对这些块有多种处理方式。对于简单磁盘，如电子集成驱动器(IDE)， 坏扇区可手工处理，如MS-DOS的Format命令执行逻辑格式化时会扫描磁盘检查坏扇区。坏扇区在FAT. 上会标明，因此程序不会使用。 对于复杂的磁盘，如小型计算机系统接口(SCSD), 其控制器维护一个磁盘坏块链表。该链表在出厂前进行低级格式化时就初始化了，并在磁盘的整个使用过程中不断更新。低级格式化将一些块保留作为备用，对操作系统透明。控制器可以用备用块来逻辑地替代坏块，这种方案称为扇区备用。 ","date":"2021-11-30 18:26:50","objectID":"https://qizhengzou.github.io/operatingsystem_base_04/:3:3","tags":["operating system"],"title":"OperatingSystem_base_04","uri":"https://qizhengzou.github.io/operatingsystem_base_04/"},{"categories":["School courses"],"content":"习题 磁盘的物理格式化和逻辑格式化： 位示图是磁盘空闲管理中的一种方式，其做法是为文件存储器建立–张位示图(尽管称其为图，其实就是一连串的二进制位)，以反映整个存储空间的分配情况。 ","date":"2021-11-30 18:26:50","objectID":"https://qizhengzou.github.io/operatingsystem_base_04/:4:0","tags":["operating system"],"title":"OperatingSystem_base_04","uri":"https://qizhengzou.github.io/operatingsystem_base_04/"},{"categories":["School courses"],"content":" 笔记来自：计算机体系结构基础（第三版）胡伟武等 引言 造计算机： 硬件方面：计算机组成原理和计算机体系结构 软件方面：操作系统和编译原理 由CPU和OS构建起来的平台举例： Wintel(Windows+X86Cpu) AA(Android+ARMCpu) ","date":"2021-11-29 14:19:01","objectID":"https://qizhengzou.github.io/ca_base_01/:0:0","tags":["computer architecture"],"title":"CA_base_01","uri":"https://qizhengzou.github.io/ca_base_01/"},{"categories":["School courses"],"content":"计算机体系结构研究内容 ","date":"2021-11-29 14:19:01","objectID":"https://qizhengzou.github.io/ca_base_01/:1:0","tags":["computer architecture"],"title":"CA_base_01","uri":"https://qizhengzou.github.io/ca_base_01/"},{"categories":["School courses"],"content":"按一下键盘，PPT就能翻一页？ 为了说明计算机体系结构研究涉及的领域，我们看一个很简单平常的问题：为什么我按一下键盘，PPT会翻一页？这是一个什么样的过程？在这个过程中，应用程序（WPS）、操作系统（Windows或Linux）、硬件系统、CPU、晶体管是怎么协同工作的？ 下面介绍用龙芯CPU构建的系统实现上述功能的原理性过程。 按一下键盘，键盘会产生一个信号送到南桥芯片，南桥芯片把键盘的编码保存在南桥内部的一个寄存器中，并向处理器发出一个外部中断信号。该外部中断信号传到CPU内部后把CPU中一个控制寄存器的某一位置为“1”，表示收到了外部中断。CPU中另外一个控制寄存器有屏蔽位来确定是否处理这个外部中断信号。 屏蔽处理后的中断信号被附在一条译码后的指令上送到重排序缓冲（Re-Order Buffer，简称ROB）。外部中断是例外（Exception，也称“异常”）的一种，发生例外的指令不会被送到功能部件执行。当这条指令成为重排序缓冲的第一条指令时CPU处理例外。重排序缓冲为了给操作系统一个精确的例外现场，处理例外前要把例外指令前面的指令都执行完，后面的指令都取消掉。 重排序缓冲向所有的模块发出一个取消信号，取消该指令后面的所有指令；修改控制寄存器，把系统状态设为核心态；保存例外原因、发生例外的程序计数器（Program Counter，简称PC）等到指定的控制寄存器中；然后把程序计数器的值置为相应的例外处理入口地址进行取指（LoongArch中例外的入口地址计算规则可以参见其体系结构手册）。 处理器跳转到相应的例外处理器入口后执行操作系统代码，操作系统首先保存处理器现场，包括寄存器内容等。保存现场后，操作系统向CPU的控制寄存器读例外原因，发现是外部中断例外，就向南桥的中断控制器读中断原因，读的同时清除南桥的中断位。读回来后发现中断原因是有人敲了空格键。 操作系统接下来要查找读到的空格是给谁的：有没有进程处在阻塞状态等键盘输入。大家都学过操作系统的进程调度，知道进程至少有三个状态：运行态、阻塞态、睡眠态，进程在等IO输入时处在阻塞态。操作系统发现有一个名为WPS的进程处于阻塞态，这个进程对空格键会有所响应，就把WPS唤醒。 WPS被唤醒后处在运行状态。发现操作系统传过来的数据是个键盘输入空格，表示要翻页。WPS就把下一页要显示的内容准备好，调用操作系统中的显示驱动程序，把要显示的内容送到显存，由图形处理器（Graphic Processing Unit，简称GPU）通过访问显存空间刷新屏幕。达到了翻一页的效果 再看一个问题：如果在翻页的过程中，发现翻页过程非常卡顿，即该计算机在WPS翻页时性能较低，可能是什么原因呢？首先得看看系统中有没有其他任务在运行，如果有很多任务在运行，这些任务会占用CPU、内存带宽、IO带宽等资源，使得WPS分到的资源不够，造成卡顿。如果系统中没有其他应用与WPS抢资源，还会卡顿，那是什么原因呢？多数人会认为是CPU太慢，需要升级。实际上，在WPS翻页时，CPU干的活不多。一种可能是下一页包含很多图形，尤其是很多矢量图，需要GPU画出来，GPU忙不过来了。另外一种可能是要显示的内容数据量大，要把大量数据从WPS的应用程序空间传给GPU使用的专门空间，内存带宽不足导致不能及时传输。在独立显存的情况下，数据如何从内存传输到显存有两种不同的机制：由CPU从内存读出来再写到显存需要CPU具有专门的IO加速功能，因为显存一般是映射在CPU的IO空间；不通过CPU，通过直接内存访问（Direct Memory Access，简称DMA）的方式直接从内存传输到显存会快得多。 “计算机体系结构”课程是研究怎么造计算机，而不是怎么用计算机。我们不是学习驾驶汽车，而是学习如何造汽车。一个计算机体系结构设计人员就像一个带兵打仗的将领，要学会排兵布阵。要上知天文、下知地理，否则就不会排兵布阵，或者只会纸上谈兵地排兵布阵，只能贻误军国大事。对计算机体系结构设计来说，“排兵布阵”就是体系结构设计，“上知天文”就是了解应用程序、操作系统、编译器的行为特征，“下知地理”就是了解逻辑、电路、工艺的特点。永远不要就体系结构论体系结构，要做到应用、系统、结构、逻辑、电路、器件的融会贯通。就像《论语》中说的“吾道一以贯之”。 通用计算机系统的层次结构： 该图把计算机系统分成应用程序、操作系统、硬件系统、晶体管四个大的层次。注意把这四个层次联系起来的三个界面。第一个界面是应用程序编程接口API（Application Programming Interface），也可以称作“操作系统的指令系统”，介于应用程序和操作系统之间。API是应用程序的高级语言编程接口，在编写程序的源代码时使用。常见的API包括C语言、Fortran语言、Java语言、JavaScript语言接口以及OpenGL图形编程接口等。使用一种API编写的应用程序经重新编译后可以在支持该API的不同计算机上运行。所有应用程序都是通过API编出来的，在IT产业，谁控制了API谁就控制了生态，API做得好，APP（Application）就多。API是建生态的起点。第二个界面是指令系统ISA（Instruction Set Architecture），介于操作系统和硬件系统之间。常见的指令系统包括X86、ARM、MIPS、RISC-V和LoongArch等。指令系统是实现目标码兼容的关键，由于IT产业的主要应用都是通过目标码的形态发布的，因此ISA是软件兼容的关键，是生态建设的终点。指令系统除了实现加减乘除等操作的指令外，还包括系统状态的切换、地址空间的安排、寄存器的设置、中断的传递等运行时环境的内容。第三个界面是工艺模型，介于硬件系统与晶体管之间。工艺模型是芯片生产厂家提供给芯片设计者的界面，除了表达晶体管和连线等基本参数的SPICE（Simulation Program with Integrated Circuit Emphasis）模型外，该工艺所能提供的各种IP也非常重要，如实现PCIE接口的物理层（简称PHY）等。 需要指出的是，在API和ISA之间还有一层应用程序二进制接口（Application Binary Interface，简称ABI）。ABI是应用程序访问计算机硬件及操作系统服务的接口，由计算机的用户态指令和操作系统的系统调用组成。为了实现多进程访问共享资源的安全性，处理器设有“用户态”与“核心态”。用户程序在用户态下执行，操作系统向用户程序提供具有预定功能的系统调用函数来访问只有核心态才能访问的硬件资源。当用户程序调用系统调用函数时，处理器进入核心态执行诸如访问IO设备、修改处理器状态等只有核心态才能执行的指令。处理完系统调用后，处理器返回用户态执行用户代码。相同的应用程序二进制代码可以在相同ABI的不同计算机上运行。 ","date":"2021-11-29 14:19:01","objectID":"https://qizhengzou.github.io/ca_base_01/:1:1","tags":["computer architecture"],"title":"CA_base_01","uri":"https://qizhengzou.github.io/ca_base_01/"},{"categories":["School courses"],"content":"计算机只是computer? 什么是计算机？大多数人认为计算机就是我们桌面的电脑，实际上计算机已经深入到我们信息化生活的方方面面。除了大家熟知的个人电脑、服务器和工作站等通用计算机外，像手机、数码相机、数字电视、游戏机、打印机、路由器等设备的核心部件都是计算机，都是计算机体系结构研究的范围。也许此刻你的身上就有好几台计算机。 计算机不光是桌面上摆的个人计算机，它可以大到一个厅都放不下，需要专门为它建一个电站来供电，也可以小到揣在我们的兜里，充电两个小时就能用一整天。不管这个计算机的规模有多大，都是计算机体系结构的研究对象。**计算机是为了满足人们各种不同的计算需求设计的自动化计算设备。**随着人类科技的进步和新需求的提出，最快的计算机会越来越大，最小的计算机会越来越小。 ","date":"2021-11-29 14:19:01","objectID":"https://qizhengzou.github.io/ca_base_01/:1:2","tags":["computer architecture"],"title":"CA_base_01","uri":"https://qizhengzou.github.io/ca_base_01/"},{"categories":["School courses"],"content":"计算机基本组成 计算机的组成非常复杂，但其基本单元非常简单。打开一台PC的机箱，可以发现电路板上有很多芯片。一个芯片就是一个系统，由很多模块组成，如加法器、乘法器等；而一个模块由很多逻辑门组成，如非门、与门、或门等；逻辑门由晶体管组成，如PMOS管和NMOS管等；晶体管则通过复杂的工艺过程形成。所以计算机是一个很复杂的系统，由很多可以存储和处理二进制运算的基本元件组成。就像盖房子一样，再宏伟、高大的建筑都是由基本的砖瓦、钢筋水泥等材料搭建而成的。在CPU芯片内部，一根头发的宽度可以并排走上千根导线；购买一粒大米的钱可以买上千个晶体管。 冯·诺依曼结构的基本思想：数据和程序都在存储器中，CPU从内存中取指令和数据进行运算并把结果也放到内存中。把指令和数据都存在内存中可以让计算机按照事先规定的程序自动地完成运算，是实现图灵机的一种简单方法。冯·诺依曼结构很好地解决了自动化的问题：把程序放在内存里，一条条取进来，自己就做起来了，不用人来干预。如果没有这样一种自动执行的机制，让人去控制计算机做什么运算，拨一下开关算一下，程序没有保存在内存中而是保存在人脑中，就成算盘了。计算机的发展日新月异，但70多年过去了还是使用冯·诺依曼结构。尽管冯·诺依曼结构有很多缺点，例如什么都保存在内存中使访存成为性能瓶颈，但我们还是摆脱不了它。 虽然经过了长期的发展，以存储程序和指令驱动执行为主要特点的冯·诺依曼结构仍是现代计算机的主流结构。笔者面试研究生的时候经常问一个问题：冯·诺依曼结构最核心的思想是什么？结果很多研究生都会答错。有人说是由计算器、运算器、存储器、输入、输出五个部分组成；有人说是程序计数器导致串行执行；等等。实际上，冯·诺依曼结构就是数据和程序都存在存储器中，CPU从内存中取指令和数据进行运算，并且把结果也放在内存中。概括起来就是存储程序和指令驱动执行。 ","date":"2021-11-29 14:19:01","objectID":"https://qizhengzou.github.io/ca_base_01/:1:3","tags":["computer architecture"],"title":"CA_base_01","uri":"https://qizhengzou.github.io/ca_base_01/"},{"categories":["School courses"],"content":"衡量计算机的指标 ","date":"2021-11-29 14:19:01","objectID":"https://qizhengzou.github.io/ca_base_01/:2:0","tags":["computer architecture"],"title":"CA_base_01","uri":"https://qizhengzou.github.io/ca_base_01/"},{"categories":["School courses"],"content":"性能 计算机的第一个重要指标就是性能。前面说的用来进行核模拟的高性能计算机对一个国家来说具有战略意义，算得越快越好。又如中央气象台用于天气预报的计算机每天需要根据云图数据解很复杂的偏微分方程，要是计算机太慢，明天的天气预报后天才算出来，那就叫天气后报，没用了。所以性能是计算机的首要指标。 什么叫性能？性能的最本质定义是“完成一个任务所需要的时间”。对中央气象台的台长来说，性能就是算明天的天气预报需要多长时间。如果甲计算机两个小时能算完24小时的天气预报，乙计算机一个小时就算完，显然乙的性能比甲好。完成一个任务所需要的时间可以由完成该任务需要的指令数、完成每条指令需要的拍数以及每拍需要的时间三个量相乘得到。完成任务需要的指令数与算法、编译器和指令的功能有关；每条指令需要的拍数与编译器、指令功能、微结构设计相关；每拍需要的时间，也就是时钟周期，与结构、电路设计、工艺等因素有关。 完成一个任务的指令数首先取决于算法。我们刚开始做龙芯的时候，计算所的一个老研究员讲过一个故事。说20世纪六七十年代的时候，美国的计算机每秒可以算一亿次，苏联的计算机每秒算一百万次，结果算同一个题目，苏联的计算机反而先算完，因为苏联的算法厉害。以对N个数进行排序的排序算法为例，冒泡排序算法的运算复杂度为O(NN)，快速排序算法的运算复杂度为O(Nlog2(N))，如果N为1024，则二者执行的指令数差100倍。 编译器负责把用户用高级语言（如C、Java、JavaScript等）写的代码转换成计算机硬件能识别的、由一条条指令组成的二进制码。转换出来的目标码的质量的好坏在很大程度上影响完成一个任务的指令数。在同一台计算机上运行同一个应用程序，用不同的编译器或不同的编译选项，运行时间可能有几倍的差距。 指令系统的设计对完成一个任务的指令数影响也很大。例如要不要设计一条指令直接完成一个FFT函数，还是让用户通过软件的方法来实现FFT函数，这是结构设计的一个取舍，直接影响完成一个任务的指令数。体系结构有一个常用的指标叫MIPS（Million Instructions Per Second）,即每秒执行多少百万条指令。看起来很合理的一个指标，关键是一条指令能干多少事讲不清楚。如果甲计算机一条指令就能做一个1024点的FFT，而乙计算机一条指令就算一个加法。两台计算机比MIPS值就没什么意义。因此后来有人把MIPS解释为Meaningless Indication of Processor Speed。现在常用一个性能指标MFLOPS（Million FLoating point Operations Per Second），即每秒做多少百万浮点运算，也有类似的问题。如果数据供不上，运算能力再强也没有用。 在指令系统确定后，结构设计需要重点考虑如何降低每条指令的平均执行周期（Cycles Per Instruction，简称CPI），或提高每个时钟周期平均执行的指令数（Instructions Per Cycle，简称IPC），这是处理器微结构研究的主要内容。CPI就是一个程序执行所需要的总的时钟周期数除以它所执行的总指令数，反之则是IPC。处理器的微结构设计对IPC的影响很大，采用单发射还是多发射结构，采用何种转移猜测策略以及什么样的存储层次设计都直接影响IPC。表1.2给出了龙芯3A1000和龙芯3A2000处理器运行SPEC CPU2000基准程序的分值。两个CPU均为64位四发射结构，主频均为1GHz，两个处理器运行的二进制码相同，但由于微结构不同，IPC差异很大，总体上说，3A2000的IPC是3A1000的2~3倍。 主频宏观上取决于微结构设计，微观上取决于工艺和电路设计。例如Pentium III的流水线是10级，Pentium IV为了提高主频，一发猛就把流水级做到了20级，还恨不得做到40级。Intel的研究表明，只要把Cache和转移猜测表的容量增加一倍，就能抵消流水线增加一倍引起的流水线效率降低。又如，从电路的角度来说，甲设计做64位加法只要1ns，而乙设计需要2ns，那么甲设计比乙设计主频高一倍。相同的电路设计，用不同的工艺实现出来的主频也不一样，先进工艺晶体管速度快，主频高。 可见在一个系统中不同层次有不同的性能标准，很难用一项单一指标刻画计算机性能的高低。大家可能会说，从应用的角度看性能是最合理的。甲计算机两个小时算完明天的天气预报，乙计算机只要一小时，那乙的性能肯定比甲的好，这总对吧。也对也不对。只能说，针对算明天的天气预报这个应用，乙计算机的性能比甲的好。但对于其他应用，甲的性能可能反而比乙的好。 ","date":"2021-11-29 14:19:01","objectID":"https://qizhengzou.github.io/ca_base_01/:2:1","tags":["computer architecture"],"title":"CA_base_01","uri":"https://qizhengzou.github.io/ca_base_01/"},{"categories":["School courses"],"content":"价格 计算机的第二个重要指标是价格。20世纪80年代以来电脑越来越普及，就是因为电脑的价格在不断下降，从一味地追求性能（Performance per Second）到追求性能价格比（Performance per Dollar）。现在中关村卖个人电脑的企业利润率比卖猪饲料的还低得多。 不同的计算机对成本有不同的要求。用于核模拟的超级计算机主要追求性能，一个国家只需要一两台这样的高性能计算机，不太需要考虑成本的问题。相反，大量的嵌入式应用为了降低功耗和成本，可能牺牲一部分性能，因为它要降低功耗和成本。而PC、工作站、服务器等介于两者之间，它们追求性能价格比的最优设计。 计算机的成本跟芯片成本紧密相关，计算机中芯片的成本包括该芯片的制造成本和一次性成本NRE（如研发成本）的分摊部分。生产量对于成本很关键。随着不断重复生产，工程经验和工艺水平都不断提高，生产成本可以持续地降低。例如做衣服，刚开始可能做100件就有10件是次品，以后做1000件也不会做坏1件了，衣服的总体成本就降低了。产量的提高能够加速学习过程，提高成品率，还可以降低一次性成本。 随着工艺技术的发展，为了实现相同功能所需要的硅面积指数级降低，使得单个硅片的成本指数级降低。但成本降到一定的程度就不怎么降了，甚至还会有缓慢上升的趋势，这是因为厂家为了保持利润不再生产和销售该产品，转而生产和销售升级产品。现在的计算机工业是一个不断出售升级产品的工业。买一台计算机三到五年后，就需要换一台新的计算机。CPU和操作系统厂家一起，通过一些技术手段让一般用户五年左右就需要换掉电脑。这些手段包括：控制芯片老化寿命，不再更新老版本的操作系统而新操作系统的文档格式不与老的保持兼容，发明新的应用使没有升级的计算机性能不够，等等。主流的桌面计算机CPU刚上市时价格都比较贵，然后逐渐降低，降到200美元以下，就逐步从主流市场中退出。芯片公司必须不断推出新的产品，才能保持盈利。但是总的来说，对同一款产品，成本曲线是不断降低的。 ","date":"2021-11-29 14:19:01","objectID":"https://qizhengzou.github.io/ca_base_01/:2:2","tags":["computer architecture"],"title":"CA_base_01","uri":"https://qizhengzou.github.io/ca_base_01/"},{"categories":["School courses"],"content":"功耗 计算机的第三个重要指标是功耗。手机等移动设备需要用电池供电。电池怎么用得久呢？低功耗就非常重要。高性能计算机也要低功耗，它们的功耗都以兆瓦（MW）计。兆瓦是什么概念？我们上大学时在宿舍里煮方便面用的电热棒的功率是1000W左右，几个电热棒一起用宿舍就停电了。1MW就是1000个电热棒的功率。曙光5000高性能计算机在中科院计算所的地下室组装调试时，运行一天电费就是一万多块钱，比整栋楼的电费还要高。计算机里产生功耗的地方非常多，CPU有功耗，内存条有功耗，硬盘也有功耗，最后为了把这些热量散发出去，制冷系统也要产生功耗。近几年来，性能功耗比（Performance per Watt）成为计算机非常重要的一个指标。 芯片功耗是计算机功耗的重要组成部分。芯片的功耗主要由晶体管工作产生，所以先来看晶体管的功耗组成。图1.3是一个反相器的功耗模型。反相器由一个PMOS管和一个NMOS管组成。其功耗主要可以分为三类： 开关功耗、短路功耗和漏电功耗。开关功耗主要是电容的充放电，比如当输出端从0变到1时，输出端的负载电容从不带电变为带电，有一个充电的过程；当输出端从1变到0时，电容又有一个放电的过程。在充电、放电的过程中就会产生功耗。开关功耗既和充放电电压、电容值有关，还和反相器开关频率相关。 短路功耗就是P管和N管短路时产生的功耗。当反相器的输出为1时，P管打开，N管关闭；输出为0时，则N管开，P管闭。但在开、闭的转换过程中，电流的变化并不像理论上那样是一个方波，而是有一定的斜率。在这个变化的过程中会出现N管和P管同时部分打开的情况，这时候就产生了短路功耗。 漏电功耗是指MOS管不能严格关闭时发生漏电产生的功耗。以NMOS管为例，如果栅极有电N管就导通；否则N管就关闭。但在纳米级工艺下，MOS管沟道很窄，即使栅极不加电压，源极和漏极之间也有电流；另外栅极下的绝缘层很薄，只有几个原子的厚度，从栅极到沟道也有漏电流。漏电流大小随温度升高呈指数增加，因此温度是集成电路的第一杀手。 优化芯片功耗一般从两个角度入手——动态功耗优化和静态功耗优化。升级工艺是降低动态功耗的有效方法，因为工艺升级可以降低电容和电压，从而成倍地降低动态功耗。芯片工作频率跟电压成正比，在一定范围内（如5%~10%）降低频率可以同比降低电压，因此频率降低10%，动态功耗可以降低30%左右（功耗和电压的平方成正比，和频率成正比）。可以通过选择低功耗工艺降低芯片静态功耗，集成电路生产厂家一般会提供高性能工艺和低功耗工艺，低功耗工艺速度稍慢一些但漏电功耗成数量级降低。在结构和逻辑设计时，避免不必要的逻辑翻转可以有效降低翻转率，例如在某一流水级没有有效工作时，保持该流水级为上一拍的状态不翻转。在物理设计时，可以通过门控时钟降低时钟树翻转功耗。在电路设计时，可以采用低摆幅电路降低功耗，例如工作电压为1V时，用0.4V表示逻辑0，用0.6V表示逻辑1，摆幅就只有0.2V，大大降低了动态功耗。 芯片的功耗是一个全局量，与每一个设计阶段都相关。功耗优化的层次从系统级、算法级、逻辑级、电路级，直至版图和工艺级，是一个全系统工程。近几年在降低功耗方面的研究非常多，和以前片面追求性能不同，降低功耗已经成了芯片设计一个最重要的任务。 信息产业是一个高能耗产业，信息设备耗电越来越多。根据冯·诺依曼的公式，现在一位比特翻转所耗的电是理论值的(10^{10})倍以上。整个信息的运算过程是一个从无序到有序的过程，这个过程中它的熵变小，是一个吸收能量的过程。但事实上，它真正需要的能量很少，因为我们现在用来实现运算的手段不够先进，不够好，所以才造成了(10^{10})倍这么高的能耗，因此我们还有多个数量级的优化空间。这其中需要一些原理性的革命，材料、设计上都需要很大的革新，即使目前在用的晶体管，优化空间也是很大的。 有些应用还需要考虑计算机的其他指标，例如使用寿命、安全性、可靠性等。以可靠性为例，计算机中用的CPU可以分为商用级、工业级、军品级、宇航级等。比如北斗卫星上面的计算机，价格贵点没关系，慢一点也没关系，关键是要可靠，我国放了不少卫星，有的就是由于其中的元器件不可靠报废了。因此在特定领域可靠性要求非常高。再如银行核心业务用的计算机也非常在乎可靠性，只要一年少死机一次，价格贵一千万元也没关系，对银行来说，核心计算机死机，所有的储户就取不了钱，这损失太大了。 因此考评一个计算机好坏的指标非常多。本课程作为本科计算机体系结构基础课程，在以后的章节中主要关注性能指标。 ","date":"2021-11-29 14:19:01","objectID":"https://qizhengzou.github.io/ca_base_01/:2:3","tags":["computer architecture"],"title":"CA_base_01","uri":"https://qizhengzou.github.io/ca_base_01/"},{"categories":["School courses"],"content":"体系结构设计的基本原则 计算机体系结构发展很快，但在发展过程中遵循一些基本原则，这些原则包括平衡性、局部性、并行性和虚拟化。 ","date":"2021-11-29 14:19:01","objectID":"https://qizhengzou.github.io/ca_base_01/:3:0","tags":["computer architecture"],"title":"CA_base_01","uri":"https://qizhengzou.github.io/ca_base_01/"},{"categories":["School courses' list"],"content":" base来自2021秋哈工大深圳软件工程 base_01 软件工程概论 1.1 软件工程的产生与发展 1.2 软件工程的基本概念 base_02 软件项目开发过程与管理 2.1 软件项目开发过程 2.2 软件项目开发管理 base_03 软件需求工程 3.1 软件需求与需求工程 软件需求 需求工程 3.2 需求获取与建模 需求获取的挑战和途径 需求建模 3.3 需求规格说明 base_04 软件设计 4.1 软件工程开发方法与软件设计 软件工程开发方法 传统开发方法 面向对象方法 软件设计 设计的概念 设计的原则 4.2 体系结构设计 软件体系结构要素 软件体系结构概念 软件体系结构的目标 软件体系结构风格 数据流风格 以数据为中心的风格 调用和返回体系结构风格 面向对象体系结构风格 层次体系结构风格 4.3 类/数据建模与设计 CRC卡片分拣法-面向对象方法 DFD-结构化方法 4.4 行为建模与设计 状态图 顺序图 协作图 活动图 4.5 物理建模与设计 组件图 base_05 软件编码、测试与质量保障 5.1 软件编程 良好的编程时间 代码审查 代码重构 5.2 软件测试 软件测试概述 软件缺陷术语 软件测试概念 软件测试基本原则 软件测试团队 软件测试策略 软件测试对象 软件测试过程 软件测试类型 测试用例 5.3 白盒测试 白盒测试方案 5.4 黑盒测试 base_06 软件实施、维护与演化 6.1 敏捷开发 敏捷方法概述 软件开发之道 敏捷方法与敏捷宣言 敏捷开发核心理念 敏捷开发方法的应用 Scrum框 Scrum框架介绍 Scrum团队角色 Scrum制品与活动 敏捷规划与可视化管理 6.2 软件实施、维护与演化 软件交付工作 软件演化法则 软件维护 软件再工程 ","date":"2021-11-25 15:50:13","objectID":"https://qizhengzou.github.io/sek_catalogue/:0:0","tags":["catalogue"],"title":"SEK_catalogue","uri":"https://qizhengzou.github.io/sek_catalogue/"},{"categories":["School courses"],"content":" 笔记来自2021秋哈工大深圳软件工程授课教师张永兵 软件实施、维护和演化 19：52 ","date":"2021-11-25 15:48:12","objectID":"https://qizhengzou.github.io/sek_base_06/:0:0","tags":["software engineering knowledge"],"title":"SEK_base_06","uri":"https://qizhengzou.github.io/sek_base_06/"},{"categories":["School courses"],"content":"6.1 敏捷开发 ","date":"2021-11-25 15:48:12","objectID":"https://qizhengzou.github.io/sek_base_06/:1:0","tags":["software engineering knowledge"],"title":"SEK_base_06","uri":"https://qizhengzou.github.io/sek_base_06/"},{"categories":["School courses"],"content":"敏捷方法概述 软件开发之道 传统的开发模式，瀑布模型是最典型的预见性开发方法，严格遵循预先计划的需求分析、设计、编码、集成、测试、维护的步骤顺序进行。 软件开发是一个逐步认知和明晰的活动。软件开发中的变化是实际存在和必然的。 今天的软件开发过程更应侧重于 弹性的开发管理方式 通过初始计划开始工作 项目的资源管理和控制 软件开发应更关注于交付的价值 高质量的交付物是最重要的 系统不是一次构建而成，而是迭代演进的 基于完整的场景构建计划，并按优先级执行 好的架构（产品）是长出来的，而不是设计出来的 敏捷方法与敏捷宣言 敏捷开发方法： 敏捷开发是一种基于更紧密的团队协作、能够有效应对快速变化需求、快速交付高质量软件的迭代和增量的新型软件开发方法。 更关注协作 更关注质量 更关注可工作的产品 更关注全才化的专才 基于实践而非基于理论 敏捷方法：适应而非预测 需求是不可预测的 软件开发应是一个自适应的跟踪过程 敏捷方法： 以人为导向而非过程导向 敏捷开发方法 软件更像一个活着的植物，软件开发是自底向上逐步有序的生长过程，类似于植物自然生长。敏捷方法遵循软件的客观规律，不断进行迭代式增量开发，最终交付符合客户价值的产品。 敏捷宣言： 我们正在通过亲身实践以及帮助他人实践，揭示更好的软件开发方法。通过这项工作，我们认为： 个体和交互 胜过 过程和工具 可以工作的软件 胜过 面面俱到的文档 客户合作 胜过 合同谈判 响应变化 胜过 遵循计划 敏捷开发核心理念 敏捷核心理念： 聚焦客户价值 消除软件开发中的浪费 交付刚刚好的系统 随时构建质量，不容忍缺陷 及时消除技术债务，持续保持快速响应 激发团队潜能 团队是价值的真正创造者，应加强团队协作，激发团队潜能 软件开发是一种团队活动，首先应做到提升沟通效率降低交流成本 不断调整以适应变化 客户是逐步发现真正需求 小批量是快速交付的关键 通过迭代计划不断调整以适应变化 应持续保持良好的软件架构 利用多层次反馈不断调整以逼近目标 敏捷开发方法的应用 ISO 9000（09版）标准将在原来八大原则的基础上新增敏捷原则 2000年美国军方软件开发标准（DOD 5000.2）推荐迭代为软件开发优选模式 2013年发布的新版PMBOK增加迭代及增量生命周期（即对应敏捷模型） ","date":"2021-11-25 15:48:12","objectID":"https://qizhengzou.github.io/sek_base_06/:1:1","tags":["software engineering knowledge"],"title":"SEK_base_06","uri":"https://qizhengzou.github.io/sek_base_06/"},{"categories":["School courses"],"content":"Scrum框 Scrum框架介绍 Scrum是一种兼顾计划性与灵活性的敏捷开发过程，它将整个开发过程分为若干次更小的迭代，每个迭代周期称为一个冲刺（Sprint） Scrum迭代开发： 迭代开发将整个软件生命周期分成多个小的迭代（一般2~4周），每一次迭代就是一个小的瀑布模型，包括需求分析、设计、实现和测试等活动，结束时都要生成一个稳定和被验证过的软件版本。 迭代开发的关键要点： 每一次迭代都建立在稳定的质量基础上，并做为下一轮迭代的基线，整个系统的功能随着迭代稳定地增长和不断完善。 每次迭代要邀请用户代表验收，提供需求是否满足的反馈。 在一次迭代中，一旦团队作出承诺，就不允许变更交付件和交付日期；如果发生重大变化，产品负责人可以中止当次迭代。 在迭代中可能会出现“分解”和“澄清”，但是不允许添加新工作或者对现有的工作进行“实质变更” 对于“分解”和“澄清”，如果存在争议，那么将其认定为变更，放到产品订单中下一次迭代再考虑。 Scrum团队角色 产品负责人（Product Owner） 职责：定义开发目标以及需要实现的特性和优先级。 Scrum主管（Scrum Master） 职责：保证团队高效而不受打扰地工作，优化工作条件和过程。 团队成员（Team） 职责：自组织地完成项目开发，使用一切可行手段保证进度和质量。 Scrum团队组织： 民主式结构：小组成员完全平等，名义上的组长与其他成员没有任何区别；大家享有充分的民主，项目工作由全体讨论协商决定，并根据每个人的能力和经验进行适当分配。 优点：同等的项目参与权激发大家的创造力，有利于攻克技术难关 缺点：缺乏明确的权威领导，很难解决意见分歧 全功能的整体团队： Scrum制品和活动 Scrum制品： 产品订单是从客户价值角度理解的产品功能列表。 功能、缺陷、增强等都可以是产品订单项 整体上从客户价值进行优先级排序 迭代订单是从开发技术角度理解的迭代开发任务。 简单环境：可直接把产品订单项分配到迭代中 复杂环境：可把一个产品订单项分为Web/后台……软件/硬件……程序/美工……等开发任务 可工作软件是可交付的软件产品。 “可交付”应视不同情况前提设定和选定交付标准 正式产品可能包括使用文档，在新产品开发初期可能只需要交付勉强看到效果的产品 Scrum活动： 敏捷规划与可视化管理 实行两级项目规划： 将面向整个项目范围的宏观计划和面向当前下一次迭代的微观计划相结合,渐进明细地进行项目规划。 发布规划是对整个产品发布过程的展望，其结果是产生产品订单。 发布规划 定义用户故事并进行优先级划分 估算规模以及评估团队开发速度 制定发布计划 发布规划是对整个产品发布过程的展望，通常的规划周期是3～6个月。 迭代规划只是对一次迭代的展望，其结果是确定包含一次迭代中具体工作任务的迭代订单。 迭代规划 确定迭代目标并选择用户故事 将用户故事分解和细化到任务 对故事和任务进行实践估算 迭代规划将产生Scrum中提到的迭代订单，一般迭代周期为4周的时间 可视化管理： 任务白板是团队开发的晴雨表，它将团队的任务和进度可视化地展现出来。而引入电子白板可能会削减团队之间的沟通，降低团队的透明度，违背了敏捷重视人和团队的原则。 燃尽图：以图形化方式展现了剩余工作量（Y轴）与时间（X轴）的关系。 ","date":"2021-11-25 15:48:12","objectID":"https://qizhengzou.github.io/sek_base_06/:1:2","tags":["software engineering knowledge"],"title":"SEK_base_06","uri":"https://qizhengzou.github.io/sek_base_06/"},{"categories":["School courses"],"content":"6.2 软件实施、维护与演化 ","date":"2021-11-25 15:48:12","objectID":"https://qizhengzou.github.io/sek_base_06/:2:0","tags":["software engineering knowledge"],"title":"SEK_base_06","uri":"https://qizhengzou.github.io/sek_base_06/"},{"categories":["School courses"],"content":"软件交付工作 项目验收交付时，还有三项工作在等着：实施、培训、验收 项目实施 项目实施是将软件系统部署到客户方的计算机系统上，协助客户准备基础数据，使软件系统顺利上线运行。 保证软件符合需求，质量过关 全面做好测试工作（集成测试、功能测试、性能测试） 制定实施计划 要发布的代码版本、数据库创建方式、基础数据准备方式 准备好程序代码和相关文档 用户手册以及其他系统文档（如需求说明书、设计文档等） 客户培训 在系统安装完成、基础数据准备齐全之后，应该组织客户培训，使其掌握对软件系统的使用和操作。 选择合适的培训人员 经验丰富、了解业务和系统 准备好培训内容 不要临时抱佛脚 制定培训计划 与客户沟通协调，安排时间 项目验收 客户对系统进行验收测试，包括范围核实（用户需求是否全部实现）和质量核实（质量属性是否满足要求） 客户在验收报告上签字，一切尘埃落定。对于大中型项目，还会有一个签字验收仪式 ","date":"2021-11-25 15:48:12","objectID":"https://qizhengzou.github.io/sek_base_06/:2:1","tags":["software engineering knowledge"],"title":"SEK_base_06","uri":"https://qizhengzou.github.io/sek_base_06/"},{"categories":["School courses"],"content":"软件演化法则 软件变化原因： 软件的变化是不可避免的 软件在使用过程中，新的需求不断出现 商业环境在不断地变化 软件中的缺陷需要进行修复 计算机硬件和软件环境的升级需要更新现有的系统 软件的性能和可靠性需要进一步改进 关键：采取适当的策略，有效地实施和管理软件的变化！ Lehman法则： 持续变化 在用的程序持续地经历变化，或逐渐变得不可用。 递增复杂性 程序的不断修改将导致结构恶化，增加了复杂性。 程序演化法则 程序演化服从统计上的确定趋势和恒定性。 组织稳定守恒 编程项目总体活动统计上是不变的。 熟悉程度守恒 后续发行对于整个系统功能不会产生很大改变。 软件演化策略： 软件维护 为了修改软件的缺陷或者增加新功能而对软件进行修改；软件的修改通常发生在局部，一般不会改变整个结构。 软件再工程 为了避免软件本身退化而对软件的一部分进行重新设计、编码和测试，以便提高软件的可维护性和可靠性等。 ","date":"2021-11-25 15:48:12","objectID":"https://qizhengzou.github.io/sek_base_06/:2:2","tags":["software engineering knowledge"],"title":"SEK_base_06","uri":"https://qizhengzou.github.io/sek_base_06/"},{"categories":["School courses"],"content":"软件维护 软件维护类型 软件维护是软件被投入运行使用后人们对软件产品所进行的修改，变更通常是修改现有的组件或增加新的组件，一般不涉及体系结构的重大变化。 改正性维护：修改软件缺陷或不足（17%） 适应性维护：修改软件使其适应不同操作环境，主要包括硬件变化、操作系统变化或者其他支持软件变化等（18%） 完善性维护：增加或修改系统功能，使其适应业务的变化（65%） 软件维护成本 软件维护成本是很昂贵的 业务应用系统：维护费用与开发成本大体相同 嵌入式实时系统：维护费用是开发成本的四倍以上 影响维护成本的因素 团队稳定性：系统移交后开发团队会解散，人员分配到其他项目中，负责维护的人员通常不是原开发人员，需要花时间理解系统。 合同责任：维护合同一般独立于开发合同，这样开发人员有可能缺少为方便维护而写软件的动力。 人员技术水平：维护人员有可能缺乏经验，而且不熟悉应用领域。 程序年龄与结构：程序结构随年龄增加而受到破坏，不易理解和变更。 软件维护过程： ","date":"2021-11-25 15:48:12","objectID":"https://qizhengzou.github.io/sek_base_06/:2:3","tags":["software engineering knowledge"],"title":"SEK_base_06","uri":"https://qizhengzou.github.io/sek_base_06/"},{"categories":["School courses"],"content":"软件再工程 软件再工程 重新构造或编写现有系统的一部分或全部，但不改变其功能 在大型系统中某些部分需要频繁维护时，可应用软件再工程 再工程的目的是努力使系统更易于维护，系统需要被再构造和再文档化 优势： 减少风险：重新开发一个在用的系统具有很高的风险，可能会有开发问题、人员问题和规格说明问题 降低成本：再工程的成本比重新开发软件的成本要小得多 再工程过程： 源代码转换 代码从原有的程序设计语言转换到一种新语言 逆向工程 分析程序并抽取信息记录其结构和功能 程序结构改善 分析和修改程序的控制结构，使其更易读和好理解 程序模块化 重新组织程序的结构 数据再工程 改变程序处理的数据以反映程序的变更 逆向工程 逆向工程是以复原软件的规格说明和设计为目标的软件分析过程 大多数情况下，逆向工程弥补缺乏良好文档的问题 开发阶段的文档与维护阶段的文档可能是不一致的 开发阶段编写的程序文档在维护阶段是非常有用的 ","date":"2021-11-25 15:48:12","objectID":"https://qizhengzou.github.io/sek_base_06/:2:4","tags":["software engineering knowledge"],"title":"SEK_base_06","uri":"https://qizhengzou.github.io/sek_base_06/"},{"categories":["School courses"],"content":" 笔记来自2021秋哈工大深圳软件工程授课教师张永兵 软件编码、测试和质量保障 ","date":"2021-11-25 15:48:07","objectID":"https://qizhengzou.github.io/sek_base_05/:0:0","tags":["software engineering knowledge"],"title":"SEK_base_05","uri":"https://qizhengzou.github.io/sek_base_05/"},{"categories":["School courses"],"content":"5.1 软件编程 软件编程是一个复杂而迭代的过程，它不仅仅是编写代码，还应该包括代码审查、单元测试、代码优化、集成调试等一系列工作。 软件设计描述SDD(逻辑概念)—-\u003e程序代码Program code（物理实体） 软件编码是一个复杂而迭代的过程，包括程序设计(program design)和程序实现(program implementation)。 软件编码要求 正确的理解用户需求和软件设计思想 正确的根据设计模型进行程序设计 正确而高效率的编写和测试源代码 软件编码是设计的继续，会影响软件质量和可维护性。 软件编程规范的必要性 软件编码规范是与特定语言相关的描写如何编写代码的规则集合。 现实 软件全生命周期的 70% 成本是维护 软件在其生命周期中很少由原编写人员进行维护 目的 提高编码质量，避免不必要的程序错误 增强程序代码的可读性、可重用性和可移植性 ","date":"2021-11-25 15:48:07","objectID":"https://qizhengzou.github.io/sek_base_05/:1:0","tags":["software engineering knowledge"],"title":"SEK_base_05","uri":"https://qizhengzou.github.io/sek_base_05/"},{"categories":["School courses"],"content":"良好的编程实践 不要编写需要外部文档支持的代码，这样的代码是脆弱的，要确保你的代码本身读起来就很清晰。 编写自文档化的代码 唯一能完整并正确地描述代码的文档是代码本身 编写可以阅读的代码，其本身简单易懂 程序模板：注释： 学会只编写够用的注释，过犹不及，重视质量而不是数量。应该把时间花在编写不需要大量注释支持的代码上，即让代码自文档化。 好的注释解释为什么，而不是怎么样 不要在注释中重复描述代码 当你发现自己在编写密密麻麻的注释来解释代码时，需要停下来看是否存在更大的问题 想一想在注释中写什么，不要不动脑筋就输入，写完之后还要在代码的上下文中回顾一下这些注释，它们是否包含正确的信息？ 当修改代码时，维护代码周围的所有注释 形式1：由 # 开头的“真正的”注释，说明选择当前实现的原因以及这种实现的原理和难点； 形式2：文档字符串，说明如何使用包、模块、类、函数（方法），甚至包括使用示例和单元测试。 例子： 函数编写的第一条规则是短小，第二条规则是更短小。函数应该做一件事，做好这件事，并且只做这件事。 浮点运算： 一个数值的准确度反映了这个值与它所代表的数量之间的接近程度，即衡量我们得到这个数值过程中的误差。 数字的精度表示其规格的紧密程度，即能够区分所表达的数与其邻近数的程度。 数字应该使用它们的准确度相当的精度来存储，但是应该使用底层硬件所能有效支持的最大精度来操作。 大多数有尽十进制小数不能被有尽二进制小数准确表示。 $0.1_{10} = 0.1000000000000000055511151231257827021181583404541015625$ 在正常的表示范围内乘以或除以2的幂（2、4、8、16、…）永远都是精确运算，永远不会存在舍入问题 运用代码分析工具。 ","date":"2021-11-25 15:48:07","objectID":"https://qizhengzou.github.io/sek_base_05/:1:1","tags":["software engineering knowledge"],"title":"SEK_base_05","uri":"https://qizhengzou.github.io/sek_base_05/"},{"categories":["School courses"],"content":"代码审查 代码审查（Code Review）是一种用来确认方案设计和代码实现的质量保证机制，它通过阅读代码来检查源代码与编码规范的符合性以及代码的质量。 代码审查的作用 检查设计的合理性 互为 Backup 分享知识、设计、技术 增加代码可读性 处理代码中的“地雷区 缺陷检查表： 编程规范 按照具体编程语言的编码规范进行检查，包括命名规则、程序注释、缩进排版、声明与初始化、语句格式等。 面向对象设计 类的设计和抽象是否合适 是否符合面向接口编程的思想 是否使用合适的设计模式 性能方面 在出现海量数据时，队列、表、文件在传输、上载等方面是否会出现问题，是否控制如分配的内存块大小、队列长度等 对 Hashtable、Vector 等集合类数据结构的选择和设置是否合适 有无滥用 String 对象的现象 是否采用通用的线程池、对象池等高速缓存技术以提高性能 类的接口是否定义良好，如参数类型等应避免内部转换 是否采用内存或硬盘缓冲机制以提高效率？ 并发访问时的应对策略 I/O 方面是否使用了合适的类或采用良好的方法以提高性能（如减少序列化、使用 buffer 类封装流等） 同步方法的使用是否得当，是否过度使用？ 递归方法中的迭代次数是否合适（应保证在合理的栈空间范围内） 如果调用了阻塞方法，是否考虑了保证性能的措施 避免过度优化，对性能要求高的代码是否使用profile工具 资源释放处理 分配的内存是否释放，尤其在错误处理路径上（如 C/C++） 错误发生时是否所有对象被释放，如数据库连接、Socket、文件等 是否同一个对象被释放多次（如 C/C++） 代码是否保存准确的对象引用计数 程序流程 循环结束条件是否准确 是否避免了死循环的产生 对循环的处理是否合适，应考虑到性能方面的影响 线程安全 代码中所有的全局变量是否是线程安全的 需要被多个线程访问的对象是否线程安全，检查有无通过同步方法保护 同步对象上的锁是否按相同的顺序获得和释放以避免死锁，注意 错误处理代码 是否存在可能的死锁或是竞争，当用到多个锁时，避免出现类似情况：线程A获得锁1，然后锁2，线程B获得锁2，然后锁1 在保证线程安全的同时，注意避免过度使用同步，导致性能降低 数据库处理 数据库设计或SQL语句是否便于移植（注意与性能会存在冲突） 数据库资源是否正常关闭和释放 数据库访问模块是否正确封装，便于管理和提高性能 是否采用合适的事务隔离级别 是否采用存储过程以提高性能 是否采用 PreparedStatement 以提高性能 通讯方面 Socket 通讯是否存在长期阻塞问题 发送接收的数据流是否采用缓冲机制 Socket 超时处理和异常处理 数据传输的流量控制问题 JAVA对象处理 对象生命周期的处理，是否对象引用已失效可设置 null 并被回收 在对象传值和传参方面有无问题，对象的 clone 方法使用是否过度 是否大量经常地创建临时对象 是否尽量使用局部对象（堆栈对象） 在只需要对象引用的地方是否创建了新的对象实例 异常处理 每次当方法返回时是否正确处理了异常，如最简单的处理是记录日志到日志文件中 是否对数据的值和范围是否合法进行校验，包括使用断言 在出错路径上是否所有的资源和内存都已经释放 所有抛出的异常是否都得到正确的处理，特别是对子方法抛出的异常，在整个调用栈中必须能够被捕捉并处理 当调用导致错误发生时，方法的调用者应该得到一个通知 不要忘了对错误处理部分的代码进行测试，很多代码在正常情况下执行良好，而一旦出错整个系统就崩溃了？ 方法（函数） 方法的参数是否都做了校验 数组类结构是否做了边界校验 变量在使用前是否做了初始化 返回堆对象的引用，不要返回栈对象的引用 方法的 API 是否被良好定义，即是否尽量面向接口编程，以便于维护和重构 安全方面 对命令行执行的代码，需要详细检查命令行参数 WEB 类程序检查是否对访问参数进行合法性验证 重要信息的保存是否选用合适的加密算法 通讯时考虑是否选用安全的通讯方式 其他 日志是否正常输出和控制 配置信息如何获得，是否有硬编码 ","date":"2021-11-25 15:48:07","objectID":"https://qizhengzou.github.io/sek_base_05/:1:2","tags":["software engineering knowledge"],"title":"SEK_base_05","uri":"https://qizhengzou.github.io/sek_base_05/"},{"categories":["School courses"],"content":"代码重构 重构（Refactoring）是对软件内部结构的一种调整，其目的是在不改变软件功能和外部行为的前提下，提高其可理解性、可扩展性和可重用性。 什么时候不适合重构？ 代码太混乱，设计完全错误 与其重构不如重新开始 明天是Deadline 永远不要做Last-Minute-Change；应推迟重构但不可忽略，即使进入Production的代码都正确地运行。 重构的工作量显著地影响估算 一个任务的估算时间是3天，如果为了重构，就需要更多的时间。 推迟重构但不忽略，可以把重构作为一个新任务，或者安排在重构的迭代周期中完成 重构与添加新功能： 添加新功能 添加新功能时，不应该修改既有代码，只管添加新功能 重构 重构时不再添加功能，只管改进程序结构 重构和添加新功能可交替进行 糟糕的代码： 重复的代码 过长的函数（难以理解） 发散式变化 某个类因为不同的原因在不同的方向上发生变化 发散式变化指的是“一个类受多个外界变化的影响”，其基本思想是把相对不变的和相对变化相隔离，即封装变化。 霰弹式修改 发生一次改变时，需要修改多个类的多个地方 散弹式修改指的是“一种变化引发多个类的修改”，其基本思想是将变化率和变化内容相似的状态和行为放在同一个类中，即集中变化。 数据泥团 同样的两至三项数据频繁地一起出现在类和参数表中。 代码声明了某些字段，并声明了处理这些字段的方法，然后又声明了更多的字段和更多的方法，如此继续。 各组字段名以类似的子串开头或结束。 如果项是类中的字段，则使用抽取类将其取至一个新类中； 如果值共同出现在方法的签名中，则使用引入参数对象的重构方法以抽取新对象； 查看这些项的使用：通常可以利用移动方法等重构技术，从而将这些使用移至新的对象中。 幼稚的数据类 类仅有字段构成，或者只有简单的赋值方法和取值方法构成。 抽取方法： 引入解释性变量： 简化条件表达式 ","date":"2021-11-25 15:48:07","objectID":"https://qizhengzou.github.io/sek_base_05/:1:3","tags":["software engineering knowledge"],"title":"SEK_base_05","uri":"https://qizhengzou.github.io/sek_base_05/"},{"categories":["School courses"],"content":"5.2 软件测试 ","date":"2021-11-25 15:48:07","objectID":"https://qizhengzou.github.io/sek_base_05/:2:0","tags":["software engineering knowledge"],"title":"SEK_base_05","uri":"https://qizhengzou.github.io/sek_base_05/"},{"categories":["School courses"],"content":"软件测试概述 软件缺陷术语 术语解释： 错误（Error）：在软件生存期内的不希望或不可接受的人为错误，其结果是导致软件缺陷的产生。 缺陷（Defect）：软件缺陷是存在于软件产品之中的那些不希望或不可接受的偏差，其结果是软件运行于某一特定条件时出现故障。 故障（Fault）：软件运行过程中出现的一种不希望或不可接受的内部状态，若无适当措施（容错）加以及时处理，便产生软件失效。 失效（Failure）：软件运行时产生的一种不希望或不可接受的外部行为结果。 缺陷激活故障，故障演变为失效 软件测试概念 IEEE：测试是使用人工和自动手段来运行或检测某个系统的过程，其目的在于检验系统是否满足规定的需求或弄清预期结果与实际结果之间的差别。 该定义明确提出了软件测试以“检验是否满足需求”为目标。 软件测试的两种思维 正向思维：验证软件正常工作 逆向思维：假定软件有缺陷 软件测试的目的 直接目标：发现软件错误 期望目标：检查系统是否满足需求 附带目标：改进软件过程 测试的局限性 测试的不彻底性 测试的不完备性 测试作用的间接性 用Venn Diagram来理解测试： 软件测试基本原则 缺陷的集群性： 软件错误具有聚集性，对存在错误的部分应重点测试。 杀虫剂悖论： 用同样的测试用例多次重复进行测试，最后将不再能够发现新的缺陷。 测试用例需要定期评审和修改，同时要不断增加新的不同测试用例来测试软件的不同部分，从而发现更多潜在的缺陷 软件测试团队 软件测试团队的任务： 软件测试与质量保证合二为一 举例：微软研发团队：","date":"2021-11-25 15:48:07","objectID":"https://qizhengzou.github.io/sek_base_05/:2:1","tags":["software engineering knowledge"],"title":"SEK_base_05","uri":"https://qizhengzou.github.io/sek_base_05/"},{"categories":["School courses"],"content":"软件测试策略 软件测试对象 软件测试并不等于程序测试，应贯穿于软件定义与开发的各个阶段。 测试对象包括： 需求规格说明 设计规格说明 源程序 软件测试过程 计划 识别测试需求 分析质量风险 拟定测试方案 制定测试计划 准备 组织测试团队 设计测试用例 开发工具和脚本 准备测试数据 执行 获得测试版本 执行和实施测试 记录测试结果 跟踪和管理缺陷 报告 分析测试结果 评价测试工作 提交测试报告 软件测试类型 测试对象角度（单元、集成、系统、验收、回归） 单元测试 单元测试（Unit Testing）是对软件基本组成单元进行的测试，其测试对象是软件设计的最小单位（模块或者类）。 单元测试一般由编写该单元代码的开发人员执行，用于检测被测代码的功能是否正确。 单元测试环境 驱动模块(driver)：模拟被测模块的上一级模块，接收测试数据，把这些数据传送给所测模块，最后再输出实际测试结果； 桩模块(stub)：模拟被测单元需调用的其他函数接口，模拟实现子函数的某些功能 集成测试 集成测试（Integration Testing）是在单元测试的基础上，将所有模块按照总体设计的要求组装成为子系统或系统进行的测试。 一次性集成方式：分别测试每个单元，再一次性将所有单元组装在一起进行测试。 渐增式集成方式：先对某几个单元进行测试，然后将这些单元逐步组装成较大的系统，在组装过程中边连接边测试 集成测试的对象是模块间的接口，其目的是找出在模块接口上，包括系统体系结构上的问题。 整体集成方式(非增量式集成) 把所有模块按设计要求一次全部组装起来，然后进行整体测试 优点： 效率高，所需人力资源少； 测试用例数目少，工作量低； 简单，易行； 缺点： 可能发现大量的错误，难以进行错误定位和修改； 即使测试通过，也会遗漏很多错误； 测试和修改过程中，新旧错误混杂，带来调试困难； 自顶向下的增量集成： 从主控模块开始，按软件的控制层次结构，以深度优先或广度优先的策略，逐步把各个模块集成在一起。 优点：能尽早地对程序的主要控制和决策机制进行检验，因此较早地发现错误；较少需要驱动模块； 缺点：所需的桩模块数量巨大；在测试较高层模块时，低层处理采用桩模块替代，不能反映真实情况，重要数据不能及时回送到上层模块，因此测试并不充分； 自底向上的集成测试： 从软件结构最底层的模块开始组装测试 优点：不用桩模块，测试用例的设计亦相对简单； 缺点：程序最后一个模块加入时才具有整体形象，难以尽早建立信心。 系统测试： 系统测试（System Testing）是在实际运行环境或模拟实际运行环境下，针对系统的非功能特性所进行的测试，包括负载测试、性能测试、压力测试、恢复测试、安全测试和可靠性测试等。 恢复测试(Recovery Testing) 恢复测试是检验系统从软件或者硬件失败中恢复的能力，即采用各种人工干预方式使软件出错，而不能正常工作，从而检验系统的恢复能力。 恢复性测试的例子 当供电出现问题时的恢复 恢复程序的执行 对选择的文件和数据进行恢复 恢复处理日志方面的能力 通过切换到一个并行系统来进行恢复 安全性测试(Security Testing)： 安全性测试检查系统对非法侵入的防范能力。 安全性测试期间，测试人员假扮非法入侵者，采用各种办法试图突破防线。 安全性测试的例子 想方设法截取或破译口令 专门定做软件破坏系统的保护机制 故意导致系统失败，企图趁恢复之机非法进入 试图通过浏览非保密数据，推导所需信息 压力测试(Press Testing)： 压力测试是检查系统在资源超负荷情况下的表现，特别是对系统的处理时间有什么影响。 压力测试的例子 对于一个固定输入速率(如每分钟120 个单词)的单词处理响应时间 在一个非常短的时间内引入超负荷的数据容量 成千上万的用户在同一时间从网上登录到系统 引入需要大量内存资源的操作 压力测试采用边界值和错误猜测方法，且需要工具的支持。 性能测试(Performance Testing) 在实际应用的环境下系统性能的表现 常与压力测试一起进行 验收测试： 验收测试是在软件产品完成了功能测试和系统测试之后、产品发布之前所进行的软件测试活动，其目的是验证软件的功能和性能是否能够满足用户所期望的要求 回归测试： 在软件生命周期中的任何一个阶段，只要软件发生了改变，就可能给该软件带来问题。 为了验证修改的正确性及其影响就需要进行回归测试。 测试技术角度 黑盒测试（功能测试） 又称功能测试，它将测试对象看做一个黑盒子，完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。 白盒测试（结构测试） 又称结构测试，它把测试对象看做一个透明的盒子，允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。 程序执行角度 静态测试 静态测试：通过人工分析或程序正确性证明的方式来确认程序正确性。 动态测试 动态测试：通过动态分析和程序测试等方法来检查程序执行状态，以确认程序是否有问题。 人工干预角度 手工测试 手工测试：测试人员根据测试大纲中所描述的测试步骤和方法，手工地输入测试数据并记录测试结果。 自动化测试 自动化测试：相对于手工测试而言，主要是通过所开发的软件测试工具、脚本等手段，按照测试工程师的预定计划对软件产品进行的自动测试。 自动化测试只是对手工测试的一种补充，但绝不能代替手工测试，二者有各自的特点。 在系统功能逻辑测试、验收测试、适用性测试、涉及物理交互性测试时，多采用黑盒测试的手工测试方法； 单元测试、集成测试、系统负载或性能、稳定性、可靠性测试等比较适合采用自动化测试； 对那种不稳定软件的测试、开发周期很短的软件、一次性的软件等不适合自动化测试； 工具本身并没有想象力和灵活性，一般自动化测试只能发现15~30%的缺陷，而手工测试可以发现70~85%的缺陷；自动化测试工具在进行功能测试时，其准确的含义是回归测试工具 测试的V模型：测试用例 设计良好的测试用例： 降低软件测试成本 保证测试工作质量 评估和检验测试效果 测试用例(testing case)： 测试用例是为特定的目的而设计的一组测试输入、执行条件和预期的结果。 测试用例是执行的最小测试实体。 测试用例就是设计一个场景，使软件程序在这种场景下，必须能够正常运行并且达到程序所设计的执行结果。 测试用例的特征： 最有可能抓住错误的； 不是重复的、多余的； 一组相似测试用例中最有效的； 既不是太简单，也不是太复杂。 测试用例的重要性： 指导人们系统地进行测试 临时性发挥也许会有灵感出现，但是多数情况下会感觉思维混乱，甚至一些功能根 本没有测到而另一些功能已经重复测过几遍。 测试用例可以帮助你理清头绪，进行比较系统的测试，不会有太多的重复，也不会 让你的测试工作产生遗漏。 有效发现缺陷，提高测试效率 测试不可能是完备的而且受到时间约束，测试用例可以帮助你分清先后主次，从而更有效地组织测试工作。 编写测试用例之后需要标识重要程度和优先级，以便在时间紧迫的情况下有重点地开展测试工作。 作为评估和检验的度量标准 测试用例的通过率和软件缺陷的数量是检验软件质量的量化标准，通过对测试用例的分析和改进可以逐步完善软件质量，不断提高测试的水平。 测试用例也可以用于衡量测试人员的工作量、进度和效率，从而更有效地管理和规划测试工作。 积累和传递测试的经验与知识 测试用例不是简单地描述一种具体实现，而是描述处理具体问题的思路。设计和维护测试用例有助于人们不断积累经验和知识，通过复用测试用例可以做到任何人实现无品质差异的测试。 测试用例设计要求： 具有代表性和典型性 寻求系统设计和功能设计的弱点 既有正确输入也有错误或异常输入 考虑用户实际的诸多使用场景 ","date":"2021-11-25 15:48:07","objectID":"https://qizhengzou.github.io/sek_base_05/:2:2","tags":["software engineering knowledge"],"title":"SEK_base_05","uri":"https://qizhengzou.github.io/sek_base_05/"},{"categories":["School courses"],"content":"5.3 白盒测试 测试的技术就是设计一组测试用例 执行每个软件构件的内部逻辑和接口 测试程序的输入和输出域以发现程序功能、行为和性能方面的错误 利用“白盒”测试用例设计技术执行程序内部逻辑 白盒测试(又称为“结构测试”或“逻辑驱动测试”) 把测试对象看做一个透明的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。 目的： 白盒测试主要对程序模块进行如下的检查： 对模块的每一个独立的执行路径至少测试一次； 对所有的逻辑判定的每一个分支(真与假)都至少测试一次； 在循环的边界和运行界限内执行循环体； 测试内部数据结构的有效性； 错误隐藏在角落里，聚集在边界处 过程： ————–5.3p11 ","date":"2021-11-25 15:48:07","objectID":"https://qizhengzou.github.io/sek_base_05/:3:0","tags":["software engineering knowledge"],"title":"SEK_base_05","uri":"https://qizhengzou.github.io/sek_base_05/"},{"categories":["School courses"],"content":"白盒测试方案 白盒测试方案技术之一：逻辑覆盖 语句覆盖 判定覆盖(分支覆盖) 条件覆盖 判定/条件覆盖 条件组合覆盖 白盒测试方案技术之二：控制结构测试 ","date":"2021-11-25 15:48:07","objectID":"https://qizhengzou.github.io/sek_base_05/:3:1","tags":["software engineering knowledge"],"title":"SEK_base_05","uri":"https://qizhengzou.github.io/sek_base_05/"},{"categories":["School courses"],"content":"基本路径测试 ","date":"2021-11-25 15:48:07","objectID":"https://qizhengzou.github.io/sek_base_05/:4:0","tags":["software engineering knowledge"],"title":"SEK_base_05","uri":"https://qizhengzou.github.io/sek_base_05/"},{"categories":["School courses"],"content":"5.4 黑盒测试 黑盒测试方法 (等价类测试和边界值测试都是面向数据的测试) 等价类测试 等价类：将程序的输入划分为若干个数据类，从中生成测试用例。并合理地假定“测试某等价类的代表值就等于对这一类其它值的测试”。 等价类划分原则： 分而不交：划分出的任意两个等价类之间不存在交集-\u003e测试无冗余 合而不变：所有等价类的并集仍然是原始的输入域-\u003e测试无漏洞 类内等价：任意一个等价类中，所有数据相互“等价”-\u003e以一代全 PDF上几个例子p28 边界值测试 经过长期的测试工作经验表明，在输入域的边界或边界附近，常常会发现大量缺陷 边界值测试倾向于选择系统边界或边界附近的数据来设计测试用例 场景法测试 基本流:系统从初始态到终止态的最主要的业务流程。测试中至少要确保系统基本流的执行是完全正确的。 完整的业务流程 备选流:备选事件流，以基本流为基础，在基本流所经过的每个判定节点处满足的不同触发条件而导致的其他事件流 仅为业务流程的执行片段 例子ATM机取款见PDF ","date":"2021-11-25 15:48:07","objectID":"https://qizhengzou.github.io/sek_base_05/:5:0","tags":["software engineering knowledge"],"title":"SEK_base_05","uri":"https://qizhengzou.github.io/sek_base_05/"},{"categories":["School courses"],"content":"5.5 变异测试 ","date":"2021-11-25 15:48:07","objectID":"https://qizhengzou.github.io/sek_base_05/:6:0","tags":["software engineering knowledge"],"title":"SEK_base_05","uri":"https://qizhengzou.github.io/sek_base_05/"},{"categories":["School courses"],"content":"5.6 性能测试 ","date":"2021-11-25 15:48:07","objectID":"https://qizhengzou.github.io/sek_base_05/:7:0","tags":["software engineering knowledge"],"title":"SEK_base_05","uri":"https://qizhengzou.github.io/sek_base_05/"},{"categories":["School courses"],"content":" 笔记来自2021秋哈工大深圳软件工程授课教师张永兵 软件设计 ","date":"2021-11-25 15:48:03","objectID":"https://qizhengzou.github.io/sek_base_04/:0:0","tags":["software engineering knowledge"],"title":"SEK_base_04","uri":"https://qizhengzou.github.io/sek_base_04/"},{"categories":["School courses"],"content":"软件工程开发方法与软件设计 ","date":"2021-11-25 15:48:03","objectID":"https://qizhengzou.github.io/sek_base_04/:1:0","tags":["software engineering knowledge"],"title":"SEK_base_04","uri":"https://qizhengzou.github.io/sek_base_04/"},{"categories":["School courses"],"content":"软件工程开发方法 传统开发方法 功能分解法 以系统需要提供的功能为中心来组织系统 首先定义各种功能，然后把功能分解为子功能 对较大的子功能进一步分解，直到可给出明确的定义 设计功能/子功能所需要的数据结构 定义功能/子功能之间的接口 作为一种早期的建模方法，没有明确地区分分析与设计 功能分解法的优缺点: 直接地反映用户的需求所以工作很容易开始 不能直接地映射问题域很难检验结 果的正确性 对需求变化的适应能力很差 局部的错误和修改很容易产生全局性的影响 功能分解法得到的系统模型：由模块及其接口构成 结构化方法：使用结构化编程、结构化分析和结构化设计技术的系统开发方法 结构化分析 结构化分析又称数据流法，其基本策略是跟踪数据流，即研究问题域中数据如何流动，以及在各个环节上进行何种处理，从而发现数据流和加工。得到的分析模型是数据流图，主要模型元素是数据流、加工、文件及端点，外加处理说明和数据字典。 结构化设计 与功能分解法基本相同，基于模块的概念建立设计模型，分为概要设计和详细设计 从功能的观点设计系统 自顶向下，逐步分解和细化 将大系统分解为若干模块，主程序调用这些模块实现完整的系统功能 结构化编程 具有一个开始和一个结束的程序或程序模块，并且在程序执行中的每一步都由三个部分之一组成：顺序、选择或循环结构 结构化需求分析方法通常需建立以下模型： 数据流图(Data Flow Diagram, DFD) 描述系统由哪些部分组成、各部分之间有什么联系等 数据字典(Data Dictionary, DD) 定义了数据流图中每一个数据元素 结构化语言(Structured Language) 判定表或判定树(Decision Table/Tree) 详细描述数据流图中不能被再分解的每一个加工的内部处理逻辑 实体联系图(Entity-Relationship Diagram, E-R) 状态转换图(State Transition Diagram, STD) 结构化方法的常见问题 需求的错误 不完整、不一致、不明确 开发人员和用户无法以同样的方式说明需求 需求分析方法与设计方法不一致，分析的结果不能平滑过渡到设计 需求的变化 需求在整个项目过程中始终发生变化 系统功能不断变化 许多变化出现在项目后期 维护过程中发生许多变化 系统结构的崩溃 系统在不断的变化中最终变得不可用 造成上述问题的根本原因： 结构化方法以功能分解和数据流为核心，但是系统功能和数据表示极有可能发生变化； 以ATM银行系统为例：帐户的可选项、利率的不同计算方式、ATM的不同界面 信息建模法 由实体-关系法（E-R方法）发展而来，核心概念是实体和关系。实体描述问题域中的事物，关系描述事物之间在数据方面的联系，都可以带有属性。发展之后的方法也把实体称为对象，并使用类型和子类型的概念，作为实体（对象）的抽象描述。 信息建模法已经很接近面向对象方法，因此有的文献也把它称为一种面向对象方法，但有以下差别： 强调的重点是信息建模和状态建模，而不是对象建模 实体中只有属性没有操作 只有属性的继承，不支持操作的继承 没有采用消息通讯 面向对象方法 软件工程方法： 结构化 复杂世界－\u003e复杂处理过程（事情的发生发展） 设计一系列功能（或算法）以解决某一问题 寻找适当的方法存储数据 面向对象 任何系统都是由能够完成一组相关任务的对象构成 如果对象依赖于一个不属于它负责的任务，那么就需要访问负责此任务的另一个 对象（调用其他对象的方法） 一个对象不能直接操作另一个对象内部的数据，它也不能使其它对象直接访问自 己的数据 所有的交流都必须通过方法调用 举例：五子棋游戏 面向过程（事件）的设计思路就是首先分析问题的步骤： 开始游戏，初始化画面 黑子走，绘制画面， 判断输赢，如分出输赢，跳至步骤6 白子走，绘制画面， 判断输赢，如未分出输赢，返回步骤2， 输出最后结果。 面向对象的设计思路是分析与问题有关的实体： 玩家：黑白双方，这两方的行为是一模一样的， 棋盘：负责绘制画面 规则：负责判定诸如犯规、输赢等。 举例：电话安装业务系统： 结构化分析-数据流和加工 面向对象方法—对象及其关系 什么情况下使用结构化的分析方法？ 什么情况下使用面向对象的分析方法？ 面向对象的程序开发： 软件设计应尽可能去描述那些极少发生变化的稳定要素：对象 银行客户、帐户 在结构化程序开发模式中优先考虑的是过程抽象，在面向对象开发模式中优先考虑的是实体(问题域的对象)； 主要考虑对象的行为而不是必须执行的一系列动作； 对象是数据抽象与过程抽象的综合； 算法被分布到各种实体中； 消息从一个对象传送到另一个对象； 控制流包含在各个对象的操作内； 系统的状态保存在各个对象所定义的数据抽象中； 二者本质区别： 面向过程的结构化系统 = 功能 + 数据 面向对象的系统 = 对象 + 消息 面向对象方法的优势： 面向对象模型更接近于问题域(尽可能模拟人类习惯的思维方式) 以问题域中的对象为基础建模 以对象、属性和操作对问题进行建模 反复细化高层模型直到可以实现的程度 努力避免在开发过程中出现大的概念跳变 将模型组织成对象的集合 真实世界中的具体事物 售货员、商品、仓库、顾客 飞机、机场等 逻辑概念 商品目录、生产计划、销售 操作系统中的分时策略、军事训练中的冲突解决规则等 把系统看做是一起工作来完成某项任务的相互作用的对象的集合 面向对象分析 分析和理解问题域，找出描述问题域和系统责任所需的类及对象，分析它们的内部构成和外部关系，建立OOA 模型。 面向对象设计 将OOA 模型细化，描述对象间交互，变成OOD 模型，并且补充与一些实现有关的部分，如人机界面、数据存储、操作细节等。 面向对象编程 用一种面向对象的编程语言将OOD 模型中的各个成分编写成程序，由于从OOA→OOD→OOP实现了无缝连接和平滑过渡，因此提高了开发工作的效率和质量。 OOA/D: 分析：强调的是对问题和需求的调查研究，而不是解决方案 面向对象分析过程中，强调的是在问题领域内发现和描述对象 设计：强调的是满足需求的概念上的解决方案（在软件方面和硬件方面），而不是其实现。 面向对象设计过程中，强调的是定义软件对象以及它们如何协作以实现需求。 有价值的分析和设计可以概括为：做正确的事（分析）和正确地做事（设计） 面向对象的基本概念： 对象(Object) 类(Class) 继承(Inheritance) 多态(Polymorphism) 消息(Message) 对象（具体。有意义的个体）： 对象(Object)：具有责任的实体。一个特殊的，自成一体的容器，对象的数据对于外部对象是受保护的。 特性：标识符（区别其他对象）、属性（状态）和操作（ 行为）。 属性(Attribute)：与对象关联的数据，描述对象静态特性； 操作(Operation)：与对象关联的函数，描述对象动态特性； 示例 学生：王洪波 属性：姓名，性别，年级，院系；年级 = “2013” 操作：选课、撤销、支付 对象是类的实例 对象与其他对象之间发生关联关系 但这个关联关系要定义为类之间的关系注意将属性划归正确的类 类： 具有相同性质、行为、对象关系、语义的对象集合 具有相同属性和操作的一组对象的抽象，它为属于该类的全部对象提供了统一的抽象描述 类是概念定义，抽象了同类对象共同的属性和操作 对象是类的一个实例 类与对象的比较 “同类对象具有相同的属性和操作”是指它们的定义形式相同，而不是说每个对象的属性值都相同。 类是静态的，类的存在、语义和关系在程序执行前就已经定义好了。 对象是动态的，对象在程序执行时可以被创建和删除。 类的属性的“可见性”(Visibility)分类： 公有属性(public) + 私有属性(private) - 保护属性(protected) # 封装(Encapsulation)：把对象的属性和操作结合成一个独立的单元，并尽可能对外界隐藏数据的实现过程，隐藏实现细节； 封装的重要意义： 保护对象，避免用户误用； 保护客户端(调用程序)，其实现过程的改变 不会影响到相应客户端的改变。 封装带来的问题： 编程的麻烦 执行效率的损失 解决办法： 不强调严格封装， 实行可见性控制。 消息(Message)： 消息传递是对象间通信的手段 通过消息请求/提供服务 一个对象向另一个对象发送消息来请求其服务 消息描述：接收对象名、操作名和参数 消息类型 同步消息，请求者需要等待响应者返回 异步消息，请求者发出消息后继续自己工作，无需等待响应者返回 消息是实现对象间交互和协同的方法 泛化（Generalization）/继承（Inheritance）： 泛化关系是类元的一般描述和具体描述之间的关系，具体描述建立在一般描述的基础之上，并对其进行了扩展。 在共享祖先所定义的成分的前提下允许它自身定义增加的描述，这被称作继承。 表示类与类之间的一般与特殊关系 子 (特殊)类可以继承共享父 (一般)类的属性和操作 单一继承：一个子类只有唯一的一个父类 多重继承：一个子类有一个以上的父类 Java不支持多重继承 继承可形成层次化的类结构 多态(Polymorphism)： 同一个操作作用于不同的对象上可以有不同的解释，并产生不同的执行结果。 接口定义形式相同，但是实现形态不一样 相同的消息发送给不同的对象时，每个对象将根据自己所属类中定义的这个操作去执行，从而产生不同的结果 多态支持对外接口统一化，但实现方式多样化 ","date":"2021-11-25 15:48:03","objectID":"https://qizhengzou.github.io/sek_base_04/:1:1","tags":["software engineering knowledge"],"title":"SEK_base_04","uri":"https://qizhengzou.github.io/sek_base_04/"},{"categories":["School courses"],"content":"软件设计 设计的概念 设计=天才+创造力 良好的软件设计的三个特征 目标：设计必须是实现所有包含在分析模型中的明确需求、以及客户期望的所有隐含需求 形态：对开发、测试和维护人员来说，设计必须是可读的、可理解的、可操作的指南 内容：设计必须提供软件的全貌，从实现的角度去说明功能、数据、行为等各个方面 “软件设计”的定义： 设计：为问题域的外部可见行为的规约增添实际的计算机系统实现所需的细节，包括关于人机交互、任务管理和数据管理的细节。 ——Coad/Yourdon 软件设计在SE中所处的位置： 设计的目标：质量 “设计阶段”是软件工程中形成质量的关键阶段，其后所有阶段的活动都要依赖于设计的结果。 “编写一段能工作的灵巧的代码是一回事，而设计能支持某个长久业务的东西则完全是另一回事。” 软件质量 外部质量：面向最终用户 如易用性、效率、可靠性、正确性、完整性等 内部质量：面向软件工程师，技术的角度 如可维护性、灵活性、可重用性、可测试性等 设计的原则 软件设计的原则 设计原则是系统分解和模块设计的基本标准，应用这些原则可以使代码更加灵活、易于维护和扩展。 抽象： 抽象是关注事物中与问题相关部分而忽略其他无关部分的一种思考方法 封装： 封装和信息隐藏是指每个软件单元对其他所有单元都隐藏自己的设计决策， 各个单元的特性通过其外部可见的接口来描述。 要求：应将单元接口设计得尽可能简单，并将单元对于环境的假设和要求降至最低。 模块化： 模块化是在逻辑和物理上将整个系统分解成多个更小的部分，其实质是“分而治之”，即将一个复杂问题分解成若干个简单问题，然后逐个解决。 系统分解原则： 系统分解的目标：高内聚、低耦合 内聚性尽量将同一个功能的模块彼此之间的通信都能放在模块内部封装起来。 如果一个模块或子系统含有许多彼此相关的元素，并且它们执行类似任务，那么其内聚性比较高；如果一个模块或子系统含有许多彼此不相关的元素，其内聚性就比较低。 耦合性两个模块或子系统之间依赖关系的强度。 如果两个模块或子系统是松散耦合的，二者相互独立，那么当其中一个发生变化时对另一个产生的影响就很小；如果两个模块或子系统是紧密耦合的，其中一个发生变化就可能对另一个产生较大影响。 层次化： 分层（Layering） 每一层可以访问下层，不能访问上层 封闭式结构：每一层只能访问与其相邻的下一层 开放式结构：每一层还可以访问下面更低的层次 层次数目不应超过7±2层 复用： 复用（Reuse）是利用某些已开发的、对建立新系统有用的软件元素来生成新的软件系统，其好处在于提高生产效率，提高软件质量。 源代码复用：对构件库中的源代码构件进行复用 软件体系结构复用：对已有的软件体系结构进行复用 框架复用：对特定领域中存在的一个公共体系结构及其构件进行复用 设计模式：通过为对象协作提供思想和范例来强调方法的复用 ","date":"2021-11-25 15:48:03","objectID":"https://qizhengzou.github.io/sek_base_04/:1:2","tags":["software engineering knowledge"],"title":"SEK_base_04","uri":"https://qizhengzou.github.io/sek_base_04/"},{"categories":["School courses"],"content":"体系结构设计 ","date":"2021-11-25 15:48:03","objectID":"https://qizhengzou.github.io/sek_base_04/:2:0","tags":["software engineering knowledge"],"title":"SEK_base_04","uri":"https://qizhengzou.github.io/sek_base_04/"},{"categories":["School courses"],"content":"软件体系结构要素 随着软件系统的规模和复杂性不断增加，对系统的全局结构设计和规划变得比算法的选择和数据结构的设计明显重要得多。 软件体系结构概念 软件体系结构（Software Architecture）包括 构成系统的设计元素的描述 设计元素之间的交互 设计元素的组合模式以及在这些模式中的约束。 软件体系结构 = 构件 + 连接件 + 约束 构件(Component)： 构件是具有某种功能的可复用的软件结构单元，表示系统中主要的计算元素和数据存储。 构件是一个抽象的概念，任何在系统运行中承担一定功能、发挥一定作用的软件体都可看作是构件。 构件特点 可分离：一个或数个可独立部署执行代码文件 可替换：构件实例可被其他任何实现了相同接口的另一构件 实例所替换 可配置：外界可通过规范化的配置机制修改构件配置数据， 进而影响（或称“定制”）构件的对外服务的功能或行为 可复用：构件可不经源代码修改，无需重新编译，即可应用 于多个软件项目或软件产品 构件组成 接口 构件接口是构件间的契约 一个接口提供一种服务，完成某种逻辑行为 构件作为一个封装的实体，只能通过其接口(Interface)与外部环境交互，表示了构件和外部环境的交互点，内部具体实现则被隐藏起来(Black-box)； 实现（功能） 构件接口服务的实现 构件核心逻辑实现 构件内部所实现的功能以方法、操作(functions、behaviors)的形式体现出来，并通过接口向外发布，进而产生与其它构件之间的关联。 构件接口与其内部实现应严格分开 连接： 连接(Connection)：构件间建立和维护行为关联与信息传递的途径； 机制：过程调用、中断、I/O、事件、进程、线程、共享、同步、并发、消息、远程调用、动态连接、API 等等 协议(Protocol)（是连接的规约(Specification)，连接的规约是建立在物理层之上的有意义信息形式的表达规定）： 对过程调用来说：参数的个数和类型、参数排列次序 对消息传送来说：消息的格式 目的：使双方能够互相理解对方所发来的信息的语义。 除了连接机制/协议的实现难易之外，影响连接实现复杂性的因素之一是“有无连接的返回信息和返回的时间”，分为： 同步 (Synchronous) 异步 (Asynchronous) 约束： 高层次的软件元素可以向低层次软件元素发出请求，低层次软件元素完成计算后向高层次发送服务应答，反之不行 每个软件元素根据其职责位于适当的层次，不可错置，如核心层不能包含界面输入接收职责 每个层次都是可替换的，一个层次可以被实现了同样的对外服务接口的层次所替代 软件体系结构的目标 软件体系结构关注的是： 如何将复杂的软件系统划分为模块、如何规范模块的构成和性能、以及如何将这些模块组织为完整的系统。 主要目标： 建立一个一致的系统及其视图集，并表达为最终用户和软件设计者需要的结构形式，支持用户和设计者之间的交流与理解。 ","date":"2021-11-25 15:48:03","objectID":"https://qizhengzou.github.io/sek_base_04/:2:1","tags":["software engineering knowledge"],"title":"SEK_base_04","uri":"https://qizhengzou.github.io/sek_base_04/"},{"categories":["School courses"],"content":"软件体系结构风格 定义： 描述特定领域中软件系统家族的组织方式的惯用模式，反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个模块和子系统有效地组织成一个完整的系统。 数据流风格 管道-过滤器风格： 把系统任务分成若干连续的处理步骤，这些步骤由通过系统的数据流连接，一个步骤 的输出是下一个步骤的输入。 每个过滤器独立于其上游和下游的构件而工作，过滤器的设计要针对某种形式的数据 输入，并且产生某种特定形式的数据输出（到下一个过滤器）。过滤器没有必要了解 与之相邻的其他过滤器的工作。 把系统任务分成若干连续的处理步骤，这些步骤由通过系统的数据流连接，一个步骤 的输出是下一个步骤的输入。 每个过滤器独立于其上游和下游的构件而工作，过滤器的设计要针对某种形式的数据 输入，并且产生某种特定形式的数据输出（到下一个过滤器）。过滤器没有必要了解 与之相邻的其他过滤器的工作。 在管道过滤器风格中构件具有良好的隐藏性和高内聚、低耦合的特点，可以很好地支持软件的重用和扩展但是这种结构不适合交互应用的情况，如果管道过长或者过滤器过于复杂的话系统的性能就会大大降低 以数据为中心的风格（仓库） 例：剪贴板 (Clipboard) 剪贴板是一个用来进行短时间的数据存储并在文档/应用之间进行数据传递和交换的软件程序 用来存储待传递和交换信息的公共区域(形成共享数据仓库)； 访问剪贴板的方式：copy \u0026 paste. 不同的应用程序通过该区域交换格式化的信息； 以数据为中心的体系结构风格(也称仓库风格) 数据存储位于这种体系结构的中心，其他构件会经常访问该数据存储，并对存储中的数据进行更新、增加、删除或者修改。 示例：注册表 只要仓库的定义良好就可以很方便地增添功能模块，从而实现向系统添加新的服务，但是这种系统的主要问题在于每个功能模块和仓库之间的耦合非常高，集中式的仓库很有可能成为系统性能的瓶颈 调用和返回体系结构的风格 主程序-子过程： 该风格是结构化程序设计的一种典型风格，从功能的观点设计系统，通过逐步分解和逐步细化，得到系统体系结构。 构件：主程序、子程序 连接器：调用-返回机制 拓扑结构：层次化结构 本质：将大系统分解为若干模块(模块化)，主程序调用这些模块实现完整的系统功能。 面向对象体系结构风格 系统被看作对象的集合，每个对象都有一个它自己的功能集合 数据及作用在数据上的操作被封装成抽象数据类型 (AbstractData Type) 只通过接口与外界交互，内部的设计决策则被封装起来 构件：类 连接件：类之间通过函数调用、消息传递实现交互 层次体系结构风格 层次化已经成为一种复杂系统设计的普遍性原则 在层次系统中，系统被组织成若干个层次，每个层次由一系列构件组成； 层次之间存在接口，通过接口形成call/return的关系 在外层，构件完成建立用户界面的操作 在内层，构件完成建立操作系统接口的操作 在中层，提供各种实用工具服务和应用软件功能 很多复杂软件的设计从操作系统到网络系统再到一般的应用几乎都是以层次结构来建立的 下层构件向上层构件提供服务，上层构件被看作是下层构件的客户端 层次系统的优点 这种风格支持基于可增加抽象层的设计，允许将一个复杂问题分解成一个增量步骤序列的实现。 由于每一层最多只影响两层，同时只要给相邻层提供相同的接口，允许每层用不同的方法实现，同样为软件复用提供了强大的支持。 不同的层次处于不同的抽象级别： 越靠近底层，抽象级别越高； 越靠近顶层，抽象级别越低； 严格分层和松散分层 严格分层系统要求严格遵循分层原则，限制一层中的构件只能与对等实体以及与它紧邻的下面一层进行交互 优点：修改时的简单性 缺点：效率低下 松散的分层应用程序放宽了此限制，它允许构件与位于它下面的任意层中的组件进行交互 优点：效率高 缺点：修改时困难 层次体系结构风格： 客户机-服务器（C/S） 客户机/服务器(Client/Server, C/S)：一个应用系统被分为两个逻辑上分离的部分，每一部分充当不同的角色、完成不同的功能，多台计算机共同完成统一的任务。 客户机(前端，front-end)：用户交互、业务逻辑、与服务器通讯的接口； 服务器(后端，back-end)：与客户机通讯的接口、业务逻辑、数据管理。 一般的，客户机为完成特定的工作向服务器发出请求；服务器处理客户机的请求并返回结果。 三层客户机/服务器(Client/Server, C/S)体系结构：在客户端与数据库服务器之间增加了一个中间层 表示层：用户界面—界面设计 业务逻辑层：业务处理—程序设计 数据层：数据存储—数据库设计 胖客户端与瘦客户端：在客户端多一些还是在服务器端多一些？ 胖客户端：客户端执行大部分的数据处理操作 瘦客户端：客户端具有很少或没有业务逻辑 浏览器-服务器（B/S） 浏览器/服务器(Browser/Server)是四层C/S风格的一种实现方式 。 表现层：浏览器 逻辑层： Web服务器 应用服务器 数据层：数据库服务器 示例： 浏览器/服务器(Browser/Server)：基于B/S体系结构的软件，系统安装、修改和维护全在服务器端解决，系统维护成本低： 客户端无任何业务逻辑，用户在使用系统时，仅仅需要一个浏览器就可运行全部的模块，真正达到了“零客户端”的功能，很容易在运行时自动升级。 良好的灵活性和可扩展性：对于环境和应用条件经常变动的情况，只要对业务逻辑层实施相应的改变，就能够达到目的。 B/S成为真正意义上的“瘦客户端”，从而具备了很高的稳定性、延展性和执行效率。 B/S将服务集中在一起管理，统一服务于客户端，从而具备了良好的容错能力和负载平衡能力。 C/S,B/S混合模式 C/S+B/S混合模式：为了克服C/S与B/S各自的缺点，发挥各自的优点，在实际应用中，通常将二者结合起来 遵循“内外有别”的原则： 企业内部用户通过局域网直接访问数据库服务器 C/S结构； 交互性增强； 数据查询与修改的响应速度高； 企业外部用户通过Internet访问Web 服务器/应用服务器 B/S结构； 用户不直接访问数据，数据安全； ","date":"2021-11-25 15:48:03","objectID":"https://qizhengzou.github.io/sek_base_04/:2:2","tags":["software engineering knowledge"],"title":"SEK_base_04","uri":"https://qizhengzou.github.io/sek_base_04/"},{"categories":["School courses"],"content":"类/数据建模与设计 ","date":"2021-11-25 15:48:03","objectID":"https://qizhengzou.github.io/sek_base_04/:3:0","tags":["software engineering knowledge"],"title":"SEK_base_04","uri":"https://qizhengzou.github.io/sek_base_04/"},{"categories":["School courses"],"content":"CRC卡片分拣法-面向对象方法 识别类的方法 使用CRC寻找类。 CRC是类 (Class) 、责任 (Responsibility) 和协作(Collaboration)的简称，CRC分析法根据类所要扮演的职责来确定类。 根据边界类、控制类和实体类的划分来帮助发现系统中的类 对领域进行分析，或利用已有的领域分析结果得到类 参考分析、设计模式来确定类 Blackjack游戏： 通过名词过滤识别出的对象类 类筛选 确定初始类 识别类的功能职责 ","date":"2021-11-25 15:48:03","objectID":"https://qizhengzou.github.io/sek_base_04/:3:1","tags":["software engineering knowledge"],"title":"SEK_base_04","uri":"https://qizhengzou.github.io/sek_base_04/"},{"categories":["School courses"],"content":"DFD-结构化方法 结构化需求分析方法通常需建立以下模型： 数据流图(Data Flow Diagram, DFD) 描述系统由哪些部分组成、各部分之间有什么联系等 数据字典(Data Dictionary, DD) 定义了数据流图中每一个数据元素 结构化语言(Structured Language) 判定表或判定树(Decision Table/Tree) 详细描述数据流图中不能被再分解的每一个加工的内部处理逻辑 实体联系图(Entity-Relationship Diagram, E-R) 状态转换图(State Transition Diagram, STD) 数据流图(Data Flow Diagram, DFD)：结构化系统分析的基本工具 描绘数据在系统中各逻辑功能模块之间的流动和处理过程，是一种功能模型 主要刻画“功能的输入和输出数据”、“数据的源头和目的地” DFD的主要元素： 加工(又称数据处理，data processing)：对数据流进行某些操作或变换。 收集、排序、选择、聚集、分析等 加工要有名字，通常是动词短语，简明地描述完成什么事情 在分层的数据流图中，加工还应编号 三种类型：计算机自动加工、手工加工、人机协作的加工 数据存储(data storage，也称文件)：需要在外存储器上保存的数据，它可以是数据库文件或任何形式的数据组织。 以名词命名 外部实体(external entity)：本系统外部环境中的实体(包括人员、组织或其他软件系统) 也称为“数据源点/数据终点”，表示产生数据的源头或消费数据的终点 以名词短语命名 不能直接访问数据存储 数据流(data flow)：数据在系统内传播的路径 由一组成分固定的数据组成。 由于数据流是流动中的数据，所以必须有流向 应用名词或名词短语命名 可能是纸张上的数据、电子数据、通过网络传输的数据等 可能存在于： 外部实体与加工之间； 加工与加工之间； 加工与数据存储之间 简单练习： DFD的层次性：自顶向下的分解(top-down) DFD的两种类型： 环境关联DFD图(Context-level DFD，或Context Diagram)：也称顶层DFD图，描述了系统与外部环境之间的数据输入/输出关系； 系统内部DFD图(Inner-level DFD)：描述系统内部各功能模块之间的数据流动关系 0-层DFD图 1-层DFD图 … N层DFD图 顶层DFD图(关联图) 通过系统和外部世界之间的联系来描述系统的范围 确定了通过某一接口与系统相连的外部实体，同时也确定了外部实体和系统之间的数据流 只包含一个加工，用以表示被开发的系统，然后考虑该系统有哪些输入数据、输出数据流 加工编号：0 0层DFD: 将顶层DFD图中的系统分解为若干个子系统，决定每个子系统间的数据接口和活动关系，得到0层DFD图； 加工编号：1、2、…、n 底层DFD: 针对0层DFD中的每一个子系统，对其继续分解得到细化的加工，进而逐渐向下构造得到1层DFD、2层DFD、…、n层DFD，一直到不能或不需再分解为止。 最底层DFD中的加工称为“基本加工”。 编号： 1层DFD：1.1、1.2、…、1.n 2层DFD：1.1.1、1.1.2、…、1.1.n … 数据流的分解： 绘制DFD的一些基本原则： 把数据存储放在0层数据流图或更低层子图上，不要放在顶层的关联图上 使用数据流图时，不要试图让数据流图反映处理的顺序，忽略系统的运行时的时间特性 加工通过数据存储进行通讯，而尽量避免从一个过程直接流到另一过程 数据不能直接由一个数据存储直接流到另一个数据存储 数据不能直接从一个外部实体直接流到一个数据存储 数据不能直接从一个数据存储直接流到一个外部实体 数据不能直接在外部实体之间流动 数据流是单向的 任何加工必须有输入和输出数据流 对现有加工进行持续的分解和组合，直到所有加工之间达到较高的聚合度； 尽量将每一张DFD上的所有元素数目控制在7-12个。 错误示例： ","date":"2021-11-25 15:48:03","objectID":"https://qizhengzou.github.io/sek_base_04/:3:2","tags":["software engineering knowledge"],"title":"SEK_base_04","uri":"https://qizhengzou.github.io/sek_base_04/"},{"categories":["School courses"],"content":"行为建模与设计 ","date":"2021-11-25 15:48:03","objectID":"https://qizhengzou.github.io/sek_base_04/:4:0","tags":["software engineering knowledge"],"title":"SEK_base_04","uri":"https://qizhengzou.github.io/sek_base_04/"},{"categories":["School courses"],"content":"状态图（Statechart Diagram) 状态图(Statechart Diagram)描述了一个特定对象的所有可能状态以及由于各种事件的发生而引起的状态之间的转移。 UML的状态图 主要用于建立类的一个对象在其生存期间的动态行为，表现一个对象所经历的状态序列，引起状态转移的事件(Event),以及因状态转移而伴随的动作(Action)。 状态图适合于描述跨越多个用例的单个对象的行为，而不适合描述多个对象之间的行为协作，因此，常常将状态图与其它技术组合使用。 “状态”建模 所有的对象都有“状态” 对象存在或者不存在 对象不存在也是一种状态 如果对象存在，则具有相应表示其属性的值 每一种状态表示一种可能的状态赋值 例如：栈 状态空间：模型建立的过程——状态空间的分解 状态图建模 建模元素 状态 一个对象在生命期中满足某些条件、执行一些行为或者等待一个事件时的存在条件。 实体对象都具有状态，状态是对象执行了一系列活动的结果。当某个事件发生后，对象的状态将发生变化 状态转移 事件 特殊的状态 初始状态、结束状态 一个状态图只能有一个初始状态，一个状态图可以有多个结束状态 组合状态 历史状态 状态图的绘制 状态种类： 组合状态：可以通过状态嵌套的方式简化图表 一个组合状态可以包含一个或多个状态 组合状态可以实现从不同抽象层次去体现状态图 嵌套在另外一个状态中的状态称之为子状态（sub-state）,一个含有子状态的状态被称作组合状态（Compound States） 【Check PIN】是组合状态，【Enter PIN】是子状态。 历史状态 使用历史状态，可以记住从组合状态中退出时所处的子状态，当再次进入组合状态时，可直接进入到这个子状态，而不是再次从组合状态的初态开始。 H和H*的区别： H只记住最外层的组合状态的历史。 H*可记住任何深度的组合状态的历史。 例：这里的H只记录Backing Up的状态 状态活动： 状态相关的活动类型 do/activity 只要处于这个状态，某个活动就会一直执行，直到离开这个状态 entry/action and exit/action 当进入（/离开）某个状态时执行的动作 include/stateDiagramName 调用另一个状态图，形成嵌套的状态图 状态迁移(Transitions) 迁移包括五部分（源状态、目标状态、触发事件、警戒条件、触发事件、动作）： 转换是状态图的一个组成部分，表示一个状态到另一个状态的移动。 状态之间的转移通常是由事件触发的，此时应在转移上标出触发转移的事件表达式。如果转移上未标明事件，则表示在源状态的内部活动执行完毕后自动触发。 警戒条件: 一个true或false测试表明是否需要进行转换 当事件发生时，只有在保护条件（警戒条件）为真时才发生转换 对于给定的状态，最终只能产生一个迁移，因此从相同的状态出来的、 事件相同的几个迁移之间的条件应该是互斥的。 状态中的事件(Event): UML中事件分为四类 Call Event (调用某个操作) Change Event：when (temperature \u003e 120) Signal event (触发事件) Time event：after 5 seconds 状态图建模风格 建模风格1：把初态放置在左上角；把终态放置在右下角 建模风格2：用过去式命名转移事件 建模风格3：警戒条件不要重叠 建模风格4：不要把警戒条件置于初始转移上 状态图的检查表 绘图风格 每个状态的命名应该是唯一的，意义明确的 只对行为复杂的状态使用组合状态建模 不要在一个图中包含太多细节 使用警戒条件时要特殊注意不要引入二义性 状态图应该具有确定性（除非特殊原因） 下述情况不适宜使用状态图： 当大部分的状态转移为“当这个状态完成时” 有很多来自对象自身发出的触发事件 ","date":"2021-11-25 15:48:03","objectID":"https://qizhengzou.github.io/sek_base_04/:4:1","tags":["software engineering knowledge"],"title":"SEK_base_04","uri":"https://qizhengzou.github.io/sek_base_04/"},{"categories":["School courses"],"content":"顺序图（Sequence Diagram） 顺序图 顺序图是强调消息时间顺序的交互图 顺序图描述了对象之间传送消息的时间顺序，表示用例中的行为顺序 顺序图将交互关系表示为一个二维图。其中，纵轴是时间轴，时间沿竖线向下延伸。横轴代表了在协作中各独立的对象 顺序图用来刻画系统实现某个功能的必要步骤 顺序图的组成 对象（Object）：类的实例，以某种角色参与交互，可以是人，物，其他系统或者子系统 对象可以是系统的参与者或者任何有效的系统对象。对象是类的实例，它使用包围名称的矩形框来标记。名称带下划线。顺序图中对象的标记符如下 对象的创建与撤销 如果对象位于顺序图的顶部，说明在交互开始之前该对象已经存在了。如果对象是在交互的过程中创建的，新建的对象在图中的位置较低。 对象在创建消息发生之后才能存在，对象的生命线也是在创建消息之后才存在的。 如果要撤销一个对象，只要在其生命线终止点放置一个“X”符号即可，该点通常是对删除或取消消息的回应。 生命线（Lifeline）：表示对象存在的时间 生命线在顺序图中表示为从对象图标向下延伸的一条虚线，表示对象存在的时间 激活（Activation） ：表示对象进行操作的时间片段 控制焦点/激活期(Focus of Control/Activation)表示对象进行操作的时间片段 激活表示该对象被占用以完成某个任务，去激活指的则是对象处于空闲状态、在等待消息。 在UML中，为了表示对象是激活的，可以将该对象的生命线拓宽成为矩形。其中的矩形称为激活条或控 制期，对象就是在激活条的顶部被激活的，对象在完成自己的工作后被去激活 控制焦点/激活期(Focus of Control/Activation)的嵌套 嵌套的FOC可以更精确地说明消息的开始和结束位置 嵌套的FOC可以表示递归 顺序图中时间约束的表示 用约束(constraint)来表示 消息（Message）： 消息(Message)用于描述对象间的交互操作和值传递过程，在UML中，消息使用箭头来表示，箭头的类型表示了消息的类型。 对象之间的消息只能单路通信、消息用箭头表示 消息类型 Synchronous 同步消息（调用消息） Asynchronous 异步消息 Return 返回消息 Time-out 超时等待 Self-message 自关联消息 同步消息（调用消息） 把调用的消息发给接受者、等待接受者放弃或者返回信息、接受者返回信息之前不能发送任何别的消息、并且工作流程被中断 异步消息 简单的说就是把消息发给接受者、不用等待接受者的反馈、可以给别的对象发消息异步消息可以并发工作 用户登陆电影可视化系统，输入用户名和密码，发出登陆请求是同步消息还是异步消息？ 微信公众号向用户推送一篇文章，推送是同步消息还是异步消息 我去银行办理业务，可能会有两种方式： 选择排队等候 另种选择取一个小纸条上面有我的号码，等到排到我这一号时由柜台的人通知我轮到我去办理业务了 返回消息 发送给对象的异步消息或调用消息、对象给的反馈、称作返回消息 如果是过程调用的返回、返回消息是隐含的、所以返回消息可以不用画 出来 如果是非过程的、返回消息要明确的表示出来！ 超时消息 接受者在指定时间内无法接受此消息、则发送者放弃这个消息 自关联消息 消息发送者给自己发消息 复合片段 一个复杂的顺序图可以划分为几个小块，每一个小块称为一个复合片段。每个复合片段由一个大方框包围，其名称显示在方框左上角的间隔区内，表示该顺序图的信息。 alt:多条路径，条件为真时执行。if/else -\u003e (alt)[condition] 通过水平虚线分割不同情形。 opt:任选，仅当条件为真时执行。If -\u003e (opt)[condition] par:并行，每一片段都并发执行 loop:循环，片段可多次执行 例子： 绘制顺序图步骤 在顺序图顶端绘制矩形框，定义参与交互的类实例（对象）名； 在每个对象下面绘制竖直虚线，表示该对象的生命线； 在对象间添加箭头表示各种类型的消息，跟踪对象间的控制流； 生命线加竖直矩形定义对象激活期，表明对象正在执行某操作； 根据需要添加框的组合与关联，表示复杂的控制结构。 例子：银行系统的交易验证： 顺序图建模意义 通过顺序图描述算法逻辑 高质量的顺序图是代码的抽象 顺序图是与语言无关的表示方式 可以绘制顺序图来描述业务逻辑 可以通过团队协作完成顺序图的绘制 可以在同一页浏览多个对象和类的行为 ","date":"2021-11-25 15:48:03","objectID":"https://qizhengzou.github.io/sek_base_04/:4:2","tags":["software engineering knowledge"],"title":"SEK_base_04","uri":"https://qizhengzou.github.io/sek_base_04/"},{"categories":["School courses"],"content":"协作图（Collaboration Diagram） 协作图 协作图是交互图的另一种表现形式，它强调参加交互的各对象的组织。主要用于描述一组相互合作的对象间的交互和链接。 协作图只对相互间有交互作用的对象和这些对象间的关系建模，而忽略了其他对象和关联。 时序图主要描述对象间消息发送的时间顺序，而协作图侧重于描述交互对象之间的链接关系，而不专门突出这些消息发送的时间顺序。 协作图不像时序图一样具备时间维，为了表示消息的时间顺序，通常要为消息加一个数字前缀。 协作图由对象、链接和消息组成。 –使用实线表示两个对象间的链接 –消息由标记在连接上方的带有标记的箭头表示 例子： 时序图与协作图比较： 时序图和协作图都属于交互图，都用于描述系统中对象之间的动态关系。两者可以相互转换，但两者强调的重点不同。 –当对象及其连接有利于理解对象之间的交互时,选择协作图； –当强调消息发送的时间顺序时,选择时序图。 –时序图中有对象生命线和控制焦点，协作图中没有；协作图中有路径，并且协作图中的消息必须要有顺序号，但时序图中没有这两个特征。 实际应用中，一般采用时序图。 对比例子：","date":"2021-11-25 15:48:03","objectID":"https://qizhengzou.github.io/sek_base_04/:4:3","tags":["software engineering knowledge"],"title":"SEK_base_04","uri":"https://qizhengzou.github.io/sek_base_04/"},{"categories":["School courses"],"content":"活动图（Activity Diagram） 活动图（Activity Diagram） 一般学习过c语言或别的程序设计语言的同学一定接触过流程图，因为流程图清晰的表达了程序的每一个步骤序列、过程、判定点和分支。 在UML里，活动图本质上就是流程图，描述系统的活动、判定点、分支等，可用于对系统的业务需求建模，因此它对于开发人员来说是一种重要的工具。 UML活动图记录了单个操作或方法的逻辑，单个用户案例或者单个业务流程的逻辑。 也可以说，活动图是用图形化的方式描述事件流 (即描述用例图中某个用例的逻辑流程) 活动图的基本概念和组成 从系统内部视角来看，活动图反映的是系统功能所要完成的动作过程。它定义了工作流从何时开始、哪里开始、按什么顺序发生、最终在哪结束。 活动图由起始状态、终止状态、活动、状态转移、决策、守护条件、同步棒和泳道组成。 活动图的起始状态和终止状态的表示同状态图。 活动图中的活动用圆角四边形表示，内部文字说明采取的动作。动作间的转移用带有箭头的实线表示。 守护条件：用来约束转移，守护条件为真时转移才可以开始。 决策：活动图中的决策用一个菱形表示。分支表示一个触发事件在不同的触发条件下引起多个不同的转移。 分支可以有一个进入转移和两个或多个输出转移。在每条输出转移上都有守护条件（即一个布尔表达式）保护，当且仅当守护条件的值为真时，该输出路径才有效。 同步棒：在建模过程中，可能会遇到对象在运行时存在两个或多个并发运行的控制流。所有的并行转移在合并前必须被执行。 在UML中，一条粗黑线表示将转移分解成两个或多个并发流，同样用粗黑线表示分支的合并。粗黑线称为同步棒。 泳道： 活动图告诉你发生了什么，但没有告诉你该项活动由谁来完成。在程序设计中，这意味着活动图没有描述出各个活动由哪个类来完成。泳道解决了这一问题。 泳道：用矩形框来表示，属于某个泳道的活动放在该矩形框内，将对象名放在矩形框的顶部，表示泳道中的活动由该对象负责。 泳道可以提高活动图的可读性,可用于建模某些复杂的活动图。 例子：“记录学生分数”的活动图： 注:活动图与状态图的标记符非常相似，有时会让人混淆。其实, 活动图是用来建模不同区域的工作如何彼此交互的；而状态图用 来表示单个的对象，以及对象的行为如何改变其状态。 例子：活动图的优缺点： 活动图最适合支持描述并行行为，这使之成为支持工作流建模的最好工具 但活动图最大的缺点是很难清楚地描述动作与对象之间的关系。 活动图的用途 活动图用于对系统的动态行为建模。活动图描述了从活动到活动的流。 在对一个系统建模时，通常有两种使用活动图的方式： (1)为工作流建模 对工作流建模强调与系统进行交互的对象所观察到的活动。用于可视化、详述、构造和文档化开发系统所涉及的业务流程。 (2)为对象的操作建模 活动图本质上就是流程图，他描述系统的活动、判定点、分支等部分。因此，在UML中，可以把活动图作为流程图来使用，用于对系统的操作建模。 活动图的适用范围 对于以下情况可以使用活动图 (1)分析用例，即用图形化的方式描述用例的事件流； (2)理解牵涉多个用例的工作流，即描述系统的业务流程； (3)处理多线程应用。 ","date":"2021-11-25 15:48:03","objectID":"https://qizhengzou.github.io/sek_base_04/:4:4","tags":["software engineering knowledge"],"title":"SEK_base_04","uri":"https://qizhengzou.github.io/sek_base_04/"},{"categories":["School courses"],"content":"物理建模与设计 ","date":"2021-11-25 15:48:03","objectID":"https://qizhengzou.github.io/sek_base_04/:5:0","tags":["software engineering knowledge"],"title":"SEK_base_04","uri":"https://qizhengzou.github.io/sek_base_04/"},{"categories":["School courses"],"content":"组件图 组件图是对面向对象系统的物理方面建模时使用的两种图之一，另一种图是配置图。目前，演示意义大于实际意义。 组件图和配置图统称系统的实现图。其中组件图显示代码本身的逻辑结构；配置图显示系统运行前的结构。 组件图描述软件组件以及组件之间的关系。组件是代码的软件模块，组件图则显示了代码的结构。 组件图画在组件视图(Component View)下面。 组件图显示了组件以及它们之间的管理信息 组件 组件是代码的软件模块，一般来说，就是一个实际文件。 组件包括以下类型： –源代码组件 –二进制组件 –可执行组件 组件的特点： 组件是物理的 组件是可替代的 组件是系统的一部分 组件图的作用 每个组件体现了系统设计中特定类的实现。良好定义的组件不直接依赖于其他组件而依赖于组件所支持的接口 每个组件实现一些接口，并使用另一些接口。 组件图的用途是显示系统中的组件之间的依赖关系，以及组件的接口和调用关系。 ","date":"2021-11-25 15:48:03","objectID":"https://qizhengzou.github.io/sek_base_04/:5:1","tags":["software engineering knowledge"],"title":"SEK_base_04","uri":"https://qizhengzou.github.io/sek_base_04/"},{"categories":["School courses"],"content":" 笔记来自2021秋哈工大深圳软件工程授课教师张永兵 ","date":"2021-11-25 15:47:59","objectID":"https://qizhengzou.github.io/sek_base_03/:0:0","tags":["software engineering knowledge"],"title":"SEK_base_03","uri":"https://qizhengzou.github.io/sek_base_03/"},{"categories":["School courses"],"content":"软件需求工程 ","date":"2021-11-25 15:47:59","objectID":"https://qizhengzou.github.io/sek_base_03/:1:0","tags":["software engineering knowledge"],"title":"SEK_base_03","uri":"https://qizhengzou.github.io/sek_base_03/"},{"categories":["School courses"],"content":"软件需求与需求工程 软件需求 软件开发要能够满足各方面的需求 质量要求：可以工作的软件； 进度要求：在预定的时间完成; 功能要求：完成用户提出的需求； 资金要求：在预算约束下完成； …… 软件需求：以一种清晰、简洁、一致且无二义性的方式，描述用户对目标软件系统在功能、行为、性能、设计约束等方面的期望，是在开发过程中对系统的约束。 需求分类： 功能性需求 非功能性需求 质量 可用性 安全性 高性能 …… 约束 业务约束 技术约束 外部接口需求 外部接口分为以下几类： 1）系统接口（system interfaces）：描述一个应用如何与系统的其他应用进行交互。 2）用户接口（user interfaces）：规约了软件产品和用户之间接口的逻辑特性。即规约对给用户所显示的数据，对用户所要求的数据以及用户如何控制该用户接口。 3）硬件接口（hardware interfaces）：如果软件系统必须与硬件设备进行交互，那么就应说明所要求的支持和协议类型。 4）软件接口（software interfaces）：允许与其他软件产品进行交互，如，数据管理系统，操作系统或数学软件包。 5）通讯接口（communications interfaces）：规约待开发系统与通讯设施（如，局域网）之间的交互。如果通讯需求包含了系统必须使用的网络类型（TCP/IP,WindowsNT)，那么有关类型的信息就应包含在SRS中。 好的需求应具备的特征 完整性：每一项需求都必须将所要实现的功能描述清楚 正确性：每一项需求都必须准确地陈述其要开发的功能； 可行性：每一项需求都必须是在已知系统和环境的权能和限制范围内可以实施的 必要性：每一项需求都应把客户真正所需要的和最终系统所需遵从的标准记录下来 划分优先级：给每项需求、特性或使用实例分配一个实施优先级以指明它在特定产品中所占的分量 无二义性：对所有需求说明的读者都只能有一个明确统一的解释 可验证性：检查一下每项需求是否能通过设计测试用例或其它的验证方法，如用演示、检测等来确定产品是否确实按需求实现 产生不合格需求的原因 无足够用户参与 “我不明白为什么要花那么多功夫收集需求” “与其与用户讨论浪费时间，不如写代码有意思” “我已经明白用户需求了” 用户需求的不断增加 若不断增加新需求，项目就越来越庞大以致超过其计划及预算范围 开发中不断延续的变更会使其整体结构日渐紊乱，补丁代码也使得整个程序难以理解和维护 模棱两可的需求 诸多读者对需求说明产生了不同的理解 单个读者能用不止一个方式来解释某个需求说明 后果：返工，重做一些你认为已做好的事情 不必要的特性 “画蛇添足”，开发人员力图增加一些“用户欣赏”但需求规格说明中并未涉及的新功能 客户可能要求一些看上去很“酷”，但缺乏实用价值的功能，而实现这些功能只能徒耗时间和成本 过于精简的规格说明 给开发人员带来挫折，使他们在不正确的假设前提和极其有限的指导下工作 给客户带来烦恼，他们无法得到他们所设想的产品 忽略了用户分类 软件由不同的人使用其不同的特性 使用频繁程度有所差异 使用者受教育程度和经验水平也不尽相同 不准确的计划 对需求分析缺乏理解会导致过分乐观的估计 需求工程 需求工程(Requirement Engineering, RE) 应用已证实有效的技术、方法进行需求分析，确定客户需求，帮助分析人员理解问题并定义目标系统的所有外部特征的过程。 通过合适的工具和记号系统地描述待开发系统及其行为特征和相关约束，形成需求文档，并对用户不断变化的需求演进给予支持。 分析并记录软件需求，把需求分解成一些主要的子系统和任务，把这些子系统或任务分配给软件；通过一系列重复的分析、设计、比较研究、原型开发过程把这些系统需求转换成软件的需求描述和一些性能参数。 需求获取(Requirement Elicitation)：通过与用户的交流，对现有系统的观察及对任务进行分析，从而开发、捕获和修订用户的需求 对用户进行分类 聆听每一类用户的需求 分析和整理所获取的需求 形成文档化的描述 需求分析(Requirement Analysis)：对收集到的需求进行提炼、分析和审查，为最终用户所看到的系统建立概念化的分析模型 定义系统的边界 建立软件原型 分析需求可行性 确定需求优先级 建立需求分析模型 创建数据字典 需求规格说明(Software Requirement Specification, SRS)： 需求开发的结果 精确的、形式化的阐述一个软件系统必须提供的功能、非功能、所要考虑的限制条件等 作为用户和开发者之间的一个契约 是用户、分析人员和设计人员之间进行理解和交流的手段 需求验证 对其他需求工程活动的质量的保证。通过数学的形式化工具或工程化的测试 过程来确保系统满足干系人的要求。 验证方法 评审（Review） 原型化（Prototyping） 模型验证（Model validation） 确认测试（Acceptance Tests） 需求管理 贯穿从需求获取到软件系统下线的全过程。需求管理涉及软件配置管理、需求跟踪、影响分析和版本控制 需求跟踪 （Requirements traceability） 描述和追踪一条需求的来龙去脉的能力，包括向前追踪到软件制品，向后追踪到需求来源 变更请求管理（Change Requests）系统化的变更管理 需求属性管理 （Requirements attributes） ","date":"2021-11-25 15:47:59","objectID":"https://qizhengzou.github.io/sek_base_03/:1:1","tags":["software engineering knowledge"],"title":"SEK_base_03","uri":"https://qizhengzou.github.io/sek_base_03/"},{"categories":["School courses"],"content":"需求获取与建模 需求获取的挑战和途径 挑战： “Yes, But”综合症：直到开发人员将用户描述的东西交给他们，用户才认为他们知道自己要什么，尽早提供可选择的启发技术原型开发、迭代方法等 “Undiscovered Ruins”综合症：用户不知道自己需要什么，或知道但不知如何表达详细调研，将用户当作领域专家来认识和激励，尝试其他交流和启发技术 “User and Developer”综合症：双方在沟通时存在交流的鸿沟熟悉应用领域，把分析员放在用户的位置上，采用用例分析方法 需求获取的手段： 面对面访谈(face-to-face interviewing) 问卷调查(Survey Research Methods) 专题讨论会(workshop) 头脑风暴(brainstorming) 需求建模 用户故事（User Story）：用户故事（User Story）是从用户角度对功能的简要描述 用例图（User Case Diagram） UML语言-面向对象的建模语言（Unified Modeling Language） 用来可视化(visualize) 、描述(specify)、构造(construct)和文档化(document)软件密集型系统的各种产品 支持不同人员之间的交流(Communication) 用例图基本概念 参与者(actor)：是某些具有行为的事物，可以是人、计算机系统或者组织，且对系统本身而言参与者是外部的。例如收银员 场景(scenario)：是参与者和系统之间的一系列特定的活动交互，也称为用例实例(use case instance) 用例(use case)：就是一组相关的成功和失败场景集合，用来描述参与者如何使用系统来实现其目标 用例：站在用户角度定义软件系统的外部特征 用例方法的基本思想：从用户的角度来看，他们并不想了解系统的内部结构和设计，他们所关心的是系统所能提供的服务，也就是被开发出来的系统将是如何被使用的 活动图（Activity Diagram） 什么是活动图？ 显示了组成复杂过程的步骤序列，例如算法或工作流 活动图用于详细描述用例 是状态图的一个变种 活动图的目的是描述动作及动作的结果 活动图中的动作可以放在“泳道中”，泳道聚合一组活动，通常根据活动的功能来组合活动。 ","date":"2021-11-25 15:47:59","objectID":"https://qizhengzou.github.io/sek_base_03/:1:2","tags":["software engineering knowledge"],"title":"SEK_base_03","uri":"https://qizhengzou.github.io/sek_base_03/"},{"categories":["School courses"],"content":"需求规格说明 软件需求规格说明书SRS (Software Requirements Specification)： 需求开发的结果，精确的阐述一个软件系统必须提供的功能和性能，以及它所要考虑的限制条件。 为了使用户和软件开发者双方对该软件的初始规定有一个共同的理解，使之成为整个开发工作的基础。 是具有一定法律效力的合同文档 清楚地描述软件在什么情况下，需要做什么，以及不能做什么 以输入/输出、输入到输出之间的转换方式来描述功能性需求 描述经过干系人磋商达成共识的非功能性需求 一般参考需求定义模板，覆盖标准模板中定义的所有条目 作为后续的软件评估依据和变更的基准 SRS作为软件开发各类人员之间进行理解和交流的手段： 用户：通过SRS指定需求，检查需求描述是否满足期望； 设计人员：了解软件需要开发的内容，将其作为软件设计的基本出发点； 测试人员：制定测试计划、测试用例和测试过程； 产品发布人员：编写用户手册和帮助信息； 项目管理人员：规划软件开发过程、准确估计开发进度和成本、控制需求变更过程 SRS应包含的内容： 功能(Functionality)： 该软件系统能够向用户提供何种服务？ 外部接口(External interfaces)： 该软件系统如何与用户、操作系统、硬件、其他软件系统进行交互？ 性能(Performance)： 软件系统在运行速度、可用性、响应时间、恢复时间等方面有哪些要求？ 非功能属性(Non-Functional Attributes)： 软件系统在可移植性、安全性、可靠性、可维护性等方面有哪些要求？ 约束条件(Design constraints imposed on an implementation)： 是否存在必要的标准、编程语言、运行环境、资源约束等因素？ SRS不应包含的内容 项目开发计划 诸如成本、人员、进度、工具、方法等 产品保证计划 诸如配置管理、验证与测试、质量保证等 软件设计细节 需求通常用于表达“做什么”，而不描述“如何做” 好的SRS应具备的特点 正确性(Correct) 无二义性(Unambiguous) 完整性(Complete) 一致性(Consistent) 按重要度/稳定性排序(Ranked for importance and/or stability) 可验证性(Verifiable) 可修改性(Modifiable) 可跟踪性(Traceable) SRS的三大组成部分 引言(introduction) 目的(purpose) 范围(scope) 术语表(definitions, acronyms, and abbreviations) 参考文献(references) 整体结构(overview) 整体描述(overall description) 产品上下文环境(product perspective) 产品外部接口(external interface) 产品功能(product functions) 用户类和特征(user characteristics) 设计和实现上的约束(constraints) 运行环境(environment) 假设和依赖(assumptions and dependencies) 未来的需求(future requirements) 需求描述(specific requirements) 各项功能的详细描述(根据各项功能来组织章节) 非功能需求 ","date":"2021-11-25 15:47:59","objectID":"https://qizhengzou.github.io/sek_base_03/:1:3","tags":["software engineering knowledge"],"title":"SEK_base_03","uri":"https://qizhengzou.github.io/sek_base_03/"},{"categories":["School courses"],"content":" 笔记来自2021秋哈工大深圳软件工程授课教师张永兵 ","date":"2021-11-25 15:47:55","objectID":"https://qizhengzou.github.io/sek_base_02/:0:0","tags":["software engineering knowledge"],"title":"SEK_base_02","uri":"https://qizhengzou.github.io/sek_base_02/"},{"categories":["School courses"],"content":"第二部分 软件项目开发过程与管理 ","date":"2021-11-25 15:47:55","objectID":"https://qizhengzou.github.io/sek_base_02/:1:0","tags":["software engineering knowledge"],"title":"SEK_base_02","uri":"https://qizhengzou.github.io/sek_base_02/"},{"categories":["School courses"],"content":"2.1 软件项目开发过程 为什么要将软件开发过程划分为多个阶段？ 六七十年代的软件开发过程：程序员个人设计、个人操作、小作坊式的开发过程，开发的软件可靠差，难以维护，无法满足快速发展的软件需求，因而产生软件危机。 如何解决软件危机？ 把软件开发过程划分为多个阶段使得每个阶段有明确的任务，通过问题的分解，将大规模、结构复杂的软件开发变的容易控制和管理。 软件开发的典型阶段： 计划 需求分析 软件设计 软件实现 软件验证 软件维护 可以通过调整软件开发不同阶段的顺序使之适应不同的情况。 为什么要验证和确认？ 存在的问题： 要求开发之前需求被充分理解 与客户的交互只在开始(需求)和最后(发布) 实际情况？用户的需求是模糊的 优点： 通过用户的反馈进行验证和确认 开发的产品与客户的需求接近 典型软件过程模型 瀑布模型 瀑布模型的开发阶段严格按照线性方式进行，每一个阶段具有相关的里程碑和交付产品，且需要确认和验证 基本思想 将软件开发过程划分为分析、设计、编码、测试等阶段 工作以线性方式进行，上一阶段的输出是下一阶段的输入 每个阶段均有里程碑和提交物 特点 需求最为重要，假设需求是稳定的 以文档为中心，文档是连接各阶段的关键 问题： 文档的问题 对于文档的评估需要各领域的专家，文档是否有效？ 当某一文档调整后的影响，不同文档间如何保持一致性？ 大量的文档就一定有效吗？ 把用户隔离在开发过程之外，不容易满足用户需求。 对于大多数软件项目，客户看到软件前无法可靠地描述他们想要的是什么，而瀑布模型却要求客户明确需求，这就很难适应许多项目开始阶段必然存在的不确定性。 客户必须要有耐心，因为只有在项目接近尾声时，他们才能得到可执行的程序。对于系统中存在的重大缺陷，如果在可执行程序评审之前没有发现，将可能造成惨重损失。 瀑布模型在某些项目中容易导致“阻塞状态”。因为任务之间的依赖性，开发团队的一些成员要等待另一些成员工作完成才能进行下一步工作。 平均水平的项目开发过程中会有25%，大型项目有40%的需求变化 需求变更导致的返工占总返工量的80% 瀑布方法需求中45%从未被使用，时间计划与实际相差4倍 瀑布模型适用场合： 软件项目较小； 需求在项目开始之前已经被全面的了解； 需求在开发中不太可能发生重大改变； 外部环境的不可控因素很少。 增量过程模型 增量模型 优点： 在时间要求较高的情况下交付产品：在各个阶段并不交付一个可运行的完整产品，而是交付满足客户需求的一个子集的可运行产品，对客户起到“镇静剂”的作用； 人员分配灵活：如果找不到足够的开发人员，可采用增量模型，早期的增量由少量人员实现，如果客户反响较好，则在下一个增量中投入更多的人力； 逐步增加产品功能可以使用户有较充裕的时间来学习和适应新产品，避免全新软件可能带来的冲击； 因为具有较高优先权的模块被首先交付，而后面的增量也不断被集成进来，这使得最重要的功能肯定接受了最多的测试，从而使得项目总体性失败的风险比较低。 缺点： 每个附加的增量并入现有的软件时，必须不破坏原来已构造好的东西。 同时，加入新增量时应简单、方便:该类软件的体系结构应当是开放的； 增量模型的适用情况 在开始开发时，需求很明确，且产品还可被适当地分解为一些独立的、可交付的软件。 在开发中，期望尽快提交其中的一些增量产品。 快速应用程序开发（RAD） RAD模型的使用方法 侧重于短开发周期(一般为60~90天)的增量过程模型，通过基于已有资源的构建方法实现快速开发。 本质：是瀑布模型的高速变体，并行运行瀑布模型。 优点： 提高软件交付速度 充分利用企业已有资产进行项目开发 缺点： 需求充分理解，系统被合理的模块化； 需要大量的人力资源来创建多个相对独立的RAD团队； 要求管理水平高，如果没有在短时间内为急速完成整个系统做好准备，RAD项目将会败； 如果系统需求是高性能，并且需要通过调整构件接口的方式来提高性能，不能采用RAD型 技术风险很高的情况下(采用很多新技术、软件需与其他已有软件建立集成、等等)，不宜采用RAD。 演化过程模型 快速原型开发模型 原型快速分析:指在分析者和用户的紧密配合下,快速确定软件系统的基本要求。 原型构造:在原型分析的基础上,根据基本需求规格说明,忽略细节,只考虑主要特性，快速构造一个可运行的系统。 原型运行与评价:软件开发人员与用户频繁通信、发现问题、消除误解的重要阶段，目的是发现新需求并修改原有需求。 原型修正:对原型系统，要根据修改意见进行修正。 判定原型完成:如果原型经过修正或改进，获得了参与者的一致认可，那么原型开发的迭代过程可以结束 优点： 快速开发出可以演示的系统，方便与客户沟通； 采用迭代技术能够使开发者逐步弄清客户的需求； 缺点： 为了尽快完成原型，开发者没有考虑整体软件的质量和长期的可维护性，系统结构通常较差； 用户可能混淆原型系统与最终系统，原型系统在完全满足用户需求之后可能会被直接交付给客户使用； 螺旋模型 该模型由**Dr.Barry Boehm[Boehm 1988]**提出。它是在瀑布模型和演化模型的基础上，加入两者所忽略的风险分析所建立的一种软件开发模型。 该模型将软件生存周期的活动分为四个可重复的阶段：规划、风险分析、开发和评估 优点：结合了原型的迭代性质与瀑布模型的系统性和可控性，是一种风险驱动型的过程模型； 采用循环的方式逐步加深系统定义和实现的深度，同时更好的理解、应对和降低风险； 确定一系列里程碑，确保各方都得到可行的系统解决方案； 始终保持可操作性，直到软件生命周期的结束； 由风险驱动，支持现有软件的复用。 缺点： 适用于大规模软件项目，特别是内部项目，周期长、成本高； 软件开发人员应该擅长寻找可能的风险，准确的分析风险，否则将会带来更大的风险； 由于构建产品所需的周期数据不确定，给项目管理带来困难； 演化速度不易把握，演化速度太快，项目陷入混乱；演化速度太慢，影响生产率； 为追求软件的高质量而牺牲了开发速度、灵活性和可扩展性； ","date":"2021-11-25 15:47:55","objectID":"https://qizhengzou.github.io/sek_base_02/:1:1","tags":["software engineering knowledge"],"title":"SEK_base_02","uri":"https://qizhengzou.github.io/sek_base_02/"},{"categories":["School courses"],"content":"2.2 软件项目开发管理 软件项目管理概念及特征 项目(Project)：精心定义的一组活动，使用受约束的资源(资金、人、原料、能源、空间等)来满足预定义的目标。 项目管理(Project Management, PM)：有效的组织与管理各类资源(例如人)，以使项目能够在预定的范围、质量、时间和成本等约束条件下顺利交付(deliver) 挑战1：在各类约束条件下交付项目； 挑战2：通过优化资源的分配与集成来满足预先定义的目标； 软件管理的4P: 软件人员 软件产品 软件过程 软件工具 软件项目估算 项目估算是对项目的规模、工作量、时间和成本等进行预算和估计的过程。 软件项目估算的挑战是项目的复杂性和不确定性 软件规模越大，复杂性越高，不确定性就越大 需求的不确定性会对项目估算产生很大影响 没有可靠的历史数据使项目估算缺少参照物 总结：估算的风险取决于资源、成本及进度的定量估算中存在的不确定性。 基本估算方法 参数估算：通过对大量的项目历史数据进行统计分析，使用项目特性参数建立经验估算模型，估算诸如成本、预算和持续时间等活动参数。 代码行技术(LOC)：从过去开发类似产品的经验和历史数据出发，估计出所开发软件的代码行数 功能点方法是依据软件信息域的基本特征和对软件复杂性的估计，估算出软件规模。这种方法适合于在软件开发初期进行估算，并以功能点为单位度量软件规模。 结构性成本模型 COCOMO（COnstructive COst MOdel是一种利用经验模型进行成本估算的方法。 故事点的基本做法：把一些常见“标准任务”给出一个“标准点数”，形成比较基线；估算时只要是同一类型任务，直接写故事点数而非天数。 人工神经网络是采用一种学习方法导出一种预测模型，首先建立神经网络，再使用一组历史项目数据（样本数据）训练网络，训练后的网络可以用于估算新项目的工作量。 项目进度安排 Step1：工作量分配 40-20-40法则 40%的工作量分配给前期的分析和设计 20%的工作量分配给编码 40%分配给测试 Step 2：定义任务网络 任务不是独立存在的，各任务在顺序上存在相互依赖关系。 项目管理里通常采用“网络图(Network Diagram)”的形式对此进行描述。 Step 3：时间分配 在绘制出任务网络图之后，下一步需要为每一个任务分配具体的执行时间。 两种具体的技术： 程序评估及评审技术(PERT) 关键路径方法(CPM) 步骤： Step 3.1：标出任务的最早开始(ES)与结束时间(EF)； Step 3.2：标出任务的最迟开始(LS)与结束时间(LF)； Step 3.3：计算关键路径(Critical Path)； Step 3.4：确定任务的开始/结束时间。 Step 3.5：绘制最终的任务进度安排(甘特图, Gantt Diagram) 甘特图（Gantt Chart）是一种通用的显示进度方法，其横轴表示时间，纵轴表示活动，线条表示在整个期间上计划和实际的活动完成情况。 Step 4：确认任务资源。确认每个任务的资源需求 Step 5：确定责任。确定每个任务的负责人和参与人 Step 6：明确结果。明确任务的输出结果（文档或部分软件） Step 7：确定里程碑(milestones)。确定任务与项目里程碑关联 项目风险管理 风险识别：确定项目有哪些风险，包括运用专家判断法、头脑风暴法等分析项目风险产生的各种原因或者影响因素，以确定风险事件及其来源。 风险评估：比较风险的大小，确定风险的性质。通过对各种风险进行定性、定量的分析，包括发生概率、影响严重性等，确定出每种风险的大小和性质。 应对计划：制定风险响应的措施和实施步骤，按照风险的大小和性质，制定相应的措施去应对和响应风险，包括风险接受、风险转移等。 风险控制：监督、检查风险事件的发生情况以及风险措施的落实情况，通过对风险事件及其来源的控制和对风险计划落实情况的监督，确保风险措施有效。 ","date":"2021-11-25 15:47:55","objectID":"https://qizhengzou.github.io/sek_base_02/:1:2","tags":["software engineering knowledge"],"title":"SEK_base_02","uri":"https://qizhengzou.github.io/sek_base_02/"},{"categories":["School courses"],"content":" 笔记来自2021秋哈工大深圳软件工程授课教师张永兵 ","date":"2021-11-25 15:43:12","objectID":"https://qizhengzou.github.io/sek_base_01/:0:0","tags":["software engineering knowledge"],"title":"SEK_base_01","uri":"https://qizhengzou.github.io/sek_base_01/"},{"categories":["School courses"],"content":"第一部分 软件工程概论 ","date":"2021-11-25 15:43:12","objectID":"https://qizhengzou.github.io/sek_base_01/:1:0","tags":["software engineering knowledge"],"title":"SEK_base_01","uri":"https://qizhengzou.github.io/sek_base_01/"},{"categories":["School courses"],"content":"软件工程的产生与发展 传统的理解： 软件：控制计算机硬件功能及其运行的指令、程序和符号语言 工程：将科学及数学原理运用于实际用途的应用手段，即高效率、低成本的设计、制造和运行各类结构、机器、进程和系统 软件工程：应用软件领域的理论方法来解决软件系统“从无到有”、“从有到好”的过程。 软件=程序+数据+文档=程序=工具=服务 软件具有复杂性、一致性、可变性（演化性）和不可见性等固有的内在特性，这是造成软件开发困难的根本原因。 工程是将理论和所学的知识应用于实践的科学，以便经济有效地解决实际问题。 工程化的方法（注重系统的构建过程）： 需求分析和定义 软件设计 编码实现 软件测试 软件交付与维护 工程化思想： 分而治之 折中 复用 总而言之，“软件工程”是： 将系统性的、规范化的、可定量的方法应用于软件的开发、运行和维护，即工程化应用到软件上； 对上述方法的研究。 软件生产过程面临的问题： 为什么软件需要如此长的开发时间？ 为什么开发成本居高不下？ 为什么在将软件交付顾客之前，我们无法找到所有的错误？ 为什么维护已有的程序要花费高昂的时间和人力代价？ 为什么软件开发和维护的过程仍旧难以度量？ 原因： 客观上：软件产品开发的复杂度和难度随软件规模呈指数级别增长 随着软件规模的急速增长，传统的软件开发方法已经不可用了 主观上：软件开发人员缺乏工程性的、 系统性的方法论 程序员具有编程的能力，但对软件开发这一过程性较强的任务却缺乏足够的工程化思维； 对软件开发一些认识地误区：软件神话(Software myths)； 没有将“软件产品研发”与“程序编码”区分清楚； 忽视需求分析、轻视软件维护； ","date":"2021-11-25 15:43:12","objectID":"https://qizhengzou.github.io/sek_base_01/:1:1","tags":["software engineering knowledge"],"title":"SEK_base_01","uri":"https://qizhengzou.github.io/sek_base_01/"},{"categories":["School courses"],"content":"软件工程基本概念 软件工程是一项受软件工程原理指导的活动，软件工程师需要捕捉和理解一个系统的基本原理模型，并根据评价标准提出合理的开发决策。 方法、过程、范型、工具—-\u003e软件质量 McCall质量模型 正确性： 软件满足需求规格说明和完成用户任务目标的程度。 可靠性： 软件在规定时间和条件下无故障持续运行的程度。 效率： 软件系统完成预定功能所需的计算机资源量。 完整性： 对未授权人员访问软件或数据的可控程度。 易用性： 用户学习、操作、准备输入和解释输出所需要的工作量。 可维护性： 定位和修复软件中的一个错误所需的工作量。 可测试性： 测试程序以确保它能完成预期功能所需的工作量。 灵活性： 修改或改进一个已经投入运行的软件所需的工作量。 可移植性： 将程序从一个硬件或软件环境移植到另一环境所需的工作量。 可复用性： 程序可以再次用于另一个应用中的程度。 互操作性： 将一个系统连接到另一个系统所需的工作量。 ISO9126 质量模型 外部质量 功能性 适合性 准确性 互操作性 安全性 可靠性 成熟性 容错性 可恢复性 易用性 易理解性 易学性 易操作性 吸引性 效率/性能 时间特性 资源利用 内部质量 可维护性 易分析性 易改变性 稳定性 易测试性 可移植性 适应性 易安装性 共存性 替换性 软件工程=最佳实践 软件系统的复杂性、动态性使得： 高深的软件理论在软件开发中变得无用武之地； 即使应用理论方法来解决，得到的结果也往往难以与现实保持一致； 因此，软件工程被看作一种实践的艺术： 做过越多的软件项目，犯的错误就越少，积累的经验越多，随后作项目的成功率就越高； 对新手来说，要通过多实践、多犯错来积累经验，也要多吸收他人失败的教训与成功的经验。 ","date":"2021-11-25 15:43:12","objectID":"https://qizhengzou.github.io/sek_base_01/:1:2","tags":["software engineering knowledge"],"title":"SEK_base_01","uri":"https://qizhengzou.github.io/sek_base_01/"},{"categories":["School courses' list"],"content":" base来自罗文坚老师，这课程是开卷考试，加之是早八课，所以上课时人少得可怜 base_01（信息安全课程概述） 教学目的、目标与内容 信息安全概述 信息安全的理解 信息与信息安全 信息安全的发展阶段 信息安全威胁 信息安全威胁的基本类型 信息安全威胁的主要表现形式 互联网的安全性 互联网的发展现状 互联网的安全现状 安全事件 国内信息安全事件 近期代表安全事件 安全趋势 信息安全意义 信息安全体系结构 base_02（密码学基础） 密码学基础知识 古典替换密码 对称密钥密码 公开密钥密码 消息认证 密码学新进展 base_03（物理安全） 概述 设备安全防护 防信息泄露 物理隔离 容错与容灾 base_04（身份认证） 概述 认证协议 基于对称密钥的认证协议 基于公开密钥的认证协议 基于CA数字证书的认证协议 公钥基础设施PKI PKI体系结构 基于X.509的PKI系统 base_05（访问控制） 概述 访问控制模型 自主访问控制 强制访问控制 基于角色的访问控制 Windows系统的安全管理 Windows系统安全体系结构 Windows系统的访问控制 活动目录与组策略 base_06（网络威胁） 概述 网络威胁的三个阶段 网络威胁分类 计算机病毒 病毒概述 传统病毒 蠕虫病毒 木马 病毒防治 网络入侵 拒绝服务攻击 口令攻击 嗅探攻击 欺骗类攻击 利用型攻击 诱骗类威胁 base_07（网络防御） 概述 防火墙 防火墙概述 防火墙的主要技术 Netfilter/IPtables防火墙 入侵检测系统 入侵检测概述 入侵检测系统分类 入侵检测技术 误用检测技术 异常检测技术 入侵诱骗技术 响应技术 Snort系统 网络防御的新技术 base_08（网络安全协议） 概述 IPSec IPSec协议族的体系结构 IPSec协议的工作方式 Internet秘钥交换协议 IKE 快速模式 新组模式和ISAKMP信息交换 SSL SSL协议的体系结构 SSL协议规范 HTTPS 安全电子交易协议 电子商务安全 SET协概述 SET的安全机制 交易处理 SET与SSL的比较 base_09（内容安全） 概述 内容保护 内容监管 版权保护 DRM概述 数字水印 内容监管 网络信息内容监管 垃圾邮件处理 base_10（信息安全管理） 概述 信息安全风险管理 风险评估 风险控制 信息安全标准 信息安全标准概述 信息技术安全性评估通用准则（CC） 信息安全管理体系标准 中国的有关信息安全标准 信息安全法律法规及道德规范 信息犯罪 信息犯罪分类 信息安全道德规范 信息安全法律规范 ","date":"2021-11-21 11:39:55","objectID":"https://qizhengzou.github.io/isc_catalogue/:0:0","tags":["catalogue"],"title":"ISC_catalogue","uri":"https://qizhengzou.github.io/isc_catalogue/"},{"categories":["School courses"],"content":" 2021秋哈工大深圳罗文坚 信息安全概论课程PPT 摘抄 网络安全协议 ","date":"2021-11-21 11:36:15","objectID":"https://qizhengzou.github.io/isc_base_08/:0:0","tags":["information security conspectus"],"title":"ISC_base_08","uri":"https://qizhengzou.github.io/isc_base_08/"},{"categories":["School courses"],"content":"8.1 概述 许多网络攻击都是由网络协议（如TCP/IP）的固有漏洞引起的，因此，为了保证网络传输和应用的安全，各种类型的网络安全协议不断涌现。 安全协议是以密码学为基础的消息交换协议，也称作密码协议，其目的是在网络环境中提供各种安全服务。 安全协议是网络安全的一个重要组成部分，通过安全协议可以实现实体认证、数据完整性校验、密钥分配、收发确认以及不可否认性验证等安全功能。 网络安全协议层次： 网络安全协议基本上与TCP/IP协议族相似，分为四层，即网络接口层、网络层、传输层和应用层。 应用层：种类繁多（SSH、PGP和SET）； 传输层：SSL、TLS和SOCKS v5等； 网络层：IPSec协议（IP Security）； 网络接口层：L2TP 、L2F、PPTP。 网络安全协议建立在密码体制基础上，运用密码算法和协议逻辑来实现加密和认证。 密钥管理主要分为人工管理和协商管理两种形式。 密钥管理都需要通过应用层服务来实现。 网络安全协议所处的网络层次不同，存在包含关系，但存在特殊应用的情况除外。 ","date":"2021-11-21 11:36:15","objectID":"https://qizhengzou.github.io/isc_base_08/:1:0","tags":["information security conspectus"],"title":"ISC_base_08","uri":"https://qizhengzou.github.io/isc_base_08/"},{"categories":["School courses"],"content":"8.2 IPSec ","date":"2021-11-21 11:36:15","objectID":"https://qizhengzou.github.io/isc_base_08/:2:0","tags":["information security conspectus"],"title":"ISC_base_08","uri":"https://qizhengzou.github.io/isc_base_08/"},{"categories":["School courses"],"content":"8.2.1 IPSec协议族的体系机构 IPSec: 1994年，IAB（Internet Architecture Board），发表《互联网体系结构中的安全问题》报告。 1994年，IETF专门成立IP安全协议工作组。 1995年，IPSec细则在互联网标准草案中颁布。 1998年11月，被提议为IP安全标准。 IPSec是一个标准的第三层安全协议族；不是一个协议，而是一个协议簇。 IETF为IPSec一共定义了12个标准文档RFC（Request For - Comments）。 IPSec对于IPv4是可选的，对于IPv6是强制性的。 IPSec提供了一种标准的、健壮的以及包容广泛的机制，可用它为IP及上层协议（如UDP和TCP）提供安全保证。 IPSec协议的优点： IPSec在传输层之下，对于应用程序是透明的。 IPSec对终端用户是透明的，因此不必对用户进行安全机制的培训。 IPSec可以为个体用户提供安全保障，可以保护企业内部的敏感信息。 IPSec协议族的体系结构： Encapsulating Security Payload（ESP，封装安全有效负载协议） Authentication Header（AH，认证头协议） 基本协议： ESP（Encapsulating Security Payload）协议 对IP数据报文实施加密和可选认证双重服务 提供了数据保密性、有限的数据流保密性、数据源认证、无连接的完整性以及抗重放攻击等服务。 AH（Authentication Header）协议 对IP数据报文实施认证服务，提供数据源认证、无连接的完整性以及一个可选的抗重放服务。 AH协议通过对IP数据包进行签名以确保其完整性，虽然数据包的内容没有加密，但是可以向接收者保证数据包的内容未被更改，还可以向接收者保证包是由发送者发送的。 AH协议和ESP协议都支持认证功能，但二者的保护范围存在着一定的差异。 AH的作用域是整个IP数据包，包括IP头和承载数据。 ESP认证功能的作用域只是承载数据，不包括IP头。 从理论上讲，AH所提供的认证的安全性高于ESP的认证服务。 ESP和AH的有效工作依赖于四个要件。 加密算法、认证算法、解释域DOI（Domain of Interpretation）以及密钥管理。 实际应用中，这些要件都是以程序或程序包的形式出现。 IPSec基本条件： 加密算法 描述各种能用于ESP的加密算法。 IPSec要求任何实现都必须支持DES（数据加密标准），也可使用3DES、IDEA(国际加密算法)、AES(高级加密算法)等其他算法。 认证算法 用于AH和ESP，以保证数据完整性及进行数据源身份认证。 IPSec用HMAC-MD5和HMAC-SHA-1作为默认认证算法，同时也支持其他认证算法，以提高安全强度。 解释域DOI(Domain of Interpretation) DOI是一个描述IPSec所涉及到的各种安全参数及相关信息的集合。 通过对DOI的访问，可以得到相关协议中各字段含义的解释，可以被与IPSec服务相关的系统参考调用。 密钥管理 密钥管理主要负责确定和分配AH和ESP中加密和认证使用的密钥，有手工和自动两种方式。 IPSec默认的自动密钥管理协议是IKE(Internet Key Exchange)。 安全关联： 安全关联SA（Security Association）是一个IPSec单向连接所涉及的安全参数和策略的集合。 决定了保护什么、如何保护以及谁来保护通信数据； 规定了用来保护数据包安全的IPSec协议类型、协议的操作模式、加密算法、认证方式、加密和认证密钥、密钥的有效存在时间以及防重放攻击的序列号等。 AH和ESP均使用SA，而且IKE协议的一个主要功能就是建立和维护SA； 一个SA定义了两个应用实体（主机或网关）间的一个单向连接；如果需要双向通讯，则需要建立两个SA。 安全关联SA的工作原理： 在SA对IP数据包处理的过程中，有两个重要的数据库起到了关键作用。 安全策略数据库（SPD，Security Policy Database）：保存着定义的处理策略，每条策略指出以何种方式对IP数据报文提供何种服务。 安全关联数据库（SAD，Security Association Database）：保存应用实体中所有的SA。 SAD中的SA是通过三元组\u003c安全参数索引，IP目的地址，安全协议标识\u003e来标识。 SPI（Security Parameter Index）：是一个与SA相关联的位串。一般在IKE 确立一个SA时，产生一个伪随机导数作为该SA的SPI。SPI 也可以人为设定。 IP目的地址：目前IPSec仅支持使用单播地址来表示SA的目的地址。 安全协议标识：标识该SA是一个AH或ESP协议的安全关联。 SPD中的SP是通过选择因子来确定的。 选择因子是从网络层和传送头内提取出来的，主要包括：目的地址、源地址、名字、协议、上层端口等。 SPD： 安全策略数据库SPD 是SA处理的核心之一，每个IPSec实现必须具有管理接口，允许用户或系统管理员管理SPD。 SPD有一个排序的策略列表，针对接收数据和发送数据有不同的处理策略。 SPD的处理方式主要有三种： Discard； Bypass IPSec； Apply IPSec。 SAD: SAD中的任意SA都被定义了以下参数（即SAD的字段）： 目的IP地址：目前的SA管理机制只支持单播地址的SA。 IPSec协议：标识SA用的是AH还是ESP。 SPI：32比特的安全参数索引，标识同一个目的地的不同的SA。 序号计数器：32比特，用于产生AH或ESP头的序号，仅用于发送数据包。 序号计数器溢出标志：标识序号计数器是否溢出。 如溢出，产生审计事件，禁止用SA继续发送数据包。 抗重放窗口：32比特计数器，用于决定进入的AH或ESP数据包是否为重发，仅用于接收数据包。 AH信息：指明认证算法、密钥、密钥生存期等与AH相关的参数。 …… ESP信息：指明加密和认证算法、密钥、初始值、密钥生存期等与ESP相关的参数。 SA的生存期：一个特定的时间间隔或字节计数。 IPSec协议模式：指明是隧道、传输或混合方式（通配符），这些内容后面讨论。 Path MTU（路径最大传输单元）：指明预计经过路径的MTU及延迟变量。 ","date":"2021-11-21 11:36:15","objectID":"https://qizhengzou.github.io/isc_base_08/:2:1","tags":["information security conspectus"],"title":"ISC_base_08","uri":"https://qizhengzou.github.io/isc_base_08/"},{"categories":["School courses"],"content":"8.2.2 IPSec协议的工作方式 IPv4与IPv6数据包结构： IPv6增加了扩展头，其原理为：大多数IP包只需要简单的处理，因此有基本报头的信息就足够了。当网络层存在需要额外信息的信息包时，就可以把这些信息编码到扩展报头上。 在实施IPSec时，IPv4和IPv6存在着一些区别，主要集中在对两种协议数据包的封装上。 IPSec的工作模式： IPSec 标准定义了 IPSec 操作的两种不同模式： 传输模式（Transport Mode）和隧道模式（Tunnel Mode）； 安全协议AH和ESP，都可以以这两种模式工作。 传输模式：只对IP数据包的有效负载进行加密或认证；继续使用以前的IP头部，只对IP头部的部分域进行修改。 隧道模式：对整个IP数据包进行加密或认证；需要新产生一个IP头部，IPSec头部放在新产生的IP头部和以前的IP数据包之间。 认证头AH： AH的工作原理：可变内容一般被填充“0”后参与计算。 目前计算认证数据的算法主要有MD5算法和SHA-1算法等。 IP包中的部分域（如生存周期，即IPv4中的TTL，IPv6中称为跳数）、AH校验值等是可变化的，因此只对在传输过程中不变的内容或可以预测变化的内容进行认证。 AH头格式： 下一个头（8位）：用来标记下一个扩展头的类型； 载荷长度（8位）：表示认证头数据的长度减2，以字（字长32位）来计； 保留（16位）：备用； SPI（32位）：用来标识安全关联； 序列号（32位）：收发双方同时保留一个序列号计数器，每收发一个IP包，序列号将递增1，当递增到232后复位； 认证数据（32N位）：认证数据域的长度可变，但必须是32的整数倍，默认为3个字（96位）。 认证数据也称为完整性校验值（Integrity Check Value，ICV），是一种报文认证编码MAC或MAC算法生成的截断码。 认证数据的计算主要使用基于秘钥的Hash算法的认证协议（Hash Message Authentication Code，HMAC），常用的包括HMAC-MD5-96和HMAC-SHA-1-96。 这两种算法是先进行散列计算，然后截取前96位作为ICV。 参与散列计算的数据包括IP包头（可变部分被置为0）、AH头（认证数据被置为0）和整个上层协议数据。 封装安全有效负荷ESP： 工作方式分传输模式和隧道模式。 ESP的封装格式： 传输模式：需对IP数据包的负载部分进行有效填充，并添加ESP尾，构造成长度为字长整数倍的规整数据块。 隧道模式：需对整个原始IP数据包进行有效填充。 ESP封装包主要包括七个部分： 安全关联索引：用来标识安全关联； 序列号：与AH相同，用来防范IP包的重放攻击； 载荷数据：被加密的传输层数据（传输模式）或整个原始IP包（隧道模式）； 填充域：提供规整化载荷数据，并隐藏载荷数据的实际长度； 填充长度：填充数据的长度； 下一个头：用来标记载荷中第一个包头的类型，具体值与AH相同； 认证数据：针对ESP包中除认证数据域外的内容进行完整性计算，得到的完整性校验值，具体计算方法与AH相同。 重放攻击： 重放攻击是指攻击者发送一个目的主机已接收过的包，对目标系统进行欺骗，主要用于身份认证过程。 重放攻击主要分为： 简单重放攻击：攻击者简单地复制一条消息，以后再重新发送它； 反向重放攻击：攻击者复制一条消息，只修改源/目的地址，然后反向发送给消息源（消息发送者）。 除了提供加密和认证服务，IPSec安全体制还考虑了反重放攻击问题。 由于IP是无连接、不可靠的服务，协议本身不能保证数据包按顺序传输，也不能保证所有数据包均被传输，这就为重放攻击提供了条件。 抵御重放攻击主要方法包括： 序列号：使用一个序列号来给每一个消息报文编号，仅当收到的消息序数顺序合法时才接受； 时间戳（Timestamp）：A接受一个消息，仅当该消息包含一个时间戳，该时间戳足够接近当前时间时才接受； 盘问/应答方式（Challenge/Response）： A期望从B获得一个新消息，首先发给B一个临时值（Challenge），并要求后续从B收到的消息（Response）包含正确的临时值或对其正确的变换值。 反重放攻击服务： IPSec使如何防范重放攻击的？ 在安全关联SA中定义了序号计数器和抗重放窗口。 序号计数器提供了设置IPSec包中序列号域的值。 当新SA建立后，发送方将序号计数器的初值置为0，每发送一个包，计数器的值加1并并置于序列号域中，直至232-1。 如需提供抗重放服务，则发送方不允许重复计数。当序列号达到232时，原SA必须终止，并产生新的SA继续工作。 抗重放窗口： 抗重放窗口W实际上就是某个特定时间接收到的数据包序号是否合法的上、下界，同时窗口具有滑动功能 ","date":"2021-11-21 11:36:15","objectID":"https://qizhengzou.github.io/isc_base_08/:2:2","tags":["information security conspectus"],"title":"ISC_base_08","uri":"https://qizhengzou.github.io/isc_base_08/"},{"categories":["School courses"],"content":"8.2.3 Internet秘钥交换协议 IPsec在提供认证或加密服务之前，必须针对安全协议、加密算法和密钥等内容进行协商，并建立SA，这个过程可以手工进行和自动完成。 IPSec默认的自动密钥管理协议是Internet密钥交换协议IKE（Internet Key Exchange）。 IKE是一个多用途的安全信息交换管理协议，被定义为应用层协议，主要用于安全策略协商以及加密认证基础材料的确定。 SNMPv3、OSPFv2及IPSec等都采用IKE进行密钥交换。 IKE是3个协议的混合体，这三个协议分别是ISAKMP、Oakley和SKEME。 ISAKMP（Internet Security Association and Key Management Protocol）设计了一个用于通信双方完成认证和密钥交换的通用框架，在此框架下可以协商和确定各种安全属性、密码算法、安全参数、认证机制等，这些协商的结果统称为安全关联SA。 Oakley算法是一种以Diffie-Hellman算法为基础的自由形态的协议，允许他人依据本身的需要来改进协议状态。 IKE在Oakley基础上，进行有效的规范化，形成了可供用户选择的多种密钥交换模式。 SKEME（Secure Key Exchange Mechanism）采用公开密钥加密的手段来实现匿名性、防抵赖和密钥更新等服务，可以提供密码生成材料技术和协商共享策略。 IKE IKE对IPSec的支持就是在通信双方之间，建立起共享安全参数及密钥（即安全关联SA）。 IKE建立SA的过程分为两个阶段： 第一阶段，协商创建一个通信信道（IKE SA），并对该信道进行验证，为双方进一步的IKE通信提供机密性、消息完整性以及消息源验证服务； 第二阶段，使用已建立的IKE SA建立IPsec SA。 当两个实体间进行IPSec连接时： 如果已经创建了IKE SA，就可以直接通过第二阶段，交换创建新的IPsec SA； 如果还没有创建IKE SA，就要通过两个阶段交换创建新的IKE SA及IPsec SA。 第一阶段: IKE定义了两种信息交换模式：主模式（Main Mode）、野蛮模式（Aggressive Mode）。 主模式协商过程： 第一步：策略协商，即确定IKE SA中所必需的有关算法和参数，包括加密算法、散列算法、认证方法以及DH组的选择。 第二步，秘钥交换，即双方交换DH算法所需要的秘钥生成基本材料，即DH公开值gx ，还有用于防范重放攻击的一次性随机数nonce 。 随后，各自计算主秘钥。 第三步，认证交换，即通信双方构造“认证者”并发给对方；验证通过，则成功建立IKE SA。 认证者是通信双方使用前两步协商得到的秘钥对双方交换的信息进行散列计算得到的散列值（或经过数字签名）。 双方交换的信息包括DH公开值、Nonce、SA内容以及身份标识符ID等。 野蛮协商过程： 验证载荷是使用协商得到的安全参数及秘钥对接收到的所有信息进行加密散列计算，得到的数据结果即为可验证信息，可作为发送方现场操作的证据。 第二阶段： IKE已经拥有了第一阶段建立起的IKE SA，通信双方的进一步协商采用SA保护，任何没有SA保护的消息将被拒收。 通常在第二阶段至少要建立两条SA，一条用于发送数据，一条用于接收数据。 此阶段IKE使用三种信息交换方式： 快速模式（Quick Mode）； 新组模式（New Group Mode）； ISAKMP信息交换（ISAKMP Info Exchange）。 快速模式 快速模式主要用于交换IPSec SA信息。 新组模式和ISAKMP信息交换 新组模式主要用于实现通信双方交换协商新的Diffie－Hellman组，属于一种请求/响应交换。 发送方发送提议的DH组的标识符及其特征，如果响应方能够接收提议，就用完全一样的消息应答。 ISAKMP信息交换主要功能是实现通信一方向对方发送错误及状态提示消息。 这并非真正意义上的交换，而只是发送单独一条消息，不需要确认。 ","date":"2021-11-21 11:36:15","objectID":"https://qizhengzou.github.io/isc_base_08/:2:3","tags":["information security conspectus"],"title":"ISC_base_08","uri":"https://qizhengzou.github.io/isc_base_08/"},{"categories":["School courses"],"content":"8.3 SSL SSL协议是NetScape公司于1994年提出的。 一种保护客户端与服务器之间数据传输安全的加密协议，其目的是确保数据在网络传输过程中不被窃听及泄密。 1996年发布了SSL v3.0，技术上更加成熟和稳定，成为事实上的工业标准，得到了多数浏览器和WEB服务器的支持。 1997年，IETF发布了传输层安全协议TLS v1.0（Transaction Layer Security），可以看成是SSL v3.1。 SSL协议提供的服务主要有： 认证用户和服务器，确保数据发送到正确的客户机和服务器； 加密数据以防止数据中途被窃取； 维护数据的完整性，确保数据在传输过程中不被改变。 ","date":"2021-11-21 11:36:15","objectID":"https://qizhengzou.github.io/isc_base_08/:3:0","tags":["information security conspectus"],"title":"ISC_base_08","uri":"https://qizhengzou.github.io/isc_base_08/"},{"categories":["School courses"],"content":"8.3.1 SSL协议的体系结构 SSL协议族由4个协议组成： 记录协议 Record Protocol、握手协议 Handshake Protocol、转换密码规范协议 Change Cipher Spec Protocol和报警协议Alert Protocol。 双层协议：SSL记录协议被定义为在传输层与应用层之间，其它三个协议则为应用层协议。 SSL连接和SSL会话： SSL协议的双层协议构建了一个完整的通讯结构： 应用层的三个协议用于构建安全环境； 下层的SSL记录协议则完成数据的安全封装。 构建安全环境涉及两个重要的概念，即SSL连接和SSL会话。 SSL连接表示的是对等网络关系，即发起方（客户端）与接收方（服务器）之间的一条位于传输层之上的逻辑链路关系，具体的传输依靠其下层协议实现。 连接是暂时的，使用结束之后即刻释放。 连接依赖于一定的规范，而这些规范会在一个会话中被描述，即每个连接与一个会话有关。 SSL会话是发起方和接收方之间的安全关联，它描述了一个（或多个）连接共享的安全参数集合。 会话是SSL握手协议创建的，一个会话可以为多个连接共享。 SSL会话与多种状态相关，状态可以理解为描述特定过程的特征信息集合。 SSL协议中，最主要的两个状态就是会话状态和连接状态。 会话状态包含标识会话特征的信息和握手协议的协商结果，用来描述一个SSL会话的特征参数。 连接状态包含客户端和服务器在传输过程中使用的加密密钥、MAC密钥、初始化位移量、一些客户端和服务器选择的随机数，主要用来描述与一个SSL连接相关联的特征参数。 客户端和服务器只需在一个连接存在时记录该连接的状态，连接状态提供的参数为SSL记录协议层使用。 SSL会话状态参数定义： SSL连接状态参数定义： 待用状态和当前操作状态： SSL会话还定义了当前操作状态和待用状态。 当SSL握手协议建立起SSL会话后，会话进入了当前操作状态。 当前操作状态包含了当前SSL记录协议正在使用的压缩算法、加密算法和MAC算法以及加、解密的秘钥等参数。 当一个连接结束时，SSL会话又从当前操作状态进入待用状态。 待用状态包含了之前握手协议协商好的压缩算法、加密算法和MAC算法，以及用于加、解密的秘钥等参数。 因此，SSL会话从建立开始不断地在当前操作状态和待用状态之间切换，直到该会话结束。 ","date":"2021-11-21 11:36:15","objectID":"https://qizhengzou.github.io/isc_base_08/:3:1","tags":["information security conspectus"],"title":"ISC_base_08","uri":"https://qizhengzou.github.io/isc_base_08/"},{"categories":["School courses"],"content":"8.3.2 SSL协议规范 SSL记录协议： SSL记录协议为SSL连接提供了两种服务。 保密性：握手协议定义了共享的、可用于对SSL有效载荷进行常规加密的秘钥。 消息完整性：握手协议定义了共享的、可用来形成报文的鉴别码（MAC）的秘钥。 SSL记录协议的功能是根据当前会话状态指定的参数以及连接状态中指定的参数等内容，对当前的连接中要传送的高层数据实施压缩与解压缩、加密与解密、计算与校验MAC等操作。 SSL记录协议对应用层数据文件的处理过程分为5个步骤。 SSL记录格式： 完整的SSL记录格式包括六个部分。 内容类型（8位）：用来指明封装数据的类型， 已定义的类型包括转换密码规范协议、报警协议、握手协议和应用数据四类。 主版本（8位）：指明SSL使用的主版本。 从版本（8位）：指明SSL使用的从版本。 压缩长度（16位）：明文负载（如压缩，则为压缩后负载）的字节长度。 负载（可变）：指待处理的明文数据经过压缩（可选）、加密后形成的密文数据。 MAC（16或20字节）：针对压缩后的明文数据进行计算得到的消息认证码。 如基于SHA-1进行计算时，MAC的长度为20个字节；基于MD5进行计算时，MAC的长度为16个字节。 SSL握手协议： SSL握手协议的作用： 用于建立会话、协商加密方法、鉴别方法、压缩方法和初始化操作；使服务器和客户能够相互鉴别对方的身份、协商加密和MAC算法；用来保护在SSL记录中发送数据的加密密钥。 SSL握手协议的内容作为SSL记录协议的负载，包含在SSL记录中，其报文格式主要包括以下三个字段： 类型（1字节）：为10种报文类型中的一种。 长度（3字节）：以字节为单位的报文长度。 内容（大于等于1字节）：与报文类型相关的参数。 SSL握手协议的报文类型： SSL握手协议操作的整个过程： SSL握手协议通过在客户端和服务器之间传递消息报文，完成会话协商谈判。 SSL转换密码规范协议： 目的是通知对方将已挂起（或新协商）的状态复制到当前状态中，用于更新当前连接使用的密码规范。 协议报文包含1个字节的信息，值为1表示更新使用新的密码规范。 SSL报警协议： 报警协议是用来将SSL传输过程中的警报信息传送给对方。 报警协议内容作为SSL记录协议的负载被包含在SSL记录中，并按照会话的当前操作状态指定的方式进行压缩和加密。 该协议的每个报文由两个字节组成。 第一个字节的值是警报级别，分为致命错误和警告两级。 如果级别是致命错误，SSL将立刻中止该连接。 第二个字节给出特定警报的代码信息。 致命错误： 意外消息：接收到不正确的信息； MAC记录出错：接收到不正确的MAC； 解压失败：解压函数接收到不正确的输入； 握手失败：双方无法在给定的选项中协商出可以接受的安全参数集； 非法参数：握手消息中的某个域超出范围或与其他域出现不一致性。 警告类型 结束通知：通知对方将不再使用此连接发送任何信息； 无证书：如果无适当证书可用，此消息可作为对方证书请求的响应发送； 证书出错：证书被破坏，签名无法通过验证； 不支持的证书：不支持接收到的证书类型； 证书撤销：该证书被其签名者撤销； 证书过期：证书超过使用期限； 未知证书：处理证书时，出现其他错误，证书无法被接受。 ","date":"2021-11-21 11:36:15","objectID":"https://qizhengzou.github.io/isc_base_08/:3:2","tags":["information security conspectus"],"title":"ISC_base_08","uri":"https://qizhengzou.github.io/isc_base_08/"},{"categories":["School courses"],"content":"8.3.3 HTTPS Netscape提出了HTTPS协议，用于解决HTTP协议的安全性问题。 简单讲是HTTP的安全版，在HTTP下加入SSL协议。 SSL一般以两种形式出现： 一是将SSL嵌入到操作系统内核，其安全机制对所有上层应用软件透明； 二是在应用层以函数库形式出现，应用程序的通信部分源码需要按照SSL通信协议格式规范来编写，并连接SSL函数库，编译生成可执行代码。 第一种形式实现SSL具有层无关特性，较为实用，HTTPS也是基于此方式实现的。 HTTPS的思想： 客户端向服务器发送一个连接请求，然后双方协商一个SSL会话，并启动SSL连接，接着就可以在SSL的应用通道上传送HTTPS数据。 注意：HTTPS使用与传统HTTP不同的端口，IANA（Internet Assigned Numbers Authority）将HTTPS端口定为443，以此来区分非安全HTTP的80端口，同时采用“https”来标识协议类型。 HTTPS的主要作用： 建立一个信息安全通道，用来保证数据传输的安全； 确认网站服务器和客户端的真实性，这就需要CA证书及认证服务。 HTTPS的身份认证可分为单向身份认证和双向身份认证。 单向身份认证：通过验证服务器的CA证书来核实其身份，为多数非电子商务交易服务所采纳。 双向身份认证：多应用于电子商务交易中。 在HTTPS服务中，CA证书的认证非常重要，主要体现在两方面： 服务器的信任问题； 客户端的信任问题。 服务器的信任必须依靠CA证书解决： HTTPS 的服务器必须从CA认证服务中心申请得到一个用于证明服务器身份的证书； 只有服务器能够提供该证书时候，客户端完成对CA证书的验证，才能信任此服务器。 在一些电子商务交易过程中，有时也会要求客户端提供有效的CA证书，以保证电子交易的有效性。 目前，多数用户的CA证书都是备份在U盘（即U盾中），并经过特殊的强加密处理及相应的密码身份验证来确保其安全性。 HTTPS协议处理过程： ","date":"2021-11-21 11:36:15","objectID":"https://qizhengzou.github.io/isc_base_08/:3:3","tags":["information security conspectus"],"title":"ISC_base_08","uri":"https://qizhengzou.github.io/isc_base_08/"},{"categories":["School courses"],"content":"8.4 安全电子交易协议 SET（Secure Electronic Transaction），Visa和MasterCard发起，联合IBM、Microsoft、Netscape、GTE等公司，于1997年6月1日推出的用于电子商务的行业规范。 SET是一种应用在Internet上、以信用卡为基础的电子付款系统规范，目的是为了保证网络交易的安全。 SET妥善地解决了信用卡电子商务交易中的交易协议、信息保密、资料完整以及身份认证等问题。 SET已获得IETF标准的认可，是电子商务的发展方向。 ","date":"2021-11-21 11:36:15","objectID":"https://qizhengzou.github.io/isc_base_08/:4:0","tags":["information security conspectus"],"title":"ISC_base_08","uri":"https://qizhengzou.github.io/isc_base_08/"},{"categories":["School courses"],"content":"8.4.1 电子商务安全 电子商务（Electronic Commerce），以网络技术为手段、以商务为核心，把销售、购物渠道移到互联网上来，打破国家与地区的壁垒，使销售达到全球化、网络化、无形化。 电子商务提供网上交易和管理等全过程的服务，包括广告洽谈、网上交易和服务传递三部分，其中网上交易是其核心。 安全问题及安全技术： 面临的安全问题 有效性 真实性 机密性 不可否认性 安全技术 网络安全技术 加密技术 认证技术 安全协议 ","date":"2021-11-21 11:36:15","objectID":"https://qizhengzou.github.io/isc_base_08/:4:1","tags":["information security conspectus"],"title":"ISC_base_08","uri":"https://qizhengzou.github.io/isc_base_08/"},{"categories":["School courses"],"content":"8.4.2 SET协议概述 SET协议是依据网络电子交易的特点，专门用于解决交易的安全问题的协议。 SET安全协议的目标： 保证交易信息在互联网上安全传输，防止数据被黑客或被内部人员窃取。 保证电子商务参与者信息的相互隔离。客户的资料加密或打包后通过商家到达银行，但是商家不能看到客户的账户和密码信息。 持卡人和商家相互认证，以确定通信双方的身份，由第三方机构负责为在线通信双方提供信用担保。 保证网上交易的实时性，使支付过程都是在线的。 要求软件遵循相同协议和报文格式，使不同厂家开发的软件具有兼容性和互操作功能。 SET的组件结构： SET的六组件 Cardholder、Merchant、Issuer、Acquirer、Payment Gateway、Certificate Authority 基于SET的网络交易流程： 顾客（持卡人）通过Internet选定物品，填写并提交订货单。 商家作出应答，告诉消费者所填订货单的货物单价、应付款数、交货方式等信息是否准确，是否有变化。 消费者选择付款方式，核定订单。此时SET开始介入。 顾客在验证商家的CA证书后，发送给商家一个包含完整订购信息和支付信息的订单。 商家接受订单后，验证顾客的身份，并向其支付卡所在金融机构（一般为银行）请求支付授权。 有关信息通过支付网关到清算机构，再到发卡机构确认。批准交易后，返回确认信息给商家。 商家发送订单确认信息给顾客。 商家发送货物或提供服务，到此一个网上交易结束。 商家通知清算机构请求支付货款。 清算银行经过一定时间间隔将钱从顾客帐号转移到商家帐号。 ","date":"2021-11-21 11:36:15","objectID":"https://qizhengzou.github.io/isc_base_08/:4:2","tags":["information security conspectus"],"title":"ISC_base_08","uri":"https://qizhengzou.github.io/isc_base_08/"},{"categories":["School courses"],"content":"8.4.3 SET的安全机制 SET协议安全性主要依靠其采用的多种安全机制： 对称密钥密码 公开密钥密码 数字签名 消息摘要 电子信封 数字证书 双重签名 安全机制解决了包括机密性、完整性、身份认证和不可否认性等问题，提供了更高的信任度和可靠性。 SET协议使如何保证商家、顾客和银行之间数据隐私的安全性？ CA证书： CA证书就是一份文档，它记录了用户的公开密钥和其他身份信息。 最重要的证书是持卡人证书和商家证书。 除此以外，还包括支付网关证书、清算机构（银行）证书、发卡机构（银行）证书。 这些证书均由一个权威的CA签发，如某金融机构的认证中心。 整个交易过程中，SET各实体可以通过数字证书证实自己的真实身份，同时可以提供自己的公钥给对方，以便交换重要的保密信息，如电子信封应用。 电子信封： SET协议使用电子信封来传递更新的密钥。 电子信封涉及到两个密钥：一个是接收方的公开密钥；另一个是发送方生成的临时密钥（对称密钥）。 发送方使用接收方的公钥加密临时密钥，一般将这个被加密的秘钥称为电子信封，接收方用其私钥解密出临时秘钥。 双重签名： SET协议核心内容是订购信息OI和支付信息PI。 DS（Dual Signature）技术将OI和PI这两部分的摘要信息绑定，确保电子交易的有效性和公正性。 分离PI与OI，确保商家不知道顾客的支付卡信息，银行不知道顾客的订购细节。 DS = EKRc [ H（H（PI）II H（OI））] 双重签名的使用过程： 顾客针对PI和OI生成DS，将DS、OI和PIMD发送给商家。 商家计算得到POMD=H（PIMD II H（OI）），然后计算POMD’=DKUc [ DS ]，其中KUc为顾客的公开密钥。如果POMD= POMD’，则商家可以认为该DS正确，批准实施进一步交易。 顾客需要生成一个对称密钥KS，使用银行的公钥加密KS，并使用KS加密DS、PI和OIMD，通过商家将EKUb [KS]IIEKs[ DS ‖ PI IIOIMD ]转发给银行。 其中KUb为银行的公开密钥。 银行计算POMD=H（H（PI）II OIMD）和POMD’=DKUc [ DS ]，如果POMD= POMD’，则银行可以认为该DS正确，批准实施交易。 ","date":"2021-11-21 11:36:15","objectID":"https://qizhengzou.github.io/isc_base_08/:4:3","tags":["information security conspectus"],"title":"ISC_base_08","uri":"https://qizhengzou.github.io/isc_base_08/"},{"categories":["School courses"],"content":"8.4.4 交易处理 SET协议为电子商务交易设计了多种类型的交易处理。 这些交易处理可以各自完成相应的功能，相互衔接配合，共同构建了一个完整的电子商务交易业务平台。 在处理中，持卡人注册和商家注册是进行安全交易的前提，购买请求、支付授权和支付获取是进行交易的核心。 交易处理：购买请求： 初始请求是顾客为了建立与商家之间的基本信任关系而发出的第一个消息。 包括顾客的支付卡品牌、对应此次请求/应答的标识ID和用于保证时限的临时值nonce。 初始应答是商家回应顾客初始请求的应答消息。 包括从顾客的初始请求中得到的nonce、要求在下一条消息中包含的新nonce和交易标识ID，这部分消息将被商家使用其私钥签名。 购买请求是顾客发送给商家具体的交易信息，主要内容包括OI和PI。首先顾客通过CA验证商家和支付网关的证书，然后生成购买请求消息发送给商家。 具体的购买请求消息如下： EKs[PI II DS II OIMD] II EKUb[Ks] II PIMD II OI II DS II CA证书顾客 购买应答是商家针对顾客的购买请求消息进行的相关响应处理。 当商家收到购买消息后，首先验证顾客的CA证书，用顾客的公钥验证双重签名； 将EKs[PI IIDS IIOIMD] IIEKUb[Ks] 转发给支付网关请求验证及支付授权，构造购买应答消息回应顾客。 购买应答消息主要包括：购买确认的应答分组、相对应的交易号索引以及商家的CA证书，前两部分将使用商家的私钥签名。 支付授权： 商家需要向支付网关申请支付授权，支付网关与发卡机构进行支付信息的确认，确保商家在完成交易后，可以收到有关支付款。 支付授权包括两个消息：授权请求和授权应答。 授权请求是商家发送给支付网关的支付授权请求消息，包括以下三部分： 顾客生成的购买信息：包括PI、DS、OIMD和顾客与支付网关之间的电子信封； 商家生成的授权信息：使用商家私钥签名并用商家生成的临时密钥Ks加密的交易标识ID（称为认证分组）和商家生成的电子信封（使用支付网关公钥加密的临时密钥Ks）； 证书：顾客的CA证书、商家的CA证书。 收到商家发送的授权请求后，支付网关需要验证所有CA证书； 解密商家的电子信封，解密认证分组并验证商家签名； 解密顾客的电子信封，验证顾客生成的DS； 比较从商家得到的交易标识ID和从顾客得到PI的交易标识ID，最后请求并接收发卡机构的认证。 授权应答是支付网关从发卡机构获得授权后，返给商家的支付授权应答消息。包括： 支付网关生成的授权相关信息：包括使用支付网关私钥签名，并用支付网关生成的临时密钥Ks加密的授权标识和支付网关生成的电子信封； 授权获取标记信息：该信息用来保证以后的支付有效。 证书：支付网关的CA证书。 支付获取： 商家为了获得货款，与支付网关之间进行支付获取消息交换，包括获取请求和获取应答两部分。 获取请求是商家发给支付网关的请求消息，告知支付网关已向顾客提供了商品或服务，并向支付网关申请索取支付款。 获取请求消息包括被签名加密的付款金额、交易标识部分以及在之前支付授权的消息中包含的授权获取标记信息和商家的证书。 当支付网关接收到获取请求消息后，验证相关信息，通过支付网络将结算信息发送给发卡机构，请求将顾客消费的资金款项转到商家在清算机构（银行）中的账户上。 在得到发卡机构的资金转账应答后，支付网关生成获取应答消息并发送给商家，以便核对其在清算机构账户中的收款情况。 支付获取应答消息包括被签名加密的获取应答报文以及支付网关的证书。 商家将此获取应答保存下来，用于匹配商家在清算机构上的账户的支付账款信息。 ","date":"2021-11-21 11:36:15","objectID":"https://qizhengzou.github.io/isc_base_08/:4:4","tags":["information security conspectus"],"title":"ISC_base_08","uri":"https://qizhengzou.github.io/isc_base_08/"},{"categories":["School courses"],"content":"8.4.5 SET与SSL的比较 SSL与SET都可以提供电子商务交易的安全机制，但是运作方式存在着明显的区别。 不同点主要表现在以下几个方面。 认证机制 安全性 网络协议体系 应用领域 应用代价 认证机制： 早期SSL没有商家身份认证机制； SSL 3.0可以实现浏览器和Web服务器双方的身份验证，但不能实现多方认证； SET要求参与交易的成员（持卡人、商家、发卡机构、清算机构和支付网关）都必须提供数字证书进行身份识别。 安全性： SET协议规范了整个商务活动的流程，在持卡人、商家、支付网关、认证中心和支付卡结算中心支局的信息流方向以及必须采用的加密方法和认证方法都收到严密的SET标准规范，最大限度地保证了商务性、服务性、协调性和集成性。 SSL只对持卡人和网络商家的信息交换进行加密保护，可以看做是用于传输的那部分的技术规范。 网络协议体系： SSL是基于传输层的通用安全协议； SET位于应用层，对网络上其他各层协议都有涉及。 应用领域： 如果电子商务应用只是通过Web或电子邮件，可以不要SET。 如果电子商务应用是一个涉及多方交易的平台，则使用SET更安全、更通用些。 应用代价： SET协议提供了B2C平台上信用卡在线支付的方式，但实现非常复杂。 ","date":"2021-11-21 11:36:15","objectID":"https://qizhengzou.github.io/isc_base_08/:4:5","tags":["information security conspectus"],"title":"ISC_base_08","uri":"https://qizhengzou.github.io/isc_base_08/"},{"categories":["School courses"],"content":" 2021秋哈工大深圳罗文坚 信息安全概论课程PPT 摘抄 网络防御 ","date":"2021-11-21 11:36:12","objectID":"https://qizhengzou.github.io/isc_base_07/:0:0","tags":["information security conspectus"],"title":"ISC_base_07","uri":"https://qizhengzou.github.io/isc_base_07/"},{"categories":["School courses"],"content":"7.1 概述 网络防御是一个综合性的安全工程，不是几个网络安全产品能够完成的任务。 防御需要解决多层面的问题，除了安全技术之外，安全管理也十分重要。 实际上，提高用户群的安全防范意识、加强安全管理所能起到效果远远高于应用几个网络安全产品。 从技术层面上看，网络安全防御体系应该是多层次、纵深型。 这种防御体系可以有效地增加入侵攻击者被检测到的风险，同时降低攻击的成功几率，从而能够较好地防御各种网络入侵行为。 目前，网络安全防御技术主要包括防火墙、入侵检测系统、VLAN、防病毒技术等。 网络安全防御体系： 防火墙：网络安全防御体系的第一道防线，是网络安全的网关设备。防火墙的工作机制是依据安全规则检查每一个通过防火墙的数据包，只有符合安全规则的数据包才能通过。 入侵检测系统：一般部署在网络内部，对网络内部的数据进行检测。当发现具有攻击特征的数据报文时，发出报警信息。 VLAN（Virtual Local Area Network，虚拟局域网）：将局域网中的各个节点，从逻辑上划分为多个网段（即VLAN），每一个VLAN都包含一组有着相同需求的工作站，与网络上形成的LAN有着相同的属性。 任一个VLAN内部的广播和单播流量都不会转发到其他VLAN中，有助于控制流量、简化网络管理、提高网络的安全性。 防病毒系统主要包括两种形式：一种是基于网络的防病毒系统，另一种是目前广泛使用的主机防病毒软件。 防病毒技术主要包括病毒检测引擎和病毒特征库两项核心技术，其中病毒检测引擎决定着系统的性能，而病毒特征库则与病毒检测的漏报率和误报率密切相关。 网络入侵防御系统（IPS，Intrusion Prevention System）：可以看成是防火墙和入侵检测系统的融合。 串接在网络关键路径上，保证受保护的网络的所有网络数据都经过IPS设备，类似于防火墙的部署。 从工作机制上看，比较接近入侵检测系统，在抗躲避的处理、协议分析、攻击识别等过程中都包含了动态与静态检测的融合。 入侵管理系统（IMS，Intrusion Management System）：可以理解为过程管理，在入侵事件的各个阶段实施预测、检测、阻断、关联分析和系统维护等工作。 云安全：融合了并行处理、网格计算、未知病毒行为判断等新兴技术和概念，通过网状的大量客户端对网络中的特定数据和异常行为进行收集整理，并传送到云服务器端进行自动分析和处理，再把解决方案分发到每一个客户端。 ","date":"2021-11-21 11:36:12","objectID":"https://qizhengzou.github.io/isc_base_07/:1:0","tags":["information security conspectus"],"title":"ISC_base_07","uri":"https://qizhengzou.github.io/isc_base_07/"},{"categories":["School courses"],"content":"7.2 防火墙 ","date":"2021-11-21 11:36:12","objectID":"https://qizhengzou.github.io/isc_base_07/:2:0","tags":["information security conspectus"],"title":"ISC_base_07","uri":"https://qizhengzou.github.io/isc_base_07/"},{"categories":["School courses"],"content":"7.2.1 防火墙概述 防火墙指的是一个由软件和硬件设备组合而成、在内部网络和外部网络之间构造的安全保护屏障，从而保护内部网络免受外部非法用户的侵入。 简单地说，防火墙是位于两个或多个网络之间，执行访问控制策略的一个或一组系统，是一类防范措施的总称。 防火墙设计目标是有效地控制内外网之间的网络数据流量，做到御敌于外。 防火墙的结构和部署考虑: 内网和外网之间的所有网络数据流必须经过防火墙。 阻塞点可以理解为连通两个或多个网络的唯一路径上的点；当这个点被删除后，各网络之间不在连通。 只有符合安全政策的数据流才能通过防火墙。 要求防火墙具有审计和管理的功能，具有可扩展性和健壮性。 防火墙分类： 从应用对象上，分为企业防火墙和个人防火墙。 企业防火墙的主要作用是保护整个企业网络免受外部网络的攻击。 个人防火墙则是保护个人计算机系统的安全。 从存在形式上，可以分为硬件防火墙和软件防火墙。 硬件防火墙采用特殊的硬件设备，有较高性能，可做为独立的设备部署；企业防火墙多数是硬件防火墙。 软件防火墙是一套安装在某台计算机系统上，执行防护任务的安全软件；个人防火墙都是软件防火墙。 防火墙主要作用： 网络流量过滤：通过在防火墙上进行安全规则配置，可以对流经防火墙的网络流量进行过滤。这是防火墙最主要的功能。 网络监控审计：防火墙记录访问并生成网络访问日志，提供网络使用情况的统计数据；发现可疑的网络访问时及时报警；将收集的信息提供给其他安全模块。 支持NAT部署：NAT（Network Address Translation，网络地址翻译）是用来缓解地址空间短缺的主要技术之一。 支持DMZ：DMZ（Demilitarized Zone，隔离区/非军事化区）是设立在非安全系统与安全系统之间的缓冲区，可以放置一些必须公开的服务器设施，如Web服务器。 支持VPN：通过VPN，企业可以将分布在各地的局域网有机地连成一个整体。 典型企业防火墙应用： 该企业网络中，由于应用了防火墙，解决了网络流量过滤及审计、地址短缺、远程安全内网访问以及DMZ部署问题。 防火墙的局限性： 防火墙无法检测不经过防火墙的流量，如通过内部提供拨号服务接入公网的流量； 防火墙不能防范来自内部人员的恶意攻击； 防火墙不能阻止被病毒感染的和有害的程序或文件的传递，如木马； 防火墙不能防止数据驱动式攻击，如一些缓冲区溢出攻击。 ","date":"2021-11-21 11:36:12","objectID":"https://qizhengzou.github.io/isc_base_07/:2:1","tags":["information security conspectus"],"title":"ISC_base_07","uri":"https://qizhengzou.github.io/isc_base_07/"},{"categories":["School courses"],"content":"7.2.2 防火墙的主要技术 根据技术特征的防火墙分类： 依据防火墙的技术特征，常见的防火墙可以分为： 包过滤防火墙 代理防火墙 个人防火墙 这三类防火墙的侧重点不同，因而采用的技术路线也有较大的区别。 包过滤防火墙： 包过滤防火墙主要是面向网络底层数据流进行审计和控管。 其安全策略主要根据数据包头的源地址、目的地址、端口号和协议类型等标志来制定，可见其主要工作在网络层和传输层。 代理防火墙： 代理防火墙基于代理（Proxy）技术，使防火墙参与到每一个内外网络之间的连接过程。 防火墙需要理解用户使用的协议，对内部节点向外部节点的请求进行还原审查后，转发给外部服务器；外部节点发送来的数据也要进行还原审查，然后封装转发给内部节点。 主要工作在应用层，有时也称为应用级网关。 个人防火墙： 目前普通用户最常使用的一种，常见如天网个人防火墙。 个人防火墙是一种能够保护个人计算机系统安全的软件。 直接在用户的计算机上运行，帮助普通用户对系统进行监控及管理，使个人计算机免受各种攻击。 防火墙涉及到的技术： ACL（Access Control List，访问控制列表） 静态包过滤 动态包过滤 应用网关代理 电路级网关（Circuit Gateway） NAT（Network Address Translation，网络地址翻译） VPN（Virtual Private Network，虚拟专用网） 访问控制列表ACL Access Control List是允许和拒绝匹配规则的集合。 规则告诉防火墙哪些数据包允许通过、哪些被拒绝。 ACL可以清晰体现防火墙的访问控制策略。 规则的顺序非常重要。 静态包过滤： 静态包过滤是指防火墙根据定义好的包过滤规则审查每个数据包，确定其是否与某一条包过滤规则匹配。 过滤规则基于数据包的包头信息进行制定，并存储在ACL中。 包头信息中包括IP源地址、IP目标地址、传输协议（如TCP、UDP、ICMP等）、TCP/UDP目标端口、ICMP消息类型等。 动态包过滤： 动态包过滤是指防火墙采用动态配置包过滤规则的方法。 根据需求动态地添加或删除ACL中的过滤规则，并通过对其批准建立的每一个连接进行跟踪，更加灵活地实现对网络连接访问的控制。 当一个合法用户请求访问外网时，向防火墙发出连接请求，防火墙审核通过后，向ACL中添加放行该用户访问的规则，该用户可以建立访问外网的会话。当防火墙接收到该用户结束访问的通知或检测到会话结束或超时的时候，将自行删除为该用户创建的规则。 实际上，静态包过滤是依据数据包的包头信息进行控管，而动态包过滤是基于会话，动态建立和删除规则。 应用代理网关： 应用代理网关被认为是最安全的防火墙技术。 应用代理网关防火墙彻底隔断内网与外网的直接通信，内网用户对外网的访问变成防火墙对外网的访问，外网返回的消息再由防火墙转发给内网用户。 应用层的协议会话过程必须符合代理的安全策略要求。 缺陷： 首先，必须能够理解繁杂的应用层协议和不断产生的新协议，才能较好地为用户服务。 其次，为了应付大量的网络连接并还原到应用层，防火墙的工作量势必大幅度提升，甚至成了网络瓶颈。 应用代理网关只适合那些用户较少，同时应用服务较少的网络。 电路级网关： 工作原理与应用代理网关基本相同，代理的协议以传输层为主，在传输层上实施访问控制策略，是在内外网络之间建立一个虚拟电路，进行通信。 由于代理传输层协议，应用电路级网关不需要审计应用层数据，只是检查内网主机与外网主机之间的传输数据来决定该会话是否合法。 因此，其所要处理的工作量远小于应用代理网关，但安全性低于应用代理网关。 NAT： NAT是一种将私有地址转换为合法IP地址的转换技术，广泛应用于各种类型网络连接Internet的工程中。 NAT不仅完美解决了IP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。 同时，对于内网用户来说，整个地址翻译过程是透明的。 实际上NAT就是把内部网络中的IP包头内内部IP地址信息用可以访问外部网络的真实IP地址信息来替换。 根据NAT的工作方式，可以分为静态NAT和动态NAT两种。 VPN： VPN是通过一个公用网络（通常是Internet）建立一个临时的、安全的连接。 可以理解为一条穿过公用网络的安全、稳定的隧道。 两台分别处于不同网络的机器可以通过这条隧道进行连接访问，就像在一个内部局域网一样。 VPN典型应用： VPN服务大致分为三类：Access VPN、Intranet VPN和Extranet VPN。 Access VPN，又称为虚拟专用拨号网（Virtual Private Dial-up Network，VPDN），是指企业员工或企业的小分支机构通过公网远程拨号的方式构筑的虚拟网。 Intranet VPN，及企业的内部与分支机构间通过VPN虚拟网进行网络连接，其最大特点是可以为总部及各分支机构提供整个企业网络的访问权限。 Extranet VPN，目的是通过一个使用专用连接的共享基础设施，将客户、供应商、合作伙伴或兴趣群体连接到企业内部网，其特点是支持对外部用户进行相应访问权限的设定。 ","date":"2021-11-21 11:36:12","objectID":"https://qizhengzou.github.io/isc_base_07/:2:2","tags":["information security conspectus"],"title":"ISC_base_07","uri":"https://qizhengzou.github.io/isc_base_07/"},{"categories":["School courses"],"content":"7.2.3 Netfilter/IPtables防火墙 2001年，Linux 2.4版内核，Netfilter/IPtables包过滤机制，被业内称为第三代Linux防火墙。 Netfilter通用架构： Netfilter是嵌入在Linux内核IP协议栈中的一个通用架构。 它提供了一系列的“表”（tables）。 每个表由若干“链”（chains）组成。 每条链中可以有一条或数条规则（rule）。 Netfilter的三个主要功能表： Filter，数据包过滤表，用于检查数据包的内容信息，决定放行还是丢弃该数据包。 Filter包含Input、Forward和Output三个链，分别用于处理目的地址是本地的数据包、目的地址不是本地的数据包和由本地产生的数据包。 Nat，网络地址转换表，用于数据包的地址翻译。 Mangle，数据包处理表，提供了修改数据包某些字段值的方法，用于IP网络中的流量控制和服务质量的实现。 Netfilter程序流程架构： Netfilter的具体实现，是通过在网络处理流程的若干位置放置一些钩子(hook)来实现的。 IP_PRE_ROUTING：处于数据包从数据链路层进入网络层的钩子点。 IP_LOCAL_IN：处于数据包从网络层进入传输层的钩子点。 IP_FORWARD：处于数据包在网络层转发的钩子点。 IP_POST_ROUTING：处于数据包从网络层进入数据链路层的钩子点。 IP_LOCAL_OUT：处于数据包从传输层进入网络层的钩子点。 规则组成： 包过滤表中的规则是通过IPtables的命令来进行管理的。 IPtables命令 = 工作表 + 使用链 + 规则操作 + 目标动作 + 匹配条件 工作表：指定该命令针对的表，缺省表为filter； 使用链：指定表下面的某个链，实际上就是确定哪个钩子点； 规则操作：包括添加规则、插入规则、删除规则、替代规则、列出规则； 目标动作：有两个，ACCEPT（继续传递数据包），DROP（丢弃数据包）； 匹配条件：指过滤检查时，用于匹配数据包头信息的特征信息串，如地址、端口等。 Netfilter/IPtables 例子： 配置目的：内网中只有202.10.13.0/24网段的用户可以访问外网，同时又只能使用TCP。 iptables -P FORWARD DROP iptables -A FORWARD -p tcp -s 202.10.13.0/24 -j ACCEPT iptables -A FORWARD -p tcp -d 202.10.13.0/24 -j ACCEPT 第一条命令是设置防火墙的默认规则为DROP。 使用链上的规则存在着优先级顺序关系，因而形成一条规则队列，匹配时顺序执行。当一个规则匹配成功，就执行该规则的目标动作并结束匹配，否则转向下一条规则。如果所有规则均匹配失败，则执行使用链的默认策略。 ","date":"2021-11-21 11:36:12","objectID":"https://qizhengzou.github.io/isc_base_07/:2:3","tags":["information security conspectus"],"title":"ISC_base_07","uri":"https://qizhengzou.github.io/isc_base_07/"},{"categories":["School courses"],"content":"7.3 入侵检测系统 ","date":"2021-11-21 11:36:12","objectID":"https://qizhengzou.github.io/isc_base_07/:3:0","tags":["information security conspectus"],"title":"ISC_base_07","uri":"https://qizhengzou.github.io/isc_base_07/"},{"categories":["School courses"],"content":"7.3.1 入侵检测概述 IDS（Intrusion Detection System，入侵检测系统） 一种对网络传输进行即时监视，在发现可疑传输时发出警报或者采取主动反应措施的网络安全系统。 一般认为，防火墙属于静态防范措施，而入侵检测系统为动态防范措施，是对防火墙的有效补充。 假如防火墙是一幢大楼的门禁，那么IDS就是这幢大楼里的监视系统。 1980年，James P. Anderson，《Computer Security Threat Monitoring and Surveillance》，此技术报告被公认是开山之作。 1984-1986年，Dorothy Denning和 Peter Neumann，实时入侵检测系统模型，IDES (Intrusion Detection Expert System)。 CIDF通用模型： IDWG（Intrusion Detection Working Group，IETF下属的研究机构）和CIDF（Common Intrusion Detection Framework，一个美国国防部赞助的开放组织）负责组织开展对IDS进行标准化和研究工作。 CIDF模型： IDS有关的重要概念： 事件：当网络或主机遭到入侵或出现较重大变化时，称为发生安全事件，简称事件。 报警：当发生事件时，IDS通过某种方式及时通知管理员事件情况称为报警。 响应：当IDS报警后，网络管理员对事件及时作出处理称为响应。 误用：误用是指不正当使用计算机或网络，并构成对计算机安全或网络安全威胁的一类行为。 异常：对网络或主机的正常行为进行采样、分析，描述出正常的行为轮廓，建立行为模型，当网络或主机上出现偏离行为模型的事件时，称为异常。 入侵特征：也称为攻击签名（Attack Signature）或攻击模式（Attack Patterns）。 一般指对网络或主机的某种入侵攻击行为（误用行为）的事件过程进行分析提炼，形成可以分辨出该入侵攻击事件的特征关键字，这些特征关键字被称为入侵特征。 感应器： 布置在网络或主机中用于收集网络信息或用户行为信息的软硬件，称为感应器。 感应器应该布置在可以及时取得全面数据的关键点上，其性能直接决定IDS检测的准确率。 入侵检测系统的工作过程： 信息收集： 入侵检测的第一步是信息收集，收集内容包括系统和网络的数据及用户活动的状态和行为。信息收集工作一般由由放置在不同网段的感应器来收集网络中的数据信息（主要是数据包）和主机内感应器来收集该主机的信息。 信息分析： 将收集到的有关系统和网络的数据及用户活动的状态和行为等信息送到检测引擎，检测引擎一般通过三种技术手段进行分析：模式匹配、统计分析和完整性分析。当检测到某种入侵特征时，会通知控制台出现了安全事件。 结果处理： 当控制台接到发生安全事件的通知，将产生报警，也可依据预先定义的相应措施进行联动响应。例如，重新配置路由器或防火墙、终止进程、切断连接、改变文件属性等。 IDS主要功能： 监测并分析用户、系统和网络的活动变化； 核查系统配置和漏洞； 评估系统关键资源和数据文件的完整性； 识别已知的攻击行为； 统计分析异常行为； 操作系统日志管理，并识别违反安全策略的用户活动。 ","date":"2021-11-21 11:36:12","objectID":"https://qizhengzou.github.io/isc_base_07/:3:1","tags":["information security conspectus"],"title":"ISC_base_07","uri":"https://qizhengzou.github.io/isc_base_07/"},{"categories":["School courses"],"content":"7.3.2 入侵检测系统分类 以数据源为分类标准 - 主机型入侵检测系统HIDS（Host-based Intrusion Detection System ） - 网络型入侵检测系统NIDS（Network-based Intrusion Detection System）。 主机型入侵检测系统： 数据来源主要是操作系统的事件日志、应用程序的事件日志、系统调用、端口调用和安全审计记录等。 HIDS只能用来检测该主机上发生的入侵行为，主要检测内部授权人员的误用以及成功避开传统的系统保护方法而渗透到网络内部的入侵活动，检测准确性高。 在检测到入侵行为后，可及时与操作系统协同阻止入侵行为的继续。 HIDS的缺点： 与操作系统平台相关，可移植性差； 需要在每个被检测主机上安装入侵检测系统，维护较复杂； 难以检测针对网络的攻击，如消耗网络资源的DoS攻击、端口扫描等。 随着针对应用层的攻击手段增多以及加密环境应用的普及，HIDS的优势逐渐明显。 HIDS优点主要包括： 性价比较高，不需要增加专门的硬件平台，当主机数量较少时性价比尤其突出； 准确率高，HIDS主要监测用户在系统中的行为活动，如对敏感文件、目录、程序或端口的访问，这些行为能够准确地反映系统实时的状态，便于区分正常的行为和非法的行为； 对流量不敏感，不会因为网络流量的增加而丢掉对网络行为的监视； 适合加密环境下的入侵检测。 网络型入侵检测系统： NIDS主要通过部署在网络关键位置上的感应器（多数为计算机）捕获网上的数据包，分析其是否具有已知的入侵特征模式。 NIDS的优点主要包括： 对用户透明，隐蔽性好，使用简便，不容易遭受来自网络上的攻击； 与被检测的系统平台无关； 利用独立的计算机完成检测工作，不会给运行关键业务的主机带来负载上的增加； 攻击者不易转移证据。 NIDS的缺点主要包括： 无法检测到来自网络内部的攻击，以及内部合法用户的误用行为； 无法分析加密的数据报文； 需要对所有的网络报文进行采集分析，主机的负荷较大，且易受DoS攻击。 HIDS和NIDS： HIDS和NIDS具有互补性。 HIDS能够更加精确地监视主机中的各种活动，适应特殊环境，如加密环境。 NIDS能够客观地反映网络活动，特别是能够监视到主机系统审计的盲区。 因此，一些入侵检测系统采用了NIDS和HIDS的混合形式，来提高对内部网络的保护力度。 以检测技术为分类标准 基于误用检测（Misuse Detection）的IDS 基于异常检测（Anomaly Detection）的IDS 基于误用检测的IDS： 误用检测是事先定义出已知的入侵行为的入侵特征，将实际环境中的数据与之匹配，根据匹配程度来判断是否发生了入侵攻击行为。 大部分入侵行为都是利用已知的系统脆弱性。通过分析入侵过程的特征、条件、顺序以及事件间的关系，可以具体描述入侵行为的特征信息。 由于依据具体特征库进行判断，所以检测准确率很高。 误用检测有时也被称为特征分析（Signature Analysis）或基于知识的检测（Knowledge-based Detection）。 误用检测的主要缺陷： 首先，检测范围受已有知识的局限，无法检测未知的攻击类型； 其次，将具体入侵手段抽象成知识具有一定困难，而且建立的入侵特征库需要不断更新维护。 基于异常检测的IDS： 异常检测是根据使用者的行为或资源使用状况的程度与正常状态下的标准特征（活动轮廓）之间的偏差来判断是否遭到入侵。如果偏差高于阈值，则发生异常。 异常检测不依赖于某个具体行为是否出现，通用性较强。 但是，对基于异常检测的IDS来说，得到正常行为或状态的标准特征以及确定阈值具有较大的难度。 首先，不可能对整个系统内的所有用户行为进行全面的描述，而且每个用户的行为是经常改变的。 其次，资源使用情况也可能由于某种特定因素发生较大的变化。 因此，基于异常检测的IDS往往漏报率低，但误报率高。 在实际应用中，往往将误用检测和异常检测项结合，以达到更好的效果。 ","date":"2021-11-21 11:36:12","objectID":"https://qizhengzou.github.io/isc_base_07/:3:2","tags":["information security conspectus"],"title":"ISC_base_07","uri":"https://qizhengzou.github.io/isc_base_07/"},{"categories":["School courses"],"content":"7.3.3 入侵检测技术 入侵检测技术研究具有综合性、多领域性的特点，技术种类繁多，涉及到许多相关学科。 从以下四个方面介绍入侵检测的主要技术方法。 误用检测 异常检测 诱骗 响应 误用检测技术 误用检测是一直比较成熟的入侵检测技术，目前大多数入侵检测系统都是基于误用检测的思想来设计实现的。 实现误用检测的方法主要包括： 专家系统； 特征分析； 模型推理； 状态转换分析； 完整性校验等。 专家系统： 安全专家将入侵检测方面的知识，以规则结构的形式表示出来，形成专家知识库。 规则结构一般采用条件判断形式，即if-then结构，if部分是构成入侵所要求的条件，then部分是发现入侵后采取的相应措施。 专家系统的主要问题是全面性问题和效率问题。 全面性问题是指难以取得专家的全部知识，同时专家的知识也很难具有充分的全面性。 效率问题是所需处理的数据量可能很大，逐一判断效率低。 特征分析： 目前商业软件主要采用的方法，也称为模式匹配。 模式匹配，就是将收集到的信息与已知的误用模式数据库进行比较，从而发现违背安全策略的行为。 该过程可以很简单（如通过字符串匹配以寻找一个简单的条目），也可以很复杂（如利用正规的数学表达式来表示安全状态的变化）。 该方法的优点是只需收集相关的数据集合，显著减少系统负担，技术成熟。 该方法的缺点是，需要不断地升级以对付不断出现的黑客攻击手法，不能检测到从未出现过的黑客攻击手段。 状态转换分析 将入侵过程看做一个行为序列，该行为序列导致系统从初始状态转入被入侵状态。 需要针对每一种入侵方法，确定系统的初始状态和被入侵状态，以及导致状态转换的转换条件。 模型推理 通过建立误用脚本模型，根据样本来推理以判断是否发生了误用行为。 完整性分析 主要关注某些特定对象是否被更改，如重要的日志、文件以及目录等内容。 完整性分析利用消息摘要函数等方法，能够识别特定对象极其微小的变化。 异常检测技术 异常检测是一种与系统相对无关、通用性较强的入侵检测技术。异常检测的思想最早由Denning在IDES系统中提出，即通过监视系统审计记录上系统使用的异常情况，可以检测出违反安全政策的事件。 通常异常检测都与一些数学分析方法相结合，但存在着误报率较高的问题。 异常检测主要针对用户行为数据、系统资源使用情况进行分析判断。 常见的异常检测方法主要包括统计分析、预测模型、系统调用监测以及基于人工智能的异常检测技术等。 统计分析 检测系统维护一个由行为模式组成的规则知识库，每个模式采用一系列系统度量来表示特定用户的正常行为。 预测模型 使用动态规则集合来检测入侵，这些规则根据所观察事件的序列关系和局部特性归纳产生序列模式。 系统调用监测 监视由特权程序进行系统调用的方法来进行异常检测。 基于人工智能的异常检测技术 这些人工智能技术主要包括数据挖掘、神经网络/深度学习、模糊证据理论等。 入侵诱骗技术 入侵诱骗是指用通过伪装成具有吸引力的网络主机来吸引攻击者，同时对攻击者的各种攻击行为进行分析，进而找到有效的应对方法。 入侵诱骗也具有通过吸引攻击者，从而保护重要的网络服务系统的目的。 常见的入侵诱骗技术主要有蜜罐（Honeypot）技术和蜜网（Honeynet）技术等。 蜜罐是一种安全资源，其价值在于被扫描、攻击和攻陷。所有流入或流出蜜罐的网络流量都可能预示了扫描、攻击和攻陷。 蜜网是蜜罐技术上发展起来的一个新概念，又称为诱捕网络。 蜜罐的核心价值在于对这些攻击活动进行监视、检测和分析。 蜜罐有两种形式： 一种是真实系统蜜罐，实际上就是一个真实运行的系统，并带有可入侵的漏洞，它所记录下的入侵信息往往是最真实的。 另一种是伪装系统蜜罐，它是运行于真实系统基础上的仿真程序，它可以伪造出各种“系统漏洞”。入侵这样的“漏洞”，只能是在一个程序框架了打转。即使成功“渗透”，对系统本身也没有损害。 利用蜜罐技术可以迷惑入侵者，从而保护真实的服务器；同时，也可以诱捕网络罪犯。 蜜网技术实质上是一类高交互蜜罐技术，其主要目的是收集黑客的攻击信息。 与传统蜜罐技术的差异：蜜网构成了一个黑客诱捕网络体系架构，该架构包含了一个或多个蜜罐，同时保证了网络的高度可控性，并提供多种工具来完成对攻击信息的采集和分析。 蜜网可以通过采用虚拟操作系统软件来实现，如VMWare等，这样可以在单一主机上实现蜜网的体系架构，即虚拟蜜网。 虚拟蜜网的引入使得架设蜜网的代价大幅降低，较容易部署和管理，但同时也带来了更大的风险。 黑客有可能识别出虚拟操作系统软件，并可能攻破虚拟操作系统，从而获得对整个虚拟蜜网甚至真实主机的控制权 响应技术 入侵检测系统的响应技术可以分为主动响应和被动响应。 主动响应是系统自动阻断攻击过程或以其他方式影响攻击过程。 被动响应是报告和记录发生的事件。 被动响应无法阻止入侵行为，只起到缩短系统管理人员反应时间的作用。 主动响应的一种表现形式就是采取反击行动。 但是，一直以来没有成为常用的响应形式，主要是有客观原因。 因为入侵者的常用攻击方法是利用一个被黑掉的系统作为攻击的平台，而且反击行动也可能会涉及法律法规等问题。 因此，当检测到入侵时，一般是利用防火墙和网关阻止来自入侵IP地址的数据包，也可以采用网络对话的方式阻断网络连接，即向入侵者的计算机发送TCP的RESET包，或发送ICMP的Destination Unreachable数据包，或者求助于被入侵主机的网络管理员。 修正系统环境也是主动响应的一种手段，主要是提高分析引擎对特定模式的敏感度，增加监视范围，更好地收集信息，以便堵住导致入侵发生的漏洞，目前被广泛应用。 ","date":"2021-11-21 11:36:12","objectID":"https://qizhengzou.github.io/isc_base_07/:3:3","tags":["information security conspectus"],"title":"ISC_base_07","uri":"https://qizhengzou.github.io/isc_base_07/"},{"categories":["School courses"],"content":"7.3.4 Snort系统 Snort入侵检测系统是一个开放源代码的轻量级网络入侵检测系统。 Snort遵循CIDF模型，使用误用检测的方法来识别发现违反系统和网络安全策略的网络行为。 Snort系统包括数据包捕获模块、预处理模块、检测引擎和输出模块四部分组。 Snort检测引擎模块： 检测引擎是Snort的核心部件，主要功能是规则分析和特征检测。 当数据包从预处理送过来后，检测引擎依据预先设置的规则检查数据包，一旦发现数据包中的内容和某条规则相匹配，就通知输出模块进行报警。 Snort将所有已知的入侵行为以规则的形式存放在规则库中，并以三维链表结构进行组织。 每一条规则由规则头和规则选项两部分组成。 规则头对应于规则树节点（Rule Tree Node，RTN），包含规则动作选项、数据包类型、源地址、源端口、目的地址、目的端口、数据流动方向等内容。 规则选项对应于规则选项节点（Optional Tree Node, OTN），包含报警信息和匹配内容等选项。 Snort规则库： Activate：报警并且激活另一条dynamic规则。Dynamic：保持空闲直到被一条activate规则激活，被激活后就作为一条log规则执行。 Snort定义了五种可选的行为： Alert：使用设定的警告方法生成警告信息，并记录这个数据报文； Log：使用设定的记录方法来记录这个数据报文； Pass：忽略这个数据报文； Activate：进行alert，然后激活另一个dynamic规则。 Dynamic：等待被一个activate规则激活，被激活后就作为一条log规则执行。 Snort规则例子： Alert tcp any any-\u003e10.1.1.0/24 80(content:\"/cgi-bin/phf”；msg:“PHF probe!\"；) 在这个规则中，括号左面为规则头，括号中间的部分为规则选项，规则选项中冒号前的部分为选项关键字(Option Keyword)。 规则头由规则行为、协议字段、地址和端口信息3部分组成。 选项关键字content是在数据包负载中搜索的模式；msg表示打印一条警告信息到警告或日志中； 这条规则的含义是：当在任何发往10.1.1.0/24子网主机80端口的tcp数据包负载中，如果发现子串“/cgi-bin/phf”，则此数据包为攻击数据包，Snort将报警并输出“PHF probe!”，表示此数据包为对本地网络Web服务器的PHF服务的探测攻击。 ","date":"2021-11-21 11:36:12","objectID":"https://qizhengzou.github.io/isc_base_07/:3:4","tags":["information security conspectus"],"title":"ISC_base_07","uri":"https://qizhengzou.github.io/isc_base_07/"},{"categories":["School courses"],"content":"7.4 网络防御的新技术 主要介绍： VLAN技术 IPS（入侵防御系统） IMS（入侵管理系统） 云安全 VLAN技术： VLAN（Virtual Local Area Network）的中文名为虚拟局域网。 1999年IEEE颁布了用于实现VLAN标准化的802.1Q协议标准草案。将VLAN定义为： VLAN是由一些局域网网段构成的与物理位置无关的逻辑组，而每个逻辑组中的成员具有某些相同的需求。 VLAN是用户和网络资源的逻辑组合，是局域网给用户提供的一种服务，而并不是一种新型局域网。 每一个VLAN的帧都有一个明确的标识符，指明发送这个帧的工作站属于哪一个VLAN。 由于VLAN是从逻辑上划分，所以同一个VLAN内的各个工作站可以在不同物理LAN网段。 VLAN的划分方式： VLAN的划分可依据不同原则，常见的方式： 基于端口、基于MAC地址和基于IP子网等几种方法。 基于端口的VLAN划分 这种划分是把一个或多个交换机上的几个端口划分一个逻辑组，这是最简单、最有效的划分方法。 基于MAC地址的VLAN划分 按MAC地址把一些节点划分为一个逻辑子网，使得网络节点不会因为地理位置的变化而改变其所属的网络，从而解决了网络节点的变更问题。 基于IP子网的VLAN划分 基于子网的VLAN，则是通过所连计算机的IP地址，来决定其所属的VLAN。 VLAN的安全性： 广播风暴防范 VLAN逻辑分段和物理网络分段不同，同一VLAN处于相同的广播域，通过VLAN的划分可以有效地阻隔网络广播，缩小广播域，控制广播风暴。 信息隔离 同一个VLAN内的计算机之间可以直接通信，不同VLAN间的通信则要通过路由器进行路由选择、转发，这样就能隔离基于广播的信息，防止非法访问。 控制IP地址盗用 该VLAN内任何一台计算机的IP地址都必须在分配给该VLAN的IP地址范围内，否则将无法通过路由器的审核，也就不能进行通信。 VLAN存在的问题： VLAN容易遭受欺骗攻击和硬件依赖性问题。 欺骗攻击主要包括MAC地址欺骗、ARP欺骗以及IP盗用转网等问题； 硬件依赖是指VLAN的组建要使用交换机，并且不同主机之间的信息交换要经过交换机。 因此，VLAN的安全性在很大程度上依赖于所使用的交换机，以及对交换机的配置。 IPS: 入侵防御系统IPS（Intrusion Prevention System）是在防火墙和IDS基础上发展起来的，但不是IDS的升级产品。 IPS采用串联的方式部署在内、外网络之间的关键路径上，其工作方式是采用基于包过滤的存储转发机制。 IPS技术可以深度感知并检查流经的网络流量，对恶意数据包进行丢弃以阻断攻击，保护网络带宽资源。 IPS结构： 流量分析器：截获数据包并处理异常情况，执行类似于防火墙的访问控制。 检测引擎：一般基于异常检测模型和误用检测模型，识别不同属性的攻击。 响应模块：丢弃数据包、中止会话、修改防火墙规则、报警、日志等。 流量调整器：流量分类和流量优化，设置不同优先级。 IPS与IDS相比的优势： 具备检测和防御功能：IDS只是检测和报警，IPS可以做到检测和防御兼顾。 可检测到IDS检测不到的攻击行为：IPS是在应用层的内容检测基础上，加上主动响应和过滤功能，填补了网络安全产品线的基于内容的安全检查的空白。 黑客较难破坏入侵攻击数据：IPS在检测攻击行为时具有实时性，因此可在入侵时予以检测防御，避免入侵攻击行为记录被破坏。 具有双向检测防御功能：IPS可以对内网和外网之间的两个方向的攻击入侵行为做到检测和防御。 IPS面临的问题： 作为串联接入网络的IPS所面临的最大问题是处理速度必须与数千兆或者更大容量的网络流量保持同步，否则成为网络瓶颈。 因此，IPS必须具有高性能、高可靠性、高安全性。 IMS: 入侵管理系统IMS（Intrusion Management System）是一个针对整个入侵过程进行统一管理的安全服务系统。 在入侵行为发生前，IMS要考虑网络中存在什么漏洞，判断可能出现的攻击行为和面临的入侵危险； 在入侵行为发生时或即将发生时，IMS不仅要检测出入侵攻击行为，还要进行阻断处理，终止入侵行为； 在入侵行为发生后，IMS要进行深层次的入侵行为分析，通过关联分析，来判断是否还存在下一次入侵攻击的可能性。 实际上，IMS应该是一个融合了多种安全防御技术的管理系统。 IMS模型： 云安全： “云”是一种新兴技术，云计算（Cloud Compute）、云存储（Cloud Storage）及云安全（Cloud Security）也随之相继产生。 最早受IBM、微软、Google等巨头追捧的“云计算”模式，是将计算资源放置在网络中，供许多终端设备来使用，其关键是分布处理、并行处理以及网格计算。云可以理解为网络中的所有可计算、可共享的资源，这是个共享资源的概念。 云安全是通过网状的大量客户端对网络中软件行为的异常监测，获取互联网中木马、恶意程序的最新信息，传送到Server端进行自动分析和处理，再把病毒和木马的解决方案分发到每一个客户端。 目前，云安全也被称为云杀毒，主要针对木马和病毒。 云安全示意图： 云安全的特点： 云安全更加强调主动和实时，将互联网打造成为一个巨大的“杀毒软件”，参与者越多，每个参与者就越安全，整个互联网就会更安全。 与传统信息安全模式相比，云安全具有如下特点： 快速感知，捕获新的威胁。与传统信息安全模式“一个人战斗”相比，云安全的客户数据中心凝聚了互联网的力量，整合了所有可能参与的人，效率大大提高。 云安全的客户端具有更专业的感知能力。 云安全存在的问题： 需要海量的客户端 只有拥有海量的客户端，才能对互联网上出现的病毒、木马、挂马网站有最灵敏的感知能力，在第一时间做出反应。 需要专业的反病毒技术和经验 如果没有反病毒技术和经验的积累，无法实现“云安全”系统及时处理处理海量的上报信息，并将处理结果共享给云安全系统的每个成员。 需要大量的资金和技术投入 开放的系统 真正的云安全系统应该满足云的原始定义，即资源共享 ","date":"2021-11-21 11:36:12","objectID":"https://qizhengzou.github.io/isc_base_07/:4:0","tags":["information security conspectus"],"title":"ISC_base_07","uri":"https://qizhengzou.github.io/isc_base_07/"},{"categories":["School courses"],"content":" 2021秋哈工大深圳罗文坚 信息安全概论课程PPT 摘抄 网络威胁 ","date":"2021-11-21 11:36:09","objectID":"https://qizhengzou.github.io/isc_base_06/:0:0","tags":["information security conspectus"],"title":"ISC_base_06","uri":"https://qizhengzou.github.io/isc_base_06/"},{"categories":["School courses"],"content":"6.1 概述 威胁：用威力逼迫恫吓使人屈服。 网络威胁：是网络安全受到威胁、存在着危险。 随着互联网的不断发展，网络安全威胁也呈现了一种新的趋势。 最初，主要是计算机病毒，比如“CIH”、“大麻”等传统病毒。 至今，已逐渐发展为包括特洛伊木马、后门程序、流氓软件、间谍软件、广告软件、网络钓鱼、垃圾邮件等等。 目前的网络威胁往往是集多种特征于一体的混合型威胁。 ","date":"2021-11-21 11:36:09","objectID":"https://qizhengzou.github.io/isc_base_06/:1:0","tags":["information security conspectus"],"title":"ISC_base_06","uri":"https://qizhengzou.github.io/isc_base_06/"},{"categories":["School courses"],"content":"6.1.1 网络威胁的三个阶段 第一阶段（1998年以前）：网络威胁主要来源于传统的计算机病毒，其特征是通过媒介复制进行传染，以攻击破坏个人电脑为目的。 第二阶段（大致在1998年以后）：网络威胁主要以蠕虫病毒和黑客攻击为主，其表现为蠕虫病毒通过网络大面积爆发、黑客攻击一些服务网站。 第三阶段（2005年以来）：网络威胁多样化，多数以偷窃资料、控制利用主机等手段谋取经济利益为目的。 ","date":"2021-11-21 11:36:09","objectID":"https://qizhengzou.github.io/isc_base_06/:1:1","tags":["information security conspectus"],"title":"ISC_base_06","uri":"https://qizhengzou.github.io/isc_base_06/"},{"categories":["School courses"],"content":"6.1.2 网络威胁分类 从攻击发起者的角度来看： 一类是主动攻击型威胁，如网络监听和黑客攻击等，这些威胁都是对方人为通过网络通信连接进行的； 另一类就是被动型威胁，一般是用户通过某种途径访问了不当的信息而受到的攻击。例如，使用了带病毒的U盘，访问了带病毒、木马、恶意软件的网页、图片和邮件等。 依据攻击手段及破坏方式进行分类： 第一类是以传统病毒、蠕虫、木马等为代表的计算机病毒； 第二类是以黑客攻击为代表的网络入侵； 第三类以间谍软件、广告软件、网络钓鱼软件为代表的欺骗类威胁。 ","date":"2021-11-21 11:36:09","objectID":"https://qizhengzou.github.io/isc_base_06/:1:2","tags":["information security conspectus"],"title":"ISC_base_06","uri":"https://qizhengzou.github.io/isc_base_06/"},{"categories":["School courses"],"content":"6.2 计算机病毒 ","date":"2021-11-21 11:36:09","objectID":"https://qizhengzou.github.io/isc_base_06/:2:0","tags":["information security conspectus"],"title":"ISC_base_06","uri":"https://qizhengzou.github.io/isc_base_06/"},{"categories":["School courses"],"content":"6.2.1 病毒概述 1949年，约翰·冯·诺依曼的论文《自我繁衍的自动机理论》，从理论上论证了当今计算机病毒的存在。 20世纪60年代初，美国贝尔实验室的三位程序员编写了一个名为“磁芯大战”的游戏，游戏中程序通过复制自身来摆脱对方的控制。 1983年，美国南加州大学的弗雷德·科恩博士研制出一种在运行过程中可以复制自身的破坏性程序，第一次验证了计算机病毒的存在。 1984年，弗雷德·科恩发表论文《计算机病毒：原理和实验》。 1986年，Brain病毒，世界上流行的第一个病毒。 1988年，罗伯特·塔潘·莫里斯（美国前国家安全局首席科学家罗伯特·莫里斯的儿子）编写Morris蠕虫。 计算机病毒定义： 《中华人民共和国计算机信息系统安全保护条例》中明确定义： 病毒是指“编制或者在计算机程序中插入的破坏计算机功能或者破坏数据，影响计算机使用并且能够自我复制的一组计算机指令或者程序代码” 计算机病毒特征： 非授权性：在用户未知（未授权）的情况下执行。 寄生性：传统病毒特有；目前的网络病毒多是独立文件。 传染性：是否具有传染性是判断一个程序是否为计算机病毒的重要条件。 潜伏性：发作时间可能是预设的，不发作很难觉察出来。 破坏性：使正常程序无法运行；窃取资料；破坏文件等。 触发性：触发条件可能是时间、日期、文件类型等。 计算机病毒发展新的趋势： 无国界：过去，以磁盘等为媒介，从国外发现到国内流行，传播周期平均需要6-12个月；目前，Internet普及，几天甚至更短时间就传遍整个世界。 多样化：引导型病毒、可执行文件型病毒、宏病毒和混合型病毒，利用Java、VB和ActiveX网页技术撰写病毒等。 破坏性更强：修改文件（含注册表）、通信端口、用户密码，挤占内存，远程控制，等等。 智能化：例如，超级病毒Verona，将病毒写入邮件原文。一旦用户用Outlook预览了该邮件，病毒就会发作。 更加隐蔽化：主题随用户的传播改变；伪装成常用程序；病毒写入文件内部，而且文件长度不变；等等。 计算机病毒分类： 计算机病毒可以根据其工作原理和传播方式划分成： 传统病毒：寄生于宿主文件内，以可移动介质为传播途径的计算机病毒。 蠕虫病毒：利用网络进行复制和传播，以独立智能程序形式存在的计算机病毒。 木马：木马一般不会自我繁殖，也并不“刻意”去感染其他文件，而是通过伪装吸引用户下载并安装在用户的计算机内，向施种木马者提供打开的被种者计算机的门户，是施种者可以任意破坏、窃取被种者的文件，甚至远程操控被种者的计算机。 ","date":"2021-11-21 11:36:09","objectID":"https://qizhengzou.github.io/isc_base_06/:2:1","tags":["information security conspectus"],"title":"ISC_base_06","uri":"https://qizhengzou.github.io/isc_base_06/"},{"categories":["School courses"],"content":"6.2.2 传统病毒 传统病毒的代表： 巴基斯坦智囊（Brain）、大麻、磁盘杀手（DISK KILLER）、CIH等。 传统病毒一般有三个主要模块组成，包括启动模块、传染模块和破坏模块。 CIH病毒： 感染Windows 95/98环境下PE格式的EXE文件（第一例）。 病毒发作时直接攻击和破坏计算机硬件系统。 该病毒通过文件复制进行传播。 计算机开机后，运行了带病毒的文件，其病毒就驻留在Wnidows核心内存里。 由初始化驻留模块、传染模块和破坏模块组成。 Signature=”00455000”表明该文件是PE格式的可执行文件，且尚未感染。 ","date":"2021-11-21 11:36:09","objectID":"https://qizhengzou.github.io/isc_base_06/:2:2","tags":["information security conspectus"],"title":"ISC_base_06","uri":"https://qizhengzou.github.io/isc_base_06/"},{"categories":["School courses"],"content":"6.2.3 蠕虫病毒 蠕虫病毒产生于20世纪80年代后期，鼎盛时期却是从20世纪90年代末开始的，而且迅速成为计算机病毒的主流。 蠕虫病毒的代表包括： Morris蠕虫，1988年 红色代码（Code Red），2001年 尼姆达（Nimda），2001年 求职信，2002年 SQL蠕虫王，2003 熊猫烧香，2006年底-2007年初，中国警方破获的首例计算机病毒大案 蠕虫与传统病毒的区别： 传统病毒是需要“寄生”，通过感染其它文件进行传播。 蠕虫病毒一般不需要寄生在宿主文件中，传播途径主要包括局域网内的共享文件夹、电子邮件、网络中的恶意网页和大量存在着漏洞的服务器等。 可以说，蠕虫病毒是以计算机为载体，以网络为攻击对象。 蠕虫病毒与普通病毒的另一个不同是，蠕虫病毒往往能够利用漏洞。 漏洞分为软件漏洞和人为缺陷。 软件漏洞主要指程序员由于习惯不规范、错误理解或想当然，在软件中留下存在安全隐患的代码。 例如，缓冲区溢出漏洞、微软IE和Outlook的自动执行漏洞等。 人为缺陷主要指的是计算机用户的疏忽，这就是所谓的社会工程学（Social Engineering）问题。 例如，当收到标题为求职信息的邮件时，大多数人都会抱着好奇的心理去点击它，则求职信病毒将顺利侵入。 蠕虫病毒的攻击和传播主要就是利用漏洞。 尼姆达蠕虫Worms.Nimda： 2001年9月18日，尼姆达病毒在全球蔓延，它能够通过多种传播渠道进行传播，传染性极强，同时破坏力也极大。 尼姆达病毒是一个精心设计的蠕虫病毒，其结构复杂堪称历年来之最。 尼姆达病毒激活后，使用其副本替换系统文件；将系统的各驱动器设为开放共享，降低系统安全性；创建Guest账号并将其加入到管理员组中，安装Guest用户后门。 由于尼姆达病毒通过网络大量传播，产生大量异常的网络流量和大量的垃圾邮件，网络性能势必受到严重影响。 Nimda传播途径： 尼姆达病毒程序： Nimda病毒的防范及清除： 感染的用户应重新安装系统，以便彻底清除其它潜在的后门。 如不能立刻重装系统，可参考下列步骤来清除蠕虫或者防止被蠕虫攻击： 下载IE和IIS的补丁程序到受影响的主机上； 安装杀毒软件和微软的CodeRedII清除程序； 备份重要数据； 断开网络连接（例如，拔掉网线）； 执行杀毒工作，清除CodeRedII蠕虫留下的后门； 安装IE和IIS的补丁； 重启系统，再次运行杀毒软件以确保完全清除蠕虫。 ","date":"2021-11-21 11:36:09","objectID":"https://qizhengzou.github.io/isc_base_06/:2:3","tags":["information security conspectus"],"title":"ISC_base_06","uri":"https://qizhengzou.github.io/isc_base_06/"},{"categories":["School courses"],"content":"6.2.4 木马 木马病毒，“木马计”，伪装潜伏的网络病毒。 1986年的PC-Write木马是世界上第一个计算机木马。 PC-Write木马伪装成共享软件PC-Write的2.72版本。 事实上，编写PC-Write的Quicksoft公司从未发行过2.72版本。 一旦用户信以为真，运行该木马程序，那么他的下场就是硬盘被格式化。 随着Internet的普及，木马逐渐形成了独特的伪装和传播两种特征，作为黑客窃取信息的工具四处泛滥。 木马是有隐藏性的、传播性的可被用来进行恶意行为的程序。因此，也被看作是一种计算机病毒。 木马一般不会直接对电脑产生危害，以控制电脑为目的。当然，电脑一旦被木马所控制，后果不堪设想。 木马的传播（种木马或植入木马）方式： 主要通过电子邮件附件、被挂载木马的网页以及捆绑了木马程序的应用软件。 木马被下载安装后完成修改注册表、驻留内存、安装后门程序、设置开机加载等，甚至能够使杀毒程序、个人防火墙等防范软件失效。 木马病毒的分类：盗号类木马、网页点击类木马、下载类木马 、代理类木马。 木马病毒的分类： 盗号类木马 通常采用记录用户键盘输入、Hook应用程序进程等方法获取用户的密码和账号。 窃取到的信息一般通过发送电子邮件或向远程控制程序直接提交的方式发送给木马作者。 盗号木马的目标一般为游戏软件、即时通讯软件以及网上交易系统。 网页点击类木马 模拟用户点击广告等动作，短时间内产生大量的点击量。 目的一般是为了赚取高额的广告推广费用。 下载类木马 体积小，功能是从网络上下载其他病毒程序或安装广告软件。 因为体积很小，下载类木马更容易传播，传播速度也更快。 通常，功能强大、体积也很大的后门类病毒，如“灰鸽子”、“黑洞”等，传播时都单独编写一个小巧的下载型木马，用户中毒后会把后门主程序下载到本机运行。 代理类木马 用户感染代理类木马后，会在本机开启HTTP、SOCKS等代理服务功能。 黑客将受感染的计算机作为跳板，以被感染用户的身份进行黑客活动，达到隐藏自己的目的。 木马病毒程序的组成： 控制端程序（客户端） 是黑客用来控制远程计算机中的木马的程序。 木马程序（服务器端） 是木马病毒的核心，是潜入被感染的计算机内部、获取其操作权限的程序。 木马配置程序 通过修改木马名称、图标等来伪装、隐藏木马程序，并配置端口号、回送地址等信息确定反馈信息的传输路径。 灰鸽子的植入方法： 被动植入是指植入过程必须依赖受害用户的手工操作。一般是伪装成合法程序，以降低用户的警觉性并诱骗用户。 主动植入是将灰鸽子程序通过程序自动安装到目标系统，植入过程无需受害用户的操作。 灰鸽子的初始化安装： 木马程序G_Server.exe运行后，将自己复制到Windows文件夹内，并释放G_Server.dll和G_Server_Hook.dll。 G_Server.dll：实现后门功能，与控制客户端通信。 G_Server_Hook.dll：隐藏木马，包括隐藏文件、隐藏进程和隐藏通信。 G_Server.exe、G_Server.dll和G_Server_Hook.dll组成了灰鸽子的服务端。 有的灰鸽子会多释放一个G_ServerKey.dll文件，用于记录键盘操作。 G_Server.exe将自己注册成服务，以便每次开机都自动运行，在加载G_Server.dll、G_Server_Hook.dll和G_ServerKey.dll后自动退出。 G_Server.exe这个名字并不是固定的，是可以定制的。 灰鸽子的隐藏技术： 隐藏文件 灰鸽子拦截了对API函数的调用，隐藏了木马程序和它注册的服务项。 即使设置了“显示所有隐藏文件”，也看不到它们。 隐藏进程 修改列举进程API函数的入口地址，在别的程序在调用这些函数的时候，首先转向木马程序。木马程序中需要做的工作就是在列表中将自己的进程信息去掉，从而实现进程的隐藏。 隐藏通讯 采用通信端口复用技术和反弹端口技术。 通讯端口复用技术是指将自己的通讯直接绑定到正常用户进程的端口，接收数据后，根据包格式判断是不是自己的，如果是它的，自己处理，否则通过127.0.0.1的地址交给真正的服务器应用进行处理。 反弹端口技术是指木马程序启动后主动连接客户，为了隐蔽起见，控制端的被动端口一般设置为80端口。 对内部网络到外部网络的访问请求，防火墙一般不进行过于严格的检查，加之其连接请求有可能伪造成对外部资源的正常访问，因此容易通过防火墙。 灰鸽子的客户端程序： 客户端程序主要包括两个功能： 定制生成服务器端程序。 控制远程的服务器端。 定制生成服务器端程序： 首先，利用客户端程序配置生成一个服务器端程序文件，服务器端文件的名字默认为G_ Server.exe，然后开始在网络中传播植入这个程序。 木马植入成功后，系统启动时，木马就会加载运行，然后通过反弹端口技术主动连接客户控制端。 客户控制端程序的功能： 对远程计算机文件管理：模仿Windows资源管理器，可以对文件进行复制、粘贴、删除、重命名、远程执行等，可以上传下载文件或文件夹，操作简单易用。 远程控制命令：查看远程系统信息、查看剪贴板、进程管理、窗口管理、插件功能、服务管理、共享管理、代理服务、MS-DOS模拟、关机、重启。 捕获屏幕，实时控制：可以连续地捕获远程计算机屏幕，并把本地的鼠标及键盘操作传送到远程被控制端，实现实时控制功能。 注册表模拟器：远程操作注册表就像操作本地注册表一样方便。 入侵者满足私欲后，可以自行删除灰鸽子文件，这一过程用户根本无法觉察。任何悲惨的事情都有可能发生。 ","date":"2021-11-21 11:36:09","objectID":"https://qizhengzou.github.io/isc_base_06/:2:4","tags":["information security conspectus"],"title":"ISC_base_06","uri":"https://qizhengzou.github.io/isc_base_06/"},{"categories":["School courses"],"content":"6.2.5 病毒防治 病毒防治技术略滞后于病毒技术。 对于大多数计算机用户来说，防治病毒首先需要选择一个有效的防病毒产品，并及时进行产品升级。 计算机病毒防治技术主要包括: 检测、清除、预防和免疫。 检测和清除是根治病毒的有力手段。 预防和免疫也是保证计算机系统安全的重要措施。 检测： 病毒检测方法主要包括：特征代码法、校验和法、行为监测法以及软件模拟法等。 特征代码法 特征代码查毒就是检查文件中是否含有病毒数据库中的病毒特征代码。 检测已知病毒的最简单、开销最小的方法。 检测工具必须不断更新版本，无法检测从未见过的新病毒。 校验和法 对正常状态下的重要文件进行计算，取得其校验和，以后定期检查这些文件的校验和与原来保存的校验和是否一致。 既可检测已知病毒，又可发现未知病毒。 因为文件内容的改变有可能是正常程序引起的，所以校验和法使用不当可能会引起误报。 行为监测法 利用病毒的特有行为特征来监测病毒的方法，称为行为监测法。当一个可疑程序运行时，监视其行为，如果发现了病毒行为，立即报警。 可以发现未知病毒，但容易引起误报。 软件模拟法 软件模拟法是为了对付多态型病毒。 多态病毒：每次感染时，采用随机方法对病毒主体进行加密，放入宿主程序的代码互不相同，特征代码法无法检测。 通过模拟病毒的执行环境，为其构造虚拟机，在虚拟机中执行病毒引擎解码程序，安全地将多态型病毒解开并还原其本来面目，再加以扫描。 软件模拟法的优点是可识别未知病毒、病毒定位准确、误报率低；缺点是检测速度受到一定影响、消耗系统资源较高。 计算机中毒的常见症状： 系统运行速度减慢； 系统经常无故发生死机； 文件长度发生变化； 存储的容量异常减少； 丢失文件或文件损坏； 屏幕上出现异常显示； 系统的蜂鸣器出现异常声响； 磁盘卷标发生变化； 系统不识别硬盘； 对存储系统异常访问； 键盘输入异常； 文件的日期、时间、属性等发生变化； 文件无法正确读取、复制或打开； 命令执行出现错误； WINDOWS操作系统无故频繁出现错误； 系统异常重新启动； 一些外部设备工作异常； 出现异常的程序驻留内存 清除： 清除病毒主要分为使用防病毒软件和手工清除病毒两种方法。 防病毒软件由安全厂商精心研制，可以有效查杀绝大多数计算机病毒，多数用户应采用防病毒软件来清除病毒。 防病毒软件对检测到的病毒一般采取三种处理方案，分别是清除、隔离和删除。 清除是指在发现文件被感染病毒时，采取的清除病毒并保留文件的动作。 隔离是指在发现病毒后，无法确认清除动作会带来什么后果，又不想直接删除文件，故采取监视病毒并阻止病毒运行的方法。 如果某类病毒清除失败、删除失败、隔离失败，对个人用户来讲，格式化硬盘、重建系统可能就是最后的有效选择 蠕虫或木马等病毒的清除： 目前，Windows操作系统下的病毒大多是蠕虫病毒或木马等网络病毒，对于这类病毒，其手工清除过程大致如下。 结束所有可疑进程 运行中的病毒，会因为文件正在使用而无法被删除，因此在清除病毒之前必须终止病毒的运行。 断开网络，关闭所有应用程序。 使用netstat -an分析机器上是否有后门程序在运行。 使用tasklist/m 来查看当前运行的进程（所有exe和dll），使用tasklist/v查看进程对应的程序是否真实。病毒通常会使用一个和系统程序相似或相同的名称。 有的病毒不止一个进程，相互守护，或者它以dll注入形式存在，可以使用ntsd -c q -p PID杀死进程，PID为进程标识符。 删除病毒文件并恢复注册表 在安全模式下，删除病毒文件，恢复注册表。 内核级后门的清除 感染了这类病毒后，即使有的应用程序并没有感染病毒，但它们的输出依然被病毒控制，用户可能得到虚假的文件列表、服务列表、进程列表和注册表键值。整个系统将是不可信任的。重装系统！ 重启后扫描 完成了上述三步，随后需要重新启动系统，并使用带有最新病毒库的防病毒软件对全盘进行扫描（这一步非常重要，做不好的话前功尽弃）。 预防： 安装防毒软件 打开你的防毒软件的自动升级服务，定期扫描计算机。 注意U盘、光盘等存储媒介 在使用软盘、光盘、U盘或活动硬盘前，进行病毒扫描。 关注下载安全 下载要从比较可靠的站点进行，下载后做病毒扫描。 关注电子邮件安全 来历不明的邮件决不要打开，决不要轻易运行附件。 使用基于客户端的防火墙 可以增强抵御黑客和恶意代码攻击的能力。 警惕欺骗性的病毒 警惕欺骗型病毒。天下没有免费的午餐。 备份 免疫： 计算机病毒免疫：提高计算机系统对计算机病毒的抵抗力，从而达到防止病毒侵害的目的，包括两个方面： 提高计算机系统的健壮性 给计算机注射“病毒疫苗”。 提高系统健壮性的主要途径包括以下内容： 及时升级操作系统，保证系统安装最新的补丁； 安装防病毒软件，及时升级病毒定义文件和防病毒引擎； 定期扫描系统和磁盘文件； 打开个人防火墙； 使用软盘或U盘写保护； 重要的数据信息写入只读光盘。 注射“病毒疫苗”： 实施免疫，伪装系统或软件已被某病毒感染，主要方法包括： 感染标识免疫：人为地为正常对象中加上病毒感染标识，使计算机病毒误以为已经感染，从而达到免疫的目的。 文件扩展名免疫：将扩展名改为非COM、EXE、SYS、BAT等形式，防止以扩展名为传染条件的文件型病毒的侵入。 将系统默认的可执行文件的后缀名改为非COM、EXE、SYS、BAT等形式，以便用户使用。 外部加密免疫：在文件的存取权限和存取路径上进行加密保护，以防止文件被非法阅读和修改。 内部加密免疫：对文件内容加密变换后进行存储，使用时再进行解密。 ","date":"2021-11-21 11:36:09","objectID":"https://qizhengzou.github.io/isc_base_06/:2:5","tags":["information security conspectus"],"title":"ISC_base_06","uri":"https://qizhengzou.github.io/isc_base_06/"},{"categories":["School courses"],"content":"6.3 网络入侵 1980年，James P Anderson首次提出了“入侵”的概念。 “入侵”是指在非授权的情况下，试图存取信息、处理信息或破坏系统，以使系统不可靠或不可用的故意行为。 网络入侵（Network Intrusion）一般是指具有熟练编写、调试和使用计算机程序的技巧的人，利用这些技巧来获得非法或未授权的网络或文件的访问，进入内部网的行为。 注意：对信息的非授权访问一般被称为破解（Cracking）。 网络入侵一般分为三个阶段： 前期准备、实施入侵和后期处理。 网络入侵的三个阶段： 前期准备阶段需要完成的工作主要包括明确入侵目的、确定入侵对象以及选择入侵手段。 入侵目的一般可分为控制主机、瘫痪主机和瘫痪网络； 入侵对象一般分为主机和网络两类； 根据目的和后果，入侵手段分为：拒绝服务攻击、口令攻击、嗅探攻击、欺骗攻击和利用型攻击。 实施入侵阶段是真正的攻击阶段，主要包括扫描探测和攻击。 扫描探测：主要用来收集信息，为下一步攻击奠定基础； 攻击：根据入侵目的、采用相应的入侵手段向入侵对象实施入侵。 后期处理阶段主要是指由于大多数入侵攻击行为都会留下痕迹，攻击者为了清除入侵痕迹而进行现场清理。 ","date":"2021-11-21 11:36:09","objectID":"https://qizhengzou.github.io/isc_base_06/:3:0","tags":["information security conspectus"],"title":"ISC_base_06","uri":"https://qizhengzou.github.io/isc_base_06/"},{"categories":["School courses"],"content":"6.3.1 拒绝服务攻击 拒绝服务攻击DoS (Denial of Service) DoS并不是某一种具体的攻击方式，而是攻击所表现出来的结果最终使得目标系统因遭受某种程度的破坏而不能继续提供正常的服务，甚至导致物理上的瘫痪或崩溃。 又称为业务否决攻击。 通常拒绝服务攻击可分为两种类型： 第一类攻击是利用网络协议的缺陷，通过发送一些非法数据包致使主机系统瘫痪； 第二类攻击是通过构造大量网络流量致使主机通讯或网络堵塞，使系统或网络不能响应正常的服务。 Ping of Death： 根据TCP/IP的规范，一个包的长度最大为65536字节。 但是，利用多个IP包分片的叠加能做到构造长度大于65536的IP数据包。 攻击者通过修改IP分片中的偏移量和段长度，使系统在接收到全部分段后重组报文时总的长度超过了65535字节。 一些操作系统在对这类超大数据包的处理上存在缺陷，当安装这些操作系统的主机收到了长度大于65536字节的数据包时，会出现内存分配错误，从而导致TCP/IP堆栈崩溃，造成死机。 Tear drop: IP数据包在网络传递时，数据包可能被分成多个更小的IP分片。 攻击者可以通过发送两个（或多个）IP分片数据包来实现Tear Drop攻击。 第一个IP分片包的偏移量为0，长度为N，第二个分片包的偏移量小于N，未超过第一个IP分片包的尾部，这就出现了偏移量重叠现象。 一些操作系统无法处理这些偏移量重叠的IP分片的重组，TCP/IP堆栈会出现内存分配错误，造成操作系统崩溃。 Syn Flood: 攻击者伪造TCP的连接请求，向被攻击的设备正在监听的端口发送大量的SYN连接请求报文； 被攻击的设备按照正常的处理过程，发送SYN ACK报文，回应连接请求报文，同时为它分配了相应的资源。 攻击者不需要建立TCP连接，因此服务器根本不会接收到第三个ACK报文，现有分配的资源只能等待超时释放。 如果攻击者能够在超时时间到达之前发出足够多的攻击报文，被攻击的系统所预留的所有TCP缓存将被耗尽，无法向正常用户提供服务，攻击者达到了攻击的目的（拒绝服务）。 Smurf攻击： Smurf攻击是以最初发动这种攻击的程序Smurf来命名的，这种攻击方法结合使用了IP地址欺骗和ICMP协议。 当一台网络主机通过广播地址将ICMP ECHO请求包发送给网络中的所有机器，网络主机接收到请求数据包后，会回应一个ICMP ECHO响应包，这样发送一个包会收到许多的响应包。 Smurf构造并发送源地址为受害主机地址、目的地址为广播地址的ICMP ECHO请求包，收到请求包的网络主机会同时响应并发送大量的信息给受害主机，致使受害主机崩溃。 如果Smurf攻击将回复地址设置成受害网络的广播地址，则网络中会充斥大量的ICMP ECHO响应包，导致网络阻塞。 Smurf攻击过程示意图： 电子邮件炸弹： 实施电子邮件炸弹攻击的特殊程序称为Email Bomber。 邮箱容量是有限的，用户在短时间内收到成千上万封电子邮件，而且每个电子邮件也比较大，那么经过一轮邮件炸弹轰炸后电子邮箱的容量可能被占满。 其他人发给用户的电子邮件将会丢失或者被退回，使用户的邮箱失去作用。 这些电子邮件炸弹所携带的大容量信息不断在网络上来回传输，很容易堵塞网络。 邮件服务器需要不停地处理大量的电子邮件，如果承受不了这样的疲劳工作，服务器随时有崩溃的可能。 DDoS: 随着计算机处理能力的快速增长，内存的大量增加，以及千兆级别网络的使用，DoS攻击很难有效。 分布式拒绝服务攻击DDOS（Distributed Denial of Service）就是很多DoS攻击源一起攻击某台服务器或网络，迫使服务器停止提供服务或网络阻塞。 DDoS攻击需要众多攻击源，而黑客获得攻击源的主要途径就是传播木马。 网络计算机一旦中了木马，这台计算机就会被后台操作的人控制，也就成了所谓的“肉鸡”，即黑客的帮凶。 使用“肉鸡”进行DDoS攻击，还可以在一定程度上保护攻击者，使其不易被发现。 DoS攻击的防御方法： 及时为系统升级，减少系统漏洞。很多DoS攻击对于新的操作系统已经失效，例如，Ping of Death攻击。 将主机或网络中的不必要的服务和端口关掉。 例如，对于非WEB主机关掉80端口。 局域网应该加强防火墙和入侵检测系统的应用和管理，过滤掉非法的网络数据包。 ","date":"2021-11-21 11:36:09","objectID":"https://qizhengzou.github.io/isc_base_06/:3:1","tags":["information security conspectus"],"title":"ISC_base_06","uri":"https://qizhengzou.github.io/isc_base_06/"},{"categories":["School courses"],"content":"6.3.2 口令攻击 口令攻击步骤： 步骤一、获取目标系统的用户帐号及其它有关信息； 步骤二、根据用户信息猜测用户口令； 使用对于用户来说有意义的、便于记忆的数据做口令将是危险的，如用户名、用户名变形、生日、电话、电子邮件地址等。 步骤三、采用字典攻击方式探测口令； 步骤四、探测目标系统的漏洞，伺机取得口令文件，破解取得用户口令。 关于获取目标系统的用户帐号及其它有关信息：一般利用一些网络服务来实现，如Finger、WHOIS、LDAP等信息服务。 Finger是UNIX系统中用于查询用户情况的实用程序。UNIX系统保存了每个用户的详细资料，可以用Finger命令查询。 WHOIS服务是一个在线的“请求/响应”式服务。WHOIS Server运行在后台监听43端口，当Internet用户搜索一个域名（或主机、联系人等其他信息时），WHOIS Server接收用户请求的信息并据此查询后台域名数据库。如果数据库中存在相应的记录，它会将相关信息，如所有者、管理信息以及技术联络信息等，反馈给用户。 LDAP是轻量级目录访问协议，其目录中存放着各类信息，如Email、联系人列表等。 关于字典攻击： 使用一些程序，自动地从电脑字典中取出一个单词，作为用户的口令输入给远端的主机，进入系统。 如果口令错误，就按序取出下一个单词，进行下一个尝试。并一直循环下去，直到找到正确的口令或字典的单词试完为止。 由于这个破译过程由计算机程序来自动完成，几个小时就可以把字典的所有单词都试一遍。 一般情况下，密码错误的连续登录次数是受限制的。 口令数量： 攻击者还可能采用穷举暴力攻击的方法来攻击口令。 一般而言，系统中可以用作口令的字符有95个： 10个数字、33个标点符号、52个大小写字母。 采用任意5个字母加上一个数字或符号则可能的排列数约为163亿，即525 × 43=16,348,773,000。 这个数字对于每秒可以进行上百万次浮点运算的计算机并不是什么困难问题，也就是说一个6位的口令将不是安全的。 一般建议使用10位以上并且是字母、数字加上标点符号的混合体。 防范口令攻击的方法： 口令的长度不少于10个字符； 口令中要有一些非字母； 口令不在英语字典中； 不要将口令写下来； 不要将口令存于电脑文件中； 不要选择易猜测的信息做口令； 不要在不同系统上使用同一口令； 不要让其他人得到口令； 经常改变口令； 永远不要对自己的口令过于自信。 ","date":"2021-11-21 11:36:09","objectID":"https://qizhengzou.github.io/isc_base_06/:3:2","tags":["information security conspectus"],"title":"ISC_base_06","uri":"https://qizhengzou.github.io/isc_base_06/"},{"categories":["School courses"],"content":"6.3.3 嗅探攻击 嗅探攻击也称为网络嗅探，是指利用计算机的网络接口截获目的地为其它计算机的数据包的一种手段。 网络嗅探的工具被称为嗅探器（sniffer），是一种常用的收集网络上传输的有用数据的方法。 这些数据可以是网络管理员需要分析的网络流量，也可以是黑客喜欢的用户账号和密码，或者一些商用机密数据等。 嗅探攻击一般是指黑客利用嗅探器获取网络传输中的重要数据。 网络嗅探也被形象地称为网络窃听。 共享网络环境： 以太网卡（也称作网络适配器或网络接口）共有四种工作方式： 广播方式：网卡能够接收网络中的广播数据； 组播方式：网卡能够接收组播数据； 直接方式：只有目的网卡才能接收该数据； 混杂模式：网卡能够接收一切通过它的数据。 如果攻击者获得其中一台主机的root权限，并将其网卡置于混杂模式，这就意味着不必打开配线盒来安装偷听设备，就可以对在共享环境下的其它计算机的通信进行窃听，在共享网络中网络通信没有任何安全性可言。 目前，采用“共享技术”的网络设备集线器已经被采用交换方式的交换机所取代。在大多数局域网中，利用混杂模式进行监听已经不可能了。 交换网络环境： 交换网络下的窃听是利用ARP欺骗实现的。 ARP（Address Resolution Protocol）协议：当主机接收到ARP应答数据包的时候，就使用应答数据包内的数据对本地的ARP缓存进行更新或添加。 ARP协议并不只是在发送了ARP请求并接收ARP应答后，添加ARP地址缓存。 ARP欺骗： 主机D给局域网中的所有主机发送ARP应答。主机A和B更新其ARP缓存表，主机C显示IP地址冲突。 假设主机D想监听主机A和主机C之间的通信内容： D给A发送ARP应答，告诉A，192.168.1.3主机的MAC地址是dd-dd-dd-dd-dd-dd。 D给C发送ARP应答，告诉C，192.168.1.1主机的MAC地址是dd-dd-dd-dd-dd-dd。 A想要发送给C的数据实际上发送给了D，D在嗅探到数据后将此数据转发给C。 C回应A的数据也发给了D，D嗅探之后转发给A。 这样可以保证A和C的通信不被中断，同时达到了嗅探的目的。 防范嗅探攻击： 检测嗅探器 通过检测混杂模式网卡来检查嗅探器的存在，例如AntiSniff工具。 安全的拓扑结构 嗅探器只能在当前网络段上进行数据捕获。将网络分段工作进行得越细，嗅探器能够收集的信息就越少。 会话加密 即使嗅探器嗅探到数据报文，也不能识别其内容。 地址绑定 在客户端使用ARP命令绑定网关的真实MAC地址； 在交换机上做端口与MAC地址的静态绑定； 在路由器上做IP地址与MAC地址的静态绑定； 用静态的ARP信息代替动态的ARP信息。 ","date":"2021-11-21 11:36:09","objectID":"https://qizhengzou.github.io/isc_base_06/:3:3","tags":["information security conspectus"],"title":"ISC_base_06","uri":"https://qizhengzou.github.io/isc_base_06/"},{"categories":["School courses"],"content":"6.3.4 欺骗类攻击 欺骗类攻击是指构造虚假的网络消息，发送给网络主机或网络设备，企图用假消息替代真实信息，实现对网络及主机正常工作的干扰破坏。 常见的假消息攻击方式： IP欺骗 ARP欺骗 DNS欺骗 伪造电子邮件 IP欺骗： IP欺骗简单地说就是一台主机设备冒充另外一台主机的IP地址，与其它设备通信。 IP欺骗主要是基于远程过程调用RPC的命令，比如rlogin、rcp、rsh等， 这些命令仅仅根据信源IP地址进行用户身份确认，以便允许或拒绝用户RPC。 IP欺骗的目的主要是获取远程主机的信任及访问特权 IP欺骗攻击主要步骤： 第一步：选定目标主机并发现被该主机信任的其它主机； 第二步：使得被信任的主机丧失工作能力，如SYN Flood攻击； 第三步：使用被目标主机信任的主机的IP地址，伪造建立TCP连接的SYN请求报文，试图以此数据报文建立与目标主机的TCP连接； 第四步：序列号取样和猜测。 第五步：使用被目标主机信任的主机的IP地址和计算出的TCP序列号，构造TCP连接的ACK报文（源IP为被目标主机信任的主机的IP地址），发送给目标主机，建立起与目标主机基于地址验证的应用连接。 如果成功，攻击者可以使用一种简单的命令放置一个系统后门，以进行非授权操作。 序列号取样和猜测： 如果攻击者可以截获目标主机的SYN-ACK数据包，则可以直接计算出目标主机接收的TCP序列号，来伪造TCP数据包； 否则，只能采取猜测计算的方法，攻击者先与目标主机的一个端口（如SMTP）建立起正常的连接，这个过程被重复若干次，并将目标主机的初始化系列号ISN存储起来，攻击者需要估计他的主机与被信任主机之间的往返时间RTT，然后可以预测ISN大小，并计算可能的TCP序列号。 ISN：Initial Sequence Number DNS欺骗： DNS欺骗的目的是冒充域名服务器，把受害者要查询的域名对应的IP地址伪造成欺骗着希望的IP地址。 伪造电子邮件： 由于SMTP并不对邮件的发送者的身份进行鉴定，攻击者可以冒充别的邮件地址伪造电子邮件。 攻击者伪造电子邮件的目的主要包括： 攻击者想隐藏自己的身份，匿名传播虚假信息，如造谣中伤某人； 攻击者想假冒别人的身份，提升可信度，如冒充领导发布通知； 伪造用户可能关注的发件人的邮件，引诱收件人接收并阅读，如传播病毒、木马等。 对于欺骗类攻击的防范方法： 抛弃基于地址的信任策略，不允许使用r类远程调用命令。 配置防火墙，拒绝网络外部与本网内具有相同IP地址的连接请求；过滤掉入站的DNS更新。 地址绑定，在网关上绑定IP地址和MAC地址；在客户端使用ARP命令绑定网关的真实MAC地址命令。 使用PGP等安全工具并安装电子邮件证书。 PGP（Pretty Good Privacy，优良保密协议）是一套用于消息加密、验证的应用程序。PGP中，每个公钥均绑定唯一的用户名和/或者E-mail地址。 ","date":"2021-11-21 11:36:09","objectID":"https://qizhengzou.github.io/isc_base_06/:3:4","tags":["information security conspectus"],"title":"ISC_base_06","uri":"https://qizhengzou.github.io/isc_base_06/"},{"categories":["School courses"],"content":"6.3.5 利用型攻击 利用型攻击是通过非法技术手段，试图获得某网络计算机的控制权或使用权，达到利用该机从事非法行为的一类攻击行为的总称。 利用型攻击常用的技术手段主要包括： 口令猜测 木马病毒 僵尸病毒 缓冲区溢出 僵尸病毒（Bot） 僵尸病毒是通过特定协议的信道连接僵尸网络服务器的客户端程序。 被安装了僵尸程序的机器称为僵尸主机， 僵尸网络（BotNet）是由这些受控的僵尸主机依据特定协议所组成的网络。 僵尸网络常用的协议包括IRC（Internet Relay Chat）、HTTP、P2P等。 僵尸病毒的程序结构与木马程序基本一致。 木马程序是被控制端连接的服务器端程序。 僵尸程序是向控制服务器发起连接的客户端程序。 僵尸病毒的传播和木马相似，传播途径包括： 电子邮件； 含有病毒的WEB网页； 捆绑了僵尸程序的应用软件； 利用系统漏洞攻击加载等。 黑客经常利用僵尸病毒发起大规模的网络攻击，如分布式拒绝服务攻击（DDoS）、海量垃圾邮件等， 缓冲区溢出： 缓冲区溢出是指当计算机程序向缓冲区内填充数据位数时超过了缓冲区本身的容量时，溢出的数据覆盖了合法数据。 缓冲区溢出是一种非常普遍、非常危险的程序漏洞，在各种操作系统、应用软件中广泛存在。 缓冲区溢出攻击，可以导致程序运行失败、系统宕机、重新启动等后果；更为严重的是可以利用它执行非授权指令，甚至可以取得系统特权并控制主机，进行各种非法操作。 缓冲区溢出的产生存在着必然性，现代计算机程序的运行机制、C语言的开放性及编译问题是其产生的理论基础。 程序在4GB或更大逻辑地址空间内运行时，一般会被装载到相对固定的地址空间，使得攻击者可以估算用于攻击的代码的逻辑地址； 程序调用时，可执行代码和数据共同存储在一个地址空间（堆栈）内，攻击者可以精心编制输入的数据，通过运行时缓冲区溢出，得到运行权； CPU CALL调用时的返回地址和C语言函数使用的局部变量均在堆栈中保存，而且C语言不进行数据边界检查，当数据被覆盖时也不能被发现。 一般来说，缓冲区溢出漏洞是程序员写程序时的马虎所致。 在很多服务程序中，大意的程序员使用了像strcpy()和strcat()等不能进行有效位检查的函数。 攻击者利用这一问题，设计编写一些代码，并将该代码设法加载到缓冲区有效载荷末尾。 这样，当发生缓冲区溢出时，返回指针指向恶意代码，从而获得系统的控制权。 缓冲区溢出的例子： #include \u003cstdio.h\u003e#include \u003cstring.h\u003e void Sayhello(char* name) { char tmpName [8]; strcpy(tmpName, name); printf(\"Hello %s\\n\", tmpName); } int main(int argc, char** argv) { Sayhello(argv[1]); return 0; } 下面内容是在Linux环境下example.c程序的执行情况： $ ./ example computer Hello computer $ ./ example computerssssssss Hello computerssssssss Segmentation fault (core dumped) 分析： ","date":"2021-11-21 11:36:09","objectID":"https://qizhengzou.github.io/isc_base_06/:3:5","tags":["information security conspectus"],"title":"ISC_base_06","uri":"https://qizhengzou.github.io/isc_base_06/"},{"categories":["School courses"],"content":"6.4 诱骗类威胁 诱骗类威胁是指攻击者利用社会工程学的思想，利用人的弱点（如人的本能反应、好奇心、信任、贪便宜等）通过网络散布虚假信息，诱使受害者上当受骗，而达到攻击者目的的一种网络攻击行为。 准确地说，社会工程学不是一门科学，而是一门艺术和窍门，它利用人的弱点，以顺从你的意愿、满足你的欲望的方式，让你受骗上当。 例如，利用短信诈骗银行信用卡号码。 网络钓鱼： Phishing是英单词Fishing（钓鱼）和Phone（电话，因为黑客起初以电话作案）的综合体，所以被称为网络钓鱼。 Phishing是指攻击者通过伪造以假乱真的网站和发送诱惑受害者按攻击者意图执行某些操作的电子邮件等方法，使得受害者“自愿”交出重要信息（例如银行账户和密码）的手段。 电子邮件诱骗 假冒网站 虚假的电子商务 电子邮件诱骗： 电子邮件服务是合法的Internet经典服务，攻击者进行电子邮件诱骗，一般需要经过以下几个步骤。 选定目标用户群：购买电子邮件地址；从公开的网站收集；邮件地址字典（常用名随机组合+服务提供商，例如bobsmith@gmail.com、bobsmith@163.com）。 构造欺骗性电子邮件：往往包含一个容易混淆的链接，冒充受害者所信任的组织机构。 搭建欺骗性网站：搭建域名和网页内容都与真正的被受害者所信任的组织机构网站极为相似的网站。 群发邮件，等待上当的受害者。 假冒网站： 建立假冒网站，骗取用户帐号、密码实施盗窃，这是对用户造成经济损失最大的恶劣手段。 攻击者建立起域名和网页内容都与真正的网上银行、网上证券交易等重要部门网站极为相似的假冒网站，并通过各种方式传播给用户。 例如，非法网址为“http: //www. 1cbc. com. cn”，而真正银行的网址是“http: //www. icbc. com. cn”， 虚假的电子商务： 攻击者建立电子商务网站，或是在比较知名、大型电子商务网站上发布虚假的商品销售信息。 网上交易多是异地交易，通常需要汇款。 不法分子一般要求消费者先付部分款，再以各种理由诱骗消费者付余款或者其他各种名目的款项，得到钱款或被识破时，犯罪分子就销声匿迹。 对于诱骗类威胁的防范： 诱骗类威胁不属于传统信息安全的范畴，传统信息安全办法解决不了非传统信息安全的威胁。 一般认为，解决非传统信息安全威胁需要运用社会工程学来反制。 防范诱骗类威胁的首要方法是加强安全防范意识，多问“为什么”，减少 “天上掉馅饼”的心理，那么绝大多数此类诱骗行为都不能得逞。 另外，用户还应该注意以下几点： 确认对方身份。 慎重对待个人信息。 谨防电子邮件泄密：不要在电子邮件中泄露私人的或财务方面的信息。 注意网站的URL地址。 ","date":"2021-11-21 11:36:09","objectID":"https://qizhengzou.github.io/isc_base_06/:4:0","tags":["information security conspectus"],"title":"ISC_base_06","uri":"https://qizhengzou.github.io/isc_base_06/"},{"categories":["School courses"],"content":" 2021秋哈工大深圳罗文坚 信息安全概论课程PPT 摘抄 访问控制 ","date":"2021-11-21 11:36:04","objectID":"https://qizhengzou.github.io/isc_base_05/:0:0","tags":["information security conspectus"],"title":"ISC_base_05","uri":"https://qizhengzou.github.io/isc_base_05/"},{"categories":["School courses"],"content":"5.1 概述 身份认证：识别“用户是谁”的问题。 访问控制：管理用户对资源的访问。 主体对于客体的每一次访问，访问控制系统均要审核该次访问操作是否符合访问控制策略。影响访问控制系统实施效果的首要因素是访问控制策略。 访问控制的基本组成元素 主体(Subject)：是指提出访问请求的实体，是动作的发起者，但不一定是动作的执行者。主体可以是用户或其它代理用户行为的实体（如进程、作业和程序等）。 客体(Object)：是指可以接受主体访问的被动实体。客体的内涵很广泛，凡是可以被操作的信息、资源、对象都可以认为是客体。 访问控制策略（Access Control Policy）：是指主体对客体的操作行为和约束条件的关联集合。简单地讲，访问控制策略是主体对客体的访问规则集合。这个规则集合可以直接决定主体是否可以对客体实施的特定的操作。 ","date":"2021-11-21 11:36:04","objectID":"https://qizhengzou.github.io/isc_base_05/:1:0","tags":["information security conspectus"],"title":"ISC_base_05","uri":"https://qizhengzou.github.io/isc_base_05/"},{"categories":["School courses"],"content":"5.2 访问控制模型 访问控制模型是一种从访问控制的角度出发，描述安全系统以及安全机制的方法。 访问控制模型，是对访问控制系统的控制策略、控制实施以及访问授权的形式化描述。 1985年，美国军方提出可信计算机系统评估准则TCSEC，其中描述了两种著名的访问控制模型： 自主访问控制DAC (Discretionary Access Control) 强制访问控制MAC (Mandatory Access Control) 1992年，美国国家标准与技术研究所(NIST)的David Ferraiolo和Rick Kuhn提出一个模型： 基于角色的访问控制RBAC(Role Based Access Control)模型 ","date":"2021-11-21 11:36:04","objectID":"https://qizhengzou.github.io/isc_base_05/:2:0","tags":["information security conspectus"],"title":"ISC_base_05","uri":"https://qizhengzou.github.io/isc_base_05/"},{"categories":["School courses"],"content":"5.2.1 自主访问控制 自主访问控制DAC： 自主访问控制DAC模型是根据自主访问控制策略建立的一种模型。 允许合法用户以用户或用户组的身份来访问系统控制策略许可的客体，同时阻止非授权用户访问客体。 某些用户还可以自主地把自己所拥有的客体的访问权限授予其它用户。 UNIX、LINUX以及Windows NT等操作系统都提供自主访问控制的功能。 访问权限信息存储： 从实现的角度来看，首先要对用户的身份进行鉴别，然后就可以按照访问控制列表所赋予用户的权限允许或限制用户访问客体资源。 主体控制权限的修改通常由特权用户或特权用户组实现。 特权用户为普通用户分配的访问权限信息的形式： 访问控制表ACL（Access Control Lists） ACL是以客体为中心建立的访问权限表，其优点在于实现简单，系统为每个客体确定一个授权主体的列表。 目前大多数PC、服务器和主机都使用ACL作为访问控制的实现机制。 访问控制能力表ACCL（Access Control Capability Lists） ACCL是以主体为中心建立的访问权限表。 能力，可以解释为请求访问的发起者所拥有的一个授权标签。授权标签表明持有者可以按照某种访问方式访问特定的客体。 访问控制矩阵ACM（Access Control Matrix） ACM通过矩阵形式表示主体用户和客体资源之间的授权关系。 如果主体和客体很多，ACM会有大量的冗余空间。 有关符号： Own：管理操作；R：读操作；W：写操作。 将管理操作与读/写操作分离，是因为管理员也许会对控制规则本身或是文件属性等做修改，即修改ACL/ACCL/ACM。 DAC小结： DAC为用户提供了灵活的数据访问方式，授权主体（特权用户、特权用户组的成员以及对客体拥有Own权限的主体）均可以完成赋予和回收其他主体对客体资源的访问权限，使得DAC广泛应用在商业和工业环境中。 DAC允许用户任意传递权限。 例如，没有访问文件file1权限的用户A可能从有访问权限的用户B那里获得访问权限。 因此DAC模型提供的安全防护还是相对比较低的，不能为系统提供充分的数据保护。 ","date":"2021-11-21 11:36:04","objectID":"https://qizhengzou.github.io/isc_base_05/:2:1","tags":["information security conspectus"],"title":"ISC_base_05","uri":"https://qizhengzou.github.io/isc_base_05/"},{"categories":["School courses"],"content":"5.2.2 强制访问控制 强制访问控制MAC： 强制访问控制MAC是一种多级访问控制策略。 系统事先给访问主体和受控客体分配不同的安全级别属性。 在实施访问控制时，系统先对访问主体和受控客体的安全级别属性进行比较，再决定访问主体能否访问该受控客体。 MAC模型形式化描述：将访问控制系统中的实体对象分为主体集S和客体集O，然后定义安全类SC(x) = \u003c L ，C \u003e。 其中，x为特定的主体或客体。L为有层次的安全级别Level；C为无层次的安全范畴Category。 安全范畴Category用来划分实体对象的归属，而同属于一个安全范畴的不同实体对象由于具有不同层次的安全级别L，因而构成了一定的偏序关系。 访问的四种形式： 向下读（RD，Read Down）： 主体安全级别高于客体信息资源的安全级别时，即SC(s)≥SC(o)，允许读操作； 向上读（RU，Read Up）： 主体安全级别低于客体信息资源的安全级别时，即SC(s)≤SC(o)，允许读操作； 向下写（WD，Write Down）： SC(s)≥SC(o)时，允许写操作； 向上写（WU，Write Up）： SC(s)≤SC(o)时，允许写操作。 MAC通过分级的安全标签实现了信息的单向流动，一直被军方采用。 Bell-LaPadula模型：只允许向下读、向上写。 可以有效防止机密信息向下级泄露，保护机密性。 Biba模型：只允许向上读、向下写的特点。 可以有效保护数据的完整性。 MAC信息流安全控制： …… ","date":"2021-11-21 11:36:04","objectID":"https://qizhengzou.github.io/isc_base_05/:2:2","tags":["information security conspectus"],"title":"ISC_base_05","uri":"https://qizhengzou.github.io/isc_base_05/"},{"categories":["School courses"],"content":"5.2.3 基于角色的访问控制 基于角色的访问控制RBAC： MAC模型和DAC模型属于传统的访问控制模型。 DAC虽然支持用户自主地把自己所拥有的客体的访问权限授予其他用户的这种做法，但当企业的组织结构或是系统的安全需求发生较大变化时，就需要大量繁琐的授权工作，系统管理员的工作势必非常繁重，更主要的是容易发生错误造成一些意想不到的安全漏洞。 MAC虽然授权形式相对简单，工作量小，但其特点不适合访问控制规则比较复杂的系统。 RBAC较好地综合了DAC和MAC的特点，基本解决了上述问题。 Group的概念：一般认为，Group是具有某些相同特质的用户集合。 在UNIX操作系统中Group可以被看成是拥有相同访问权限的用户集合。 定义用户组时，会为该组赋予相应的访问权限。 如果一个用户加入了该组，则该用户即具有了该用户组的访问权限。 角色Role的理解： 角色Role的概念：一个角色是一个与特定工作活动相关联的行为与责任的集合。 Role不是用户的集合，也就与组Group不同。 将一个角色与一个组绑定，则这个组就拥有了该角色拥有的特定工作的行为能力和责任。 组Group和用户User都可以看成是角色分配的单位和载体。而一个角色Role可以看成具有某种能力或某些属性的主体的一个抽象。 引入角色Role的目的： 引入角色的概念，目的是为了隔离用户（Subject，动作主体）与Privilege（权限，指对客体Object的一个访问操作，即操作Operation+客体对象Object）。 Role作为一个用户与权限的代理层，所有的授权应该给予Role而不是直接给User或Group。 RBAC模型的基本思想是将访问权限分配给一定的角色，用户通过饰演不同的角色获得角色所拥有的访问许可权。 例子： 在一个公司里，用户角色可以定义为经理、会计、出纳员和审计员，具体的权限如下： 经理：允许查询公司的经营状况和财务信息，但不允许修改具体财务信息，必要时可以根据财务凭证支付或收取现金，并编制银行账和现金帐； 会计：允许根据实际情况编制各种财务凭证及账簿，但不包括银行账和现金帐； 出纳员：允许根据财务凭证支付或收取现金，并编制银行账和现金帐； 审计员：允许查询审查公司的经营状况和财务信息，但不允许修改任何账目。 RBAC小结： RBAC的策略陈述易于被非技术的组织策略者理解，既具有基于身份策略的特征，也具有基于规则策略的特征。 在基于组或角色的访问控制中，一个用户可能不只是一个组或角色的成员，有时又可能有所限制。 例如，经理可以充当出纳员的角色，但不能负责会计工作，即各角色之间存在相容和相斥的关系。 RBAC灵活、方便和安全，目前在大型数据库系统的权限管理中得到普遍应用。 制定访问控制策略的三个基本原则： 最小特权原则： 是指主体执行操作时，按照主体所需权利的最小化原则分配给主体权力。 最小特权原则的优点是最大限度地限制了主体实施授权行为，可以避免来自突发事件和错误操作带来的危险。 最小泄漏原则： 是指主体执行任务时，按照主体所需要知道信息的最小化原则分配给主体访问权限。 多级安全策略： 是指主体和客体间的数据流方向必须受到安全等级的约束。多级安全策略的优点是避免敏感信息的扩散。 对于具有安全级别的信息资源，只有安全级别比它高的主体才能够对其访问。 ","date":"2021-11-21 11:36:04","objectID":"https://qizhengzou.github.io/isc_base_05/:2:3","tags":["information security conspectus"],"title":"ISC_base_05","uri":"https://qizhengzou.github.io/isc_base_05/"},{"categories":["School courses"],"content":"5.3 Windows系统的安全管理 ","date":"2021-11-21 11:36:04","objectID":"https://qizhengzou.github.io/isc_base_05/:3:0","tags":["information security conspectus"],"title":"ISC_base_05","uri":"https://qizhengzou.github.io/isc_base_05/"},{"categories":["School courses"],"content":"5.3.1 Windows系统安全体系结构 Windows系统采用层次性的安全架构： 安全主体： Windows系统的安全性主要围绕安全主体展开，保护其安全性。 安全主体主要包括用户、组、计算机以及域等。 用户是Windows系统中操作计算机资源的主体，每个用户必须先行加入Windows系统，并被指定唯一的账户； 组是用户账户集合的一种容器，同时组也被赋予了一定的访问权限，放到一个组中的所有账户都会继承这些权限； 计算机是指一台独立计算机的全部主体和客体资源的集合，也是Windows系统管理的独立单元； 域是使用域控制器(DC, Domain Controller)进行集中管理的网络。域控制器是共享的域信息的安全存储仓库，同时也作为域用户认证的中央控制机构。 安全子系统： 安全子系统既可以用于工作站，也可以用于服务器，区别在于服务器版的用户账户数据库可以用于整个域，而工作站版的数据库只能本地使用。 Windows登录认证流程： SSPI：Security Support Provider Interface ","date":"2021-11-21 11:36:04","objectID":"https://qizhengzou.github.io/isc_base_05/:3:1","tags":["information security conspectus"],"title":"ISC_base_05","uri":"https://qizhengzou.github.io/isc_base_05/"},{"categories":["School courses"],"content":"5.3.2 Windows系统的访问控制 Windows系统的访问控制： 访问控制模块的组成 访问令牌（Access Token）和安全描述符（Security Descriptor），它们分别由访问者和被访问者持有。通过访问令牌和安全描述符的内容，Windows可以确定持有令牌的访问者能否访问持有安全描述符的对象。 访问控制的基本控制单元“账户”。 账户是一种参考上下文(context)，是一个具有特定约束条件的容器，也可以理解为背景环境。 操作系统在这个上下文描述符上运行该账户的大部分代码。 那些在登录之前就运行的代码（例如服务）运行在一个账户（特殊的本地系统账户SYSTEM）的上下文中。 安全标识符SID： Windows中的每个账户或账户组都有一个安全标识符SID（Security Identity）。 Administrator、Users等账户或者账户组在Windows内部均使用SID来标识的。 每个SID在同一个系统中都是唯一的。 例如S-1-5-21-1507001333-1204550764-1011284298-500就是一个完整的SID。 第一个数字（本例中的1）是修订版本编号； 第二个数字是标识符颁发机构代码（Windows 2000为5）； 4个子颁发机构代码； 相对标识符RID（Relative Identifier）。 RID 500代表Administrator账户，RID 501是Guest账户。从1000开始的RID代表用户账户。 访问令牌： 每个访问令牌都与特定的Windows账户相关联，访问令牌包含该帐户的SID、所属组的SID以及帐户的特权信息。 Window 访问控制： …… ","date":"2021-11-21 11:36:04","objectID":"https://qizhengzou.github.io/isc_base_05/:3:2","tags":["information security conspectus"],"title":"ISC_base_05","uri":"https://qizhengzou.github.io/isc_base_05/"},{"categories":["School courses"],"content":"5.3.3 活动目录与组策略 活动目录与组策略： Windows的网络管理中有两个非常重要的管理技术，即活动目录AD （Active Directory）和组策略GP （Group Policy） ，它们的协调工作有效提升了Windows网络的安全性。 活动目录AD是一个面向网络对象管理的综合目录服务。 网络对象包括用户、用户组、计算机、打印机、应用服务器、域、组织单元（OU）以及安全策略等。 AD 提供的是各种网络对象的索引集合，也可以看作是数据存储的视图，将分散的网络对象有效地组织起来，建立网络对象索引目录，并存储在活动目录的数据库内。 活动目录AD的管理划分： AD把整个域作为一个完整的目录来进行管理。 组策略GP： 活动目录AD是Windows网络中重要的安全管理平台，组策略GP是其安全性的重要体现。 组策略可以理解为依据特定的用户或计算机的安全需求定制的安全配置规则。 管理员针对每个组织单元OU定制不同的组策略，并将这些组策略存储在活动目录的相关数据库内，可以强制推送到客户端实施组策略。 活动目录AD可以使用组策略命令来通知和改变已经登录的用户的组策略，并执行相关安全配置。 组策略工作流程： 用户完成网络登录后，就会受到AD直接控制管理，依据所在OU的GP来实施安全配置。 组策略的实施： 注册表是Windows系统中保存系统应用软件配置的数据库。 很多配置都是可以自定义设置的，但这些配置发布在注册表的各个角落。如果是手工配置，可想是多么困难和繁琐。 组策略可以将系统中重要的配置功能汇集成一个配置集合，管理人员通过配置并实施组策略，达到直接管理计算机的目的。 简单点说，实施组策略就是修改注册表中的相关配置。 组策略和活动目录AD配合： 组策略分为基于活动目录的和基于本地计算机的两种： AD组策略存储在域控制器上活动目录AD的数据库中，它的定制实施由域管理员来执行；而本地组策略存放在本地计算机内，由本地管理员来定制实施。 AD组策略实施的对象是整个组织单元OU；本地组策略只负责本地计算机。 组策略和活动目录AD配合： 组策略可以部署在OU、站点或域的范围内，也可以部署在本地计算机上。 部署在本地计算机时，组策略不能发挥其全部功能，只有和AD配合，组策略才可以发挥出全部潜力。 组策略的主要工作： 部署软件 设置用户权力 软件限制策略 管理员可以通过配置组策略，限制某个用户只能运行特定的程序或执行特定的任务。 控制系统设置： 允许管理员统一部署网络用户的Windows服务。 设置登录、注销、关机、开机脚本。 通用桌面控制 安全策略 重定向文件夹 基于注册表的策略设置 ","date":"2021-11-21 11:36:04","objectID":"https://qizhengzou.github.io/isc_base_05/:3:3","tags":["information security conspectus"],"title":"ISC_base_05","uri":"https://qizhengzou.github.io/isc_base_05/"},{"categories":["School courses"],"content":" 2021秋哈工大深圳罗文坚 信息安全概论课程PPT 摘抄 身份认证 ","date":"2021-11-21 11:35:58","objectID":"https://qizhengzou.github.io/isc_base_04/:0:0","tags":["information security conspectus"],"title":"ISC_base_04","uri":"https://qizhengzou.github.io/isc_base_04/"},{"categories":["School courses"],"content":"4.1 概述 问题的提出：什么是身份认证？ 身份认证是证实用户的真实身份与其所声称的身份是否相符的过程。 身份认证的依据应包含只有该用户所特有的、并可以验证的特定信息。 用户所知道的或所掌握的信息（Something the user know），如密码、口令等； 用户所拥有的特定东西（Something the user possesses），如身份证、护照、密钥盘等； 用户所具有的个人特征（Something the user is or How he behaves），如指纹、笔迹、声纹、虹膜、DNA等。 目前身份认证技术主要包括三类： 基于口令的认证技术： 简单灵活，但容易泄露。 基于密码学的认证技术：包括基于对称密钥的认证、基于公开密钥的认证协议。 生物特征的认证技术：依附于人体，不易伪造，不易模仿！ 身份认证 根据认证条件的数目分类： 仅通过一个条件的相符合来证明一个人的身份，称之为单因子认证； 通过两种不同条件来证明一个人的身份，称之为双因子认证； 通过组合多种不同条件来证明一个人的身份，称之为多因子认证。 根据认证数据的状态来看： 静态数据认证：指用于识别用户身份的认证数据事先已产生并保存在特定的存储介质上； 动态数据认证：指用于识别用户身份的认证数据不断动态变化，每次认证使用不同的认证数据，即动态密码。动态密码由一种称为动态令牌的专用设备（硬件或软件）产生，其产生动态密码的算法与认证服务器采用的算法相同。 ","date":"2021-11-21 11:35:58","objectID":"https://qizhengzou.github.io/isc_base_04/:1:0","tags":["information security conspectus"],"title":"ISC_base_04","uri":"https://qizhengzou.github.io/isc_base_04/"},{"categories":["School courses"],"content":"4.2 认证协议 认证协议： 以网络为背景的认证技术的核心基础是密码学。 对称密码和公开密码是实现用户身份识别的主要技术。 实现认证必须要求示证方和验证方遵循一个特定的规则来实施认证，这个规则被称为认证协议。 认证过程的安全取决于认证协议的完整性和健壮性。 ","date":"2021-11-21 11:35:58","objectID":"https://qizhengzou.github.io/isc_base_04/:2:0","tags":["information security conspectus"],"title":"ISC_base_04","uri":"https://qizhengzou.github.io/isc_base_04/"},{"categories":["School courses"],"content":"4.2.1 基于对称密钥的认证协议 基于对称密钥的认证协议： 示证方和验证方共享密钥，通过共享密钥来维系彼此的信任关系，实际上认证就是建立某种信任关系的过程。 在只有少量用户的封闭式网络系统中，各用户之间的双人共享密钥的数量有限，可以采用挑战-应答方式来实现认证； 对于规模较大的网络系统，一般采用密钥服务器的方式来实现认证，即依靠可信的第三方完成认证。 有关符号表示： 𝐀→𝐁：表示A向B发送一条信息。 𝑬_k (𝒙)：使用共享秘钥k对信息串x加密。 𝒙||𝒚：表示x和y相连接。 基于挑战-应答方式的认证协议 由验证方生成一个大的随机数据串，即挑战，将挑战发送给示证方。 示证方使用共享秘钥加密挑战，然后回送给验证方， 验证方通过解密密文得到挑战，通过验证挑战的正确与否，来认证示证方的身份。 Needham-Schroeder认证协议： 所有的使用者共同信任一个公正的第三方，此第三方被称为认证服务。 每个使用者需要在认证服务器AS（Authentication Server）上完成注册，AS保存每一个用户的信息并与每一个用户共享一个对称密钥。 用户和AS之间的信任关系依靠它们的共享秘钥来维系。 有关符号： KDC （Key Distribution Center）为AS的秘钥分配中心，主要功能是为用户生成、分发通信秘钥。 𝐈𝐃_𝐀 和𝐈𝐃_𝐁分别是A和B的网络用户标识。 Needham-Schroeder协议描述: …… Needham-Schroeder协议的漏洞： Needham-Schroeder协议存在漏洞。 假定攻击方C掌握了A和B之间通信的一个老的会话。 C可以在第3步冒充A利用老的会话欺骗B。 除非B记住所有以前使用的与A通信的会话密钥，否则B无法判断这是一个重放攻击。 Kerberos Kerberos的设计目标是用对称密钥系统为客户机/服务器应用程序提供强大的第三方认证服务。 每个用户或应用服务器与Kerberos分享一个对称密钥。 Kerberos由两个部分组成： 认证服务器AS（Authentication Server） 票据授予服务器TGS（Ticket Granting Server）。 允许一个用户通过交换加密消息，在整个网络上与另一个用户或应用服务器互相证明身份，Kerberos给通讯双方提供对称密钥。 票据Ticket是客户端访问服务器时，提交的用于证明自己身份，并可传递通信会话秘钥的认证资料。 AS负责签发访问TGS服务器的票据，TGS负责签发访问其它应用服务器的票据。 协议内容 …… Windows用户登录认证过程： …… ","date":"2021-11-21 11:35:58","objectID":"https://qizhengzou.github.io/isc_base_04/:2:1","tags":["information security conspectus"],"title":"ISC_base_04","uri":"https://qizhengzou.github.io/isc_base_04/"},{"categories":["School courses"],"content":"4.2.2 基于公开密钥的认证协议 基于公开密钥的认证协议： 基于公开密钥体制下的认证协议通常有两种认证方式： 方式一：实体A需要认证实体B，A发送一个明文挑战消息（也称挑战因子，通常是随机数）给B，B接收到挑战后，用自己的私钥对挑战明文消息加密，称为签名；B将签名信息发送给A，A使用B的公钥来解密签名消息，称为验证签名，以此来确定B是否具有合法身份。 方式二：实体A将挑战因子用实体B的公钥加密后发送给B，B收到后是用自己的私钥解密还原出挑战因子，并将挑战因子明文发还给A，A可以根据挑战因子内容的真伪来核实B的身份。 Needham-Schroeder公钥认证： …… 基于CA数字证书的认证协议： 基于CA数字证书的认证协议属于公开秘钥的认证协议范畴，只是引入了一个可信的第三方来管理公钥并提供仲裁。在实际的网络环境中，公钥是采用数字证书（Certificate）的形式来完成发布的。 数字证书是一个经过权威的、可信赖的、公正的第三方机构（即CA认证中心，Certificate Authority）签名的包含拥有者信息及公开密钥的文件。 X. 509 V3证书格式： 基于数字证书进行身份认证的过程： 通过5个环节，B可以确认A的身份及其签名的信息。 A提交资料，申请证书。 CA审核A的资料，颁发用CA私钥签过名的数字证书。 该数字证书包含了A的身份信息和A的公钥。由于使用了CA的私钥签名，因此其他人无法伪造。 A使用私钥对特定信息进行签名，连同数字证书一起发送给B，B为验证方。 B为了能够核实A的数字证书的真伪，必须先获得CA的公钥。 B使用CA的公钥对A的数字证书进行合法性验证，通过后获得A的公钥，对A签过名的特定信息进行认证，进而确认A的身份及其签名的信息。 ","date":"2021-11-21 11:35:58","objectID":"https://qizhengzou.github.io/isc_base_04/:2:2","tags":["information security conspectus"],"title":"ISC_base_04","uri":"https://qizhengzou.github.io/isc_base_04/"},{"categories":["School courses"],"content":"4.3 公钥基础设施PKI 公钥基础设施PKI： 为了解决Internet上电子商务等应用的安全问题，世界各国经过多年的研究，初步形成了一套完整的Internet安全解决方案，即目前被广泛采用的公钥基础设施（Public Key Infrastructure，PKI）。 PKI是一种遵循一定标准的密钥管理基础平台，为所有网络应用提供加密和数字签名等密码服务所必需的密钥和证书管理。 PKI就是利用公钥理论和技术建立的提供安全服务的基础设施。 用户可利用PKI平台提供的服务进行安全的电子交易、通信和互联网上的各种活动。 ","date":"2021-11-21 11:35:58","objectID":"https://qizhengzou.github.io/isc_base_04/:3:0","tags":["information security conspectus"],"title":"ISC_base_04","uri":"https://qizhengzou.github.io/isc_base_04/"},{"categories":["School courses"],"content":"4.3.1 PKI体系结构 PKI采用数字证书技术来管理公钥，通过CA认证中心把用户的公钥和用户的其他标识信息捆绑在一起，在互联网上验证用户的身份。中心是公钥算法和数字证书技术。CA认证中心是第三方的可信任机构。 PKI体系结构： 认证机构CA是PKI的核心执行机构，也称为认证中心，其主要功能包括数字证书的申请注册、证书签发和管理。 其工作内容包括验证并标识证书申请者的身份，对证书申请者的信用度、申请证书的目的、身份的真实可靠性等问题进行审查，确保证书与身份绑定的正确性。 当服务范围较大时，CA可以拆分出证书申请注册机构（Registration Authority，RA），专门负责证书的注册申请和撤销申请等管理工作。 证书库（Repository）是CA颁发证书和撤销证书的集中存放地，是网上的公共信息库，可供公众进行开放式查询。 查询的目的有两个：一是想得到与之通信实体的公钥，二是要验证通信对方的证书是否已进入黑名单。 证书库一般采用LDAP（Lightweight Directory Access Protocol）协议搭建分布式的目录系统。 秘钥备份及恢复：当用户证书生成时，秘钥被CA备份存储。当秘钥丢失需要恢复时，用户只需向CA提出申请，CA就会为用户自动进行秘钥恢复。 证书撤销处理：证书和秘钥都有一定的生成期限。当用户的私钥泄露或公司职员离职时，都需要撤销原CA证书。被撤销的CA证书进入证书库的黑名单，公众可查询核实。 PKI应用接口是使用者和PKI交互的唯一途径，可以看成是PKI的客户端软件。使用者在其计算机上安装PKI的客户端软件。 PKI平台包括以上四个基本功能模块和一个应用接口模块。 ","date":"2021-11-21 11:35:58","objectID":"https://qizhengzou.github.io/isc_base_04/:3:1","tags":["information security conspectus"],"title":"ISC_base_04","uri":"https://qizhengzou.github.io/isc_base_04/"},{"categories":["School courses"],"content":"4.3.2 基于X.509的PKI系统 基于X.509的PKI系统： X.509是国际电信联盟-电信（ITU-T）部分标准和国际标准化组织（ISO）的证书格式标准。 X.509的主要作用是确定了公钥证书结构的基准。 当前使用的版本是X.509 V3。 X.509 V3证书包括一组按预定义顺序排列的强制字段，还有可选扩展字段。即使在强制字段中，X.509证书也具有很大的灵活性，因为它为大多数字段提供了多种编码方案。 X.509的CA目录的层次结构： 基于X. 509的层次型认证机构分布： 用户a的证书链可以使用下面的形式表达： KRA《CAB》KRB《CAC》KRC《CAD》KRD《CAa》 KRX表示X的私钥签名，CAX表示X的证书。 如果某用户x希望验证用户a的证书。 用户a的CA证书是认证机构D签发的，用户x只要得到认证机构D的公钥，就可以验证用户a的证书中D的签名，即完成对用户a的证书的认证，从而得到用户a的公钥。 假如用户x不能确定D的公钥，就必须查看D的证书。 由于D的证书是由认证机构C签发的，因此，用户x需要使用C的公钥验证D的证书并得到其公钥。 以此类推，最坏的情况是用户x需要使用认证机构A的公钥，而A是此认证机构的根，A的证书也叫根证书，是使用其私钥自签名产生的。 用户在使用CA证书之前必须先下载安装A的证书，同时系统会自动加载保存认证机构A的公钥。 一个典型的PKI模型： PKI系统功能： 接收验证用户数字证书的申请； 确定是否接受用户数字证书的申请； 向申请者颁发（或拒绝颁发）数字证书； 接收、处理用户的数字证书更新请求； 接收用户数字证书的查询、撤销； 产生和发布证书的有效期； 数字证书的归档； 密钥归档； 历史数据归档。 ","date":"2021-11-21 11:35:58","objectID":"https://qizhengzou.github.io/isc_base_04/:3:2","tags":["information security conspectus"],"title":"ISC_base_04","uri":"https://qizhengzou.github.io/isc_base_04/"},{"categories":["School courses"],"content":" 2021秋哈工大深圳罗文坚 信息安全概论课程PPT 摘抄 物理安全 ","date":"2021-11-21 11:35:55","objectID":"https://qizhengzou.github.io/isc_base_03/:0:0","tags":["information security conspectus"],"title":"ISC_base_03","uri":"https://qizhengzou.github.io/isc_base_03/"},{"categories":["School courses"],"content":"概述 物理安全技术包括: 防盗、防火、防静电、防雷击、防信息泄漏、物理隔离； 基于物理环境的容灾技术和物理隔离技术也属于物理安全技术范畴。 物理安全是信息安全的必要前提。 如果不能保证信息系统的物理安全，其他一切安全内容均没有意义。 ","date":"2021-11-21 11:35:55","objectID":"https://qizhengzou.github.io/isc_base_03/:1:0","tags":["information security conspectus"],"title":"ISC_base_03","uri":"https://qizhengzou.github.io/isc_base_03/"},{"categories":["School courses"],"content":"设备安全防护 防盗 计算机也是偷窃者的目标，计算机偷窃行为所造成的损失可能远远超过计算机本身的价值。 对于保密程度要求高的计算机系统及其外部设备，应安装防盗报警装置，制定安全保护方法及夜间留人值守。 安全保护设备 有源红外报警器、无源红外报警器和微波报警器等； 计算机系统是否安装报警系统，安装什么样的报警系统，要根据系统的安全等级及计算机中心信息与设备的重要性来确定。 防盗技术 在计算机系统和外部设备上加无法去除的标识； 使用一种防盗接线板，一旦有人拔电源插头，就会报警； 可以利用火灾报警系统，增加防盗报警功能； 利用闭路电视系统对计算机中心的各部位进行监视保护等 防火 火灾因素： 电气原因、人为因素或外部火灾蔓延引起的。 计算机机房的主要防火措施如下： 计算机中心选址 建筑物的耐火等级 不间断供电系统或自备供电系统 防雷设施与抗静电地板 严禁存放腐蚀性物品和易燃易爆物品 禁止吸烟和随意动火 计算机机房的主要防火措施 计算机中心应设置在远离散发有害气体及生产、储存腐蚀性物体和易燃易爆物品的地方，或建于其常年上风方向。 不宜设在落雷区、矿区以及填杂土淤泥、流沙层、地层断裂、地址活动频繁区和低洼潮湿的地方； 要避开有强电磁场、强振动源和强噪音源的地方。同时必须保证自然环境清洁、交通运输方便以及电力、水源充足。 建筑物的耐火等级不应低于二级，要害部位应达到一级。 五层以上房间内、地下室以及上下层或邻近有易燃易爆炸危险的房间内不得安装计算机。 机房与其他房间要用防火墙分割封闭，装修、装饰材料要用不燃或阻燃材料。 信息存储设备要安装在单独的房间，资料架和资料柜应采用不燃材料制作。 电缆竖井和管道竖井在穿过楼板时，必须用耐火极限不低于1h的不燃烧体隔板分开。电缆管道在穿过机房的墙壁处，也要设置耐火极限不低于0.75h的不燃烧体隔板，穿墙电缆应套金属管，缝隙应用不燃材料封堵。 要建立不间断供电系统或自备供电系统，并在靠近机房部位设置紧急断电装置。计算机系统的电源线上，不得接有负荷变化的空调系统、电动机等电气设备，并做好屏蔽接地。消防用电设备的配电线路明敷时应穿金属管，暗敷时应敷设在不燃结构内。电气设备的安装和检修、改线和临时用线等应符合电气防火的要求。 机房外面应有良好的防雷设施。设施、设备的接地电阻应符合国家规定的有关标准要求。机房内宜选用具有防火性能的抗静电地板。 可视情况设置火灾自动报警、自动灭火系统，并尽量避开可能招致电磁干扰的区域或设备，同时配套设置消防控制室。 计算机中心应严禁存放腐蚀性物品和易燃易爆物品。检修时必须先关闭设备电源，再进行作业，并尽量避免使用易燃溶剂。 所有工作场所应禁止吸烟和随意动火。工作人员应掌握必要的防火常识和灭火技能，值班人员每日要定时做好防火安全巡回检查，应配备轻便的气体灭火器。 防静电 静电产生：接触 → 电荷 → 转移 → 偶电层形成 → 电荷分离。 静电是一种电能，具有高电位、低电量、小电流和作用时间短的特点。 设备或人体上的静电最高可达数万伏甚至数十万伏；在正常操作下，常达数百至数千伏。 静电放电火花造成火灾，还能使大规模集成电损坏，这种损坏可能是不知不觉造成的。 静电防范： 静电的泄漏和耗散、静电中和、静电屏蔽与接地、增湿等。 防范静电的基本原则是“抑制或减少静电荷的产生，严格控制静电源”。 计算机机房的静电防范措施 温度、湿度要求：温度18~28度，湿度40%~65%。 空气含尘要求：每升直径大于0.5-m的含尘浓度粒应小于3500个，每升直径大于5-m的含尘浓度粒应小于30个。含尘粒子为非导电、非导磁性和非腐蚀性的。 地面要求：当采用地板下布线方式时，可铺设防静电活动地板；当采用架空布线方式时，应采用静电耗散材料作为铺垫材料。 墙壁、顶棚、工作台和座椅的要求：墙壁和顶棚表明应光滑平整，减少积尘，避免炫光。允许采用具有防静电性能的墙纸及防静电涂料。可选用铝合金箔材做表面装饰材料。工作台、椅、终端台应是防静电的。 静电保护接地要求：静电保护接地电阻应不大于10欧姆，防静电活动地板金属支架、墙壁、顶棚的金属层都应接静电地，整个通信机房形成一个屏蔽罩。通信设备的静电地、终端操作台地线应分别接到总地线母体汇流排上。 人员和操作要求：操作者必须进行静电防护培训后才能操作。 其它防静电措施：必要时装设离子静电消除器，以消除绝缘材料上的静电和降低机房内的静电电压。机房内的空气过于干燥时，应使用加湿器或其他办法用以满足机房对湿度的要求。 设施维护：定期（如一周）对防静电设施进行维护和检验。 防雷击 雷电防范的主要措施是： 根据电气及微电子设备的不同功能及不同受保护程序和所属保护层来确定防护要点，做分类保护。 常见的防范措施主要包括： 接闪：让闪电能量按照人们设计的通道泄放到大地中去。接闪装置包括避雷针、避雷线和避雷带等。 接地：让已经纳入防雷系统的闪电能量泄放入大地。 分流：一切从室外来的导线与接地线之间并联一种适当的避雷器，当直接雷或感应雷在线路上产生的过电压波沿着导线进入室内或设备时，避雷器的电阻突然降到低值，近于短路状态，将闪电电流分流入地。 屏蔽：用金属网、箔、壳、管等导体把需要保护的对象包围起来，阻隔闪电的脉冲电磁场从空间入侵的通道。 ","date":"2021-11-21 11:35:55","objectID":"https://qizhengzou.github.io/isc_base_03/:2:0","tags":["information security conspectus"],"title":"ISC_base_03","uri":"https://qizhengzou.github.io/isc_base_03/"},{"categories":["School courses"],"content":"防信息泄露 电磁泄露 电子计算机和其他电子设备一样，工作时产生电磁发射，电磁发射包括辐射发射和传导发射。 电磁发射可能产生两个问题： 电磁干扰； 信息泄露。 电磁干扰 电磁干扰EMI（Electro Magnetic Interference） 是指一切与有用信号无关的、不希望有的，或对电器及电子设备产生不良影响的电磁发射。 防止EMI要从两个方面来考虑： 减少电子设备的电磁发射； 提高电子设备的电磁兼容性EMC。 电磁兼容性EMC（Electro Magnetic Compatibility）： 电子设备在自己正常工作时产生的电磁环境，与其它电子设备之间相互不影响的电磁特性。 TEMPEST 电磁发射还可能被高灵敏的接收设备接收并进行分析、还原，造成了计算机的信息泄露。 针对这一现象，美国国家安全局开展了一项绝密项目，后来产生了TEMPEST （Transient Electromagnetic Pulse Emanation Standard）技术及相关产品。 TEMPEST技术又称为计算机信息泄漏安全防护技术，是一项综合性的技术，包括泄露信息的分析、预测、接收、识别、复原、防护、测试、安全评估等项技术，涉及到多个学科领域。 常规的信息安全技术（如加密传输等）不能解决输入和输出端的电磁信息泄露问题，因为人机界面不能使用密码，而使用通用的信息表示方法，如CRT显示、打印机打印信息等。事实证明，这些设备电磁泄露造成的信息泄露十分严重。 通常我们把输入、输出的数据信号及它们的变换称为核心红信号。那些可以造成核心红信号泄密的控制信号称为关键红信号，红信号的传输通道或单元电路称为红区。 所谓的“TEMPEST”，要解决的问题就是防止红信号发生电磁信息泄漏。 防电磁信息泄露，主要包括三个层面： 抑制电磁发射，采取各种措施减小“红区”电路电磁发射； 屏蔽隔离，在其周围利用各种屏蔽材料使红信号电磁发射场衰减到足够小，使其不易被接收，甚至接收不到； 相关干扰，采取各种措施使相关电磁发射信号即使被接收到也无法识别。 防电磁泄漏的常用方法： 屏蔽法（即空域法） 屏蔽法主要用来屏蔽辐射及干扰信号。 采用各种屏蔽材料和结构，合理地将辐射电磁场与接收器隔离开，使辐射电磁场在到达接收器时强度降低到最低限度，从而达到控制辐射的目的。 空域防护是对空间辐射电磁场控制的最有效和最基本的方法。机房屏蔽室就是这种方法的典型例子。 频域法 频域法主要解决正常的电磁发射受干扰问题。 不论是辐射电磁场，还是传导的干扰电压和电流都具有一定的频谱，即由一定的频率成分组成。 通过频域控制的方法来抑制电磁干扰辐射的影响，即利用系统的频率特性将需要的频率成分（信号、电源的工作交流频率）加以接收，而将干扰的频率加以剔除。 频域法就是利用要接收的信号与干扰所占有的频域不同，对频域进行控制。 时域法 与频域法相似，时域法也是用来回避干扰信号。 当干扰非常强，不易受抑制、但又在一定时间内阵发存在时，通常采用时间回避方法，即信号的传输在时间上避开干扰。 窃听 窃听是指通过非法的手段获取未经授权的信息。 窃听的实现主要依赖于各种“窃听器”。不同的窃听器针对的对象不同，主要包括会议谈话、有线电话、无线信号、电磁辐射以及计算机网络等。 窃听技术，是指窃听行动所使用的窃听设备和窃听方法的总称。 目前已经形成了有线、无线、激光、红外、卫星和遥感等种类齐全的庞大窃听家族，而且被窃听的对象也从军事机密向商业活动甚至平民生活发展。 有线窃听：主要指针对他人之间的有线通信线路予以秘密侵入，以探知其通信内容。典型的是对固定电话的监听。 无线窃听：通过相关设备侵入他人间的无线通信线路以探知其通信内容，典型的是对移动电话的监听。 激光窃听：用激光发生器产生的一束极细的红外激光射在被窃听房间的玻璃上，房间内有人谈话时，窗玻璃会随声波发生轻微震动，从玻璃上反射回来的激光中包含了室内声波震动信息，经过接收器接收，解调放大，就能将声音还原。 辐射窃听：利用各种电子设备存在的电磁泄露，收集电磁信号并还原，得到相应信息。 计算机网络窃听：通过在网络的特殊位置按照窃听软件，接收能够收到的一切信息，并分析还原为原始信息。 防窃听：指搜索发现窃听装置及对原始信息进行特殊处理，以达到消除窃听行为或使窃听者无法获得特定原始信息。 防窃听技术主要分为两种： 检测：主要指主动检查是否存在窃听器，可以采用电缆加压技术、电磁辐射检测技术以及激光探测技术等； 防御：主要是采用基于密码编码技术对原始信息进行加密处理，确保信息即使被截获也无法还原出原始信息。 另外，电磁信号屏蔽也属于窃听防御技术。 ","date":"2021-11-21 11:35:55","objectID":"https://qizhengzou.github.io/isc_base_03/:3:0","tags":["information security conspectus"],"title":"ISC_base_03","uri":"https://qizhengzou.github.io/isc_base_03/"},{"categories":["School courses"],"content":"物理隔离 概述： 物理隔离概念，最早出现在美国、以色列等国家的军方，用以解决涉密网络与公共网络连接时的安全。 在我国的政府涉密网络及军事涉密网络的建设中，也涉及了需要物理隔离的问题。 物理隔离，首先遇到的问题是安全域的问题。国家的安全域一般以信息涉密程度划分为涉密域和非涉密域。 涉密域：涉及国家秘密的网络空间。 非涉密域：不涉及国家的秘密，但是涉及本单位、本部门或者本系统的工作秘密的网络空间。 公共服务域：既不涉及国家秘密，也不涉及工作秘密。 物理隔离： 较早时描述的单词Physical Disconnection。 后来用Physical Separation和Physical Isolation。 目前开始使用Physical Gap这个词汇，直译为物理隔离，意为通过制造物理的豁口，来达到物理隔离的目的。 最初的物理隔离方法：建立两套网络系统和计算机设备。 一套用于内部办公，另一套用于与互联网连接。 采用两套互不相连的系统，不仅成本高，而且极为不便。 这一矛盾促进了物理隔离设备的开发。 对物理隔离的理解表现： 阻断网络的直接连接。 阻断网络的Internet逻辑连接。 隔离设备的传输机制具有不可编程的特性，因此不具有感染的特性。 任何数据都是通过两级移动代理的方式来完成，两级移动代理之间是物理隔离的。 隔离设备具有审查的功能。 隔离设备传输的原始数据，不具有攻击或对网络安全有害的特性。如txt文件不会有病毒一样，也不会执行命令。 强大的管理和控制功能。 从隔离的内容看，隔离分为网络隔离和数据隔离。 数据隔离：指存储设备的隔离，即一个存储设备不能被几个网络共享。 网络隔离：把被保护的网络从公开的、无边界的、自有的环境中独立出来。 物理隔离和逻辑隔离： 物理隔离与逻辑隔离有很大的区别。 物理隔离的哲学是不安全就不连网，要绝对保证安全； 物理隔离部件的安全功能应保证被隔离的计算机资源不能被访问（至少应包括硬盘、软盘和光盘），计算机数据不能被重用（至少应包括内存）。 逻辑隔离的哲学是在保证网络正常使用下，尽可能安全。 逻辑隔离部件的安全功能应保证被隔离的计算机资源不能被访问，只能进行隔离器内外的原始应用数据交换。 网络物理隔离的基本形式： 内外网络无连接，内网与外网之间任何时刻均不存在连接，是最安全的物理隔离形式。 客户端物理隔离，采用隔离卡使一台计算机既连接内网又连接外网，可以在不同网络上分时地工作，在保证内外网络隔离的同时，节省资源、方便工作。 网络设备端物理隔离，在网络设备处的物理隔离常常要与客户端的物理隔离相结合，它可以使客户端通过一条网线由远端切换器连接双网，实现一台工作站连接两个网络的目的。 服务器端物理隔离，实现在服务器端的数据过滤和传输，使内外网之间同一时刻没有连线，能快速、分时地传递数据 ","date":"2021-11-21 11:35:55","objectID":"https://qizhengzou.github.io/isc_base_03/:4:0","tags":["information security conspectus"],"title":"ISC_base_03","uri":"https://qizhengzou.github.io/isc_base_03/"},{"categories":["School courses"],"content":"容错与容灾 容错： 任何信息系统都存在脆弱性问题。 保证系统可靠性的三条途径： 避错是完善设计和制造，试图构造一个不会发生故障的系统，但这是不太现实的。 纠错做为避错的补充。一旦出现故障，可以通过检测、排除等方法来消除故障，再进行系统的恢复。 容错是第三条途径。其基本思想是即使出现了错误，系统也可以执行一组规定的程序。 容错系统： 高可用度系统：可用度用系统在某时刻可以运行的概率衡量。高可用度系统面向通用计算机系统，用于执行各种无法预测的用户程序，主要面向商业市场。 长寿命系统：长寿命系统在其生命期中不能进行人工维修，常用于航天系统。 延迟维修系统：延迟维修系统也是一种容灾系统，用于航天、航空等领域，要求满足在一定阶段内不进行维修仍可保持运行。 高性能系统：高性能系统对于故障（瞬间或永久）都非常敏感，因此应当具有瞬间故障的自动恢复能力，并且增加平均无故障时间。 关键任务系统：关键任务系统出错可能危及人的生命或造成重大经济损失，要求处理正确无误，而且恢复故障时间要最短。 常用的数据容错技术： 空闲设备：也称双件设备，就是备份两套相同的部件。正常情况下，一套运行，一套空闲。当正常运行的部件出现故障时，原来空闲的一台立即替补。 镜像：镜像是把一份工作交给两个相同的部件同时执行。这样，在一个部件出现故障时，另一个部件继续工作。 复现：复现也称延迟镜像，与镜像一样需要两个系统，但是它把一个系统称为原系统，另一个成为辅助系统。辅助系统从原系统中接收数据，与原系统中的数据相比，辅助系统接收数据存在着一定延迟。当原系统出现故障时，辅助系统只能在接近故障点的地方开始工作。 负载均衡：负载均衡是指将一个任务分解成多个子任务，分配给不同的服务器执行，通过减少每个部件的工作量，增加系统的稳定性。 容灾： 容灾是针对灾害而言。灾害对于系统来说，危害性比错误要大、要严重。从保护系统的安全性出发，备份是容错、容灾以及数据恢复的重要保障。 地震、火灾、水灾、暴乱、恐怖活动等。 容灾的真正含义是对偶然事故的预防和恢复。 解决方案有两类： 对服务的维护和恢复； 保护或恢复丢失的、被破坏的或被删除的信息。 只有将两者结合起来，才能提供完整的灾难恢复方案。 灾难恢复策略： （1）做最坏的打算；对于可能遭受的破坏情况，尽量考虑周全。 （2）充分利用现有资源；例如，利用磁盘、光盘等备份系统的信息和数据，直接用于灾难恢复。 （3）既重视灾后恢复，也注意灾前措施。 数据和系统的备份和还原是事故恢复能力的重要组成。 数据备份越新、系统备份越完整的机构部门就越容易实现灾难恢复操作。 例如，每天进行增量备份，每周进行一次完整备份。 对于特别重要的部门，必须异地备份。 ","date":"2021-11-21 11:35:55","objectID":"https://qizhengzou.github.io/isc_base_03/:5:0","tags":["information security conspectus"],"title":"ISC_base_03","uri":"https://qizhengzou.github.io/isc_base_03/"},{"categories":["School courses"],"content":" 2021秋哈工大深圳罗文坚 信息安全概论课程PPT 摘抄 密码学基础 解决数据的机密性、完整性、不可否认性以及身份识别等问题均需要以密码为基础密码技术是保障信息安全的核心基础。 密码学(Cryptography)包括密码编码学和密码分析学两部分。 将密码变化的客观规律应用于编制密码用来保守通信秘密的，称为密码编码学； 研究密码变化客观规律中的固有缺陷，并应用于破译密码以获取通信情报的，称为密码分析学 ","date":"2021-11-21 11:35:51","objectID":"https://qizhengzou.github.io/isc_base_02/:0:0","tags":["information security conspectus"],"title":"ISC_base_02","uri":"https://qizhengzou.github.io/isc_base_02/"},{"categories":["School courses"],"content":"密码学基础知识 密码体制 消息在密码学中被称为明文(Plain Text)。 伪装消息以隐藏它的内容的过程称为加密(Encrypt)。 被加密的消息称为密文(Cipher Text)。 把密文转变为明文的过程称为解密(Decrypt)。 完整密码体制要包括如下五个要素： M是可能明文的有限集称为明文空间； C是可能密文的有限集称为密文空间； K是一切可能密钥构成的有限集称为密钥空间； E为加密算法，对于任一密钥， 都能够有效地计算； D为解密算法，对于任一密钥，都能够有效地计算。 密码体系必须满足如下特性： 加密算法(Ek：M-\u003eC)和解密算法(Dk：C-\u003eM)满足: Dk(Ek(x))=x，这里xϵM； 破译者不能在有效的时间内破解出密钥k或明文x。 密码学的发展阶段 密码学的发展历程大致经历了三个阶段： 古代加密方法（手工阶段） 例如，塞塔式密码，藏头诗等。 古典密码（机械阶段） 文字替换，使用手工或机械变换的方式实现。 近代密码（计算机阶段） 与计算机技术、电子通信技术紧密相关。 摆脱了原先用铅笔和纸进行手工设计时易犯的错误。 摆脱了用电子机械方式实现的密码机的高额费用。 密码的分类 依据密码体制的特点以及出现的时间分类： 古典替换密码 文字替换，使用手工或机械变换的方式实现。 例如，单表代替密码、多表代替密码以及转轮密码。 对称密钥密码 加密过程和解密过程使用同一密钥来完成。 又称为秘密密钥密码，或单密钥密码。 分为分组密码和序列密码。 公开密钥密码 加密过程和解密过程使用两个不同的密钥来完成。 又称为非对称密钥密码，双密钥密码。 依据处理数据的类型： 分组密码(block cipher) 将定长的明文块转换成等长的密文，这一过程是在密钥控制下完成的。 对于大部分分组密码，分组大小是64位；以后会增加。 又称为分块密码或者块密码。 序列密码(stream cipher) 加解密时一次处理明文中的一个或几个比特。 又称为流密码。 非对称密码体制都是分组密码。 密码分析 密码分析也称为密码攻击。密码分析攻击主要包括： 唯密文攻击：有一些消息的密文。 已知明文攻击：有一些消息的密文以及对应的明文。 选择明文攻击：不仅有一些消息的密文及对应的明文，而且可选择被加密的明文。 自适应选择明文攻击：选择明文攻击的特殊情况。不仅能选择被加密的明文，而且也能基于以前加密的结果修正这个选择。 选择密文攻击：能选择不同的被加密的密文，并可得到对应的解密的明文。例如，得到了一个防篡改的自动解密盒，但不知道密钥。 选择密钥攻击：并不表示密码分析者能够选择密钥，只表示密码分析者具有不同密钥之间的关系的有关知识。不是很实际，但有时很有效。 ","date":"2021-11-21 11:35:51","objectID":"https://qizhengzou.github.io/isc_base_02/:1:0","tags":["information security conspectus"],"title":"ISC_base_02","uri":"https://qizhengzou.github.io/isc_base_02/"},{"categories":["School courses"],"content":"古典替换密码 简单代替密码 指将明文字母表M中的每个字母用密文字母表C中的相应字母来代替。 例如：移位密码、乘数密码、仿射密码等。 移位密码 具体算法是将字母表的字母右移k个位置，并对字母表长度作模运算。 每一个字母具有两个属性，本身代表的含义，可计算的位置序列值。 加密函数：Ek(m) = (m + k) mod q； 解密函数：Dk (c) = ( c – k ) mod q； 乘数密码 将明文字母串逐位乘以密钥k并进行模运算。 数学表达式：Ek ( m )=k * m mod q, gcd (k, q) = 1。gcd(k, q)=1表示k与q的最大公因子为1。 算法描述： M=C=Z/(26)，明文空间和密文空间同为英文字母表空间，包含26个元素；q=26； K={k∈整数集 | 0 \u003c k \u003c 26，gcd(k, 26)=1}，密钥为大于0小于26，与26互素的正整数； Ek ( m ) = k * m mod q。 Dk-1(c)=k-1 * c mod q，其中k-1为k在模q下的乘法逆元。 乘数密码的密钥k与26互素时，加密变换才是一一映射的。 k的选择有11种：3、5、7、9、11、15、17、19、21、23、25。 k取1时没有意义。 k-1为k在模q下的乘法逆元。 其定义为k-1 * k mod q =1， 可采用扩展的欧几里德算法。欧几里德算法又称辗转相除法，用于计算两个整数a和b的最大公约数。 仿射密码 仿射密码可以看作是移位密码和乘数密码的结合。 密码体制描述如下： M=C=Z/(26)；q=26； K={ k1, k2∈Z | 0\u003c k1, k2\u003c26，gcd(k1, 26)=1}； Ek(m)=(k1m + k2) mod q； Dk(c)= k1-1( c - k2) mod q，其中k1-1为k1在模q下的乘法逆元。 密钥情况：k1和k2？ 基于统计的密码分析 简单代替密码的加密是从明文字母到密文字母的一一映射。 攻击者统计密文中字母的使用频度，比较正常英文字母的使用频度，进行匹配分析。 如果密文信息足够长，很容易对单表代替密码进行破译。 多表代替密码 多表代替密码是以一系列代替表依次对明文消息的字母进行代替的加密方法。 多表代替密码使用从明文字母到密文字母的多个映射来隐藏单字母出现的频率分布。 每个映射是简单代替密码中的一对一映射。 若映射系列是非周期的无限序列，则相应的密码称为非周期多表代替密码。 非周期多表代替密码：对每个明文字母都采用不同的代替表（或密钥）进行加密，称作一次一密密码。 这是一种理论上唯一不可破译的密码。但需要的密钥量和明文消息长度相同，难于广泛使用。 维吉尼亚Vigenère密码 经典的多表代换密码有： Vigenère、Beaufort、Running Key、Vernam和轮转机等密码。 维吉尼亚Vigenère密码 是以移位代替为基础的周期多表代替密码。 加密时每一个密钥被用来加密一个明文字母，当所有密钥使用完后，密钥又重新循环使用。 维吉尼亚Vigenère密码算法如下： EK(m)=C1 C2 … Cn，其中Ci=（mi + ki）mod 26； 密钥K可以通过周期性反复使用以至无穷。 ","date":"2021-11-21 11:35:51","objectID":"https://qizhengzou.github.io/isc_base_02/:2:0","tags":["information security conspectus"],"title":"ISC_base_02","uri":"https://qizhengzou.github.io/isc_base_02/"},{"categories":["School courses"],"content":"对称密钥密码 对称密钥密码的通讯安全性取决于密钥的机密性，与算法本身无关，算法是公开的。 对称密码加密系统从工作方式上可分为： 分组密码、序列密码 分组密码原理： 明文消息分成若干固定长度的组，进行加密；解密亦然。 序列密码（流密码）： 通过伪随机数发生器产生性能优良的伪随机序列（密钥流），用该序列加密明文消息流，得到密文序列；解密亦然。 数据加密标准DES 1973年，美国国家标准局NBS公开征集国家密码标准方案，要求： 算法必须提供高度的安全性； 算法必须有详细的说明，并易于理解； 算法的安全性取决于密钥，不依赖于算法； 算法适用于所有用户； 算法适用于不同应用场合； 算法必须高效、经济； 算法必须能被证实有效； 算法必须是可出口的。 1974年，NBS开始第二次征集时，IBM公司提交了算法LUCIFER。 1977年，LUCIFER被美国国家标准局NBS作为“数据加密标准 FIPS PUB 46”发布，简称为DES。 S-DES加密算法： S-DES：Simplified DES，简化的DES。 S-DES是由美国圣达卡拉大学的Edward Schaeffer教授提出的，主要用于教学，其设计思想和性质与DES一致，有关函数变换相对简化，具体参数要小得多。 输入为一个8位的二进制明文组和一个10位的二进制密钥，输出为8位二进制密文组。 涉及的主要函数： 与密钥变换有关的两个置换函数：P8、P10；与密钥变换有关的循环移位函数Shift。 用于数据加密变换的4个基本函数：初始置换IP、复合函数fk、转换函数SW、末尾置换IP-1。 解密与加密基本一致。 P10=(3,5,2,7,4,10,1,9,8,6) 循环左移函数LS P8=(6,3,7,4,8,5,10,9) IP=(2,6,3,1,4,8,5,7) IP-1=(4,1,3,5,7,2,8,6) E/P=（4,1,2,3,2,3,4,1） “⊕”：按位异或运算； S盒函数 S0和S1为两个盒子函数，将输入作为索引查表，得到相应的系数作为输出。 P4=（2,4,3,1） SW：将左4位和右4位交换。 S盒函数按下述规则运算： 输入的第1位和第4位二进制数合并为一个两位二进制数，作为S盒的行号索引i； 将第2位和第3位同样合并为一个两位二进制数，作为S盒的列号索引j； 确定S盒矩阵中的一个系数（i，j）。 此系数以两位二进制数形式作为S盒的输出。 例如： L’=（l0, l1, l2, l3）=（0，1，0，0）， （i，j）=（0, 2） 在S0中确定系数3，则S0的输出为11B。 DES的安全问题 1977年，人们估计要耗资两千万美元建成一个专门计算机用于DES的破译，而且需要12个小时的破解才能得到结果。 1994年世界密码大会，M. Matsui提出线性分析方法，利用243个已知明文，成功破译DES。 1997年，首届“向DES挑战”的竞技赛。罗克·维瑟用了96天时间破解了用DES加密的一段信息。 2000年1月19日，电子边疆基金会组织25万美元的DES解密机，以22.5小时成功破解DES加密算法。 DES的最近一次评估是在1994年，同时决定1998年12月以后，DES将不再作为联邦加密标准。 DES的密钥长度仅有56bit（64bit中有8位用于奇偶校验）。 其他对称密码简介： 为提高安全性，主要有两种研究思路。 对DES进行复合变换，强化它的抗攻击能力； 开辟新的算法。 三重DES RC5 IDEA AES算法 ","date":"2021-11-21 11:35:51","objectID":"https://qizhengzou.github.io/isc_base_02/:3:0","tags":["information security conspectus"],"title":"ISC_base_02","uri":"https://qizhengzou.github.io/isc_base_02/"},{"categories":["School courses"],"content":"公开密钥密码 公开密钥密码体制是现代密码学最重要的发明，也可以说是密码学发展史上最伟大的革命。 两大特点： 与之前的所有密码不同，其算法不是基于代替和置换，二是基于数学函数。 与使用一个密钥的传统的对称密钥密码不同，公开密钥密码是非对称的，使用两个独立的密钥。 一般认为，密码学就是保护信息传递的机密性，其实这仅仅是现代密码学主题的一个方面。 对信息发送人与接收人的真实身份的验证、事后对所发出或接收信息的不可抵赖性，以及保障数据的完整性是现代密码学主题的另一方面。 公开密钥密码，又称非对称密钥密码或双密钥密码。 加密密钥和解密密钥为两个独立密钥。 公开密钥密码的通信安全性取决于私钥的保密性 Diffie-Hellman密钥交换算法 数学知识：原根 素数p的原根（primitive root）的定义：如果a是素数p的原根，则数a mod p, a2 mod p, …, ap-1 mod p是不同的并且包含从1到p-1之间的所有整数的某种排列。对任意的整数b（mod p ≠ 0），可以找到唯一的幂i，满足b≡ai mod p，且1 ≤ i ≤ p-1。 注：“b≡a mod p”等价于“b mod p = a mod p”，称为“b与a模p同余”。 数学知识：离散对数 若a是素数p的一个原根，则相对于任意整数b（mod p ≠ 0），必然存在唯一的整数i（1 ≤ i ≤ p-1），使得b≡ai mod p，i称为b的以a为基数且模p的幂指数，即离散对数。 对于函数y≡gx mod p，其中，g为素数p的原根，y与x均为正整数，已知g、x、p，计算y是容易的；而已知y、g、p，计算x是困难的，即求解y的离散对数x是困难的。 注：离散对数的求解为数学界公认的困难问题。 Alice和Bob协商好一个大素数p，和一个大的整数g，1 \u003c g \u003c p，g是p的原根。p和g无须保密，可为网络上的所有用户共享。 RSA公开密钥算法 大整数因子分解 RSA密码算法 RSA密码体制： 明文和密文均是0到n之间的整数，n通常为1024位二进制数或309位十进制数。 明文空间M=密文空间C={x∈Z|0\u003c x \u003c n, Z为整数集合}。 RSA密码的密钥生成具体步骤如下： 选择互异的素数p和q，计算n=pq，A(n) = (p - 1)(q - 1)； 选择整数e，使gcd(A(n), e) = 1，且1 \u003c e \u003c A(n)； 计算d，d = e-1 mod A(n)，即d为模A(n)下e的乘法逆元； 公钥Pk = { e, n }，私钥Sk = { d, n, p, q } 加密：c = (m的e次方) mod n；解密：m = (c的d次方) mod n。 RSA的安全性 RSA的安全性是基于单向函数ek(x)=xe(mod n) ，求逆计算不可行。 解密的关键是了解陷门信息，即能够分解n=pq，知道(n)=(p-1)(q-1)，从而解出解密私钥d。 如果要求RSA是安全的，p与q必为足够大的素数，使分析者没有办法在多项式时间内将n分解出来。 RSA开发人员建议，p和q的选择应该大约是100位的十进制素数，模n的长度要求至少是512bit。 国际数字签名标准ISO/IEC 9796中规定n的长度为512bit。 为了抵抗现有的整数分解算法，对RSA模n的素因子p和q还有如下要求： |𝒑−𝒒|很大，通常p和q的长度相同。 𝒑−𝟏和𝒒−𝟏分别含有大素因子𝒑_𝟏和𝒒_𝟏。 𝒑_𝟏−𝟏和𝒒_𝟏−𝟏分别含有大素因子𝒑_𝟐和𝒒_𝟐。 𝒑+𝟏和𝒒+𝟏分别含有大素因子𝒑_𝟑和𝒒_𝟑。 其他公开密钥密码简介 基于大整数因子分解问题: RSA密码、Rabin密码 基于有限域上的离散对数问题： Diffie-Hellman公钥交换体制、ElGamal密码 基于椭圆曲线上的离散对数问题： Diffie-Hellman公钥交换体制、ElGamal密码。 Rabin密码算法是M. Rabin设计的，是RSA密码算法的一种改进。 RSA是基于大整数因子分解问题，Rabin则是基于求合数的模平方根的难题。 Elgamal算法是Taher Elgamal发明的，既能用于数据加密，也能用于数字签名，其安全性依赖于计算有限域上离散对数这一难题，其不足之处是它的密文成倍扩张。 大整数分解算法的发展，计算机速度的提高和网络的发展，RSA的密钥长度需要不断增加。 但是，密钥长度的增加，导致了加密、解密的速度大为降低。 需要新的算法来代替RSA！ 1985年，Koblitz和Miller分别独立提出将椭圆曲线用于密码算法，其根据是椭圆曲线上的离散对数问题（ECDLP，Elliptic Curve Discrete Logarithm Problem）。 椭圆曲线密码体制（ECC，Elliptic Curve Cryptosystems）相比于RSA的优势： 相同的密钥长度，ECC抗攻击性比RSA强很多倍。 计算量小，处理速度快。 存储空间小。ECC的密钥尺寸和系统参数比RSA要小得多。 带宽要求低。对于短消息加密，ECC带宽要求比RSA低得多。带宽要求低使得ECC在无线网络领域具有广泛的应用前景。 ECC是新一代安全电子交易(SET)协议中缺省的公钥密码算法。 ","date":"2021-11-21 11:35:51","objectID":"https://qizhengzou.github.io/isc_base_02/:4:0","tags":["information security conspectus"],"title":"ISC_base_02","uri":"https://qizhengzou.github.io/isc_base_02/"},{"categories":["School courses"],"content":"消息认证 概述： 威胁信息完整性的行为主要包括： 伪造：假冒他人的信息源向网络中发布消息； 内容修改：对消息的内容进行插入、删除、变换和修改； 顺序修改：对消息进行插入、删除或重组消息序列； 时间修改：针对网络中的消息，实施延迟或重放； 否认：接受者否认收到消息，发送者否认发送过消息。 消息认证是保证信息完整性的重要措施。其目的主要包括： 证明：消息的信源和信宿的真实性； 证明：消息内容是否曾受到偶然或有意的篡改， 证明：消息的序号和时间性是否正确。 消息和信息的关系： 信息，一般解释为，“事物运动状态或存在方式的不确定性的描述”。 消息，一般解释为，“用文字、符号、数据、语言、音符、图片、图像等能够被人们感觉感官所感知的形式，把客观物质运动和主观思维活动的状态表示出来的载体”。 消息是信息的载体，信息通过消息来传递；消息是符号形式的，信息则是消息所反映的实质内容。 认证技术在功能上可以分为两层。 下层包含一个产生认证符的函数；认证符是一个用来认证消息的值； 上层是以认证函数为原语；接收方可以通过认证函数来验证消息的真伪。 消息认证由具有认证功能的函数来实现的。 消息加密，用消息的完整密文作为消息的认证符； 消息认证码MAC（Message Authentication Code），也称密码校验和，使用密码对消息加密，生成固定长度的认证符； 消息编码，是针对信源消息的编码函数，使用编码抵抗针对消息的攻击。 对称密钥密码对消息加密，不仅具有机密性，同时也具有一定的可认证性; 公开密钥密码本身就提供认证功能，其具有的私钥加密、公钥解密以及反之亦然的特性; 消息认证码： 消息认证码MAC的基本思想： 利用事先约定的密码，加密生成一个固定长度的短数据块MAC，并将MAC附加到消息之后，一起发送给接收者； 接收者使用相同密码对消息原文进行加密得到新的MAC，比较新的MAC和随消息一同发来的MAC，如果相同则未受到篡改。 生成消息认证码的方法主要包括： 基于加密函数的认证码：使用加密函数生成固定长度的认证符。 消息摘要：将任意长度的消息全文作为单向散列函数的输入，进行散列计算，得到的被压缩到某一固定长度的散列值（即消息摘要）作为认证符。消息摘要的运算-过程无需加密算法的参与，其关键是单向散列函数是否具有良好的无碰撞性。 消息编码： 使用消息编码对信息进行认证，基本思想来源于信息通信中的差错校验码。 差错校验码是差错控制中的检错方法。数据通信中的噪音可能会使得传输的比特值改变，用校验码可以检测出来。同样，一些人为造成的比特值的改变，使用差错控制也可以检测到。 消息编码认证的基本思想： 引入冗余度，使通过信道传送的可能序列集M（编码集）大于消息集S（信源集）。 发送方从M中选出用来代表消息的许用序列Li，即对信息进行编码；接收方根据编码规则，进行解码，还原出发送方按此规则向他传来的消息。 窜扰者不知道被选定的编码规则，因而所伪造的假码字多是M中的禁用序列，接收方将以很高的概率将其检测出来，并拒绝通过认证。 散列函数： 散列函数（Hash Function）的目的 将任意长的消息映射成一个固定长度的散列值（hash值），也称为消息摘要。 消息摘要可以作为认证符，完成消息认证。 散列函数的健壮性： 弱无碰撞特性：散列函数h被称为是弱无碰撞的，是指在消息特定的明文空间X中，给定消息x∈X，在计算上几乎找不到不同于x的x’，x'∈X，使得h(x)=h(x’)。 强无碰撞特性：散列函数h被称为是强无碰撞的，是指在计算上难以找到与x相异的x’，满足h(x)=h(x’)，x'可以不属于X。 单向性：散列函数h被称为单向的，是指通过h的逆函数h-1来求得散列值h(x)的消息原文x，在计算上不可行。 数字签名： 数字签名：Digital Signature。 在ISO7498-2标准定义为： “附加在数据单元上的一些数据或是对数据单元所作的密码变换，这种数据或变换可以被数据单元的接收者用来确认数据单元来源和数据单元的完整性，并保护数据不会被人（例如接收者）伪造”。 美国电子签名标准对数字签名作了如下解释： “数字签名是利用一套规则和一个参数对数据进行计算所得的结果，用此结果能够确认签名者的身份和数据的完整性”。 一般来说，数字签名可以被理解为： 通过某种密码运算生成一系列符号及代码，构成可以用来进行数据来源验证的数字信息。 从签名形式上分，数字签名有两种。 一种是对整个消息的签名。 一种是对压缩消息的签名。 它们都是附加在被签名消息之后或在某一特定位置上的一段数据信息。 数字签名主要目的： 保证接收方能够确认或验证发送方的签名，但不能伪造；发送方发出签名消息后，不能否认所签发的消息。 设计数字签名必须满足下列条件： 签名必须基于一个待签名信息的位串模板； 签名必须使用某些对发送方来说是唯一的信息，以防止双方的伪造与否认； 必须相对容易生成、识别和验证数字签名； 伪造该数字签名在计算复杂性意义上具有不可行性。 既包括对一个已有的数字签名构造新的消息，也包括对一个给定消息伪造一个数字签名。 数字签名主要采用公钥加密技术来实现。 通常情况下，一次数字签名涉及三个信息，分别是一个哈希函数、发送者的公钥、发送者是私钥。 数字签名的一般应用过程 发送方： 首先，使用散列函数对消息报文进行散列计算，生成散列值（消息报文摘要），并用自己的私钥对这个散列值进行加密，加密的散列值即为数字签名。 然后，这个加密的散列值将作为消息报文的附件和消息报文一起发送给接收方。 接收方： 首先，用与发送方一样的散列函数计算原始消息报文的散列值，接着再用发送方的公钥来对报文附加的数字签名进行解密，得到发送方计算的散列值。 然后，比较两个散列值。如果相同，接收方就可确认消息报文的发送方，并且消息报文是完整的。 数字签名方法 基于对称密钥密码体制，也可以依靠其密钥的双方保密的特点来实现数字签名，但使用范围受到局限。 目前，数字签名多数还是基于公钥密码体制，常见的数字签名算法有RSA、ElGamal、DSA以及椭圆曲线数字签名算法等。 另外，还有一些特殊数字签名方法，如盲签名、代理签名、群签名、门限签名、具有消息恢复功能的签名等，它们与具体应用环境密切相关。 美国国家标准技术研究所（NIST）1994年公布了数字签名标准（DSS，Digital Signature Standard），采用的算法是DSA。 DSA是Schnorr和ElGamal签名算法变种，是基于有限域上的离散对数问题设计的。DSA算法不是标准的公钥密码，只能提供数字签名，但安全性和灵活性好，被广泛应用于金融等领域。 ","date":"2021-11-21 11:35:51","objectID":"https://qizhengzou.github.io/isc_base_02/:5:0","tags":["information security conspectus"],"title":"ISC_base_02","uri":"https://qizhengzou.github.io/isc_base_02/"},{"categories":["School courses"],"content":"密码学新进展 混沌密码学 1989年，英国数学家Matthews，基于混沌的加密技术。 混沌系统具有良好的伪随机特性、轨道的不可预测性、对初始状态及控制参数的敏感性等一系列特性； 传统的密码算法敏感性依赖于密钥，而混沌映射依赖于初始条件和映射中的参数； 传统的加密算法通过加密轮次来达到扰乱和扩散，混沌映射则通过迭代，将初始域扩散到整个相空间； 传统加密算法定义在有限集上，而混沌映射定义在实数域内。 量子密码 1970年，威斯纳提出利用单量子态制造不可伪造的“电子钞票”，这个构想由于量子态的寿命太短而无法实现， 1984年，IBM的贝内特和加拿大学者布拉萨德，提出了第一个量子密码方案，由此迎来了量子密码学的新时期。 量子密码体系采用量子态作为信息载体，经由量子通道在合法的用户之间传送密钥。 量子密码的安全性由量子力学原理所保证，被称为是绝对安全的。 所谓绝对安全，是指即使在窃听者可能拥有极高的智商、可能采用最高明的窃听措施、可能使用最先进的测量手段，密钥的传送仍然是安全的，可见量子密码研究具有极其重大的意义。 DNA计算 1994年，Adleman等科学家进行了世界上首次DNA计算，解决了一个7节点有向汉密尔顿回路问题。 由于DNA计算具有的信息处理的高并行性、超高容量的存储密度和超低的能量消耗等特点，非常适合用于攻击密码计算系统的不同部分，对传统的基于计算安全的密码体制提出了挑战。 ","date":"2021-11-21 11:35:51","objectID":"https://qizhengzou.github.io/isc_base_02/:6:0","tags":["information security conspectus"],"title":"ISC_base_02","uri":"https://qizhengzou.github.io/isc_base_02/"},{"categories":["School courses"],"content":" 笔记来自哈工大深圳2021秋数据库系统理论课授课老师：刘圣鑫 故障恢复 ","date":"2021-11-21 10:18:45","objectID":"https://qizhengzou.github.io/mysql_base_14/:0:0","tags":["mysql"],"title":"Mysql_base_14","uri":"https://qizhengzou.github.io/mysql_base_14/"},{"categories":["School courses"],"content":"数据库的故障类型及其影响 DBMS的运行方式： DBMS利用内存(主存)和外存(辅存)这样的存储体系来进行数据库管理 在内存中, 又将其分为程序数据(事务数据)和系统数据 事务： 事务是DBMS对数据库进行控制的基本逻辑单元。 事务：宏观上是由程序员设置的一条或多条SQL语句的一次执行；微观上是对数据元素的一系列基本操作，如读写等。需要提交和撤销。 数据元素： 通常1数据元素 = 1磁盘块/内存页 也可以更小(=1 记录)或更大(=1 关系) 事务具有四个特性：ACID特性 原子性Atomicity 一致性Consistency 隔离性Isolation 持久性Durability 故障恢复涉及到如何保证原子性和持久性 数据库的故障及其影响 事务故障 某一个程序(事务)自身运行错误所引起的故障 影响该程序(事务)本身 系统故障 由于掉电、非正常关机等所引起的故障 影响正在运行的事务以及数据库缓冲区, 数据库缓冲区将涉及正在运行和已经运行的事务 介质故障 由于介质损坏等所引起的故障 影响是全面的，既影响内存中的数据, 又影响介质中存储的数据 ","date":"2021-11-21 10:18:45","objectID":"https://qizhengzou.github.io/mysql_base_14/:1:0","tags":["mysql"],"title":"Mysql_base_14","uri":"https://qizhengzou.github.io/mysql_base_14/"},{"categories":["School courses"],"content":"数据库故障恢复的宏观思路 数据库故障恢复 把DB由当前不正确状态恢复到已知为正确的某一状态。 需要保证事务的： 原子性：事务的所有操作，要么全都执行，要么全都不执行。 持久性：已提交的事务对数据库产生的影响是持久的，未提交的事务对数据库不应有影响。 事务故障的恢复 事务故障可通过重做事务(Redo)和撤消事务(Undo)来恢复。重做事务可保证已提交事务的持久性，而撤销事务则消除未提交事务的影响 系统故障恢复 运行日志(System Log) 运行日志是DBMS维护的一个文件，该文件以流水方式记录了每一个事务对数据库的每一次操作及操作顺序 运行日志直接写入介质存储上，会保持正确性 当事务对数据库进行操作时：先写运行日志；写成功后，再与数据库缓冲区进行信息交换 系统故障可通过运行日志来恢复 按照运行日志记录的事务操作顺序重做事务(当事务在发生故障时已正确结束) 或撤消事务(当事务在发生故障时未结束) 但故障恢复是需要时间的 运行日志保留了若干天的记录，当发生系统故障时应从哪一个点开始恢复呢？ DBMS在运行日志中定期的设置和更新检查点(checkpoint) 检查点是这样的时刻: 在该时刻, DBMS强制使内存DB Buffer中的内容与介质DB中的内容保持一致，即将DB Buffer更新的所有内容写回DB中 检查点表征了：在检查点之前内存中数据与介质中数据是保持一致的 系统故障的恢复 检查点之前结束的事务不需要恢复(已经写回DB) 检查点之后结束或发生的事务需 要依据运行日志进行恢复(不能确定是否写回DB): 故障点前结束的重做, 故障点时刻未结束的撤消 介质故障恢复 副本(Copy) 在某一时刻，对数据库在其他介质存储上产生的另一份等同记录 用副本替换被损坏的数据库 介质故障的恢复 用副本替换被破坏的数据库 由于介质故障影响全面, 在用副本恢复后还需要依据运行日志进行恢复 如何确定备份的时刻: 转储点 过频，影响系统工作效率；过疏，会造成运行日志过大，也影响系统运行性能 备份转储周期与运行日志的大小密切相关，应注意防止衔接不畅而引起的漏洞 小结： 三种类型故障：事务故障、系统故障和介质故障 三种恢复手段: 事务的撤消与重做, 运行日志和备份 两个重要时刻：检查点和转储点 ","date":"2021-11-21 10:18:45","objectID":"https://qizhengzou.github.io/mysql_base_14/:2:0","tags":["mysql"],"title":"Mysql_base_14","uri":"https://qizhengzou.github.io/mysql_base_14/"},{"categories":["School courses"],"content":"什么是日志 事务涉及到的： 数据库通常由元素构成 通常，1 元素 = 1 磁盘块 = 1 内存页/块 可以更小，= 1 记录 或更大 = 1 关系 每个事务都会读/写某些元素 READ(X,t)：将元素X读到事务的局部变量t中 WRITE(X,t)：将事务局部变量t写回元素X INPUT(X)：将元素X从磁盘读入到内存缓冲区中 OUTPUT(X)：将元素X写回到磁盘中 每个事务都以提交或者撤销结束 COMMIT：事务提交 ABORT：事务撤销 DBMS需要保证事务的： 持久性：已提交的事务对数据库产生的影响是持久的，未提交的事务对数据库不应有影响。 原子性：事务的所有操作，要么全都执行，要么全都不执行 不同的缓冲区策略会影响事务的持久性： Force：内存中的数据最晚在commit的时候写入磁盘。 No steal：不允许在事务commit之前把内存中的数据写入磁盘。 No force：内存中的数据可以一直保留，在commit之后过一段时间再写入磁盘。(此时在系统崩溃的时候可能还没写入到磁盘，需要Redo)。– 灵活 Steal：允许在事务commit之前把内存中的数据写入磁盘。(此时若系统在commit之前崩溃时，已经有数据写入到磁盘了，要恢复到崩溃前的状态，需要Undo)。–灵活 事务故障会影响事务的原子性 怎样记录日志： 日志： 一个包含日志记录的只能追加的顺序文件, 不同事务的日志记录交错存储，按发生时间存储 发生系统故障时，使用日志进行恢复: 故障时已提交的事务，重做(Redo) 故障时未提交的事务，撤销(Undo) 日志记录的信息 \u003c Start T\u003e，表示事务T已经开始 \u003c Commit T\u003e，表示事务T成功完成 \u003c Abort T\u003e，事务T未成功，被中止 \u003c T, X, v1\u003e 或者 \u003c T, X, v2\u003e 或者 \u003c T, X, v1,v2\u003e表示事务T改变了数据库元素X，X原来的值为v1(X的旧值)，X新的值为v2 三种日志: Undo型日志，Redo型日志，Undo/Redo型日志 ","date":"2021-11-21 10:18:45","objectID":"https://qizhengzou.github.io/mysql_base_14/:3:0","tags":["mysql"],"title":"Mysql_base_14","uri":"https://qizhengzou.github.io/mysql_base_14/"},{"categories":["School courses"],"content":"Undo型日志及其故障恢复 Undo型日志 对于任一事务T，按下列顺序向磁盘输出T的日志信息： 首先，\u003c T, X, v\u003e被写到日志中 其次，OUTPUT(X) 最后，\u003c COMMIT T\u003e或\u003c ABORT T\u003e被写到日志中 注意：Undo型日志仅保留旧值。\u003c T, X, v\u003e，v为X原来的值(X的旧值) Undo型日志：“将事务改变的所有数据写到磁盘前不能提交该事务 利用undo型日志进行恢复 首先，确定每一个事务是否已完成? \u003c START T\u003e….\u003c COMMIT T\u003e…. = yes \u003c START T\u003e….\u003c ABORT T\u003e……. = no(已结束，但未完成) \u003c START T\u003e……………………… = no 然后，从日志的尾部开始按日志记录的反序，处理每一日志记录，撤销未完成事务的所有修改 \u003c COMMIT T\u003e:标记T已完成 \u003c ABORT T\u003e: 标记T已结束但未完成 \u003c T,X,v\u003e: 如果T未完成，则将X=v写回磁盘；否则跳过； \u003c START T\u003e: 跳过 检查点 静止检查点：周期性地对日志设置检查点 停止接受新的事务, 等到所有当前活跃事务提交或终止，并在日志中写入了COMMIT或ABORT记录后 将日志刷新到磁盘，写入日志记录\u003c CKPT\u003e，并再次刷新日志 非静止检查点 在设置检查点时不必关闭系统，允许新事务进入 写入一条\u003c START CKPT(T1,…,Tk)\u003e其中T1,…,Tk 是所有活跃的未结束的事务 继续正常的操作，直到T1,…,Tk都完成时，写入\u003c END CKPT ","date":"2021-11-21 10:18:45","objectID":"https://qizhengzou.github.io/mysql_base_14/:4:0","tags":["mysql"],"title":"Mysql_base_14","uri":"https://qizhengzou.github.io/mysql_base_14/"},{"categories":["School courses"],"content":"Redo型日志及其故障恢复 Redo型日志 Undo型日志的问题“将事务改变的所有数据写到磁盘前不能 提交该事务”—如何解决? 对于任一事务T，按下列顺序向磁盘输出T的日志信息： 首先，\u003c T, X, v\u003e被写到日志中 其次，\u003c COMMIT T\u003e被写到日志中 最后，OUTPUT(X) 注意：redo型日志保留新值。\u003c T, X, v\u003e，v为X更新后的值(X的新值) 注意：与undo型的差别，在后两步，先写提交记录后输出，还是先输 出，再写提交记录。 利用redo日志进行恢复 确定每一个事务是否已完成? \u003c START T\u003e….\u003c COMMIT T\u003e…. = yes \u003c START T\u003e….\u003c ABORT T\u003e…….= no(已结束，但未完成) \u003c START T\u003e………………………= no 从日志的起始位置开始按日志记录的正序处理每一日志记录，重做已提交事务的所有修改： \u003c COMMIT T\u003e:标记T已完成 \u003c ABORT T\u003e:标记T已结束但未完成 \u003c T,X,v\u003e: 如果T已完成，则将X=v写回磁盘；否则跳过； \u003c START T\u003e: 跳过 检查点 非静止检查点 在进行检查点设置时不必关闭系统，允许新事务进入 写入一条\u003c START CKPT(T1,…,Tk)\u003e其中T1,…,Tk 是所有活跃的未结束的事务 将所有已提交的事务写回磁盘， 继续正常的操作，直到T1,…,Tk都完成时，写入\u003c END CKPT\u003e ","date":"2021-11-21 10:18:45","objectID":"https://qizhengzou.github.io/mysql_base_14/:5:0","tags":["mysql"],"title":"Mysql_base_14","uri":"https://qizhengzou.github.io/mysql_base_14/"},{"categories":["School courses"],"content":"Undo/Redo结合型日志及其故障恢复 Redo型日志与Undo型日志的比较: Undo型日志: OUTPUT必须先做。 如果\u003c COMMIT T\u003e可见, T确定地已将所有其数据写回磁盘，因此不必重做 –– 但可能引起性能下降(因可能频繁地写磁盘) Redo型日志： OUTPUT必须后做。 如果\u003c COMMIT T\u003e不可见, T确定地没有将其任何数据写回到磁盘，因此无需撤销 –– 但灵活性差(数据必须在Commit后才可见) 如更喜欢灵活性 – Undo/Redo型日志 Undo/Redo型日志 对于任一事务T，按下列顺序向磁盘输出T的日志信息： 第(1)步，\u003c T, X, u, v\u003e被写到日志中 第(2)or(3)步，\u003c COMMIT T\u003e被写到日志中 第(3)or(2)步，OUTPUT(X) 注意：undo/redo型日志既保留新值v，也保留旧值u。 注意：与undo型和redo型的差别，在后两步。Redo型是先写提交记录 后输出；undo型是先输出，再写提交记录；undo/redo型则无所谓谁先谁 后，只要保证\u003c T,X,u,v\u003e被先于OUTPUT写完即可。 利用undo/Redo型日志进行恢复 首先，确定每一个事务是否已完成? \u003c START T\u003e….\u003c COMMIT T\u003e…. = yes \u003c START T\u003e….\u003c ABORT T\u003e……. = no(已结束，但未完成) \u003c START T\u003e……………………… = no 自前向后地，按日志记录的正序，重做所有已提交的事务；自 后向前，按日志记录的反序，撤销所有未完成事务的所有修改。 \u003c COMMIT T\u003e:标记T已完成 \u003c ABORT T\u003e:标记T已结束但未完成 \u003c T,X,u,v\u003e:如果T未完成，则将X=u写回磁盘；否则将x=v写回磁盘； \u003c START T\u003e:跳过 ","date":"2021-11-21 10:18:45","objectID":"https://qizhengzou.github.io/mysql_base_14/:6:0","tags":["mysql"],"title":"Mysql_base_14","uri":"https://qizhengzou.github.io/mysql_base_14/"},{"categories":["School courses"],"content":" 2021秋哈工大深圳罗文坚 信息安全概论课程PPT 摘抄 信息安全课程概述 ","date":"2021-11-21 10:13:37","objectID":"https://qizhengzou.github.io/isc_base_01/:0:0","tags":["information security conspectus"],"title":"ISC_base_01","uri":"https://qizhengzou.github.io/isc_base_01/"},{"categories":["School courses"],"content":"教学目的、目标与内容 课程定位：信息安全领域基础课程 《密码学基础》与《网络安全》等课程的先修课程。 课程目的： 对信息安全领域知识有较全面的了解； 掌握信息安全领域的基本原理和工作机制； 具有解决一些信息安全问题的能力； 为学生进一步在信息安全领域进行深入学习打下基础 课程目标： 全面了解信息安全知识领域的体系结构，了解信息安全发展历史，了解信息安全技术产生与发展，了解信息安全问题对国家及社会的影响； 理解密码的基本理论及应用方法，掌握身份认证及访问控制的基本方法，具有设计信息安全方案的初步能力，了解网络威胁的产生机理与网络防御的基本技术，具有解决信息安全问题的初步能力； 了解信息安全系统、工程的技术标准及操作规范，明确有关信息安全的法律法规，建立初步的信息安全工程素质和全面的信息安全法律意识。 总学时：32 ；讲课学时：32 教学内容： 信息安全概述 密码学基础 物理安全 身份认证 访问控制 网络威胁 网络防御 网络安全协议 内容安全 信息安全管理 教材：翟健宏. 信息安全导论. 北京: 科学出版社. 2019. 主要参考书：Stallings William著, 王后珍等译.《密码编码学与信息安全—原理与实践(第7版). 电子工业出版社. 2017 期末考试（开卷）：60％ 作业（+课堂练习）：40% 教师： 罗文坚，luowenjian@hit.edu.cn，信息楼L1721 助教：4人 常亚桐、宋振、罗永康、杨向凯。 课件发布：QQ群。 ","date":"2021-11-21 10:13:37","objectID":"https://qizhengzou.github.io/isc_base_01/:1:0","tags":["information security conspectus"],"title":"ISC_base_01","uri":"https://qizhengzou.github.io/isc_base_01/"},{"categories":["School courses"],"content":"信息安全概述 ","date":"2021-11-21 10:13:37","objectID":"https://qizhengzou.github.io/isc_base_01/:2:0","tags":["information security conspectus"],"title":"ISC_base_01","uri":"https://qizhengzou.github.io/isc_base_01/"},{"categories":["School courses"],"content":"信息安全的理解 信息与信息安全 信息：事物运动的状态与方式 ISO给出的解释：“信息是通过施加于数据上的某些约定而赋予这些数据的特定含义”。 通常我们可以把消息、信号、数据、情报和知识等都看作信息。信息本身是无形的，借助信息介质以多种形式存在或传播。 信息安全： ISO给出的定义：“在技术上和管理上为数据处理系统建立的安全保护，保护信息系统的硬件、软件及相关数据不因偶然或者恶意的原因遭到破坏、更改及泄露”。 信息安全的目的：“确保以电磁信号为主要形式的、在计算机网络化系统中进行获取、处理、存储、传输和应用的信息内容在各个物理及逻辑区域中的安全存在，并不发生任何侵害行为”。 信息安全的发展阶段 信息安全的发展阶段 通信安全—→ 信息安全—→信息保障 通信安全（COMSEC）阶段 20世纪90年代以前，这一阶段的信息安全可以简单称为通信安全，主要目的是保障传递的信息安全，防止信源、信宿以外的对象查看信息。 信息安全（INFOSEC）阶段 20世纪90年代以后，主要保证信息的机密性、完整性、可用性、可控性、不可否认性。 信息安全（INFOSEC）阶段：要点有机密性、完整性、可用性、可控性、不可否认性。 机密性（Confidentiality）指信息只能为授权者使用而不泄漏给未经授权者的特性。 完整性（Integrity）指保证信息在存储和传输过程中未经授权不能被改变的特性。 可用性（Availability）指保证信息和信息系统随时为授权者提供服务的有效特性。 可控性（Controllability）指授权实体可以控制信息系统和信息使用的特性。 不可否认性（Non–Repudiation）指任何实体均无法否认其实施过的信息行为的特性，也称为抗抵赖性 信息保障（IA，Information Assurance）阶段 1996年，美国国防部提出了信息保障： 保护（Protect）、检测（Detect）、反应（React）、恢复（Restore）四个方面。 我国也对信息保障给出了相关解释： 信息保障是对信息和信息系统的安全属性及功能、效率进行保障的动态行为过程。它运用源于人、管理、技术等因素所形成的预警能力、保护能力、检测能力、反应能力、恢复能力和反击能力，在信息和系统生命周期全过程的各个状态下，保证信息内容、计算环境、边界与连接、网络基础设施的真实性、可用性、完整性、保密性、可控性、不可否认性等安全属性，从而保障应用服务的效率和效益，促进信息化的可持续健康发展。 信息保障（IA，Information Assurance）阶段 信息保障三大要素： 人是信息保障的基础； 技术是信息保障的核心； 管理是信息保障的关键。 信息安全不是一个孤立静止的概念，具有系统性、相对性和动态性。 ","date":"2021-11-21 10:13:37","objectID":"https://qizhengzou.github.io/isc_base_01/:2:1","tags":["information security conspectus"],"title":"ISC_base_01","uri":"https://qizhengzou.github.io/isc_base_01/"},{"categories":["School courses"],"content":"信息安全威胁 信息安全威胁的基本类型 信息泄露：信息被有意或无意泄露给某个非授权的实体。 信息伪造：某个未授权的实体冒充其他实体发布信息，或者从事其他网络行为。 完整性破坏：非法手段窃取信息的控制权，未经授权对信息进行修改、插入、删除等操作，使信息内容发生不应有的变化。 业务否决或拒绝服务：攻击者通过对信息系统进行过量的、非法的访问操作使信息系统超载或崩溃，从而无法正常进行业务或提供服务。 未经授权访问：某个未经授权的实体非法访问信息资源，或者授权实体超越其权限访问信息资源。 信息安全威胁的主要表现形式 攻击原始资料 人员泄露，废弃的介质，窃取 破坏基础设施 破坏电力系统，破坏通讯网络，破坏信息系统场所 攻击信息系统 物理侵入，特洛伊木马，恶意访问，服务干扰，旁路控制，计算机病毒 攻击信息传输 窃听，业务流分析，重放。 恶意伪造 业务欺骗，假冒，抵赖 自身失误 内部攻击 ","date":"2021-11-21 10:13:37","objectID":"https://qizhengzou.github.io/isc_base_01/:2:2","tags":["information security conspectus"],"title":"ISC_base_01","uri":"https://qizhengzou.github.io/isc_base_01/"},{"categories":["School courses"],"content":"互联网的安全性 互联网的发展现状 1983年，ARPA和美国国防部通信局研制TCP/IP协议，该协议被做为其BSD UNIX的一部分。 1986年，NSF利用Internet Protocol，连接5个科研教育服务机构，建立了NSFnet广域网。 1987年开始，中国四大网络CSTnet、CERNET、Chinanet、GBnet与Internet直连。 2007年底，我国互联网用户1.62亿，其中宽带上网用户达到1.22亿，中文网站89.8万个，IPv4地址总数9800多万个，国际出口带宽总量为368927Mbps。 互联网的安全现状 2000年开始，病毒制造产业化操作，黑色产业链每年的整体利润预计高达数亿元。 黑客窃取的个人资料，包括QQ密码、网游密码、银行账号、信用卡帐号，等等。任何可以直接或间接转换成金钱的东西，都成为不法分子窃取的对象。 CERT（Computer Emergency Response Team）统计： 在1988年安全事件6件，2001年5万件，2003年为13万7千多件，在2003年以后发生呈线性增长。 据中国计算机网络应急技术处理协调中心统计： 2006年26476件，是2005年9112件的三倍。 安全事件 1988年,著名的“Internet蠕虫事件”使得6000余台计算机的运行受到影响。 1998年2月份，黑客利用Solar Sunrise弱点入侵美国防部网络，攻击相关系统超过500台计算机，而攻击者只是采用了中等复杂工具。 2000年春季,黑客分布式拒绝服务攻击（DDOS）大型网站，导致大型ISP服务机构Yahoo网络服务瘫痪。 2001年5月,中美黑客大战。 2001年8月，“红色代码”蠕虫利用微软web服务器IIS 4.0或5.0中index服务的安全缺陷，攻破目的机器，并通过自动扫描感染方式传播蠕虫，已在互联网上大规模泛滥。 2003年，“冲击波”蠕虫的破坏力就更大；安全专家Bruce Schneier撰文分析认为，美国2003年8月份大停电与“冲击波蠕虫”相关。 近期代表性安全事件 30人贩卖6亿条个人信息 2020年1月，镇江丹阳警方侦破一起公安部督办的侵犯公民个人信息案，涉及10多个省市，抓获犯罪嫌疑人30名。该团伙采用境外聊天工具和区块链虚拟货币收付款，共贩卖个人信息6亿余条。 台积电生产工厂和营运总部中勒索病毒 2020年8月3日晚间，台积电生产工厂和营运总部，突然传出电脑遭病毒入侵且生产线全数停摆的消息。 某黑客组织对我国关键领域发动钓鱼邮件攻击 钓鱼邮件攻击，邮件以“海事政策分析和对南亚的港口安全影响”、“2020年自主研发项目立项论证报告”等主题，主要针对我国政府部门、科研机构相关人员发起定向邮件攻击 委内瑞拉国家电网干线遭攻击，全国大面积停电 2020年5月，委内瑞拉副总统罗德里格斯宣布消息，委内瑞拉国家电网干线遭到攻击，造成全国大面积停电。 新西兰证交所连续一周遭受DDoS攻击导致交易中断（2020年8月25-31日） 黑客入侵500多组商店和家庭摄像头！已被广州警方刑拘（2021年8月） 该案是广东省首例打击非法入侵“常规摄像头”的黑客案件，具有典型意义。 App侵害用户权益专项整治行动 针对App侵害用户隐私安全的问题，工信部已建立全国App技术检测平台，对国内上架的热门App进行技术检测 安全趋势 集团化、产业化的趋势 产业链：病毒木马编写者-\u003e专业盗号人员-\u003e销售渠道-\u003e专业玩家 病毒不再安于破坏系统，销毁数据，而是更关注财产和隐私。 电子商务成为热点，针对网络银行的攻击也更加明显。 “黑客”逐渐变成犯罪职业 财富的诱惑，使得黑客袭击不再是一种个人兴趣，而是越来越多的变成一种有组织的、利益驱使的职业犯罪。 事例：拒绝服务相关的敲诈勒索和“网络钓鱼” 恶意软件的转型 恶意软件在行为上将有所改观，病毒化特征削弱，但手段更“高明”，包含更多的钓鱼欺骗元素。 我国是恶意软件最多的国家。 网页挂马危害继续延续 服务器端系统资源和流量带宽资源大量损失。 成为网络木马传播的“帮凶”。 客户端的用户个人隐私受到威胁。 利用应用软件漏洞的攻击将更为迅猛 新的漏洞出现要比设备制造商修补的速度更快。 一些嵌入式系统中的漏洞难以修补。 零日攻击现象日趋普遍。 Web2.0的产品受到挑战 以博客、论坛为首的web2.0产品成为病毒和网络钓鱼的攻击目标。 社区网站上带有社会工程学性质的欺骗往往超过安全软件所保护的范畴。 自动邮件发送工具日趋成熟，垃圾邮件制造者正在将目标转向音频和视频垃圾邮件。 无线网络、移动手机成为安全重灾区，消费者电子设备遭到攻击的可能性增大 在无线网络中被传输的信息没有加密或者加密很弱，很容易被窃取、修改和插入，存在较严重的安全漏洞。 手机病毒利用普通短信、彩信、上网浏览、下载软件与铃声等方式传播，还将攻击范围扩大到移动网关、WAP服务器或其他的网络设备。 越来越多采用USB标准进行连接，并使用了更多存储设备和电脑外围产品。 信息安全意义 互联网安全不仅影响普通网民的信息和数据的安全性，而且严重的影响国家的健康发展。 网络安全与政治 网络安全与经济 网络安全与军事 网络安全与社会稳定 ","date":"2021-11-21 10:13:37","objectID":"https://qizhengzou.github.io/isc_base_01/:2:3","tags":["information security conspectus"],"title":"ISC_base_01","uri":"https://qizhengzou.github.io/isc_base_01/"},{"categories":["School courses"],"content":"信息安全体系结构 CIA三元组是信息安全的三个最基本的目标： 机密性Confidentiality：指信息在存储、传输、使用过程中，不会泄漏给非授权用户或实体； 完整性Integrity：指信息在存储、使用、传输过程中，不会被非授权用户篡改或防止授权用户对信息进行不恰当的篡改； 可用性Availability：指确保授权用户或实体对信息资源的正常使用不会被异常拒绝，允许其可靠而及时地访问信息资源。 DAD（Disclosure、Alteration、Destruction）是最普遍的三类风险。 泄露、篡改、破坏。 围绕CIA三元组展开的知识体系： 密码学是三个信息安全目标的技术基础。 CIA技术存在着一定程度上的内容交叉 面向应用的层次型技术体系架构： 信息系统基本要素 人员、信息、系统 安全层次 三个不同部分存在五个安全层次与之对应 每个层次均为其上层提供基础安全保证 物理安全指对网络及信息系统物理装备的保护。 运行安全指对网络及信息系统的运行过程和运行状态的保护。 数据安全指对数据收集、存储、检索、传输等过程提供的保护，不被非法冒充、窃取、篡改、抵赖。 内容安全指依据信息内涵判断是否违反特定安全策略，采取相应的安全措施。 管理安全指通过针对人的信息行为的规范和约束，提供对信息的机密性、完整性、可用性以及可控性的保护。 安全服务（Security Service）： 鉴别服务：确保某个实体身份的可靠性。 访问控制：确保只有经过授权的实体才能访问受保护的资源。 数据机密性：确保只有经过授权的实体才能理解受保护的信息。 数据完整性：防止对数据的未授权修改和破坏。 抗抵赖性 ：用于防止对数据源以及数据提交的否认 安全机制（Security Mechanism）： 加密：用于保护数据的机密性。 数字签名：保证数据完整性及不可否认性的一种重要手段。 访问控制：访问实体成功通过认证，访问控制对访问请求进行处理，查看是否具有访问所请求资源的权限，并做出相应的处理。 数据完整性：用于保护数据免受未经授权的修改。 鉴别交换：用于实现通信双方实体的身份鉴别。 业务流填充：针对的是对网络流量进行分析攻击。 路由控制：可以指定数据报文通过网络的路径。路径上的节点都是可信任的。 公证机制：由第三方来确保数据完整性、数据源、时间及目的地的正确。 ","date":"2021-11-21 10:13:37","objectID":"https://qizhengzou.github.io/isc_base_01/:2:4","tags":["information security conspectus"],"title":"ISC_base_01","uri":"https://qizhengzou.github.io/isc_base_01/"},{"categories":["School courses"],"content":"系统模型 ","date":"2021-11-17 08:45:55","objectID":"https://qizhengzou.github.io/distributedsystem_base_02/:0:0","tags":["distributed system"],"title":"DistributedSystem_base_02","uri":"https://qizhengzou.github.io/distributedsystem_base_02/"},{"categories":["School courses"],"content":"简介 物理模型是描述系统的-个最显式的方法，它从计算机(和其他设备，例如移动电话)及其互联的网络方面考虑系统的硬件组成。 体系结构模型从系统的计算元素执行的计算和通信任务方面来描述系统。 基础模型采用抽象的观点描述分布式系统的某个方面。本章介绍考察分布式系统三个重要方面的基础模型: 交互模型，它考虑在系统元素之间通信的结构和顺序; 故障模型，它考虑一个系统可能不能正确操作的方式; 安全模型，它考虑如何保护系统使其不受到正确操作的干扰或不被窃取数据。 ","date":"2021-11-17 08:45:55","objectID":"https://qizhengzou.github.io/distributedsystem_base_02/:1:0","tags":["distributed system"],"title":"DistributedSystem_base_02","uri":"https://qizhengzou.github.io/distributedsystem_base_02/"},{"categories":["School courses"],"content":"物理模型 物理模型是从计算机和所用网络技术的特定细节中抽象出来的分布式系统底层硬件元素的表示。 ","date":"2021-11-17 08:45:55","objectID":"https://qizhengzou.github.io/distributedsystem_base_02/:2:0","tags":["distributed system"],"title":"DistributedSystem_base_02","uri":"https://qizhengzou.github.io/distributedsystem_base_02/"},{"categories":["School courses"],"content":"体系结构模型 本节采取一种三阶段方法: 首先，描述支撑现代分布式系统的核心基本体系结构元素，重点展示现在已有方法的不同; 考察能在开发复杂分布式系统解决方案中单独使用或组合使用的复合体系结构模式; 最后，对于以上体系结构风格中出现的不同编程风格，考虑可用于支持它们的中间件平台。 注意，有许多与本章中介绍的体系结构模型相关的权衡，其中涉及采用的系统体系结构元素、所采用的模式和(在合适的地方)使用的中间件，它们会影响结果系统的性能和有效性。理解这样的权衡可以说是分布式系统设计中的关键技能。 ","date":"2021-11-17 08:45:55","objectID":"https://qizhengzou.github.io/distributedsystem_base_02/:3:0","tags":["distributed system"],"title":"DistributedSystem_base_02","uri":"https://qizhengzou.github.io/distributedsystem_base_02/"},{"categories":["School courses"],"content":"体系结构元素 通信实体：从系统的观点，回答通常是非常清楚的,这是因为在一个分布式系统中通信的实体通常是进程，这导致普遍地把分布式系统看成是带有恰当进程间通信范型的多个进程(如在第4章中讨论的)，有两个注意事项: 在一些原始环境中，例如传感器网络,基本的操作系统可能不支持进程抽象(或甚至任何形式的隔离)，因此在这些系统中通信的实体是结点。 在大多数分布式系统环境中，用线程补充进程，所以，严格说来，通信的末端是线程。 对象：对象已被引人以便在分布式系统中使用面向对象的方法(包括面向对象的设计和面向对象的编程语言)。在分布式面向对象的方法中，-个计算由若千交互的对象组成，这些对象代表分解给定问题领域的自然单元。对象通过接口被访问，用一个相关的接口定义语言(IDL) 提供定义在一个对象上的方法的规约。分布式对象已经成为分布式系统研究的一个主要领域，第5章和第8章将进一步讨论这个话题。 组件:因为对象的引入，许多重要的问题已被认为与分布式对象有关，组件技术的出现及使用是对这些弱点的一个直接响应。组件类似于对象，因为它们为构造分布式系统提供面向问题的抽象，也是通过接口被访问。关键的区别在于组件不仅指定其(提供的)接口而且给出关于其他组件/接口的假设，其他组件/接口是组件完成它的功能必须有的。换句话说,组件使得所有依赖显式化，为系统的构造提供一个更完整的合约。这个合约化的方法鼓励和促进第三方开发组件，也通过去除隐含的依赖 提升了一个更纯粹的组合化方法来构造分布式系统。基于组件的中间件经常对关键领域如部署和服务器方编程支持提供额外的支持[ Heineman and Councill 2001]。关于基于组件方法的进一步细节请参见第8章。 Web服务: Web 服务代表开发分布式系统的第三种重要的范型[Alonso et al. 2004]。Web 服务与对象和组件紧密相关，也是采取基于行为封装和通过接口访问的方法。但是，相比而言，通过利用Web标准表示和发现服务，Web 服务本质上是被集成到万维网(即W3C)的。W3C ( World WideWeb)联盟把Web服务定义成： 一个软件应用，通过URI被辨识，它的接口和绑定能作为XML制品被定义描述和发现。一个Web服务通过在基于互联网的协议上利用基于XML的消息交换支持与其他软件代理的直接交互。 换句话说，Web服务采用的基于Web的技术在-定程度上定义了Web服务。另一个重要的区别来源于技术使用的风格。对象和组件经常在一个组织内部使用，用于开发紧耦合的应用，但Web服务本身通常被看成完整的服务，它们可以组合起来获得增值服务，它们经常跨组织边界，因此可以实现业 务到业务的集成。Web服务可以由不同的提供商用不同的底层技术实现。Web服务将在第9章做进一步的探讨。 通信范型我们现在转向在分 布式系统中实体如何通信,考虑三种通信范型: 进程间通信; 远程调用; 间接通信。 进程间通信指的是用于分布式系统进程之间通信的相对底层的支持，包括消息传递原语、直接访问由互联网协议提供的API (套接字编程)和对多播通信的支持。第4章将详细讨论这样的服务。 远程调用代表分布式系统中最常见的通信范型，覆盖一系列分布式系统中通信实体之间基于双向交换的技术，包括调用远程操作、过程或方法。进一步的定义参见下面内容(详细讨论见第5章): 请求-应答协议是一个有效的模式，它加在一个底层消息传递服务之上，用于支持客户-服务器计算。特别的，这样的协议通常涉及一对消息的交换，消息从客户到服务器，接着从服务器返回客户，第一个消息包含在服务器端执行的操作的编码，然后是保存相关参数的字节数组，第二个消息包含操作的结果，它也被编码成字节数组。这种范型相对原始，实际上仅被用于嵌人式系统，对嵌人式系统来说性能是至关重要的。这个方法也被用在5.2节描述的HTTP协议中。正如下面讨论的，大多数分布式系统将选择使用远程过程调用或者远程方法调用，但注意底层的请求-应答交换支持两种方法。 远程过程调用( Remote Procedure Call, RPC)的概念，最初由Birell 和Nelson [1984] 提出，代表了分布式计算中的一个主要突破。在RPC中,远程计算机上进程中的过程能被调用，好像它们是在本地地址空间中的过程一样。底层RPC系统隐藏了分布的重要方面，包括参数和结果的编码和解码、消息的传递和保持过程调用所要求的语义。这个方法直接而且得体地支持了客户-服务器计算，其中,服务器通过一个服务接口提供一套操作, 当这些操作本地可用时客户直接调用这些操作。因此，RPC系统(在最低程度上)提供访问和位置透明性。 远程方法调用( Remote Method Invocation, RMI) 非常类似于远程过程调用，但它应用于分布式对象的环境。用这种方法，-个发起调用的对象能调用一个远程对象中的方法。与RPC一样，底层的细节都对用户隐藏。不过，通过支持对象标识和在远程调用中传递对象标识符作为参数，RMI 实现做得更多。它们也从与面向对象语言(见第5章相关讨论)的紧密集成中获得更多的好处。 上述技术具有一个共同点:通信代表发送者和接收者之间的双向关系，其中，发送者显式地把消息/调用送往相关的接收者。接收者通常了解发送者的标识，在大多数情况下，双方必须在同时存在。相比而言，已经出现若千技术，这些技术支持间接通信,通过第三个实体，允许在发送者和接收者之间的深度解耦合。尤其是: 发送者不需要知道他们正在发送给谁(空间解耦合)。 发送者和接收者不需要同时存在(时间解耦合)。 第6章将详细讨论间接通信。 间接通信的关键技术包括: 组通信:组通信涉及消息传递给若干接收者，因此是支持一对多通信的多方通信范型。组通信依赖组抽象，-一个组在系统中用-一个组标识符表示。接收方通过加人组，就能选择性接收发送到组的消息。发送者通过组标识符发送消息给组，因此，不需要知道消息的接收者。组通常也要维护组成员,具有处理组成员故障的机制。 发布-订阅系统:许多系统，例如第1章中金融贸易的例子，被归类于信息分发系统，其中，大量生产者(或发布者)为大量的消费者(或订阅者)发布他们感兴趣的信息项(事件)。采用前述的任-核心通信范型来实现这个需求是复杂且低效的，因此，出现了发布-订阅系统(有时也叫分布式基于事件的系统)用于满足此项重要需求[ Muhl et al. 2006]。发布-订阅系统共享同一个关键的特征，即提供-一个中间服务,有效确保由生产者生成的信息被路由到需要这个信息的消费者。 消息队列:虽然发布-订阅系统提供一种一对多风格的通信,但消息队列提供了点对点服务,其中生产者进程能发送消息到一个指定的队列，消费者进程能从队列中接收消息，或被通知队列里有新消息到达。因此，队列是生产者和消费者进程的中介。 元组空间:元组空间提供了进-步的间接通信服务，并支持这样的模型一进程 能把任意的结构化数据项( 称为元组)放到一个持久元组空间，其他进程可以指定感兴趣的模式，从而可以在元组空间读或者删除元组。因为元组空间是持久的，读操作者和写操作者不需要同时存在。这种风格的编程，也被称为生成通信，由Gelemter [ 1985]作为一种并行编程范型引人。已经开发了不少分布式实现，采用了客户-服务器-风格的实现或采用了更分散的对等方法。 分布式共享内存:分布式共享内存(Distributed Shared Memory, DSM)系统提供一种抽象，用于支持在不共享物理(内存的进程之间共享数据。提供给程序员的是-套熟悉的读或写(共享)数据结构的抽象，就好像这些数据在程序员自已本地的地址空间一样,从而提供了高层的分布透明性。基本的基础设施必须确保以及时的方式提供副本，也必须处理与数据同步和一致性相关的问题。分布式共享内存的概述在第6章中介绍。 到目前为止讨论的体系结构 角色和责任，在一个分布式系统中, 进程，或者说，对象、组件、服务，包括Web服务(为简单起见，我们在本节中使用术语“进程”)相互交互完成一个有用的活动，例如支持一次聊天会话。在这样做的时候，进程扮演给定的角色，在建立所采用的整体体系结构时，这些角色是基本的。本节我们考察两种起源于单个进程角色的体系结构风格:客户-服务器风格和对等风格。 客户-服务器:这是讨论分布式系统时最常引用的体系结构。它是历史上最重要的体系结构，现在仍被广泛地使用。图2-3 给出了一个简单的结构，其中，进程扮演服务器和客户的角色。特别是,为了访问服务器管理的共享资源，客户进程可以与不同主机上的服务器进程交互。如图2-3所示，一台服务器也可以是其他服务器的客户。例如，Web服务器通常是管理存储Web页面文件的本地文件服务器的客户。Web 服务器和大多数其他互联网服务是DNS服务的客户，DNS服务用于将互联网域名翻译成网络地址。另一个与Web相关的例子是搜索引擎,搜索引擎能让用户通过互联网查看Web页面上可用的信息汇总。这些信息汇总通过称为“Web 抓取”的程序形成，该程序在搜索引擎站点以后台方式运行，利用HTTP请求访问互联网上的Web服务器。因此，搜索引擎既是服务器又是客户:它回答来自浏览器客户的查询，并且运行作为其他Web服务器客户的Web抓取程序。在这个例子中，服务器任务(对用户查询的回答)和Web抓取的任务( 向其他Web服务器发送请求)是完全独立的，很少需要同步它们，它们可以并行运行。事实上,一个典型的搜索引擎正常情况下包含许多并发执行的线程，一些线程为它的客户服务，另一些线程运行Web抓取程序。 对等体系结构:在这种体系结构中,涉及一项任务或活动的所有进程扮演相同的角色，作为对","date":"2021-11-17 08:45:55","objectID":"https://qizhengzou.github.io/distributedsystem_base_02/:3:1","tags":["distributed system"],"title":"DistributedSystem_base_02","uri":"https://qizhengzou.github.io/distributedsystem_base_02/"},{"categories":["School courses"],"content":"体系结构模式 我们给出分布式系统中几个关键的体系结构模型，包括分层体系结构( layering architecture)、层次化体系结构( tiered ar-chitecture)和瘦客户相关的概念(包括虚拟网络计算的特定机制)。我们也把Web服务当做一个体系结构模式进行了考察，给出了其他可以应用在分布式系统中的模式。 分层，分层的概念是-一个熟悉的概念，与抽象紧密相关。在分层方法中，一个复杂的系统被分成若干层，每层利用下层提供的服务。因此，一个给定的层提供-一个软件抽象，更高的层不清楚实现细节，或不清楚在它下面的其他层。就分布式系统而言，这等同于把服务垂直组织成服务层。一个分布式服务可由一个或多个服务器进程提供，这些进程相互交互，并与客户进程交互，维护服务中的资源在系统范围内的-致视图。 层次化体系结构层次化体系结构 与分层体系结构是互补的。分层将服务垂直组织成抽象层，而层次化是一项组织给定层功能的技术，它把这个功能放在合适的服务器上，或者作为第二选择放在物理结点上。 AJAX的作用:在1.6节中，我们介绍了AJAX ( Asynchronous Javascript And XML)是Web所使用的标准客户-服务器交互方式的扩展。AJAX满足了Javascript 前端程序( 运行在Web浏览器中)和基于服务器的后端程序(拥有描述应用状态的数据)之间的细粒度通信的需要。概括而言，在标准的Web交互方式中，浏览器发送HTTP请求给服务器，请求给定URL的页面、图像或其他资源。服务器发送整个页面作为应答，这个页面或者从服务器上的-一个文件中读取，或者由一个程序生成，取决于 URL中可识别的资源类型。当客户收到内容时，浏览器根据其MIME类型( text/html、image/jpg 等)相关的显示方式呈现它。虽然Web页面由不同类型的内容项组成，但是整个页面以它在html页面定义中指定的方式由浏览器组合并呈现。 瘦客户，分布式计算的趋势是将复杂性从最终用户设备移向互联网服务。这点在向云计算(见第1章)发展的趋势中最明显，在上面讨论的层次化体系结构中也能看到。这个趋势导致了对瘦客户概念的兴趣，它使得能以很少的对客户设备的假设或需求，获得对复杂网络化服务的访问，这些服务可以通过云解决方案提供。更具体来说，术语瘦客户指的是一个软件层，在执行一个应用程序或访问远程计算机上的服务时，由该软件层提供一个基于窗口的本地用户界面。 其他经常出现的模式： 代理 代理(proxy) 模式是分布式系统中经常出现的模式，其主要用于支持远程过程调用或远程方法调用的位置透明性。用这种方法，一个代理在本地地址空间中被创建，用于代表远程对象。这个代理提供与远程对象-样的接口，程序员调用这个代理对象，因此无须了解交互的分布式特性。在RPC和RMI中，代理支持位置透明性的作用将在第5章做进一步的讨论。 注意代理也被用于封装其他的功能( 诸如复制或缓存的放置策略等)。 web服务中的业务代理 Web服务中的业务代理(brokerage)的使用能被看成是一个在可能很复杂的分布式基础设施中支持互操作性的体系结构模式。特别地，这个模式是由服务提供商、服务请求者和服务代理(提供与请求的服务-致的服务)三部分组成，如图2-11所示。这个业务代理模式在分布式系统的多个领域被多次应用，例如Java RMI中的注册服务、CORBA中的名字服务( 分别参见第5章和第8章的讨论)。 反射 反射( reflection)模式在分布式系统中作为支持内省(系统的动态发现的特性)和从中调停(动态修改结构或行为的能力)的手段而被持续地使用。.例如，Java的内省能力被用于RMI的实现中，提供通用的分发(参见5.4.2节的讨论)。在一个反射系统中，标准的服务接口在基础层可供使.用，但元层接口也可以提供对涉及服务实现的组件及组件参数的访问。许多技术在元层可用，包括截获到达的消息或调用、动态发现由给定对象提供的接口、发现和适应系统底层体系结构的能力。反射被应用于分布式系统中的多个领域，特别是反射中间件领域，例如，可以用于支持更多的可配置及重配置中间件体系结构[Kon et al. 2001]。与分布式系统相关的体系结构模式更多的例子可以在Bushmann等人[2007] 的著作中找到。. ","date":"2021-11-17 08:45:55","objectID":"https://qizhengzou.github.io/distributedsystem_base_02/:3:2","tags":["distributed system"],"title":"DistributedSystem_base_02","uri":"https://qizhengzou.github.io/distributedsystem_base_02/"},{"categories":["School courses"],"content":"相关的中间件解决方案 第1章引入了中间件，在2.3.2节讨论分层体系结构时又重温了中间件。中间件的任务是为分布式系统的开发提供-一个高层的编程抽象，并且通过分层，对底层基础设施中的异构性提供抽象，从而提升互操作性和可移植性。中间件解决方案是基于2. 3. 1节引人的体系结构模型，也支持更复杂的体系结构模式。本节我们简要回顾一下现在存在的中间件类别，为在本书的其他部分进-步研究这 些解决方案做好准备。 中间件的类别 远程过程调用包, (如Sun RPC,第5章)和组通信(如ISIS,第6章和第18章)属于最早的中间件实例。从那以后，出现了大量不同风格的中间件，大部分都基于上面介绍的体系结构模型。我们在图2-12中给出了中间件平台的分类，其中交叉引用了其他章,那些章更详细地讨论了不同种类的中间件。需要强调的是分类并不精确，现代中间件平台试图提供混合的解决方案。例如，许多分布式对象平台提供分布式事件服务，来补充传统的对远程方法调用的支持。类似地，出于互操作性的原因,许多基于组件的平台(和平台的其他分类)也支持Web服务和标准。从中间件标准和今天可用的技术的角度来看,还应该强调这个分类并不完整，其目的在于给出中间件的主要类别。其他(未给出的)解决方案是比较特定的，例如，特定于提供某-通信范型，如消息传递、远程过程调用、分布式共享内存、元组空间或组通信。 图2-12中的中间件的顶层分类是根据通信实体和相关通信范型而确定的，遵循五个主要的体系结构模型:分布式对象、分布式组件、发布-订阅系统、消息队列和Web服务。对等系统是这些类别的补充，基于2.3. 1节讨论的协作方法，对等系统是中间件-一个相当独立的分支。应用服务器，显示为分布式组件的子类，也提供对三层体系结构的直接支持。特别地，应用服务器提供了结构以支持应用逻辑和数据存储的分离，以及对其他特性( 如安全性和可靠性)的支持。详细细节将延后到第8章讨论。 除了编程抽象之外，中间件也能提供分布式系统的基础设施服务,供应用程序或其他服务使用。这些基础设施服务与中间件提供的分布式编程模式是紧密绑定的。例如，CORBA (第8章)提供给应用一系列的CORBA服务，包括对程序安全和可靠的支持。如上所述和在第8章中的进-一步讨论，应用服务器也提供对这些服务的内在支持。 中间件的限制 许多分布式应用完全依赖中间件提供的服务来支持应用的通信和数据共享需求。例如，一个适合客户-服务器模型的应用，如一个名字和地址的数据库，可以依赖只提供远程方法调用的中间件。 通过依靠中间件支持的开发，能大大简化分布式系统的编程，但系统可依赖性的一些方面要求应用层面的支持。 考虑从发送者的邮件主机传递大量的电子邮件消息到接收者的邮件主机。乍一看，这是一个TCP数据传输协议的简单应用( 见第3章的相关讨论)。但考虑这样的问题:用户试图在一个可能不可靠的网络上传递非常大的文件。TCP提供一些错误检测和更正， 但它不能从严重的网络中断中恢复。因此，邮件传递服务增加了另一层次的容错，维护一个进展记录，如果原来的TCP连接断开了，用一个新的TCP连接继续传递。 Saltzer、Reed 和Clarke的一篇经典论文[Saltzer et al. 1984]对分布式系统的设计给出了类似的、有价值的观点，他们称之为“端到端争论”。可将他们的陈述表述为: 一些与通信相关的功能，可以只依靠通信系统终点(end point)的应用的知识和帮助，即可完整、可靠地实现。因此，将这些功能作为通信系统的特征不总是明智的(虽然由通信系统提供一个不完全版本的功能有时对性能提高是有用的)。可以看出他们的论点与通过引人适当的中间件层将所有通信活动从应用编程中抽象出来的观点是相反的。 争论的关键是分布式程序正确的行为在很多层面上依赖检查、错误校正机制和安全手段，其中有些要求访问应用的地址空间的数据。任何企图在通信系统中单独完成的检查将只能保证部分正确性。因此，可能在应用程序中重复同样的任务,降低了编程效率,更重要的是增加了不必要的复杂性并要执行冗余的计算。 这里不进一步介绍他们的争论细节,强烈推荐读者阅读前面提到的那篇论文一那里有许多说明的实例。原文作者之一最近指出:争论给互联网设计带来的实质性好处最近面临着为满足当前应用需求而转向网络服务专门化的危险[ www. reed. com]。 这个争论给中间件设计者带来一个实际的两难困境，而且给定当代分布式系统中种类繁多的应用(和相关的环境条件) (见第1章)，这些困难与日俱增。本质上，底层中间件行为与一个给定应用或应用集的需求和相关环境上下文(如底层网络的状态和风格)有关。这个看法推动了对上下文感知和中间件自适应解决方案的兴趣，见Kon等人的讨论[2002] 。 ","date":"2021-11-17 08:45:55","objectID":"https://qizhengzou.github.io/distributedsystem_base_02/:3:3","tags":["distributed system"],"title":"DistributedSystem_base_02","uri":"https://qizhengzou.github.io/distributedsystem_base_02/"},{"categories":["School courses"],"content":"基础模型 上面的各种系统模型完全不同，但具有一些基本特性。特别是，所有的模型都由若干进程组成,这些进程通过在计算机网络上发送消息而相互通信，所有的模型都共享下列设计需求:实现进程及网络的性能和可靠性特征，确保系统中资源的安全性。本节给出基于基本特性的模型，利用这些模型，我们能更详细地描述系统可能展示的特征、故障和安全风险。 通常，为了理解和推理系统行为的某些方面，一个基础模型应该仅包含我们要考虑的实质性成分。这样一个模型的目的是: 显式地表示有关我们正在建模的系统的假设。 给定这些假设，就什么是可能的、什么是不可能的给出结论。结论以通用算法或要确保的特性 的形式给出。特性成立的保证依赖于逻辑分析和(适当时候的)数学证明。 了解设计依赖什么、不依赖什么，我们就能从中获益。如果在一个特定系统中实现-个设计，这个设计能否运作，我们只需询向在那个系统中假设是否成立。通过清晰、显式地给出我们的假设，就能利用数学技巧证明系统的特征，这些特征对任何满足假设的系统都成立。最后，通过从细节(如硬件)中抽象系统的基本实体和特性，我们就能阐明对系统的理解。 我们希望在我们的基本模型中提取的分布式系统情况能解决下列问题: 交互:计算在进程中发生，进程通过传递消息交互，并引发进程之间的通信(信息流)和协调(活动的同步和排序)。在分布式系统的分析和设计中,我们特别关注这些交互。交互模型必须反映通信带来的延迟，这些延迟的持续时间会比较长，交互模型必须反映独立进程相互配合的准确性受限于这些延迟，受限于在分布式系统中很难跨所有计算机维护同一时间概念。 故障:只要分布式系统运行的任-计算机上出现故障(包括软件故障)或连接它们的网络出现故障，分布式系统的正确操作就会受到威胁。我们的模型将对这些故障进行定义和分类。这为分析它们潜在效果以及设计能容忍每种类型故障的系统奠定了基础。 安全:分布式系统的模块特性和开放性将其暴露在外部代理和内部代理的攻击下。我们的安全模型对发生这种攻击的形式给出了定义并进行了分类，为分析对系统的威胁以及设计能抵御这些威胁的系统奠定了基础。为了帮助讨论和推理，我们对本章介绍的模型进行了必要的简化，省略了许多真实系统中的细节。 它们与真实系统的关系，以及在模型帮助下揭示的问题环境中的解决方案是本书讨论的主题。 ","date":"2021-11-17 08:45:55","objectID":"https://qizhengzou.github.io/distributedsystem_base_02/:4:0","tags":["distributed system"],"title":"DistributedSystem_base_02","uri":"https://qizhengzou.github.io/distributedsystem_base_02/"},{"categories":["School courses"],"content":"交互模型 体系结构模型对系统体系结构的讨论表明分布式系统由多个以复杂方式进行交互的进程组成。例如: 多个服务器进程能相互协作提供服务，前面提到的例子有域名服务(它将数据分区并复制到互联网中的服务器上)和Sun的网络信息服务(它在局域网的几个服务器上保存口令文件的复制版本)。 对等进程能相互协作获得一个共同的目标。例如，一个语音会议系统，它以类似的方式分布音频数据流，但它有严格的实时限制。 大多数程序员非常熟悉算法的概念一采取一系列步骤以执行期望的计算。简单的程序由算法控制，算法中的每一步都有严格的顺序。由算法决定程序的行为和程序变量的状态。这样的程序作为一个进程执行。由多个上面所说的进程组成的分布式系统是很复杂的。它们的行为和状态能用分布式算法描述一分布式算法定 义了组成系统的每个进程所采取的步骤，包括它们之间消息的传递。消息在进程之间传递以便在它们之间传递信息并协调它们的活动。每个进程执行的速率和进程之间消息传递的时限通常是不能预测的。要描述分布式算法的所有状态也非常困难，因为它必须处理所涉及的一个或多个进程的故障或消息传递的故障。 进程交互完成了分布式系统中所有的活动。每个进程有它自已的状态，该状态由进程能访问和更新的数据集组成，包括程序中的变量。属于每个进程的状态完全是私有的一也就是说， 它不能被其他进程访向或更新。 本节讨论分布式系统中影响进程交互的两个重要因素: 通信性能经常是一个限制特性。 不可能维护-个全局时间概念。 通信通道的性能。在我们的模型中， 通信通道在分布式系统中可用许多方法实现，例如，通过计算机网络上的流或简单消息传递来实现。计算机网络上的通信有下列与延迟(lateney)、 带宽( band-widh)和抖动(itter) 有关的性能特征: 从一个进程开始发送消息到另–个进程开始接收消息之间的间隔时间称为延迟。延迟包括: 第一串比特通过网络传递到目的地所花费的时间。例如，通过卫星链接传递消息的延迟是无线电信号到达卫星并返回的时间。 访问网络的延迟，当网络负载很重时，延迟增长很快。例如，对以太网传送而言，发送站点要等待网络空闲。 操作系统通信服务在发送进程和接收进程上所花费的时间，这个时间会随操作系统当前的负载的变化而变化。 计算机网络的带寬是指在给定时间内网络能传递的信息总量。当大量通信通道使用同-一个网络时，它们就不得不共享可用的带宽。 抖动是传递一系列消息所花费的时间的变化值。抖动与多媒体数据有关。例如，如果音频数据 的连续采样在不同的时间间隔内播放，那么声音将严重失真。 计算机时钟和时序事件。分布式系统中的每台计算机有自己的内部时钟,本地进程用这个时钟获得当前时间值。因此，在不同计算机上运行的两个进程能将时间戳与它们的事件关联起来。但是，即使两个进程在同时读它们的时钟,它们各自的本地时钟也会提供不同的时间值。这是因为计算机时钟和绝对时间之间有偏移，更重要的是，它们的漂移率互不相同。术语时钟漂移率( clock drit rate)指的是计算机时钟偏离绝对参考时钟的比率。即使分布式系统中所有计算机的时钟在初始情况下都设置成相同的时间，它们的时钟最后也会相差巨大，除非进行校正。 有几种校正计算机时钟的时间的方法。例如，计算机可使用无线电接收器从全球定位系统( GPS)以大约1μs的精度接收时间读数。但GPS接收器不能在建筑物内工作，同时，为每一台计算机增加GPS在费用上也不合理。相反，具有精确时间源(如GPS)的计算机可发送时序消息给网络中的其他计算机。在两个本地时钟时间之间进行协商当然会受消息延迟的影响。有关时钟漂移和时钟同步的更详细的讨论见第14章。 交互模型的两个变体。在分布式系统中，很难对进程执行、消息传递或时钟漂移所花的时间设置时间限制。两种截然相反的观点提供了一对简单模型:第一个模型对时间有严格的假设，第二个模型对时间没有假设。 同步分布式系统: Hadzilacos 和Toueg [1994] 定义了一个同步分布式系统，它满足下列约束: 进程执行每一步的时间有一个上限和下限。 通过通道传递的每个消息在一个已知的时间范围内接收到。 每个进程有一个本地时钟，它与实际时间的偏移率在一个已知的范围内。 对于分布式系统，建议给出合适的关于进程执行时间、消息延迟和时钟漂移率的上界和下界是可能的。但是达到实际值并对所选值提供保证是比较困难的。除非能保证上界和下界的值，否则任何基于所选值的设计都不可靠。但是，按同步系统构造算法，可以对算法在实际分布式系统的行为提供一些想法。例如，在同步系统中，可以使用超时来检测进程的故障，参见下面的2.4.2节。 同步分布式系統是能够被构造出来的。所要求的是进程用已知的资源需求完成任务，这些资源需求保证有足够的处理器周期和网络能力;还有要为进程提供漂移率在一定范围内的时钟。 异步分布式系统:许多分布式系统，例如互联网，是非常有用的，但它们不具备同步系统的资格。 因此我们需要另一个模型。异步分布式系统是对下列因素没有限制的系统: 进程执行速度 例如， 进程的一步可能只花费亿万分之一秒，而进程的另一步要花费一个世纪的时间，也就是说，每一步能花费任意长的时间。 消息传递延迟 例如， 从进程A到进程B传递一个消息的时间可能快得可以忽略，也可能要花费几年时间。换句话说，消息可在任意长时间后接收到。 时钟漂移率 时钟漂移率可以是任意的。 异步模型对执行的时间间隔没有任何假设。这正好与互联网一致，在互联网中,服务器或网络负载没有内在的约束，对像用FTP传输文件要花费多长时间也没有限制。有时电子邮件消息要花几天时间才能到达。下面的“Pepperland协定”部分说明在异步分布式系统中达成协定的困难性。即使有这些假设，有些设计问题也能得到解决。例如，虽然Web并不总能在一个合理的时间限制内提供特定的响应，但浏览器的设计可以做到让用户在等待时做其他事情。对异步分布式系统有效的任何解决方案对同步系统同样有效。 实际的分布式系统经常是异步的，因为进程需要共享处理器，而通信通道需要共享网络。例如，如果有太多特性未知的进程共享一个处理器，那么任何一个进程的性能都不能保证。但是，有许多不能在异步系统中解决的设计问题,在使用时间的某些特征后就能解决。在最终期限之前传递多媒体数据流的每个元素就是这样-个问题。对这样的问题，可使用同步模型。 事件排序。在许多情况下， 我们有兴趣知道一个进程中的一个事件(发送或接收一个消息)是发生在另一个进程中的另一个事件之前、之后或同时。尽管缺乏精确的时钟，但系统的执行仍能用事件和它们的顺序来描述。 ","date":"2021-11-17 08:45:55","objectID":"https://qizhengzou.github.io/distributedsystem_base_02/:4:1","tags":["distributed system"],"title":"DistributedSystem_base_02","uri":"https://qizhengzou.github.io/distributedsystem_base_02/"},{"categories":["School courses"],"content":"故障模型 在分布式系统中，进程和通信通道都有可能出故障，即它们可能偏离被认为是正确或所期望的行为。故障模型定义了故障可能发生的方式，以便理解故障所产生的影响。Hadzilacos 和Toueg [ 1994]提供了一种分类法，用于区分进程故障和通信通道故障。这些故障将分别在下面的“ 遗漏故障”、“随机故障”和“时序故障”部分介绍。 本书将贯穿使用故障模型。例如: 第4章给出数据报和流通信的Java接口，它们分别提供不同程度的可靠性。 第5章给出支持RMI的请求-应答协议。它的故障特征取决于进程和通信通道两者的故障特征。该协议能用数据报或流通信实现。可根据实现的简单性、性能和可靠性作出决定。 第17章给出事务的两阶段的提交协议。它用于在面对进程和通信通道的确定性故障时完成事务。 遗漏故障。遗漏故障类错误指的是进程或通信通道不能完成它应该做的动作。 进程遗漏故障:进程主要的遗漏故障是崩溃。当我们说进程崩溃了，意为进程停止了，将不再执行程序的任何步骤。能在故障面前存活的服务,如果假设该服务所依赖的服务能干净利落地崩溃，即进程仍能正确运行或者停止运行,那么它的设计能被简化。其他进程通过下列事实能检测到这种进程崩溃:这个进程一再地不能对调用消息进行应答。然而，这种崩溃检测的方法依赖超时的使用，即进程用一段固定时间等待某个事件的发生。在异步系统中，超时只能表明进程没有响应一它 可能是崩溃了，也可能是执行速度慢，或者是消息还没有到达。如果其他进程能确切检测到进程已经崩溃，那么这个进程崩溃称为故障-停止。在同步系统中, 如果确保消息已被传递，而其他进程又没有响应时，进程使用超时来检测，那么就会产生故障–停止 行为。 通信遗漏故障:考虑通信原语send和re-ceive。进程p通过将消息m插人到它的外发消息缓冲区来执行send。通信通道将m传输到q的接收消息缓冲区。进程q通过将m从它的接收消息缓冲区取走并完成传递来执行receive ( 见图2-14)。通常由操作系统提供外发消息缓冲区和接收消息缓冲区。 随机故障术语随机故障或拜占庭故障用于描述可能出现的最坏的故障，此时可能发生任何类型的错误。 时序故障时序故障适用于同步分布式系统。在这样的系统中，对进程执行时间、消息传递时间和时钟漂移率均有限制。时序故障见图2-16的列表。这些故障中的任何一个均可导致在指定时间间隔内对客户没有响应。 故障屏蔽分布式系统中的每个组件通常是基于其他一组组件构造的。利用存在故障的组件构造可靠的服务是可能的。例如，保存有数据副本的多个服务器在其中一个服务器崩溃时能继续提供服务。 一对一通信的可靠性虽然基本的通信通道可能出现前面描述的遗漏故障，但用它来构造一个能屏蔽某些故障的通信服务是可能的。 术语可靠通信可从下列有效性和完整性的角度来定义: 有效性:外发消息缓冲区中的任何消息最终能传递到接收消息缓冲区。 完整性:接收到的消息与发送的消息一致，没有消息被传递两次。 对完整性的威胁来自两个方面: 任何重发消息但不拒绝到达两次的消息的协议。要检测消息是否到达了两次，可以在协议中给消息附加序号。 心怀恶意的用户，他们可能插人伪造的消息、重放旧的消息或篡改消息。在面对这种攻击时为维护完整性要采取相应的安全措施。 ","date":"2021-11-17 08:45:55","objectID":"https://qizhengzou.github.io/distributedsystem_base_02/:4:2","tags":["distributed system"],"title":"DistributedSystem_base_02","uri":"https://qizhengzou.github.io/distributedsystem_base_02/"},{"categories":["School courses"],"content":"安全模型 在第1章中，我们识别出资源共享是分布式系统的一个激发因素。 在2.3节中，我们用进程来描述分布式系统的体系结构，其中可能封装了如对象、组件或服务等的高层抽象，而且，我们通过与其他进程的交互来访问系统。那个体系结构模型为我们的安全模型提供了基础: 通过保证进程和用于进程交互的通道的安全以及保护所封装的对象免遭未授权访问可实现分布式系统的安全。 保护对象。用户运行客户程序，由客户程序向服务器发送调用以完成在对象上的操作。服务器完成每个调用指定的操作并将结果发给客户。 保护进程和它们的交互进程通过发送消息进行交互。消息易于受到攻击，因为它们所使用的网络和通信服务是开放的，以使得任一对进程可以进行交互。服务器和对等进程暴露它们的接口，使得任何其他进程能给它们发送调用。 敌人。为了给安全威胁建模，我们假定敌人(有时也称为对手)能给任何进程发送任何消息，并读取或复制一对进程之间的任何消息，如图2-18所示。这种攻击能很简单地实现，它利用连接在网上的计算机运行一个程序读取那些发送给网络上其他计算机的网络消息，或是运行一个程序生成假的服务请求消息并声称来自授权的用户。攻击可能来自合法连接到网络的计算机或以非授权方式连接到网络的计算机。来自一个潜在敌人的威胁包括对进程的威胁和对通信通道的威胁。 对进程的威胁:在分布式系统中,一个用于处理到达的请求的进程可以接收来自其他进程的消息，但它未必能确定发送方的身份。通信协议(如IP)确实在每个消息中包括了源计算机的地址，但对一个敌人而言，用一个假的源地址生成一个消息并不困难。缺乏消息源的可靠的知识对服务器和客户的正确工作而言是一个威胁，具体解释如下: 服务器:因为服务器能接收来自许多不同客户的调用，所以它未必能确定进行调用的主体的身份。即使服务器要求在每个调用中加入主体的身份，敌人也可能用假的身份生成一个调用。在没有关于发送方身份的可靠知识时，服务器不能断定应执行操作还是拒绝执行操作。例如，邮件服务器不知道从指定邮箱中请求一个邮件的用户是否有权限这样做，或者它是否为来自一个敌人的请求。 客户:当客户接收到服务器的调用结果时，它未必能区分结果消息来自预期的服务器还是来自一个“哄骗”邮件服务器的敌人。因此，客户可能接收到一个与原始调用无关的结果，如一个假的邮件(不在用户邮箱中的邮件)。 对通信通道的威胁:一个敌人在网络和网关上行进时能复制、改变或插人消息。当信息在网络上传递时，这种攻击会对信息的私密性和完整性构成威胁，对系统的完整性也会构成威胁。例如，包含用户邮件的结果消息可能泄露给另-一个用户或者可能被改变成完全不同的东西。另一种形式的攻击是试图保存消息的拷贝并在以后重放这个消息，这使得反复重用同一消息成为可能。例如，有些人通过重发请求从一个银行账户转账到另一个银行账户的调用消息而受益。利用安全通道可解除这些威胁，安全通道是基于密码学和认证的，详细内容见下面的描述。 解除安全威胁。下面将介绍安全系统所基于的主要技术。 第11章将详细讨论安全的分布式系统的设计和实现。 密码学和共享秘密:假设一对进程(例如某个客户和某个服务器)共享一个秘密，即它们两个知道秘密但分布式系统中的其他进程不知道这个秘密。如果由一对进程交换的消息包括证明发送方共享秘密的信息，那么接收方就能确认发送方是一对进程中的另一个进程。当然，必须小心以确保共享的秘密不泄露给敌人。 密码学是保证消息安全的科学,加密是将消息编码以隐藏其内容的过程。现代密码学基于使用密钥(很难猜测的大数)的加密算法来传输数据，这些数据只能用相应的解密密钥恢复。 认证:共享秘密和加密的使用为消息的认证(证明由发送方提供的身份)奠定了基础。基本的认证技术是在消息中包含加密部分，该部分中包含足够的消息内容以保证它的真实性。对文件服务器的一个读取部分文件的请求，其认证部分可能包括请求的主体身份的表示、文件的标识、请求的日期和时间，所有内容都用一个在文件服务器和请求的进程之间共享的密钥加密。服务器能解密这个请求并检查它是否与请求中指定的未加密细节相对应。 安全通道:加密和认证用于构造安全通道，安全通道作为已有的通信服务层之上的服务层。安全通道是连接一对进程的通信通道，每个进程代表一个主体行事，如图2- 19所示。- 一个安全通道有下列特性: 每个进程确切知道其他正在执行的进程所代表的主体身份。因此，如果客户和服务器通过安全通道通信，那么服务器要知道发起调用的主体身份，并能在执行操作之前检查它们的访向权限。这使得服务器能正确地保护它的对象，以便客户相信它是从真实的服务器上接收到的结果。 安全通道确保在其上传送的数据的私密性和完整性(防止篡改)。 每个消息包括一个物理的或逻辑的时间戳以防消息被重放或重排序。 其他可能的来自敌人的威胁。1.5.3 节简要介绍了两个安全威胁一拒绝服 务攻击和移动代码的部署。作为敌人破坏进程活动的可能的机会，我们要再介绍一下这两个安全威胁。 拒绝服务:在这种攻击形式下，敌人通过超量地、无意义地调用服务或在网络上进行消息传送，干扰授权用户的活动，导致物理资源( 网络带宽、服务器处理能力)的过载。这种攻击通常意在延迟或阻碍其他用户的动作。例如，建筑物中的电子门锁可能由于受到对计算机控制的电子锁的过多非法请求而失效。 移动代码:如果进程接收和执行来自其他地方的程序代码(如1. 5.3节提到的邮件附件)，那么这些移动代码就会带来新的、有趣的安全问题。这样的代码很容易扮演特洛伊木马的角色，声称完成的是无害的事情但事实上包括了访问或修改资源的代码，这些资源对宿主进程是合法可用的但对代码的编写者是不合法的。实现这种攻击有多种不同的方法，因此必须非常小心地构造宿主环境以避免攻击。其中的大多数问题已在Java和其他移动代码系统中解决了，但从最近的一段历史看，移动代码问题暴露了一些让人窘迫的弱点。这-点也很好地说明了所有安全系统的设计都需要严格的分析。 安全模型的使用。有人认为, 在分布式系统中获得安全是件简单的事，即根据预定义的访问权限控制对象的访问以及通信的安全通道的使用，但是通常却不是这样。安全技术(如加密)和访问控制的使用会产生实质性的处理和管理开销。前面概述的安全模型提供了分析和设计安全系统的基础，其中这些开销保持最少,但对分布式系统的威胁会在许多地方出现，需要对系统网络环境、物理环境和人际环境中所有可能引发的威胁进行仔细的分析。这种分析涉及构造威胁模型，由它列出系统会遭遇 的各种形式的攻击、风险评估和每个威胁所造成的后果。要在抵御威胁所需的安全技术的有效性和开销之间做出权衡。 ","date":"2021-11-17 08:45:55","objectID":"https://qizhengzou.github.io/distributedsystem_base_02/:4:3","tags":["distributed system"],"title":"DistributedSystem_base_02","uri":"https://qizhengzou.github.io/distributedsystem_base_02/"},{"categories":["School courses"],"content":"小结 如2.2节所展示的，从底层物理特性角度，例如，系统的规模、系统内在的异构性、从特性角度(如安全)提供端到端解决方案的实际需求等，分布式系统的复杂性正在增加。这使得从模型角度理解和探讨分布式系统显得更加重要。本章考虑了底层物理模型，并深度考察了支撑分布式系统的体系结构模型和基础模型。 本章从所包含的体系结构模型角度给出了描述分布式系统的方法，明晰了这个设计空间的内涵，包括查看什么在通信以及这些实体如何通信等核心问题，以及基于给定物理基础设施，考虑每个元素可以扮演的角色与合适的放置策略，并把它们补充到设计中去。 本章还介绍了体系结构模式在由底层核心元素(例如上述的客户-服务器模型)构造复杂设计中发挥的关键作用,给出了支持分布式系统的中间件解决方案的主要类型，包括基于分布式对象、组件、Web服务和分布式事件的解决方案。从体系结构模型角度看，客户-服务器方法是一种常见的体系结构模型一 Web 和其他互联网服务(如FIP、新闻和邮件以及Web服务和DNS)均基于这个模型，文件归档和其他本地服务也是如此。像DNS这种有大量的用户并管理大量信息的服务是基于多个服务器的，并使用数据分区和复制来提高可用性和容错能力。客户和代理服务器上的缓存得到广泛使用以提高服务的性能。不过，现在有许多方法对分布式系统进行建模，包括各种可替代的观点，如对等计算和更多的面向问题的抽象(如对象、组件或服务)。 基础棋型补充了体系结构模型，它们帮助从诸如性能、可靠性和安全角度对分布式系统的特性进行推理。特别地，我们给出了交互模型、故障模型和安全模型。它们识别出构造分布式系统的基本组件的共同特征。交互模型关注进程和通信通道的性能以及全局时钟的缺乏。它将同步系统看成在进程执行时间、消息传递时间和时钟漂移上有已知范围的系统，将异步系统看成在进程执行时间、消息传递时间和时钟漂移上没有限制的系统一这是对互联网行为的描述。 故障模型将分布式系统中的进程故障和基本的通信通道故障进行了分类。屏蔽是一项技术，依靠它，可将不太可靠的服务中的故障加以屏蔽，并基于此构造出较可靠的服务。特别是，通过屏蔽基本的通信通道的故障，可从基本的通信通道构造出可靠的通信服务。例如，遗漏故障可通过重传丢失的消息加以屏蔽。完整性是可靠通信的一个性质一它要求接收到的消息 与发送的消息一致，并且没有消息被发送两次。有效性是可靠通信的另一个性质一它要求发送消息缓冲区中的任何消息最终都能传递到接收消息缓冲区。 安全模型可识别出在一个开放的分布式系统中对进程和通信通道可能的威胁。有些威胁与完整性有关:恶意用户可能篡改消息或重放消息。其他的威胁则会损害私密性。另一个安全问题是发送消息所代表的主体(用户或服务器)的认证。安全通道使用密码技术来确保消息的完整性和私密性，并使得相互通信的主体可以进行验证。 ","date":"2021-11-17 08:45:55","objectID":"https://qizhengzou.github.io/distributedsystem_base_02/:5:0","tags":["distributed system"],"title":"DistributedSystem_base_02","uri":"https://qizhengzou.github.io/distributedsystem_base_02/"},{"categories":["School courses"],"content":" 王道考研操作系统笔记 内存管理 ","date":"2021-11-10 13:14:39","objectID":"https://qizhengzou.github.io/operatingsystem_base_03/:0:0","tags":["operating system"],"title":"OperatingSystem_base_03","uri":"https://qizhengzou.github.io/operatingsystem_base_03/"},{"categories":["School courses"],"content":"内存管理基础 ","date":"2021-11-10 13:14:39","objectID":"https://qizhengzou.github.io/operatingsystem_base_03/:1:0","tags":["operating system"],"title":"OperatingSystem_base_03","uri":"https://qizhengzou.github.io/operatingsystem_base_03/"},{"categories":["School courses"],"content":"内存管理概念：程序装入与链接、逻辑地址与物理地址空间、内存保护。 存储器是计算机系统的重要组成部分，是计算机系统中的一种 宝贵而紧俏的资源。操作系统中的存储管理是指对内存(又称主存。默认情况下，本章的存储器指的是内存)的管理， 是操作系统的重要功能之一。 内存管理的功能 存储管理的主要任务是为多道程序的运行提供良好的环境，方便用户使用存储器，提高存储器的利用率以及从逻辑上扩充存储器。为此，存储管理应具有以下功能。 内存的分配和回收。 由操作系统完成内存空间的分配和管理，使程序设计人员摆脱存储空间分配的麻烦，提高编程效率。为此，系统应记住内存空间的使用情况:实施内存的分配;回收系统或用户释放的内存空间。 地址变换。 在多道程序环境下，程序中的逻辑地址与内存中的物理地址通常不一致,因此存储管理必须提供地址变换功能，将逻辑地址转换为物理地址。 扩充内存。借助于虚拟存储技术或其他自动覆盖技术，为用户提供比内存空间大的地址空间，从而实现从逻辑上扩充内存容量的目的。 存储保护。 保证进入内存的各道作业都在自己的存储空间内运行，互不干扰。既要防止一道作业因发生错误而破坏其他作业，也要防止其破坏系统程序。这种保护一般由硬件和软件配合完成。 应用程序的编译、链接与装入 应用程序从用户编写的源文件到内存中执行的进程，大致分为3个阶段:首先，经过编译程序(Compiler)将源代码编译为若干个目标模块(Object Module);其次，通过链接程序(Linker)将编译好的目标模块以及所需的库函数链接在一起，形成完整的装入模块(LoadModule);最后，通过装入程序(Loader)将这些装入模块装入内存并执行。简单来说，从源程序到执行的进程，经历了编译、链接、装入三个步骤，如图3-1所示。 对程序设计者来说，数据的存放地址由数据名称决定，称为名地址或符号名地址，源程序的地址空间因此称为名空间或符号名空间。源程序经过编译之后得到目标代码，由于编译程序无法得知代码驻留在内存中的实际位置(即物理地址)，一般总 是从0号单元开始编址,并顺序分配所有地址单元，这些都不是真实的内存地址，因此称为相对地址或者虚拟地址。 一个完整的程序可以由多个模块构成，这些模块都是从0号单元开始编址。当链接程序将多个模块链接为装入模块时，链接程序会按照各个模块的相对地址将其地址构成统一的从0号单元开始编址的相对地址。当装入程序将可执行代码装入内存时，程序的逻辑地址与程序在内存的实际地址(物理地址)通常不同，这就需要通过地址转换将逻辑地址转换为物理地址，这个过程叫作重定位。不同地址的变换过程如图3-2所示。 程序的链接有3种方式。 静态链接。在程序运行之前，先把各个目标模块及所需库链接为一个完整的可执行程序，以后不再拆开。 装入时动态链接。将应用程序编译后所得到的一组目标模块装入内存时采用边装入边链接的动态链接方式。 运行时动态链接。直到程序运行过程中需要一些模块时，才对这些模块进行链接。这种链接方式将对某些模块的链接推迟到执行时才进行，也就是说，在执行过程中，当发现一个被调用模块尚未装入内存时，立即去找到该模块并将之装入内存，然后把它链接到调用者模块上。凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上,这样不仅可缩短程序的装入过程，而且可节省大量的内存空间，便于修改和更新，便于实现对目标模块的共享。 程序的装入也有3种方式。 绝对装入。在编译时就知道程序将要驻留在内存的物理地址，编译程序产生含有物理地址的目标代码。这种方式不适合多道程序设计。 可重定位装入。根据内存当前情况，将装入模块装入到内存的适当位置，地址变换通常在装入时一次完成，之后不再改变，这种方式也称为静态重定位。静态重定位的实现很简单，当操作系统为程序分配了一个以某地址为起始地址的连续主存区域后，重定位时将程序中指令或操作数的逻辑地址加上这个起始地址就得到了物理地址。如图3-3所示，作业被装入到从1000开始的内存空间中，因此该作业的物理地址为“逻辑地址+ 1000”。动态运行装入。允许程序运行时在内存中移动位置。把装入模块装入到内存后的所有地址都是相对地址，在程序执行过程中每当访问到相应指令或数据时，才将要访问的程序或数据的相对地址转换为物理地址。由于重定位过程是在程序执行期间随着指令的执行逐步完成的，因此也称为动态重定位。动态重定位的实现要依靠硬件地址变换机构。”最简单的实现方法是利用一个重定位寄存器。当某个作业开始执行时，操作系统负责把该作业在主存中的起始地址送入重定位寄存器中，之后在作业的整个执行过程中，每当访问内存时，系统就会自动将重定位寄存器的内容加到逻辑地址中去，从而得到与该逻辑地址对应的物理地址。图3-4给出了地址变换过程的例子。在图3-4中，作业被装入到主存中从1000号单元开始的一个存储区中，在它执行时，操作系统将重定位寄存器设置为1000。当程序执行到1100号单元中的指令时，硬件地址变换机构自动地将这条指令中的取数地址500加上重定位寄存器的内容,得到物理地址1500。然后以1500作为访问内存的物理地址，将数据1234 送入寄存器。 静态重定位的特点是容易实现，无须增加硬件地址变换机构。但它要求为每个程序分配一个连续的存储区，如果空间不足以放下整个程序就不能分配，而且在程序执行期间不能移动，不能再申请内存空间，难以做到程序和数据的共享。 动态重定位的特点是可以将程序分配到不连续的存储区中;在程序运行之前装入它的部分代码即可投入运行，然后在程序运行期间根据需要动态申请分配内存，便于程序段的共享;可以向用户提供一个比主存的存储空间大得多的地址空间。但动态重定位需要附加硬件支持,且实现存储管理的软件算法比较复杂。在重定位中通常会设置一个重定位寄存器，用来存放进程分配的内存空间的地址，该寄存器也称为基址寄存器，当CPU需要访问内存时，将逻辑地址转化为物理地址。转化公式为物理地址=基址寄存器内容+逻辑地址 逻辑地址和物理地址 逻辑地址(Logical Address)是指由程序产生的与段(与页无关，因为只有段对用户可见)相关的偏移地址部分。源代码在经过编译后，目标程序中所用的地址就是逻辑地址，而逻辑地址的范围就是逻辑地址空间。在编译程序对源代码进行编译时，总是从0号单元开始编址，地址空间中的地址都是相对于0开始的，因此逻辑地址也称为相对地址。在系统中运行的多个进程可能会有相同的逻辑地址,但这些逻辑地址映射到物理地址上时就变为了不同的位置。物理地址(PhysicalAddress)是指出现在CPU外部地址总线上的寻址物理内存的地址信号，是逻辑地址变换后的最终结果地址，物理地址空间是指内存中物理地址单元的集合。进程在运行过程中需要访问存取指令或数据时，都是根据物理地址从主存中取得。物理地址对于一般的用户来说是完全透明的，用户只需要关心程序的逻辑地址就可以了。从逻辑地址到物理地址的转换过程由硬件自动完成，这个转换过程叫作地址重定位。 内存保护 内存保护是为了防止一个作业有意或无意地破坏操作系统或其他作业。常用的内存保护方法有界限寄存器方法和存储保护键方法。 界限寄存器方法 采用界限寄存器方法实现内存保护又有上、下界寄存器方法以及基址和限长寄存器方法两种实现方式。 上、下界寄存器方法。采用上、下界寄存器分别存放作业的结束地址和开始地址。在作业运行过程中，将每一个访问内存的地址与这两个寄存器中的内容进行比较，如超出范围，便产生保护性中断。 基址和限长寄存器方法。采用基址和限长寄存器分别存放作业的起始地址及作业的地址空间长度，基址寄存器也叫重定位寄存器，限长寄存器也叫界地址寄存器。在作业运行过程中，将每一个访问内存的相对地址和重定位寄存器中的值相加，形成作业的物理地址;限长寄存器与相对地址进行比较，若超过了限长寄存器的值，则发出越界中断信号，并停止作业的运行。 存储保护键方法 存储保护键方法是给每个存储块分配一个单独的保护键，其作用相当于一把“锁”。不同于分区存储块，一个分区由若干存储块组成，每个存储块大小相同，一个分区的大小必须是存储块的整数倍。此外，进入系统的每个作业也被赋予一个保护键，它相当于一把“钥匙”。当作业运行时，检查“钥匙”和“锁”是否匹配，如果二者不匹配，若系统发出保护性中断信号，并停止作业的运行。 ","date":"2021-11-10 13:14:39","objectID":"https://qizhengzou.github.io/operatingsystem_base_03/:1:1","tags":["operating system"],"title":"OperatingSystem_base_03","uri":"https://qizhengzou.github.io/operatingsystem_base_03/"},{"categories":["School courses"],"content":"交换与覆盖 覆盖技术 覆盖(Overlay)技术主要用在早期的操作系统中，因为在早期的单用户系统中内存的容量一般很小，可用的存储空间受到限制，某些大作业不能一次全部装入内存中，这就产生了大作业与小内存的矛盾，为此引入了覆盖技术。所谓覆盖技术，就是把一个大的程序划分为一系列覆盖，每个覆盖是一个相对独立的程序单位。把程序执行时并不要求同时装入内存的覆盖组成一组，称为覆盖段;将这个覆盖段分配到同一个存储区域，这个存储区域称为覆盖区，它与覆盖段一一对应。显然，为了使一个覆盖区能被相应覆盖段中的每个覆盖在不同时刻共享，其大小应由覆盖段中的最大覆盖来确定。 覆盖技术对程序员的要求较高，程序员必须把一个程序划分为不同的程序段，并规定好执行和覆盖顺序，操作系统根据程序员提供的覆盖结构来完成程序段之间的覆盖。例如，一个用户程序由6个模块组成，图3-5给出了各个模块的调用关系，从中看到，Main模块是一个独立的段，其调用A和B模块，A和B模块是互斥被调用的两个模块。在A模块执行过程中，其调用C模块，而B模块执行过程中，它可能调用D或E模块(D和E模块也是互斥被调用的)。因此，可以为该用户程序建立图3-5所示的覆盖结构，其中Main模块是常驻段，其余部分组成两个覆盖段。由以上推理可知，A和B模块组成覆盖段1,C、D和E模块组成覆盖段2。为了实现真正覆盖，相应的覆盖区应为每个覆盖段中最大覆盖的大小。采用覆盖技术后，运行该用户程序总共只需80KB的内存。覆盖技术的特点是打破了必须将一个进程的全部信息装入主存后才能运行的限制。但当同时执行程序的代码量超过主存时，程序仍然不能运行。 交换技术 交换(Swapping)技术就是把暂时不用的某个程序及数据部分(或全部)从内存移到外存中，以便腾出必要的内存空间;或把指定的程序或数据从外存读到相应的内存中，并将控制权转给它，让其在系统上运行的一种内存扩充技术。处理器三级调度中的中级调度就是采用了交换技术。 交换技术最早用在麻省理工大学的兼容分时系统(CTSS)中，任何时刻在该系统的内存中都只有一个完整的用户作业，当其运行一段时间后，或由于分配给它的时间片用完，或由于需要其他资源而等待，系统就把它交换到外存上，同时把另一个作业调入内存运行。这样可以在存储容量不大的小型机上实现分时运行。早期的一些 小型分时系统大多采用这种交换技术。 与覆盖技术相比，交换技术不要求程序员给出程序段之间的覆盖结构，且交换主要是在进程或作业之间进行，而覆盖则主要在同一个作业或进程中进行。另外，覆盖技术只能覆盖与覆盖程序段无关的程序段。交换进程由换出和换入两个过程组成。由于覆盖技术要求给出程序段之间的覆盖结构，使得它对用户不透明，因此有主存无法存放用户程序的矛盾，现代操作系统是通过虚拟内存技术解决这一矛盾的。覆盖技术已经成为历史，而交换技术在现代操作系统中仍然有较强的生命力。 交换技术的特点是打破了一个程序一旦进入主存便一 直运行到结束的限制。但运行的进程大小仍然受实际主存的限制。 有关交换需要注意以下几点。 交换需要备份存储，通常是使用快速磁盘。它必须足够大，并且提供对这些内存映像的直接访问。 为了有效使用CPU，需要每个进程的执行时间比交换时间长，而影响交换时间的因素主要是转移时间。 如果换出进程，必须确保该进程完全空闲。 交换空间通常作为磁盘的一整块，且独立于文件系统。 交换通常在有许多进程运行且内存空间紧张时开始启动，而在系统负荷减轻时暂停。 普通的交换使用不多，但交换技术的某些变种在许多系统中(如UNIX系统)仍发挥着作用。 注:如果大家想要了解挂起状态，可以查看相关资料(考试大纲对挂起状态不做要求)。由于系统资源有限，需要挂起一些进程，以满足一些进程的需要(比如在实时操作系统中或者需要实时完成的进程需要更多资源时)。对挂起进程的操作之一就是交换，系统将被挂起的进程暂时交换到了外存上，以腾出系统资源来执行其他更为主要的进程(比如实时进程)或处理系统某些突发事件。 ","date":"2021-11-10 13:14:39","objectID":"https://qizhengzou.github.io/operatingsystem_base_03/:1:2","tags":["operating system"],"title":"OperatingSystem_base_03","uri":"https://qizhengzou.github.io/operatingsystem_base_03/"},{"categories":["School courses"],"content":"连续分配管理方式 补充知识点:什么是内部碎片与外部碎片? 解析:根据碎片出现的情况，可以将碎片分为内部碎片和外部碎片。内部碎片是指已经分配给作业但不能被利用的内存空间，外部碎片是指系统中还没有分配给作业，但由于碎片太小而无法分配给申请内存空间的新进程的存储块，如下面讲到的固定分区分配中存在内部碎片，而动态分区分配中存在外部碎片。通俗点理解就是，某个作业所占用的内存区域如果没有装满，就是内部碎片，而作业与作业之间，如果有内存区域没有分配给某个作业，但又不能分配给任何作业,就是外部碎片。 单一连续分配 单一连续分配是一种最简单的存储管理方式，通常只能用于单用户、单任务的操作系统中。这种存储管理方式将内存分为两个连续存储区域，其中一个存储区域固定地分配给操作系统使用，通常放在内存低地址部分，另一个存储区域给用户作业使用。通常，用户作业只占用所有分配空间的一部分，剩下一部分实际上浪费掉了。一个容量为256KB的内存中，操作系统占用32KB，剩下的224KB全部分配给用户作业，如果一个作业仅需64KB，那么就有160KB的存储空间没有被利用单一连续分配方式采用静态分配，适合单道程序，可采用覆盖技术。作业一旦进入内存，就要等到其结束后才能释放内存。因此，这种分配方式不支持虚拟存储器的实现，无法实现多道程序共享主存。 单一连续分配方式的优点是管理简单，只需要很少的软件和硬件支持，且便于用户了解和使用，不存在其他用户干扰的问题。其缺点是只能用于单用户、单任务的操作系统，内存中只装入一道作业运行，从而导致各类资源的利用率都很低。单一连续分配会产生内部碎片。 固定分区分配， 固定分区分配(也称为固定分区存储管理)方法是最早使用的一种可运行多道程序的存储管理方法，它将内存空间划分为若干个固定大小的分区，每个分区中可以装入一道程序。分区的大小可以不等，但事先必须确定，在运行时不能改变。当有空闲分区时，便从后备队列中选择一个适当大小的作业装入运行。固定分区分配中，程序通常采用静态重定位方式装入内存。为了实现固定分区分配，系统需要建立一张分区 说明表，以记录可用于分配的分区号、分区的大小、分区的起始地址及状态，通常按照分区大小顺序排序，例如，将主存的可用区域划分为5个分区，如图3-7所示。 当某个用户程序要装入内存时，由内存分配程序检索分区说明表，从表中找出一个能满足要求的尚未分配的分区分配给该程序，然后修改分区说明表中相应分区表项的状态;若找不到大小足够的分区，则拒绝为该程序分配内存。当程序执行完毕不再需要内存资源时，释放程序占用的分区，管理程序只需将对应分区的状态设置为未分配即可。分区大小可以相等，也可以不相等。 分区大小相等。缺乏灵活性，造成内存空间的浪费，当程序太大时，一个分区又不足以装入该程序，导致程序无法运行。 分区大小不相等。可把内存区划分成含有多个较小的分区、适量的中等分区及少量的大分区。可根据程序的大小为之分配适合的分区。 固定分区分配的优点是可用于多道程序系统最简单的存储分配，其缺点是不能实现多进程共享一个主存区，利用率较低，会产生内部碎片。 动态分区分配 动态分区分配又称为可变式分区分配，是一种动态划分存储器的分区方法。这种分配方法并不事先将主存划分成一块块的分区，而是在作业进入主存时，根据作业的大小动态地建立分区，并使分区的大小正好满足作业的需要。因此，系统中分区的大小是可变的，分区的数目也是可变的。 分区分配中的数据结构 为了实现动态分区分配，系统中也必须设置相应的数据结构来记录内存的使用情况。常用的数据结构形式如下。 空闲分区表。设置一个空闲分区表来登记系统中的空闲分区，每个空闲分区对应一个表项，每个表项包含分区号、起始地址、大小及状态。 空闲分区链。用链头指针将内存中的空闲分区链接起来，构成空闲分区链。 分区分配算法 为了将一个作业装入内存，应按照一定的分配算法从空闲分区表(或空闲分区链)中选出一个满足作业需求的分区分配给作业。如果这个空闲分区的容量比作业申请的空间容量要大，那么将该分区的一部分分配给作业，剩下的一部分仍然留在空闲分区表( 或空闲分区链)中，同时需要对空闲分区表(或空闲分区链)中的有关信息进行修改。目前常用的分配算法有以下4种。 首次适应算法(First Fit, FF)。 把空闲分区按照地址递增的次序用链表串成一个队列，每次需要为一个进程分配内存时都从队首开始找，顺着链表直到找到足够大的空闲分区，然后按照作业大小从该分区划分出一块内存空间分配给请求者，余下的空闲分区仍然留在空闲分区表(或者空闲分区链)中。若从头到尾都不存在符合条件的分区，则分配失败。 优点: 优先利用内存低地址部分的空闲分区，从而保留了高地址部分的大的空闲分区，无内部碎片。 缺点:由于低地址部分不断被划分，致使低地址端留下许多难以利用的很小的空闲分区(外部碎片)，而每次查找又都是从低地址部分开始，这无疑增加了查找可用空闲分区的开销。 下次适应算法(Next Fit, NF)。 该算法又称为循环首次适应算法，即在首次适应算法的基础上把队列改成循环队列(依然是将空闲分区按照地址递增的次序排列)，而且也不是每次从队首开始找空闲分区，而是从上次找到的空闲分区的下一个分区开始找。 优点: 这样使得空闲分区的分布更加均匀，减少了查找空闲分区的开销。 缺点: 导致缺乏大的空闲分区。 最佳适应算法(Best Fit, BF)。 要求将空闲分区按照容量大小递增的次序排列。每次为作业分配内存空间时，总是将能满足空间大小需要的最小的空闲分区分配给作业。这样可以产生最小的内存空闲分区。 优点: 这种方法总能分配给作业最恰当的分区，并保留大的分区。 缺点:导致产生很多难以利用的碎片空间。 最差适应算法(Worst Fit, WF)。 要求空闲分区按照容量大小递减的次序排列。每次为作业分配内存空间时，总是将满足要求且最大的内存空间分配给作业。 优点: 这样使分给作业后剩下的空闲分区比较大，足以装入其他作业。 缺点: 由于最大的空闲分区总是因首先分配而被划分，当有大作业到来时，其存储空间的申请会得不到满足。 分区的回收 当作业执行结束时，系统应回收已使用完毕的分区。系统根据回收分区的大小及首地址，在空闲分区表(或空闲分区链)中检查是否有相邻的空闲分区，如有相邻空闲分区，则合并成一个大的空闲区，并修改有关的分区状态信息。回收分区与已有空闲分区的相邻情况有以下4种，如图3-9所示。 回收区上邻接一个空闲分区，如图3-9a所示。此时应将回收区与上邻接分区F1合并成一个连续的空闲分区。合并分区的首地址为空闲分区F1的首地址，其大小为二者之和。 回收区下邻接一个空闲分区，如图3-9b 所示。此时应将回收区与下邻接分区F1合并成一个连续的空闲分区。合并分区的首地址为回收区的首地址，其大小为二者之和。 回收区 上、下各邻接一个空闲分区，如图3-9c所示。此时应将回收区与F1、F2 合并为一个连续的空闲分区。合并分区的首地址为F1的首地址，其大小为三者之和，且应当把F2从空闲分区表(或空闲分区链)中删除。 回收区不与任何空闲分区相邻接，这时单独建立表项，填写分区大小及地址等信息，加入空闲分区表(或空闲分区链)的适当位置，如图3-9d所示。 分区分配的动态管理 在分区存储管理方式中，必须把作业装入到一片连续的内存空间中。如果系统中有若干小的分区，其总容量大于要装入的作业，但由于它们不相邻接，致使作业不能装入内存。例如，内存中有4个空闲分区不相邻接，它们的大小分别为20KB、30KB、 15KB、 25KB, 总大小为90KB。但如果有一个 40KB的作业到达，因系统中所有空闲分区的容量均小于40KB,故此作业无法装入内存，所以就需要对分区分配进行动态管理。 目前主要有两种分区重定位技术。 拼接技术。所谓碎片(也可称为零头)，是指内存中无法被利用的存储空间。在分区存储管理方式下，系统运行一段时间后，内存中的碎片会占据相当数量的空间。解决碎片问题的方法之一是将 存储器中所有已分配分区移动到主存的一端，使本来分散的多个小空闲区连成一个大的空闲区。这种通过移动把多个分散的小分区拼接成一个大分区的方法称为拼接或紧凑，也可称为紧缩。 除了有怎样进行拼接的技术问题外，拼接技术的实现还存在一个拼接时机的问题，这个问题有两种解决方案。 第一种方案是在某个分区 回收时立即进行拼接，这样在主存中总是只有一个连续的空闲区。但拼接很费时间，拼接频率过高会使系统开销加大。 第二种方案是当找不到足够大的空闲分区且总容量可以满足作业要求时进行拼接。这样拼接的频率比上一种方案要低得多，但空闲分区的管理稍微复杂一些。 动态重定位分区分配技术。动态重定位分区分配算法与动态分区分配算法基本相同，两者的差别仅在于:在这种分配算法中增加了拼接功能，通常是在找不到足够大的空闲分区来满足作业要求，而系统中空闲分区容量总和大于作业要求时进行拼接。 动态分区分配的优缺点 优点: 实现了多道程序共用主存(共用是指多进程同时存在于主存中的不同位置); 管理方案相对简单、不需要更多开销;③实现存储保护的手段比较简单。 缺点: 主存利用不够充分，存在外部碎片; 无法实现多进程共享存储器信息(共享是指多进程都使用同一个主存段);③无法实现主存的扩充，进程地址空间受实际存储空间的限制。 ","date":"2021-11-10 13:14:39","objectID":"https://qizhengzou.github.io/operatingsystem_base_03/:1:3","tags":["operating system"],"title":"OperatingSystem_base_03","uri":"https://qizhengzou.github.io/operatingsystem_base_03/"},{"categories":["School courses"],"content":"非连续分配管理方式：分页管理方式、分段管理方式、段页式管理方式。 非连续分配允许一个程序分散地装入到不相邻的内存分区中。在连续分配管理方式中我们发现，即使内存有超过1GB的空闲空间，但如果没有连续的1GB的空间，需要1GB空间的作业当然是无法运行的;但如果采用非连续分配方式，作业所要求的1GB内存空间可以分散地分配在内存的各个区域，当然这也需要额外的空间去存储它们(分散区域)的索引，使得非连续分配方式的存储密度低于连续存储方式。 非连续分配管理方式根据分区大小是否固定分为分页存储管理方式和分段存储管理方式，其中分页存储管理方式根据运行作业时是否需要把作业的所有页都装入内存才能运行而分为基本分页存储管理方式和请求分页存储管理方式，请求分页存储管理方式将在3.2节进行讲解。 基本分页存储管理方式 在分区存储管理中，要求把作业放在一个连续的存储区中， 因而会产生碎片问题(外部碎片)。尽管通过拼接技术可以解决碎片问题，但代价较高。如果允许将一个作业存放到许多不相邻接的分区中，那么就可以避免拼接，从而有效地解决外部碎片问题。基于这一思想，引入了分页存储管理( 或称页式存储管理)技术。 分页原理 在分页存储管理中，用户作业的地址空间被划分成若干个大小相等的区域，称为页或页面。相应地，将主存的存储空间也分成与页面大小相等的区域，称为块或物理块。在为作业分配存储空间时，总是以块为单位来分配，可以将作业中的任意一页放到主存的任意一块中。 ★注:主存中与页面大小相等的物理块也可称为页框。 在调度作业运行时，必须将它的所有页面一次调入主存;若主存中没有足够的物理块，则作业等待。这种存储管理方式称为简单分页或纯分页。页面的大小由机器的地址结构决定。在确定地址结构时，若选择的页面较小，可使页内碎片较小并减少内存碎片的总空间，有利于提高内存利用率;但也会使每个进程要求较多的页面，从而导致页表过长，占用较多内存，还会降低页面换进换出的效率。若选择的页面较大，虽然可以减少页表长度，提高页面换进换出的效率，但却会使页内碎片增大。因此，页面的大小应选择适中(通常为2的整数幂)，以方便地址变换，一般为 512B~4KB。分页存储管理系统中的逻辑地址(见图3-10)包含两部分内容:前一部分为页号 P,后一部分为页内位移W(也称为页内偏移量)。 上述地址结构中，两部分构成的地址长度为32位。其中0~11位是页内位移地址，即每页的大小为2的12次方B=4KB，12~31 位是页号，即一个进程运行的最多页数为2的20次方=1M页。假设逻辑地址为A，页面大小为L，则页号P= (int) (A/L)。 页内位移W=A%L。其中，“(int)”是强制类型转换为整型，“/” 为取商操作，“%”是取余操作。 页表 为了将逻辑地址上连续的页号映射到物理内存中后成为离散分布的多个物理块，需要将每个页面和每个物理块一对应， 这种映射关系就体现在页表上。页表中每个页表项都由页号和块号组成，根据页表项就可以找到每个页号所对应物理内存中物理块的块号。页表通常存放在内存中。图3-11给出了页表的示例。假设一个用户程序在基本分页存储管理方式中被分成n页,如图3-11a所示，则其页号与内存中的块号的对应关系如图3-11b中页表所示。根据页表所示的对应关系，用户程序的每一页分 别存储于图3-11c的内存区域中。 基本地址变换机构 图3-12给出了分页存储管理系统的地址变换机构,整个地址变换过程都是由硬件自动完成的。 页表寄存器(PTR): 用来存放页表在内存中的起始地址和页表的长度。 如图3-12所示，假设页面大小为L、页表长度为M、逻辑地址为A、物理地址为E，下面列出从逻辑地址A得到物理地址E去访问内存的步骤。 1)计算页号P=(int)(A/L);页内位移W=A%L。 2)比较页号P和页表长度M，若P≥M,则产生越界中断，否则转到3)接着执行。 3)页表起始地址F与页号P和页表项长度的乘积相加，用得到的地址值到内存中取出该内存单元存放的数b，这个b就是物理块号。 4)物理块号b和物理块大小的乘积与页内位移w组合成物理地址E。 5)用得到的物理地址E去访问内存。 具有快表的地址变换机构 从上面的介绍可知，若页表全部放在主存中，则存取一个数据或一 条指令至少要访问两次主存。其中，第一次是通过访问页表以确定所存取的数据或指令的物理地址，第二次才根据所得到的物理地址存取数据或指令。显然，这种方法比通常执行指令的速度慢了一半。 为了提高地址变换的速度，可以在地址变换机构中增设一个具有并行查找功能的高度缓冲存储器(又称联想存储器或快表),将部分页表项放在这个高速缓冲存储器中。快表(TLB)一般是由半导体存储器实现的，其工作周期与CPU的周期大致相同，但造价较高。为了降低成本，通常是在快表中存放正在运行作业当前访问的那些页表项，页表的其余部分仍然存放在内存中。具有快表的地址变换机构如图3-13所示。 增加快表后的地址变换过程如下。 根据逻辑地址得出页号P与页内位移W。 先将页号与快表中的所有页号进行对比，若有匹配的页号，则直接读出对应块号，与页内位移拼接得到物理地址;若没有匹配的页号，则还需访问内存中的页表，从页表中取出物理块号，与页内位移拼接得到物理地址，并将此次的页表项存入快表中。 用得到的物理地址访问内存。 由于快表是寄存器，存储空间有限，往往放不了几个页表单元，因此在快表中不一定总能找到所需的页号对应的块号。每次查找页表前都先查找快表，如果找到所需的页号，就直接读出块号，然后只需访问内存一次;如果没有找到所需的页号，那么只能再从页表中找块号，这样就需要访问内存两次，而且比没有快表时增加了访问快表所需的时间。所以要尽量保证快表中放置常用的页号和对应的块号，这样才能真正地做到减少访问时间。 两级页表和多级页表 页表大小计算。在基础分页系统中，页表长度M是由页号的位数决定的。而页表的大小可以理解成一个矩形的面积，这个矩形的长度就是页表长度M,宽度是每个页表项的大小，即块号的位数。关于页表的计算通常第一步就应分析地址结构，这样有助于做题。 两级页表。从页表大小的计算公式可知，页表大小和页表长度成正比，而页表长度又随着页号位数的增长而呈指数式增长。所以，如果系统的逻辑地址的位数较多，页表会非常大，而整张页表都需要连续地存放在内存中，这是件很困难的事情，于是就有了两级页表。如图3-14所示，两级页表的系统将逻辑地址划分为外层页号、外层页内地址和页内地址。先用外层页号P1在外部页表上查找，找出的单元内容是二级页表，的首地址，页表的首地址加上外层页内地址P2就是页表项的地址，取出里面的数值(即物理块号),物理块号与页内地址d相组合就得到了物理地址。在两级页表机制下，无论是外层页号的位数还是外层页内地址的位数都比一级页表机制少了很多，这样页表的长度就可以减少很多，相应页表的大小也大大减小了。 多级页表。对于32位的机器(逻辑地址的位数是32位)，采用两级页表机构是合适的，但对于64位的系统，两级页表机构会使页表的大小变得不可接受,所以可以通过继续增加页表的级数来减小页表的大小，不过会使页表的数量大大增加。多级页表最主要的缺点是要多次访问内存，每次地址变换很浪费时间。 页的共享与保护 在多道程序系统中，数据的共享是很重要的。在分页存储管理系统中，实现共享的方法是使共享用户地址空间中的页指向相同的物理块。在分页存储管理系统中实现共享比在分段系统中要困难。这是因为，分页存储管理系统中将作业的地址空间划分成页面的做法对用户是透明的，同时作业的地址空间是线性连续的，当系统将作业的地址空间分成大小相同的页面时，被共享的部分不一定被包含在一个完整的页面中，这样不应共享的数据也被共享了，不利于保密。另外，共享部分的起始地址在各作业的地址空间划分成页的过程中，在各自页面中的页内位移可能不同，这也使得共享比较难。 分页存储管理系统可以为内存提供两种保护方式:一种是地址越界保护，即通过比较地址变换机构中的页表长度和所要访问的逻辑地址中的页号来完成;另一种是通过页表中的访问控制信息对内存信息提供保护，例如，在页表中设置一个存取控制字段，根据页面使用情况将该字段定义为读、写、执行等权限，在进行地址变换时，不仅要从页表的相应表目中得到该页对应的块号，同时还要检查木次操作与存取控制字段允许的操作是否相符，若不相符，则由硬件捕获并发出保护性中断。 基本分页存储管理方式的优缺点 优点: 内存利用率高; 实现了离散分配; 便于存储访问控制; 无外部碎片。 缺点: 需要硬件支持(尤其是快表); 内存访问效率下降; 共享困难; 内部碎片。 基本分段存储管理方式 前面介绍的各种存储技术中，用户逻辑地址空间是一个线性连续的地址空间。而通常情况下，一个作业是由多个程序段和数据段组成的，这就要求编译链接程序将它们按照一维线性地址排列，从而给程序及数据的共享带来了困难。另外，程序员一般希望按照逻辑关系将作业分段，且每段要有自己的名字，以便根据名字访问相应的程序段或者数据段。分段存储管理能较好地解决上述问题。因此，分段存储管理相较于分页存储管理有如下优点。 方便编程: 用户把自己的作业按照逻辑关系划分为若千个段，每段都是从0开始编址，有自己的名称和长度。 信息共享: 页面是存放信息的物理单位，没有完整的意义;而段是信息的逻辑单位，用户可以把需要共享的部分代码和数据放在同一段以便信 息共享。 信息保护:由于每一段都包含相对独立的信息，因此对信息保护可以采取对段进行保护，信息保护相对于分页式方便许多。 分段存储原理 在分段存储管理系统中，作业的地址空间由若千个逻辑分段组成，每个分段是一组逻辑意义上","date":"2021-11-10 13:14:39","objectID":"https://qizhengzou.github.io/operatingsystem_base_03/:1:4","tags":["operating system"],"title":"OperatingSystem_base_03","uri":"https://qizhengzou.github.io/operatingsystem_base_03/"},{"categories":["School courses"],"content":"虚拟内存管理 ","date":"2021-11-10 13:14:39","objectID":"https://qizhengzou.github.io/operatingsystem_base_03/:2:0","tags":["operating system"],"title":"OperatingSystem_base_03","uri":"https://qizhengzou.github.io/operatingsystem_base_03/"},{"categories":["School courses"],"content":"虚拟内存基本概念 虚拟内存的引入原因 前面介绍的若干种存储管理方法都是分析如何将多个程序装入内存中并行。这些方法都具有如下两个特点:一次性( 作业全部装入内存后才能执行)和驻留性(作业常驻内存直到运行结束)。它们均难以满足较大的作业或者较多的作业进入内存执行。而程序在执行过程中，有些代码是较少用到的(比如错误处理部分)，而且有的程序需要较长时间的I/O处理，从而导致了很多内存空间的浪费。为此引入了一种能够让作业部分装入就可以运行的存储管理技术，即虚拟内存管理技术。 局部性原理 大多数程序执行时，在一个较短的时间内仅使用程序代码的一部分， 相应地，程序所访问的存储空间也局限于某个区域，这就是程序执行的局部性原理。其表现如下。 时间局部性。 一条指令的一次执行和下次执行，一个数据的一次访问和下次访问，都集中在一个较短的时期内。 空间局部性。当前指令和邻近的几条指令，当前访问的数据和邻近的数据，都集中在一个较小的区域内。 虚拟内存的定义及特征 基于局部性原理，在程序装入时，一方面可以将程序的一部分放入内存，而将其余部分放在外存，然后启动程序( 部分装入)。在程序执行过程中，当所访问的信息不在内存中时，再由操作系统将所需的部分调入内存(请求调入)。另一方面，操作系统将内存中暂时不使用的内容置换到外存上，从而腾出空间存放将要调入内存的信息(置换功能)。从效果上看，计算机系统好像为用户提供了一个存储容量比实际内存大得多的存储器，这种从逻辑上扩充内存容量的存储器系统称为虚拟存储器(简称虚存)。将其称为虚拟存储器是因为这种存储器实际上并不存在，系统只是提供了部分装入、请求调入和置换功能，给用户的感觉是好像存在一个能满足作业地址空间要求的内存。虚拟内存的意义是让程序存在的地址空间与运行时的存储空间分开，程序员可以完全不考虑实际内存的大小，而在地址空间内编写程序。虛拟存储器的容量由计算机的地址结构决定，并不是无限大。 虚拟内存具有如下特征。 离散性。程序在内存中离散存储(★注:离散性并不是虚拟内存的特有特征，基本分页和分段也具有离散性)。 多次性。 一个作业可以分成多次调入内存。 对换性 (交换性)。作业在运行过程中可以换入、换出。虚拟性。从逻辑上扩充内存容量，用户可以使用的空间可以远大于实际内存容量。 实现虚拟内存的硬件和软件支持 实现虚拟存储技术，需要有一定的物质基础。 要有相当数量的外存， 足以存放多个用户的程序。 要有一定容量的内存， 在处理器上运行的程序必须有一部分信息存放在内存中。 中断机构，当用户访问的部分不在内存中时中断程序运行。 地址变换机构， 以动态实现虛地址到实地址的地址变换。 相关数据结构，段表或页表。 常用的虚拟存储技术有请求分页存储管理、请求分段存储管理和请求段页式存储管理。 ","date":"2021-11-10 13:14:39","objectID":"https://qizhengzou.github.io/operatingsystem_base_03/:2:1","tags":["operating system"],"title":"OperatingSystem_base_03","uri":"https://qizhengzou.github.io/operatingsystem_base_03/"},{"categories":["School courses"],"content":"请求分页管理方式 分页存储管理方式虽然解决了内存中的外部碎片问题，但它要求将作业的所有页面一次性调入主存。当主存可用空间不足或作业太大时，这就会限制一些作业进入主存运行。为此引入了请求分页(也称请求页式)存储管理方式，先将程序部分载入内存执行，当需要其他部分时再调入内存。很明显，这种方法是根据程序的局部性原理产生的。 请求分页原理 请求分页存储管理方法在作业地址空间的分页、存储空间的分块等概念上和分页存储管理完全一样。它是在分页存储管理系统的基础上，通过增加请求调页功能、页面置换功能所形成的一种虚拟存储系统。在请求分页存储管理中，作业运行之前，只要将当前需要的一部分页面装入主存，便可以启动作业运行。在作业运行过程中，若所要访问的页面不在主存中, 则通过调页功能将其调入，同时还可以通过置换功能将暂时不用的页面置换到外存上，以便腾出内存空间。 可以说，请求分页=基本分页+请求调页功能+页面置换功能。 页表结构 在请求分页系统中使用的主要数据结构仍然是页表，其基本作用是将程序地址空间中的逻辑地址转换成内存空间中的物理地址。由于请求分页系统只将作业的一部分调入内存，还有一部分存放在磁盘上，故需要在页表中增加若干项，以供操作系统在实现页面的调入、换出功能时参考。扩充后的页表项如图3-21所示。 页表中各字段的作用如下。 页号和物理块号。 这两个字段在分页存储管理中已经定义过，是进行地址变换所必需的。 状态位(存在位)。用于判断页面是否在主存中。每当进行主存访问时，根据该位判断要访问的页面是否在主存中，若不在主存中，则产生缺页中断。 访问字段。 用于记录页面在一段时间内被访问的次数，或最近已有多久未被访问，以供置换算法在选择换出页面时参考。 修改位。用于表示页面调入内存后是否被修改过。当处理器以写方式访问页面时，系统将设置该页面的修改位。由于内存中的页面在外存上都有副本，因此，若页面未被修改,则在该页面置换出时不需要将页面写到外存，以减少磁盘写的次数;若页面被修改，则必须将页面重新写到外存上。 外存地址。用于指出页面在外存上的存放地址，供调入页面时使用。 缺页中断与地址变换 在请求分页存储管理系统中，若所访问的页面在内存中，其地址变换过程与分页存储管理相同;若访问的页面不在内存，则应先将该页面调入内存，再按照与基本分页存储管理相同的方式进行地址变换。 若系统发现所要访问的页面不在内存中，便产生一个缺页中断信号，此时用户程序被中断，控制转到操作系统的缺页中断处理程序。缺页中断处理程序根据该页在外存的位置将其调入内存。在调页过程中，若内存中有空闲空间，则缺页中断处理程序只需把缺页装入任何一个空闲存储块中，再对页表中的相应表项进行修改(如填写物理块号、修改状态位、设置访问字段及修改位初值等)即可;若内存中无空闲空间，则必须先淘汰内存中的某些页面，若被淘汰页曾被修改过，则要将其写回外存。具体流程如图3-22所示。 缺页中断是一个比较特殊的中断，它与一般中断相比有着明显的区别，主要表现在以下方面。 在指令 的执行期间产生和处理缺页中断。通常，CPU是在指令执行完毕后检查是否有中断请求到达，若有，便响应。而缺页中断是在一条指令的执行期间发现要访问的指令和数据不在内存时产生和处理的。 一条指令可以产生多个缺页中断。例如，一条双操作数的指令，每个操作数都不在内存中，则这条指令执行时至少将产生两个缺页中断。 请求分页管理方式的优缺点 优点: 可以离散储存程序，降低了碎片数量; 提供虛拟存储器，提高了主存利用率， 有利于多道程序运行，方便用户。 缺点: 必须有硬件支持; 有些情况下系统会产生抖动现象; 程序最后一页仍然存在未被利用的部分空间。 ","date":"2021-11-10 13:14:39","objectID":"https://qizhengzou.github.io/operatingsystem_base_03/:2:2","tags":["operating system"],"title":"OperatingSystem_base_03","uri":"https://qizhengzou.github.io/operatingsystem_base_03/"},{"categories":["School courses"],"content":"页面置换算法：最佳置换算法(OPT)、先进先出置换算法(FIFO)、最近最少使用置换算法(LRU)、时钟置换算法(CLOCK)。 页面置换算法(也称为页面淘汰算法)是用来选择换出页面的算法。在请求页式存储管理方式中，由于一个进程运行时不是所有页面都在内存中，因此会出现缺页中断，此时内存没有空闲的物理块，就需要置换出内存中的一页，具体置换出哪一页面是由页面置换算法决定的，由此可见，页面置换算法的优劣直接影响到系统的效率。 要注意把页面置换和连续分配方式中的交换区别开来，页面置换的单位是页面而不是整个进程，交换的单位是整个进程。 当发生缺页中断后，系统不一定会执行页面置换算法。因为发生缺页中断仅仅说明需要执行的页面没有在内存中，如果内存空间中还有空闲块，只需用缺页中断处理程序把需要的页面从外存调入内存即可，不需要页面置换算法;只有内存中没有空闲块时才需要页面置换算法。所以，缺页中断不一定导致页面置换算法的执行。 最佳置换(OPT)算法 在预知一个进程的页面号引用串的情况下，每次都淘汰以后不再使用的或以后最迟再被使用的页面，这种算法就是最佳置换算法。显然，最佳置换算法是最优的，具有最低的缺页率。但由于实际操作中往往无法事先知道以后会引用到的所有页面的信息，因此最佳置换算法无法实现，只能作为一个标准来衡量其他置换算法的优劣。 先进先出(FIFO) 算法 FIFO算法是最简单的页面置换算法，每次总是淘汰最先进入内存的页面，也就是淘汰在内存驻留时间最长的页面。该算法实现简单，用一个队列的数据结构就可以实现，将页面按照次序排成一个队列，并设置指针指向最先进入的页面，每次需要淘汰页面时，将指针所指的页面淘汰即可。 不过FIFO算法可能会产生Belady异常(缺页次数随着分配的物理块号的增加而增加,后面会详细介绍)，这是由于FIFO算法忽略了一种现象，就是最早调入的页面往往是使用最频繁的页面，因此FIFO算法与进程实际运行规律不符，可能选择淘汰的页面是程序经常使用的页面，实际效果不好。 最近最少使用(LRU) 算法 选择最近最长时间没有被使用的页面予以淘汰，其思想是用以前的页面引用情况来预测将来会出现的页面引用情况，也就是假设一个页面刚被访问，那么不久该页面还会被访问。即最佳置换算法是“向后看”，而最近最少使用算法则是“向前看”。该算法可以用寄存器组和栈来实现，性能较好。常用的页面置换算法中，LRU算法最接近最佳置换算法。 时钟置换(CLOCK)算法 时钟置换(CLOCK)算法也称为最近未使用(NRU) 算法，是LRU和FIFO的折中。作为LRU的近似算法，CLOCK算法给每个页面设置一个访问位，用以标识该页最近有没有被访问过。CLOCK维护一个内存中所有页面的循环链表，当程序需要访问链表中存在的页面时，该页面的访问位就被置位为1;否则，若程序要访问的页面没有在链表中，那就需要淘汰一个内存中的页面，于是一个指针就从上次被淘汰页面的下一个位置开始顺序地去遍历这个循环链表，当这个指针指向的页面的访问位为1时，就把该访问位清零，指针再向下移动，当指针指向的页面的访问位为0时，就选择淘汰掉这一页面， 若遍历了一遍 链表仍没找到可以淘汰的页面，就继续遍历下去。 CLOCK算法比LRU算法少了很多硬件的支持，实现比较简单，但比FIFO算法所需硬件要多。 改进型时钟(CLOCK) 算法 还有一种改进型CLOCK算法，它考虑了页面载入内存后是否被修改的问题，增加了修改位。在访问位同为0的进程间优先淘汰没有修改过的页面，因为没有修改过的页面可以被直接淘汰掉，而修改过的页面需要写回到外存中。与简单CLOCK算法相比，该算法可减少磁盘I/O次数，但会增加扫描次数。 改进型CLOCK算法增加了修改位后，每个页面的状态存在如下4种情况。 最近未被访问过，也未被修改过(访问位=0，修改位=0)。 最近被访问过，未被修改过(访问位=1，修改位=0)。 最近未被访问，但被修改过(访问位=0,修改位=1)。 最近被访问过，也被修改过(访问位=1,修改位=1)。 改进型时钟算法的算法步骤如下: 1)从指针的当前位置开始，扫描循环链表。在这次扫描过程中，对访问位和修改位不做修改。选择遇到的第一个(访问位=0，修改位=0) 的页面用于替换。 2)如果第1)步没有找到，重新扫描，寻找(访问位=0，修改位=1)的页面用于替换。在这个扫描过程中，每一个非替换的页面都将其访问位置0。 3)如果第2)步仍没有找到，则回到起始位置，此时所有页面的访问位均为0，重新执行第1)步和第2)步，则一定能找到替换页面。 其他页面置换算法 (1)最不常用置换(LFU)算法 选择到当前时间为止访问次数最少的页面淘汰。该算法要求为每页设置一个访问计数器，每当页面被访问时，该页的访问计数器加1。发生缺页中断时，淘汰计数值最小的页面，并将所有计数器清零。 (2)页面缓冲(PBA)算法， PBA算法是对FIFO算法的发展，通过建立置换页面的缓冲，找回刚被置换的页面，从而减少系统I/O的消耗。PBA算法用FIFO算法选择被置换页，选择出的页面不是立即换出，而是放入两个链表之一中。如果页面未被修改，就将其归入到空闲页面链表的末尾，否则将其归入到已修改页面链表的末尾。这些空闲页面和已修改页面会在内存中停留一段时间。如果这些页面被再次访问，只需将其从相应链表中移出，就可以返回给进程，从而减少了一次磁盘I/O。需要调入新的物理页时，将新页面读入到空闲页面链表的第一个页面中，然后将其从该链表中移出。当已修改页达到一定数目后，再将其一起写入磁盘，然后将它们归入空闲页面链表。这样能大大减少I/O操作的次数。 ","date":"2021-11-10 13:14:39","objectID":"https://qizhengzou.github.io/operatingsystem_base_03/:2:3","tags":["operating system"],"title":"OperatingSystem_base_03","uri":"https://qizhengzou.github.io/operatingsystem_base_03/"},{"categories":["School courses"],"content":"工作集与页面分配策略 工作集理论 为了解决抖动现象，引入了工作集的概念。工作集是基于局部性原理假设的。如果能预知程序在某段时间间隔内要访问哪些页面，并能提前将它们调入内存，将会大大降低缺页率，从而减少置换工作，提高CPU利用率。 工作集是最近n次内存访问的页面的集合，数字n称为工作集窗口，也就是工作集的大小。经常被使用的页面会在工作集中，若一个页面不再使用，则它会被从工作集中丢弃。当一个进程寻址一个不在工作集内的页面时，会产生一个缺页中断。在处理缺页中断时，更新工作集并在需要时从磁盘中读入此页面。 工作集模型的原理是:让操作系统监视各个进程的工作集，主要是监视各个工作集的大小。若有空闲的物理块，则可以再调一个进程到内存以增加多道的程度;若工作集的大小总和增加超过了所有可用物理块的数量总和，则操作系统可以选择一个内存中的进程对换到磁盘中去，以减少内存中的进程数量来防止抖动的发生。正确选择工作集窗口大小，即分配给进程的页面数，对存储器的有效利用率和系统吞吐率的提高都将产生重要影响:一 方面，若窗口选得很大，进程虽不易产生缺页，但存储器也将不会得到充分利用;另一方面，若窗口选得过小，则会使进程在运行过程中频繁产生缺页中断，反而降低了系统吞吐率。 页面分配策略 在请求分页存储管理系统中，可以采用两种页面分配策略，即固定分配和可变分配。在进行页面置换时，也可以采用两种策略，即全局置换和局部置换。将它们组合起来，有如下3种适合的策略(固定分配全局置换不合理，因此不存在这种策略)。 固定分配局部置换。 为每个进程分配一 定数目的物理块， 这个数目是确定的，进程运行期间都不会改变。这样，进程之间不会争夺物理块，会导致有些进程因为物理块太少而频繁地缺页中断，有些进程由于分配的物理块太多而浪费内存空间。采用固定分配局部置换策略时，需要用算法决定每个进程分配多少块物理块，常用的算法有平均分配算法、按比例分配算法以及考虑优先权的分配算法。 可变分配全局置换。 操作系统维护一个空闲物理块队列，每次有进程缺页时都从空闲物理块队列上取下一个分配给它，如果系统中已经没有空闲的物理块了，那么系统将有可能调出任何进程中的其中一页。 可变分配局部置换。 为每个进程分配一定量的物理块后，每次发生缺页中断且内存中没有空闲物理块时，只让进程换出自己的某个内存页，但当一个进程频繁地发生缺页中断时，OS为它分配额外的物理块，直到缺页率降低到合适程度为止，当一个进程缺页率特别低时，适当减少分配给它的物理块的数量。可变分配局部置换策略在可以获得较高的内存空间利用率的同时，保证每个进程有较低的缺页率。 页面调入策略 请求调页 策略。一个页面只有在被用到时才被调入到内存中，否则就放在外存中。这种调页方式在一个进程刚启动时会频繁地出现缺页中断，这是因为一开始内存中没有该进程的任何页面。该策略实现简单，但容易产生较多的缺页中断，时间开销大，容易产生抖动现象。 预调页策略。该策略是指将预计不久之后会被用到的页面一并调入到内存，尽管暂时它们还没被用到。在程序启动时，如果程序员能指出哪些页面是首先应该被调入的，并把它们放一起，那么通过预调页策略就可以一次性把它们调入内存，从而可以节省不少时间。这是一种基于局部性原理的预测，通常用于程序的首次调入。 从何处调入页面 请求分页系统中的外存分为两部分:用于存放文件的文件区和用于存放对换页面的对换区。通常，由于对换区是采用连续分配方式，而文件是采用离散分配方式，因此对换区的磁盘I/O速度比文件区的高。这样，每当发生缺页请求时，系统应从何处将缺页调入内存，可分成如下3种情况。 系统拥有足够的对换区空间。这时可以全部从对换区调入所需页面，以提高调页速度。为此，在进程运行前，便应将与该进程有关的文件从文件区复制到对换区。 系统缺少足够的对换区空间。这时凡是不会被修改的文件，都直接从文件区调入;而当置换出这些页面时，由于它们未被修改而不必再将它们换出，以后再调入时，仍从文件区直接调入。但对于那些可能被修改的部分，在将它们换出时，就应调到对换区，以后需要时再从对换区调入。 UNIX方式。由于与进程有关的文件都放在文件区，因此凡是未运行过的页面都应 从文件区调入。而对于曾经运行过但又被换出的页面，由于是被放在对换区，因此在下次调 入时，应从对换区调入。由于UNIX系统允许页面共享，因此某进程所请求的页面有可能已 被其他进程调入内存，此时也就无须再从对换区调入。 ","date":"2021-11-10 13:14:39","objectID":"https://qizhengzou.github.io/operatingsystem_base_03/:2:4","tags":["operating system"],"title":"OperatingSystem_base_03","uri":"https://qizhengzou.github.io/operatingsystem_base_03/"},{"categories":["School courses"],"content":"抖动现象与缺页率 Belady 异常 FIFO置换算法的缺页率可能会随着所分配的物理块数的增加而增加，这种奇怪的现象就是Belady异常。例如，对于引用串1,2,3,4,1,2,5，1,2,3，4，5，内存中物理块数为3时发生9次缺页中断，而物理块数为4时反倒会发生10次缺页中断。产生Belady异常的原因是FIFO算法的置换特征与进程访问内存的动态特征相矛盾，即被置换的页面并不是进程不会访问的。FIFO算法可能出现Belady异常，而LRU算法和最佳置换算法永远不会出现Belady异常，被归类为堆栈算法的页面置换算法也不可能出现Belady异常。 抖动现象 若选用的页面置换算法不合适，可能会出现这种现象:刚被淘汰的页面，过后不久又要访问，并且调入不久后又调出，如此反复，使得系统把大部分时间用在了页面的调入调出上,而几乎不能完成任何有效的工作，这种现象称为抖动(或颠簸)。抖动产生的原因是在请求分页系统中的每个进程只能分配到所需全部内存空间的一部分。 缺页率 假定一个作业共有n页，系统分配给该作业m页的空间(m≤n)。如果该作业在运行中共需要访问A次页面(即引用串长度为A),其中所要访问页面不在内存，需要将所需页调入内存的次数为F，则缺页率定义为f=F/A，命中率即为1-f。缺页率是衡量页面置换算法的重要指标。通常缺页率会受置换算法、分配的页面数量、页面大小等因素的影响。缺页率对于请求分页管理系统是很重要的，如果缺页率过高，会直接导致读取页面的平均时间增加，会使进程执行速度显著降低。因此，如何降低缺页率是一项非常重要的工作。 ","date":"2021-11-10 13:14:39","objectID":"https://qizhengzou.github.io/operatingsystem_base_03/:2:5","tags":["operating system"],"title":"OperatingSystem_base_03","uri":"https://qizhengzou.github.io/operatingsystem_base_03/"},{"categories":["School courses"],"content":"习题 “大哥，注意单位！” 静态重定位是在程序运行之前由装入程序完成的(即装入内存时进行的)。而页式存储管理方案在运行过程中可能改变程序位置，静态重定位不能满足其要求。 只有FIFO算法会导致Belady异常。 ","date":"2021-11-10 13:14:39","objectID":"https://qizhengzou.github.io/operatingsystem_base_03/:3:0","tags":["operating system"],"title":"OperatingSystem_base_03","uri":"https://qizhengzou.github.io/operatingsystem_base_03/"},{"categories":["School courses"],"content":" 王道考研操作系统笔记 进程管理 ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:0:0","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"进程与线程 ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:1:0","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"进程概念 进程引入 在计算机操作系统中，进程是资源分配的基本单位（与线程的主要区别），也是独立运行的基本单位。 程序的顺序执行： 顺序性。处理器的操作严格按照程序所规定的顺序执行，即每一个操作必须在下一个操作开始之前结束。 封闭性。程序一旦开始运行，其执行结果不受外界因素影响。因为程序在运行时独占系统的各种资源，所以这些资源的状态(除初始状态外)只有本程序才能改变。 可再现性。 只要程序执行时的初始条件和执行环境相同，当程序重复执行时，都将获得相同的结果(即程序的执行结果与时间无关)。 程序的并发执行 程序的并发执行是指若千个程序(或程序段)同时在系统中运行，这些程序(或程序段)的执行在时间上是重叠的，即一个程序( 或程序段)的执行尚未结束，另一个程序(或程序段)的执行已经开始。程序的并发执行虽然提高了系统的处理能力和资源利用率，但也带来了一些新问题，产生了一些与顺序执行时不同的特征: 间断性。程序在并发执行时，由于它们共享资源或为完成同一项任务而相互合作,致使并发程序之间形成了相互制约关系。这种相互制约关系将导致并发程序具有“执行一暂停执行一执行”这种间断性的活动规律。 失去封闭性。程序在并发执行时，多个程序共享系统中的各种资源，因而这些资源的状态将由多个程序来改变，致使程序的运行失去封闭性。这样一个程序在执行时， 必然会受到其他程序影响，例如，当处理器被某程序占用时，其他程序必须等待。 不可再现性。程序并发执行时，由于失去了封闭性，也将导致失去其运行结果的可再现性。 进程的定义以及描述 在多道程序环境下，程序的并发执行破坏了程序的封闭性和可再现性，使得程序和计算不再一一对应，程序活动不再处于一个封闭系统中，程序的运行出现了许多新的特征。在这种情况下，程序这种静态概念已经不能如实地反映程序活动的这些特征，为此引入了一个新的概念：进程。 进程的定义，进程的概念从提出之后，许多人都对进程有过各式各样的定义，这里给出几种比较容易理解又能反映进程实质的定义: 进程是程序，在处理器上的一次执行过程。 进程是可以和别的进程并行执行的计算。 进程是程序在一个数据集合上的运行过程，是系统进行资源分配和调度的一个独立单位。 进程可定义为一个数据结构及能在其上进行操作的一个程序。 进程是一个程序关于某个数据集合在处理器上顺序执行所发生的活动。 上述这些描述从不同角度对进程进行了阐述，尽管各有侧重，但本质是相同的。 进程的特征，进程具有以下几个基本特征: 动态性。 进程是程序在处理器上的一次执行过程，因而是动态的。动态特性还表现在它因创建而产生，由调度而执行，因得不到资源而暂停，最后因撤销而消亡。 并发性。 并发性是指多个进程同时存在于内存中，能在一段时间内同时运行。引入进程的目的是使程序能与其他程序并发执行，以提高资源利用率。 独立性。进程是一个能独立运行的基本单位，也是系统进行资源分配和调度的独立单位。 异步性。异步性是指进程以各自独立的、不可预知的速度向前推进。 结构特征。为了描述和记录进程的运动变化过程，并使之能正确运行，应为每个进程配置一个进程控制块(Process Control Block, PCB)。 这样从结构上看，每个进程都由程序段、数据段和一个进程控制块组成。 进程和程序的关系，进程和程序是两个密切相关但又有所不同的概念,它们在以下几个方面存在区别和联系： 进程是动态的，程序是静止的。进程是程序的执行，每个进程包含了程序段和数据段以及进程控制块(PCB)，而程序是有序代码的集合，无执行含义。 进程是暂时的，程序是永久的。进程是一个状态变化的过程，程序可以长久保存。 进程与程序的组成不同。进程的组成包括程序段、数据段和进程控制块。 通过多次执行， 一个程序可以产生多个不同的进程;通过调用关系，一个进程可以执行多个程序。进程可创建其他进程，而程序不能形成新的程序。 进程具有并行特性(独立性、异步性)，程序则没有。 什么是进程映像?进程映像与进程的关系是什么? 由程序段、相关数据段和PCB三部分构成了进程映像，也叫进程实体。进程映像是静态的，进程是动态的，进程是进程实体的运行过程。 进程和作业的区别： 作业是用户需要计算机完成某项任务而要求计算机所做工作的集合。一个作业的完成要经过作业提交、作业收容、作业执行和作业完成4个阶段。而进程是已提交完毕的作业的执行过程，是资源分配的基本单位。两者的主要区别如下: 作业是用户向计算机提交任务的任务实体。在用户向计算机提交作业之后，系统将它放入外存中的作业等待队列中等待执行;而进程则是完成用户任务的执行实体，是向系统申请分配资源的基本单位。任一进程，只要它被创建，总有相应的部分存在于内存中。 一个作业可 由多个进程组成，且必须至少由一个进程组成，但一个进程不能构成多个作业。 作业的概念主要用在批处理系统中。像UNIX这样的分时系统则没有作业的概念;而进程的概念则用在几乎所有的多道程序系统中。 进程的组成 进程控制块(PCB)。每个进程均有一个PCB,它是一个既能标识进程的存在、又能刻画执行瞬间特征的数据机构。当进程被创建时，系统为它申请和构造一个相应的PCB。 程序段。 程序段是进程中能被进程调度程序调度到CPU.上执行的程序代码段，能实现相应的特定功能。 数据段。 一个进程的数据段可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或结果数据。系统根据PCB感知进程的存在。PCB是进程存在的唯一标志。一般来说，根据操作系统的要求不同，PCB所包含的内容多少会有些不同，但通常都包括下面所列出的内容。 进程标识符 (PID)。 每个进程都有唯一的进程标识符，以区别于系统内部的其他进程。在创建进程时，由系统为进程分配唯一的进程标识号。 在Windows 7系统下，打开任务管理器，依次单击“查看”→“选择列”，勾选“PID (进程标识符)”，即可在任务管理器中查看到进程PID信息，通常是纯数字。这里看到的PID是内部标识符，为了区别于外部标识符。 进程当前状态。说明进程的当前状态，以作为进程调度程序分配处理器的依据。 进程队列指针。用于记录PCB队列中下一个PCB的地址。系统中的PCB可能组织成多个队列，如就绪队列、阻塞队列等。 程序和数据地址。指出进程的程序和数据所在的地址。 进程优先级。反映进程要求CPU的紧迫程度。优先级高的进程可以优先获得处理器。 CPU现场保护区。当进程因某种原因释放处理器时，CPU现场信息(如指令计数器、状态寄存器、通用寄存器等)被保存在PCB的该区域中，以便该进程重新获得处理器后能继续执行。 通信信息。 记录进程在执行过程中与别的进程所发生的信息交换情况。 家族联系。有的系统允许进程创建子进程，从而形成一个进程家族树。 在PCB中，本进程与家族的关系是必须指明的，如它的子进程与父进程的标识。 占有资源清单。进程所需资源及当前已分配资源清单。 在一个系统中，通常存在着很多进程，有的处于就绪状态，有的处于阻塞状态，而且阻塞的原因各不相同。为了方便进程的调度和管理，需要将各进程的PCB用适当的方法组织起来。目前常用的组织方式有链接方式和索引方式。 为什么说PCB是进程存在的唯一标志? 首先来看PCB的作用: PCB是系统为每个进程定义的一个数据结构，其作用是使程序(含数据)能独立运行;PCB使一个在多道程序环境下不能独立运行的程序(含数据)成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程，因此PCB是为了保证程序的并发执行。创建进程,实质上是创建进程的PCB;而撤销进程，实质上是撤销进程的PCB。 其次来解释为什么PCB是进程存在的唯一标志。 在系统调度到某进程后，要根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存地址，找到其程序和数据:进程在执行过程中，当需要和与之合作的进程实现同步、通信或访问文件时，也都需要访问PCB; 当进程由于某种原因而暂停执行时，又需将其断点的处理机环境保存在PCB中。可见，在进程的整个生命期中，系统总是通过PCB对进程进行控制的，亦即系统是根据进程的PCB感知该进程的存在的，所以，PCB是进程存在的唯一标志。 ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:1:1","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"进程的状态与转换 进程的5种基本状态 在进程的运行过程中，由于系统中多个进程的并发运行及相互制约的结果，使得进程的状态不断发生变化。通常，一个运行中的进程至少可划分为5种基本状态。 就绪状态。进程已获得了除处理器以外的所有资源，一旦获得处理器，就可以立即执行，此时进程所处的状态为就绪状态。 执行状态(运行状态)。当一个进程获得必要的资源并正在CPU上执行时，该进程所处的状态为执行状态。 阻塞状态(等待状态)。正在执行的进程，由于发生某事件而暂时无法执行下去(如等待I/O完成)，此时进程所处的状态为阻塞状态。当进程处于阻塞状态时，即使把处理器分配给该进程，它也无法运行。 创建状态。进程正在被创建，尚未转到就绪状态。申请空白的PCB,并向PCB中填写一些控制和管理进程的信息;然后由系统为该进程分配运行时所需的资源;最后把该进程转入就绪状态。 结束状态。进程正在从系统中消失，可能是正常结束或其他原因中断退出运行。 进程状态的相互转换： 状态转化的典型原因： 就绪状态→执行状态。一个进程被进程调度程序选中。 执行状态→阻塞状态。请求并等待某个事件发生。 执行状态→就绪状态。时间片用完或在抢占式调度中有更高优先级的进程变为就绪状态。 阻塞状态→就绪状态。进程因为等待的某个条件发生而被唤醒。 从上述的状态转换的原因可以得出以下结论: 进程状态的转换并非都是可逆的，进程既不能从阻塞状态变为执行状态，也不能从就绪状态变为阻塞状态。 进程之间的状态转换并非都是主动的，在很多情况下都是被动的，只有从执行状态到阻塞状态是程序的自我行为( 因事件而主动调用阻塞原语)，其他都是被动的。例如，从执行状态到就绪状态，通常是由时钟中断引起的(时间片用完);从阻塞状态到就绪状态，是上一个使用处理器的进程把一个阻塞进程唤醒的。 进程状态的唯一性。一个具体的进程在任何一个指定的时刻必须且只能处于一种状态。 ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:1:2","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"进程控制 进程控制的职责是对系统中的所有进程实施有效的管理，其功能包括进程的创建、进程的撤销、进程阻塞与唤醒等。这些功能一般是由操作系统的内核来实现的。 进程创建原语 在多道程序环境中，只有进程才可以在系统中运行。为了使一个程序能运行，必须为它创建进程。导致进程创建的事件有用户登录、作业调度和请求服务。 用户登录。 在分时系统中，用户在终端输入登录信息，系统检测并通过之后就会为该终端用户建立新进程并插入到就绪队列。 作业调度。 在批处理系统中，当作业调度程序按一定的算法调度到某个作业时，便将该作业装入内存，为其分配资源并创建进程，并插入到就绪队列。 请求服务。 基于进程的需要，由其自身创建一个新进程并完成特定任务。 进程创建是通过创建原语实现的。其主要操作过程如下。 先向系统申请一个空闲PCB，并指定唯一的进程标识符(PID)。 为新进程分配必要的资源。 将新进程的PCB初始化。为新进程的PCB填入进程名、家族信息、程序数据地址、优先级等信息。 将新进程的PCB插入到就绪队列。 进程的撤销 一个进程在完成其任务后应予以撤销，以便及时释放它所占用的各类资源。撤销原语可采用两种策略:一种是只撤销一个具有指定标识符的进程;另一种是撤销指定进程及其所有子孙进程。导致进程撤销的事件有进程正常结束、进程异常结束及外界干预等。 撤销原语的功能是撤销一个进程， 其主要操作过程如下: 先从PCB集合中找到被撤销进程的PCB。 若被撤销进程正处于执行状态，则应立即停止该进程的执行，设置重新调度标志，以便进程撤销后将处理器分配给其他进程。 对后一种撤销策略，若被撤销进程有子孙进程，还应将该进程的子孙进程予以撤销。 回收被撤销进程所占有的资源，或者归还给父进程，或者归还给系统。最后，回收它的PCB。 进程的阻塞与唤醒 阻塞原语(P原语)的功能是将进程由执行状态转为阻塞状态，而唤醒原语(V原语)的功能则是将进程由阻塞状态变为就绪状态。当一个进程期待的某一事件尚未出现时，该进程调用阻塞原语将自己阻塞起来。★注:注意此处是由该进程自身调用原语阻塞自己的，是一种主动行为。 阻塞原语的主要操作过程如下: 首先停止当前进程的运行。因该进程正处于执行状态，故应中断处理器。 保存该进程的CPU现场以便之后可以重新调用该进程并从中断点开始执行。 停止运行该进程， 将进程状态由执行状态改为阻塞状态，然后将该进程插入到相应事件的等待队列中。 转到进程调度程序，从就绪队列中选择个新的进程投入运行。 对处于阻塞状态的进程，当该进程期待的事件出现时，由发现者进程调用唤醒原语将阻塞的进程唤醒，使其进入就绪状态。 注:此处是由发现者进程调用唤醒原语而不是被阻塞进程本身调用，因此唤醒对于阻塞进程是一种被动行为。 唤醒原语的主要操作过程如下: 将被唤醒进程从相应的等待队列中移出。 将状态改为就绪 并插入相应的就绪队列。 应当注意的是:一个进程由执行状态变为阻塞状态，是由这个进程自已调用阻塞原语去完成的:而进程由阻塞状态转变为就绪状态，则是由另一个发现者进程调用唤醒原语实现的，一般这个发现者进程与被唤醒进程是合作的并发进程。 进程切换 进程切换是指处理器从一个进程的运行转到另一个进程的运行，这个过程中，进程的运行环境产生了实质性的变化。 进程切换的过程如下: 保存处理器上下文，包括程序计数器和其他寄存器。 更新PCB信息。 把进程的PCB移入相应队列，如就绪、某事件的阻塞队列等。 选择另一个进程执行， 更新其PCB. 更新内存管理的数据结构。 恢复处理器上下文。 ★注:注意此处与调度的区别，调度是决定将系统资源分配给哪个进程，进程切换是实际分配系统资源。另外需要注意进程切换一定会产生中断，进行处理器模式切换，即从用户态进入内核态，之后又回到用户态;但处理器模式切换不一定产生进程切换，如系统调用同样会从用户态进入内核态，之后回到用户态，但在逻辑上，仍然是同一进程占用处理器执行。 ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:1:3","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"线程概念与多线程模型 线程是近年来操作系统领域出现的一种非常重要的技术，其重要程度丝毫不亚于进程。线程的引入提高了程序并发执行的程度，从而进一步提高了系统吞吐量。 线程的概念 线程的引入 如果说在操作系统中引入进程的目的是使多个程序并发执行，以改善资源利用率及提高系统吞吐量，那么，在操作系统中再引入线程，则是为了减少程序并发执行时所付出的时空开销，使操作系统具有更好的并发性。为了说明这一点， 下面来回顾一下进程的两个基本属性。 进程是一个拥有资源的独立单元。 进程同时又是一个可以被处理器独立调度和分配的单元。 上述两个属性构成了程序并发执行的基础。然而，为了使进程能并发执行，操作系统还必须进行一系列的操作，如创建进程、撤销进程和进程切换。在进行这些操作时，操作系统要为进程分配资源及回收资源，为运行进程保存现场信息，这些工作都需要付出较多的时空开销。正因如此，在系统中不宜设置过多的进程，进程切换的频率也不宜太高，这就限制了系统并发程度的进一步提高。 为了使多个程序更好地并发执行，并尽量减少操作系统的开销，不少操作系统研究者考虑将进程的两个基本属性分离开来，分别交由不同的实体来实现。为此，操作系统设计者引入了线程，让线程去完成第二个基本属性的任务，而进程只完成第一个基本属性的任务。 线程的定义 线程的定义与进程类似，存在多种不同的提法。这些提法可以相互补充对线程的理解。 线程是进程内的一个执行单元，比进程更小。 线程是进程内 的一个可调度实体。 线程是程序 (或进程)中相对独立的一个控制流序列。 线程本身不能单独运行，只能包含在进程中，只能在进程中执行。 综上所述，不妨将线程定义为:线程是进程内一个相对独立的、可调度的执行单元。线程自己基本.上不拥有资源，只拥有一点在运行时必不可少的资源(如程序计数器、一组 寄存器和栈)，但它可以与同属一个进程的其他线程共享进程拥有的全部资源。多线程是指一个进程中有多个线程，这些线程共享该进程资源。这些线程驻留在相同的地址空间中，共享数据和文件。如果一个线程修改了一个数据项，其他线程可以了解和使用此结果数据。一个线程打开并读一个文件时， 同一进程中的其他线程也可以同时读此文件。 线程的实现 在操作系统中有多种方式可实现对线程的支持。最自然的方法是由操作系统内核提供线程的控制机制。在只有进程概念的操作系统中，可由用户程序利用函数库提供线程的控制机制。还有一种做法是同时在操作系统内核和用户程序两个层次上提供线程控制机制。 内核级线程是指依赖于内核，由操作系统内核完成创建和撤销工作的线程。在支持内核级线程的操作系统中，内核维护进程和线程的上下文信息并完成线程切换工作。一个内核级线程由于IO操作而阻塞时，不会影响其他线程的运行。这时，处理器时间片分配的对象是线程，所以有多个线程的进程将获得更多处理器时间。 用户级线程是指不依赖于操作系统核心，由应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制的线程。由于用户级线程的维护电应用进程完成，不需要操作系统内核了解用户级线程的存在，因此可用于不支持内核级线程的多进程操作系统，甚至是单用户操作系统。用户级线程切换不需要内核特权，用户级线程调度算法可针对应用优化。许多应用软件都有自己的用户级线程。由于用户级线程的调度在应用进程内部进行，通常采用非抢占式和更简单的规则，也无须用户态/核心态切换，因此速度特别快。当然，由于操作系统内核不了解用户线程的存在，当一个线程阻塞时，整个进程都必须等待。这时处理器时间片是分配给进程的，当进程内有多个线程时，每个线程的执行时间相对减少。 有些操作系统提供了，上述两种方法的组合实现。在这种系统中，内核支持多线程的建立、调度与管理;同时，系统中又提供使用线程库的便利，允许用户应用程序建立、调度和管理用户级的线程。由于同时提供内核线程控制机制和用户线程库，因此可以很好地将内核级线程和用户级线程的优点结合起来。 线程与进程的比较 由于进程与线程密切相关，因此有必要对进程与线程的异同进行比较。 调度。在传统的操作系统中， 拥有资源和独立调度的基本单位都是进程。而在引入线程的操作系统中，线程是独立调度的基本单位，进程是拥有资源的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换，如从一个进程内的线程切换到另一个进程的线程中，将会引起进程切换。 拥有资源。 不论是传统操作系统还是设有线程的操作系统，进程都是拥有资源的基本单位，而线程不拥有系统资源( 也有一点必不可少的资源，并非什么资源都没有)，但线程可以访问其隶属进程的系统资源。 并发性。 在引入线程的操作系统中，不仅进程之间可以并发执行，而且同一进程内的多个线程之间也可以并发执行。这使得操作系统具有更好的并发性，大大提高了系统的吞吐量。 系统开销。由于创建进程或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，操作系统所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及整个当前进程CPU环境的保存及新调度到进程的CPU环境的设置;而线程切换时，只需保存和设置少量寄存器内容，因此开销很小。另外，由于同一进程内的多个线程共享进程的地址空间，因此，多线程之间的同步与通信非常容易实现，甚至无须操作系统的干预。 多线程模型 有些系统同时支持用户级线程和内核级线程，因此根据用户级线程和内核级线程连接方式的不同产生了3种不同的多线程模型。 多对一模型。多对一模型将多个用户级线程映射到一个内核级线程上。在采用该模型的系统中，线程在用户空间进行管理，效率相对较高。但是，由于多个用户级线程映射到一个内核级线程，只要一个用户级线程阻塞，就会导致整个进程阻塞。而且由于系统只能识别一个线程(内核级线程)，因此即使有多处理器，该进程的若千个用户级线程也只能同时运行一个，不能并行执行。 一对一模型。一对一模型将内核级线程与用户级线程一对应。这样做的好处是当一个线程阻塞时，不影响其他线程的运行，因此一对一模型的并发性比多对一模型要好。而且这样做之后，在多处理器上可以实现多线程并行。这种模型的缺点是创建一个用户级线程时需要创建一个相应的内核级线程。 多对多模型。 多对多模型将多个用户级线程映射到多个内核级线程( 内核级线程数不多于用户级线程数，内核级线程数根据具体情况确定)。采用这样的模型可以打破前两种模型对用户级线程的限制，不仅可以使多个用户级线程真正意义上并行执行，而且不会限制用户级线程的数量。用户可以自由创建所需的用户级线程，多个内核级线程根据需要调用用户级线程，当一个用户级线程阻塞时，可以调度执行其他线程。 ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:1:4","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"进程通信:共享存储系统、消息传递系统、管道通信. 进程通信是指进程之间的信息交换。进程的互斥与同步就是一种进程间的通信方式。由于进程互斥与同步交换的信息量较少且效率较低，因此称这两种进程通信方式为低级进程通信方式。相应地，也可以将P、V原语称为两条低级进程通信原语。目前，高级进程通信方式可以分为3大类:共享存储器系统、消息传递系统和管道通信系统。 共享存储器系统 为了传输大量数据，在存储器中划出一块共享存储区，多个进程可以通过对共享存储区进行读写来实现通信。在通信前，进程向系统申请建立一个共享存储区，并指定该共享存储区的关键字。若该共享存储区已经建立，则将该共享存储区的描述符返回给申请者。然后，申请者把获得的共享存储区附接到进程上。这样，进程便可以像读写普通存储器一样读写共享存储区了。 消息传递系统 在消息传递系统中，进程间以消息为单位交换数据，用户直接利用系统提供的一组通信命令(原语)来实现通信。操作系统隐藏了通信的实现细节，简化了通信程序，得到了广泛应用。根据实现方式不同，消息传递系统可以分为以下两类。 直接通信方式。发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。 间接通信方式。发送进程把消息发送到某个中间实体(通常称为信箱)中，接收进程从中取得消息。这种通信方式又称为信箱通信方式。该通信方式广泛应用于计算机网络中，与之相应的通信系统称为电子邮件系统。 管道通信系统 管道是用于连接读进程和写进程以实现它们之间通信的共享文件。向管道提供输入的发送进程(即写进程)以字符流形式将大量的数据送入管道，而接收管道输出的进程(即读进程)可以从管道中接收数据。 注:管道是一个共享文件，不能单纯地从字面上仅将管道理解为一个传输通道。 ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:1:5","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"处理器调度 调度是操作系统的一个基本功能，几乎所有资源在使用前都需要调度。由于CPU是计算机的首要资源，因此调度设计均围绕如何能够高效利用CPU展开。在多道程序环境下，一个作业从提交到执行，通常都要经历多级调度，如高级调度、中级调度和低级调度。而系统的运行性能在很大程度上都取决于调度，因此调度便成为多道程序的关键。在不同操作系统中，所采用的调度层次不完全相同。在一些系统中仅采用一级调度，而在另一些系统中则可能采用两级或三级调度，在执行调度时所采用的调度算法也可能不同。图2-5给出了调度层次的示意图，由此可以看出，一个作业从提交开始直到完成，往往要经历三级调度。 ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:2:0","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"处理器的三层调度 高级调度(作业调度)： 高级调度又称为宏观调度、作业调度或者长程调度,其主要任务是按照一定的原则从外存上处于后备状态的作业中选择一个或者多 个，给它们分配内存、输入/输出设备等必要资源，并建立相应的进程，以使该作业具有获得竞争处理器的权利(作业是用户在一次运算过程或一次事务处理中要求计算机所做工作的总和)。作业调度的运行频率较低，通常为几分钟一次。在批处理系统或通用操作系统中的批处理部分，新提交的作业先存放在磁盘上,因此需要通过作业调度将它们分批装入内存。而在其他类型的操作系统中，通常不需要配置作业调度。 每次执行作业调度时，我们都需要解决两个问题:第一，调度程序必须决定操作系统可以接纳多少个作业;第二，调度程序必须决定接纳哪些作业。下面简单分析一下这两个问题。作业调度每次要接纳多少个作业进入内存取决于多道程序的并发程度，即允许有多少个作业同时在内存中运行。当内存中可以同时运行的作业太多时，可能会影响到系统的服务质量，如导致周转时间太长。而当内存中同时运行的作业太少时，又会导致系统资源利用率和吞吐量下降。因此，多道程序的并发程度应根据系统的规模和运行速度来确定。应将哪些作业从外存调入内存取决于所采取的调度算法。最简单的调度算法是先来先服务调度算法，它将最早进入外存的作业最先调入内存;较常用的一种调度算法是短作业优先调度算法，它将外存上执行时间最短的作业最先调入内存;此外还有其他调度算法。 中级调度 中级调度又称为中程调度或者交换调度，引入中级调度是为了提高内存利用率和系统吞吐量，其主要任务是按照给定的原则和策略，将处于外存对换区中的具备运行条件的进程调入内存，并将其状态修改为就绪状态，挂在就绪队列上等待;或者将处于内存中的暂时不能运行的进程交换到外存对换区，将此时的进程状态称为挂起状态。中级调度主要涉及内存管理与扩充(其实中级调度可以理解为在换页时将页面在外存与内存之间调度),因此会在存储管理部分对其进行介绍。 低级调度(进程调度) 低级调度又称为微观调度、进程调度或者短程调度，其主要任务是按照某种策略和方法从就绪队列中选取一个进程，将处理器分配给它。进程调度的运行频率很高，一般隔几十毫秒要运行一次。后面将对此进行详细讲解。 注:由于作业调度与进程调度有时候容易混淆，特总结高级调度(作业调度)与低级调度(进程调度)的区别如下: 作业调度为进程被调用做准备，进程调度使进程被调用。换言之，作业调度的结果是为作业创建进程，而进程调度的结果是进程被执行。 作业调度次数少，进程调度频率高。 有的系统可以不设置作业调度，但进程调度必须有。 ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:2:1","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"调度的基本准则 不同调度算法有不同的调度策略，这也决定了调度算法对不同类型的作业影响不同。在选择调度算法时，我们必须考虑不同算法的特性。为了衡量调度算法的性能，人们提出了一些评价标准。 CPU利用率 CPU是系统最重要、也是最昂贵的资源，其利用率是评价调度算法的重要指标。在批处理以及实时系统中，一般要求 CPU的利用率要达到比较高的水平，不过对于PC和某些不强调利用率的系统来说，CPU利用率并不是最主要的。 系统吞吐量 系统吞吐量表示单位时间内CPU完成作业的数量。对长作业来说，由于它要占用较长的CPU处理时间，因此会导致系统吞吐量下降;而对短作业来说，则相反。 响应时间 相对于系统吞吐量和CPU利用率来说，响应时间是比较面向用户的。在交互系统中，尤其在多用户系统中，多个用户同时对系统进行操作，都要求在一定时间内得到响应，不能使某些用户的进程长期得不到调用。因此，从用户角度看，调度策略要保证尽量短的响应时间，使响应时间在用户的接受范围内。 周转时间 从每个作业的角度来看，完成该作业的时间是至关重要的，通常用周转时间或者带权周转时间来衡量。 周转时间 周转时间是指作业从提交至完成的时间间隔，包括等待时间和执行时间。周转时间T;用公式表示为作业i的周转时间T=作业i的完成时间-作业i的提交时间 平均周转时间 平均周转时间是指多个作业(例如n个作业)周转时间的平均值。平均周转时间T用公式表示为T= (T+T2+…+Tn) /n 带权周转时间 带权周转时间是指作业周转时间与运行时间的比。作业i的带权周转时间w;用公式表示为W:=作业i的周转时间/作业i的运行时间 平均带权周转时间 与平均周转时间类似，平均带权周转时间是多个作业的带权周转时间的平均值。公式略。 ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:2:2","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"进程调度 在多道程序系统中，用户进程数往往多于处理器数，这将导致用户进程争夺处理器。此外，系统进程同样需要使用处理器。因此，系统需要按照一定的策略动态地把处理器分配给就绪队列中的某个进程，以便使之执行。处理器分配的任务由进程调度程序完成。 进程调度的功能 记录系统中所有进程的有关情况以及状态特征。为了实现进程调度，进程管理模块必须将系统中各进程的执行情况和状态特征记录在各个进程的PCB中，同时还应根据各个进程的状态特征和资源需求等信息将进程的PCB组织成相应的队列，并依据运行情况将进程的PCB在不同状态队列之间转换。进程调度模块通过PCB的变化来掌握系统中所有进程的执行情况和状态特征。 选择获得处理器的进程。按照一定的策略选择一个处于就绪状态的进程，使其获得处理器执行。根据不同的系统设计目标，有各种各样的选择策略。例如，先来先服务调度算法、时间片轮转调度算法等。这些选择策略决定了调度算法的性能。 处理器分配。当正在运行的进程由于某种原因要放弃处理器时，进程调度程序应保护当前运行进程的CPU现场，将其状态由运行变成就绪或阻塞，并插入到相应队列中去;同时恢复程序还应根据一定原则从就绪队列中挑选出一个进程， 把该进程从就绪队列中移出，恢复其CPU现场，并将其状态改为运行。 引起进程调度的原因 当前运行进程运行结束。因任务完成而正常结束，或者因出现错误而异常结束。 当前运行进程因某种原因，比如I/O请求、P操作、阻塞原语等，从运行状态进入阻塞状态。 执行完系统调用等系统程序后返回用户进程，这时可以看作系统进程执行完毕，从而可以调度一个新的用户进程。 在采用抢占调度方式的系统中，一个具有更高优先级的进程要求使用处理器，则使当前运行进程进入就绪队列(这与调度方式有关)。 在分时系统中，分配给该进程的时间片已用完(这与系统类型有关)。 不能进行进程调度的情况 处理中断的过程中。中断处理过程复杂，在实现上很难做到进程切换，而且中断处理是系统工作的一部分，逻辑上不属于某一进程， 不应被剥夺处理器资源。 在操作系统内核程序临界区中。进程进入临界区后，需要独占式地访问共享数据,理论上必须加锁，以防止其他并行程序进入，在解锁前不应切换到其他进程运行，以加快该共享数据的释放。 其他需要完全屏蔽中断的原子操作过程中。如加锁、解锁、中断现场保护、恢复等原子操作。原子操作不可再分，必须一次完成，不能进行进程切换。 进程调度的方式 进程调度方式是指当某一个进程 正在处理器上执行时，若有某个更为重要或紧迫的进程需要进行处理(即有优先级更高的进程进入就绪队列)，此时应如何分配处理器。通常有以下两种进程调度方式: 抢占方式。 又称为可剥夺方式。这种调度方式是指当一个进程正在处理器上执行时，若有某个优先级更高的进程进入就绪队列，则立即暂停正在执行的进程，将处理器分配给新进程。 非抢占方式。 又称为不可剥夺方式。这种方式是指当某一个进程正在处理器上执行时，即使有某个优先级更高的进程进入就绪队列，仍然让正在执行的进程继续执行，直到该进程完成或因发生某种事件而进入完成或阻塞状态时，才把处理器分配给新进程。 ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:2:3","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"典型调度算法： 进程调度的核心问题是采用什么样的算法将处理器分配给进程。下面介绍几种常用的进程调度算法。标题括号中的内容表示该调度算法的适用范围。 先来先服务调度算法(作业调度、进程调度) 先来先服务调度算法(FCFS)是一种最简单的调度算法，可以用于作业调度与进程调度。其基本思想是按照进程进入就绪队列的先后次序来分配处理器。先来先服务调度算法采用非抢占的调度方式，即一旦一个进程(或作业)占有处理器，它就一直运行下去，直到该进程(或作业)完成其工作或因等待某一事件而不能继续执行时才释放处理器。 从表面上看，先来先服务调度算法对于所有进程(或作业)是公平的，即按照它们到来的先后次序进行服务。但假设有等数量的长进程(10t) 和短进程(t), 因为数量相等，所以谁先到的概率也相等。当长进程先来时，短进程的等待时间为10t,而当短进程先来时，长进程的等待时间仅为t。所以说先来先服务调度算法有利于长进程(作业),不利于短进程(作业)。 现在，先来先服务调度算法已经很少作为主要的调度策略，尤其是不能作为分时系统和实时系统的主要调度策略，但它常被结合在其他调度策略中使用。例如，在使用优先级作为调度策略的系统中，往往对多个具有相同优先级的进程或作业按照先来先服务原则进行处理。 短作业优先调度算法(作业调度、进程调度) 短作业优先(SJF)调度算法用于进程调度时被称为短进程优先调度算法，该算法既可以用于作业调度，也可以用于进程调度。 短作业(或进程)优先调度算法的基本思想就是把处理器分配给最快完成的作业(或进程)。 在作业调度中，短作业优先调度算法每次从后备作业队列中选择估计运行时间最短的一个或几个作业调入内存，分配资源，创建进程并放入就绪队列。 在进程调度中，短进程优先调度算法每次从就绪队列中选择估计运行时间最短的进程，将处理器分配给它，使该进程运行并直到完成或因某种原因阻塞才释放处理器。 可以证明，在所有作业同时到达时，SJF 调度算法是最佳算法，平均周转时间最短(如果短进程先执行，长进程等待时间较长进程先执行的情况要短很多，因此平均等待时间最短,而进程运行时间是确定不变的)。但该算法很显然对长作业不利，当有很多短作业不断进入就绪队列时，长作业会因长期得不到调度而产生“饥饿\"现象(“饥饿”现象是指在一段时间内，进程得不到调度执行或得不到所需资源)。 优先级调度算法(作业调度、进程调度) 优先级调度算法是一种常用的进程调度算法，既可用于作业调度，也可用于进程调度。其基本思想是把处理器分配给优先级最高的进程。 该算法的核心问题是如何确定进程的优先级。 进程的优先级用于表示进程的重要性，即运行的优先性。进程优先级通常分为两种: 静态优先级和动态优先级。 静态优先级是在创建进程时确定的，确定之后在整个进程运行期间不再改变。确定静态优先级的依据有以下几种: 按进程类确定。 通常，系统中有两类进程，即系统进程和用户进程。系统中各进程的运行速度以及系统资源的利用率在很大程度上依赖于系统进程。例如，若系统中某种共享输入输出设备由一个系统进程管理，那么使用这种设备的所有进程的运行速度都依赖于这一个系统进程。所以，系统进程的优先级应高于用户进程。在批处理与分时结合的系统中，为了保证分时用户的响应时间，前台作业的进程优先级应高于后台作业的进程。 按作业的资源要求确定。 根据作业要求系统提供的资源，比如处理器时间、内存大小、I0设备的类型及数量等来确定作业的优先级。由于作业的执行时间事先难以确定，因此只能根据用户提出的估计时间来确定。进程所申请的资源越多，估计的运行时间越长，进程的优先级越低。 按用户类型和要求确定。计算机系统的用户可按不同标准分类，但通常与用户类型和收费标准有关。用户的收费标准越高，则该用户作业对应进程的优先级也越高，例如租用服务器，租金越贵的服务器在该服务器提供商的所有服务器中的优先级越高。 动态优先级是指在创建进程时，根据进程的特点及相关情况确定一个优先级，在进程运行过程中再根据情况的变化调整优先级。确定动态优先级的依据有以下几种: 根据进程占有CPU时间的长短来决定。一个进程占用CPU的时间越长，则优先级越低，再次获得调度的可能性就越小;反之，一个进程占用CPU的时间越短，则优先级越高，再次获得调度的可能性就越大。 根据就绪进程等待CPU时间的长短来决定。一个就绪进程在就绪队列中等待的时间越长，则优先级越高，获得调度的可能性就越大:反之，一个就绪进程在就绪队列中等待的时间越短，则优先级越低，获得调度的可能性就越小。 基于优先级的调度算法还可以按调度方式的不同分为非抢占优先级调度算法和抢占优先级调度算法。 非抢占优先级调度算法的实现思想是系统一旦将处理器分配给就绪队列中优先级最高的进程，该进程便会一直运行下去， 直到由于其自身原因(任务完成或申请设备等)主动让出处理器时，才将处理器分配给另一个当前优先级最高的进程。 抢占优先级调度算法的实现思想是将处理器分配给优先级最高的进程，并使之运行。在进程运行过程中，一旦出现了另个优先级更高的进程(如一个更高优先级进程因等待的事件发生而变为就绪状态)，进程调度程序就停止当前的进程，而将处理器分配给新出现的优先级更高的进程。 ★注;在优先级相同的情况下，通常按照先来先服务或者短作业优先的顺序执行。 时间片轮转调度算法(进程调度) 在分时系统中，进程调度通常采用时间片轮转调度算法。在时间片轮转调度算法中，系统将所有就緒进程按到达时间的先后次序排成一个队列，进程调度程序总是选择队列中的第一个进程执行，并规定执行一定时间， 称为时间片(例如100ms)。当该进程用完这一时间片时(即使进程并未执行结束)，系统将它送至就绪队列队尾，再把处理器分配给下一个就绪进程。这样，处于就绪队列中的进程就可以依次轮流获得一个时间片 的处理时间，然后重新回到队列尾部排队等待执行，如此不断循环，直至完成。 在时间片轮转调度算法中，时间片的大小对系统性能的影响很大。如果时间片设置得太大，所有进程都能在一个时间片内执行完毕，那么时间片轮转调度算法就退化为先来先服务调度算法:如果时间片设置得太小，那么处理器将在进程之间频繁切换，处理器真正用于运行用户进程的时间将减少。因此，时间片的大小应设置适当。 时间片的大小通常由以下因素确定: 系统的响应时间。分时系统必须满足系统对响应时间的要求，系统响应时间与时间片的关系可以表示为：T=Nxq，其中，T为系统的响应时间，q为时间片的大小，N为就绪队列中的进程数。根据这个关系可以得知，若系统中的进程数一定，时间片的大小与系统响应时间成正比。 就绪队列中的进程数目。在响应时间固定的情况下，就绪队列中的进程数与时间片的大小成反比。 系统的处理能力。通常要求用户键入的常用命令能够在一个时间片内处理完毕。因此，计算机的速度越快，单位时间内可处理的命令就越多，时间片就可以越小。 高响应比优先调度算法(作业调度) 高响应比优先调度算法综合了先来先服务与短作业优先两种调度算法的特点，即考虑了作业的等待时间和作业的运行时间两个因素，弥补了之前两种调度算法只考虑其中一个因素的不足。 高响应比优先调度算法主要用于作业调度。其基本思想是每次进行作业调度时，先计算就绪队列中的每个作业的响应比，挑选响应比最高的作业投入运行。响应比的计算公式为：响应比=作业响应时间/估计运行时间，即，响应比= (作业等待时间+估计运行时间) /估计运行时间 从公式可以看出，该算法有利于短作业(作业等待时间相同时，估计运行时间越短，响应比越高)，同时考虑长作业(只要作业等待时间足够长，响应比就会变为最高)。该算法对于短作业和长作业都有考虑，但由于要计算每个后备作业的响应比，因此增加了系统开销。 多级队列调度算法(进程调度) 多级队列调度算法的基本思想是根据进程的性质或类型，将就绪队列划分为若千个独立的队列，每个进程固定地分属于一个队列。每个队列采用一种调度算法，不同的队列可以采用不同的调度算法。例如，为交互型任务设置一个就绪队列，该队列采用时间片轮转调度算法;再如，为批处理任务另外设置一个就绪队列，该队列采用先来先服务调度算法。 多级反馈队列调度算法(进程调度) 多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合与发展。通过动态调整进程优先级和时间片的大小，多级反馈队列调度算法可兼顾多方面的系统目标。例如，为提高系统吞吐量和缩短平均周转时间而照顾短进程;为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程;同时，也不必事先估计进程的执行时间。 首先，应设置多个就绪队列，并为每个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列的优先级次之，其余队列的优先级逐次降低。 其次，每个队列中的进程执行时间片的大小也各不相同，进程所在队列的优先级越高，其相应的时间片就越短。通常，第(i+1)队列的时间片是第i队列时间片的两倍。 再次，当一个新进程进入系统时，应先将其放入第一个队列末尾，按先来先服务的原则排队等待调度。当轮到该进程执行时，如能在此时间片完成，便可准备撤离系统;如果该进程在一个时间片结束时尚未完成，调度程序便将该进程转入第二个队列的末尾，再同样按照先来先服务原则等待调度执行;如果该进程在第二个队列中运行一个时间片后仍未完成，再以同样方法转入第三个队列。如此下去，最后一个队列中使用时间片轮转调度算法。 最后，仅当第一个队列空闲时，调度程序才调度第二个队列中的进程运行;仅当第一个至第(i-1)个队列均为空时，才会调度第i个队列中的进程运行。当处理器正在为第i个队列中的某进程服务时，若又有新进程进入优先级较高的队列中，则此时新进程将抢占正在运行","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:2:4","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"同步与互斥 ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:3:0","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"进程同步的基本概念 接下来进入到本章的关键部分进程同步。 在学习进程同步之前，先介绍一些关键的概念。 两种形式的制约关系 间接相互制约关系(互斥) 若某一进程要求使用某种资源，而该资源正被另一进程使用，并且该资源不允许两个进程同时使用，那么该进程只好等待已占用资源的进程释放资源后再使用。这种制约关系的基本形式是“进程一资源一进程 ”。 这种制约关系源于多个同种进程需要互斥地共享某种系统资源(比如打印机),互斥是设置在同种进程之间以达到互斥地访问资源的目的(比如在生产者~消费者问题中，生产者与生产者之间需要互斥地访问缓冲池)。 直接相互制约关系(同步) 某一进程若收不到另一进程给它提供的必要信息就不能继续运行下去，这种情况表明了两个进程之间在某些点上要交换信息，相互交流运行情况。这种制约关系的基本形式是“进程-进程”。 这种制约主要源于进程间的合作，同步设置在不同进程之间以达到多种进程间的同步(比如在生产者.消费者问题中，生产者就可以生产产品并放入缓冲池，消费者从缓冲池取走产品进行消费，若生产者没有生产产品，则消费者无法进行消费)。 注:区分互斥与同步只需记住，只要是同类进程即为互斥关系，不同类进程即为同步关系，例如消费者与消费者就是互斥关系，消费者和生产者就是同步关系。 临界资源与临界区 进程在运行过程中，一般会与其他进程共享资源，而有些资源的使用具有排他性。把同时仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机、绘图机等。 为了保证临界资源的正确使用,我们可以把临界资源的访问过程分成4部分。这4部分都属于要访问临界资源的进程，是进程中的一部分代码。 进入区。为了进入临界区使用临界资源，在进入区要检查是否可以进入临界区;如果可以进入临界区，通常设置相应的正在访问临界区”标志，以阻止其他进程同时进入临界区。 临界区。进程中用于访问临界资源的代码，又称临界段。 退出区。临界区后用于将“正在访问临界区”标志清除的部分。 剩余区。进程中除上述3部分以外的其他部分。 临界资源和临界区是两个比较容易混淆的概念，有人可能会理解为临界区就是临界资源所在地址，这样理解显然是错误的。简单来说，临界资源是一种系统资源，需要不同进程互斥访问，而临界区则是每个进程中访问临界资源的一段代码，是属于对应进程的，临界区前后需要设置进入区和退出区以进行检查和恢复。临界区和临界资源是不同的，临界资源是必须互斥访问的资源，这种资源同时只能被一个进程所使用，但需要这种资源的进程不止一个，因此需要对使用临界资源的进程进行管理，这也就产生了临界区的概念。 这里还要弄清楚一个概念:每个进程的临界区代码可以不相同。临界区代码由于要访问临界资源，因此要在进入临界区之前(也就是执行临界区代码之前)进行检查，至于每个进程对临界资源进行怎样的操作，这和临界资源及互斥同步管理是无关的，比如，磁带机是明显的临界资源，有两个进程都要对其进行操作，A要写磁带前半部分，B要读磁带后半部分，这两个进程对磁带操作的部分就是这两个进程各自的临界区，不能同时执行，但内容是不相同的，不可认为临界资源相同，访问这些资源的代码也是相同的。 互斥的概念与要求 根据互斥的定义，当一个进程进入临界区使用临界资源时，另一个进程必须等待，直到占用该临界资源的进程退出临界区后，才允许新的进程访问该临界资源。为了禁止两个进程同时进入临界区，软件算法或同步机构都应遵循以下准则。 空闲让进。当没有进程处于临界区时，可以允许一个请求进入临界区的进程立即进入自己的临界区。 忙则等待。当已有进程进入其临界区时，其他试图进入临界区的进程必须等待。 有限等待。对要求访问临界资源的进程，应保证能在有限的时间内进入自己的临界区。让权等待。当一个进程因为某些原因不能进入自己的临界区时，应释放处理器给其他进程。 同步的概念与实现机制 一般来说，一个进程相对另一个进程的运行速度是不确定的。也就是说，进程之间是在异步环境下运行的。但是相互合作的进程需要在某些关键点上协调它们的工作。所谓进程同步，是指多个相互合作的进程在一些关键点上可能需要互相等待或互相交换信息，这种相互制约关系称为进程同步。也可以用信号量同步（后面详细介绍） ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:3:1","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"实现临界区互斥的基本方法：软件实现方法、硬件实现方法。 互斥既可以用软件方法实现，也可以用硬件方法实现。 软件方法 对临界区互斥访问技术的研究始于20世纪60年代，早期主要从软件方法上进行研究，下面介绍这些软件方法。它们有的是正确的，有的是不正确的。介绍这些方法是为了说明用软件方法解决互斥和同步问题的困难性和复杂性。 例如，有两个进程Po和PI，互斥地共享某个资源。Po和PI是循环进程，它们执行一个无限循环程序,每次使用资源一个有限的时间间隔。 算法1:设置一个公用整型变量turn,用来表示允许进入临界区的进程标识。若turm为0,则允许进程Po进入临界区;否则循环检查该变量，直到turm变为本进程标识;在退出区，修改允许进入进程的标识turn为1。进程PI的算法与此类似。两个进程的程序结构如下: int turn=0; P0:{ Do{ while(turn!=0); //turn不为0时循环检查，直到为0（进入区） 进程P0的临界区代码CS0; //临界区 turn=1; //退出区 进程P0的其他代码； } while(true) //循环执行这段代码 } P1:{ Do{ while(turn!=1); //进入区 进程P1的临界区代码CS1; //临界区 turn=0; //退出区 进程P1的其他代码； } while(true) } 此方法可以保证互斥访问临界资源，但存在的问题是强制两个进程以交替次序进入临界区，很容易造成资源利用不充分。例如，当进程Po退出临界区后将turn置为1,以便允许进程P1进入临界区，但如果进程P1暂时并未要求访问该临界资源，而Po又想再次访问临界资源，则它将无法进入临界区。可见，此算法不能保证实现“空闲让进”准则。 算法2:设置标志数组flag[]表示进程是否在临界区中执行，初值均为假。在每个进程访问该临界资源之前，先检查另一个进程是否在临界区中，若不在，则修改本进程的临界区标志为真并进入临界区，在退出区修改本进程临界区标志为假。两进程的程序结构如下: enum boolean{false,true}; //设置数据元素类型 boolean flag[2]={false,false}; //设置标志数组 P0:{ Do{ while flag[1]; //flag[1]为真表示P!在访问临界区，P0等待（进入区） flag[0]=true; //进入区 进程P0的临界区代码CS0; //临界区 flag[0]=false; //退出区 进程P0的其他代码； } while(true) } P1:{ Do{ while flag[0]; //flag[0]为真表示P0在访问临界区，P1等待（进入区） flag[1]=true; //进入区 进程P1的临界区代码CS1; //临界区 flag[1]=false; //退出区 进程P1的其他代码； } while(true) } 此算法解决了“空闲让进”的问题，但又出现了新问题，即当两个进程都未进入临界区时，它们各自的访问标志都为false,若此时刚好两个进程同时都想进入临界区，并且都发现对方的标志值为false (当两进程交替执行了检查语句后，都满足flag[]=false 的条件)，于是两个进程同时进入了各自的临界区，这就违背了临界区的访问规则“忙则等待”。 算法3:本算法仍然设置标志数组flag[],但标志用来表示进程是否希望进入临界区，每个进程在访问临界资源之前，先将自己的标志设置为真，表示希望进入临界区，然后检查另一个进程的标志。若另一个进程的标志为真，则进程等待;反之，则进入临界区。 此算法可以有效防止两进程同时进入临界区，但存在两个进程都进不了临界区的问题，即当两个进程同时想进入临界区时，它们分别将自己的标志位设置为true, 并且同时去检查对方的状态，发现对方也要进入临界区，于是都阻塞自己，结果导致两者都无法进入临界区，造成“死等”现象，这就违背了“有限等待”的准则。 算法4:本算法的思想是算法3和算法1的结合。标志数组flag[]表示进程是否希望进入临界区或是否在临界区中执行。此外，还设置了一个turn变量，用于表示允许进入临界区的进程标识。 至此，算法4可以完全正常工作，利用flag[]解决临界资源的互斥访问，而利用turm 解决“饥饿”现象。 注:.上述内容中，前3个算法分别违背了4个准则中的“空闲让进”“忙则等待”和“有限等待”准则，对于让权等待则没有具体涉及。下面简单介绍一种违背“让权等待”准则的情况一“忙等”。 所谓“忙等”，是指“不让权”的等待，也就是说，进程因为某事件的发生而无法继续执行时，仍然不释放处理器，并通过不断执行循环检测指令来等待该事件的完成以便能够继续执行。“忙等”的主要缺点是浪费CPU的时间，另外还可能引起预料不到的后果，例如，某个采取高优先权调度且不剥夺的系统，目 前两个进程共享某个临界资源，进程A的优先级高，进程B的优先级低，此时B正在访问临界资源(即处于临界区内),而A也要进入自己的临界区，由于A的优先级较高，B所等待的事件可能会因A的存在而迟迟得不到处理，而B又一直占用处理器，因此两进程都无法向前推进，导致“忙等”。从上面的软件实现方法可以看出，对于两个进程间的互斥，最主要的问题就是标志的检查和修改不能作为一个整体来执行，因此容易导致无法保证互斥访问的问题。 硬件方法 完全利用软件方法实现进程互斥有很大的局限性，现在已经很少单独采用软件方法。硬件方法的主要思想是用一条指令完成标志的检查和修改这两个操作，因而保证了检查操作与修改操作不被打断;或通过中断屏蔽的方式来保证检查和修改作为一个整体执行。 硬件方法主要有两种: 一种是中断屏蔽;另一种是硬件指令。在计算机组成原理中会详细讲解中断与指令，操作系统中涉及较少，因此不展开叙述。 与前面的软件实现方法相比，由于硬件方法采用处理器指令能够很好地把检查和修改操作结合成一个不可分割的整体，因此具有明显的优点。具体而言，硬件方法的优点体现在以下几个方面: 适用范围广。硬件方法适用于任何数目的进程，在单处理器和多处理器环境中完全相同。 简单。硬件方法的标志设置简单，含义明确，容易验证其正确性。 支持多个临界区。当一个进程内有多个临界区时，只需为每个临界区设立一个布尔变量。 硬件方法有诸多优点，但也有一些自身无法克服的缺点。这些缺点主要包括进程在等待进入临界区时要耗费处理器时间，不能实现“让权等待”(需要软件配合进行判断);进入临界区的进程的选择算法用硬件实现有一些缺陷，可能会使一些进程一直选不上，从而导致“饥饿”现象。 ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:3:2","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"信号量 虽然前面讲解的软件及硬件方法都可以解决互斥问题，但它们都存在缺点。软件方法的算法太复杂，效率不高、不直观，而且存在“忙等”现象(在进入区时会持续检测标志变量)。就硬件方法而言，对于用户进程，中断屏蔽方法不是一种合适的互斥机制;硬件指令方法有不能实现“让权等待”等缺点。 荷兰著名的计算机科学家Djkstra于1965年提出了一个同步机构，称为信号量，其基本思想是在多个相互合作的进程之间使用简单的信号来同步。 信号量及同步原语 信号量是一个确定的二元组(s, q),其中s是一个具有非负初值的整型变量, q是一个初始状态为空的队列。整型变量s表示系统中某类资源的数目，当其值大于0时，表示系统中当前可用资源的数目;当其值小于0时，其绝对值表示系统中因请求该类资源而被阻塞的进程数目。除信号量的初值外，信号量的值仅能由P操作(又称为wait操作)和V操作(又称为signal 操作)改变。操作系统利用它的状态对进程和资源进行管理。 一个信号量的建立必须经过说明，即应该准确说明s的意义和初值(★注:这个初值不是一个负值)。每个信号量都有相应的一个队列，在建立信号量时队列为空。 设s为一个信号量，P(s)执行时主要完成以下动作:先执行s=s-1;若s≥0，则该进程继续运行;若s\u003c0，则阻塞该进程，并将它插入该信号量的等待队列中。 V(s)执行时主要完成下述动作:先执行s=s+1;若s\u003e0，则该进程继续执行;若s≤0,则从该信号量等待队列中移出第一个 进程，使其变为就绪状态并插入就绪队列，然后再返回原进程继续执行。 注: P、V操作均为不可分割的原子操作，这保证了对信号量进行操作过程中不会被打断或阻塞。P操作相当于申请资源，V操作相当于释放资源。P操作和V操作在系统中一定是成对出现的，但未必在一个进程中，可以分布在不同进程中。 信号量的分类 整型信号量 整型信号量是一个整型量s，除初始化外，仅能通过标准的原子操作P和V来访问。整型信号量引入了P、V操作，但是在进行P操作时，若无可用资源，则进程持续对该信号量进行测试，存在“忙等”现象，未遵循“让权等待”准则。 记录型信号量(资源信号量) 为了解决整型信号量存在的“忙等”问题，添加了链表结构，用于链接所有等待该资源的进程，记录型信号量正是因采用了记录型的数据结构而得名。当进程对信号量进行P操作时，若此时无剩余资源可用，则进程自我阻塞，放弃处理器，并插入到等待链表中。可见，该机制遵循“让权等待”准则。当进程对信号量进行V操作时，若链表中仍有等待该资源的进程，则唤醒链表中的第一个等待进程。如果信号量初值为1,表示该资源为同时只允许一个进程访问的临界资源。由于AND型信号量与信号量集近年来在考试中从未涉及，而且这两项的内容就是对前面两种信号量的一种扩充，因此可以略过，不必在此浪费时间。 信号量的应用 信号量可以用来实现进程互斥和描述前趋关系，前趋关系不是考查重点。这里只介绍实现进程同步与互斥的简单例子。 实现进程同步 假设存在并发进程Pr和P2。P1中有一条语句SI, P2中有一条语句S2，要求SI必须在S2之前执行。这种同步问题使用信号量就能很好解决。 实现进程互斥 假设有进程PI和P2，两者有各自的临界区，但系统要求同时只能有一个进程进入自己的临界区。这里使用信号量可以很方便地解决临界区的互斥进入。设置信号量N,初值为1 (即可用资源数为1)，只需要将临界区放在P(N)和V(N)之间即可实现两进程的互斥进入。 若有两个或者多个进程需要互斥访问某资源，可以设置一个初值为1的信号量，在这些进程的访问资源的代码前后分别对该信号量进行P操作和V操作，即可保证进程对该资源的互斥访问。 ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:3:3","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"经典同步问题：生产者消费者问题、读者写者问题、哲学家进餐问题。 生产者消费者问题 生产者消费者问题是著名的进程同步问题。它描述的是一组生产者向一组消费者提供产品，他们共享一个有界缓冲区，生产者向其中投入产品，消费者从中取走产品。这个问题是许多相互合作进程的一种抽象。 例如，在输入时，输入进程是生产者，计算进程是消费者;在输出时，计算进程是生产者，打印进程是消费者。 为解决这一问题， 应当设置两个同步信号量: 一个说明空缓冲区数目，用empty表示，初值为有界缓冲区大小n;另一个说明满缓冲区数目(即产品数目),用full表示，初值为0。此外，还需要设置一个互斥信号量mutex,初值为1,以保证多个生产者或者多个消费者互斥地访问缓冲池。 生产者~消费者问题的同步程序结构描述如下: 特别注意如下内容: Pf(ul)/P(empty)与 P(mutex)的顺序不可颠倒，必须先对资源信号量进行P操作，再对互斥信号量进行P操作，否则会导致死锁。例如，此时缓冲区已满，而生产者先P (mutex),取得缓冲池访问权，再P (empty)， 此时由于缓冲池已满，empty=0， 导致P (empty)失败，生产者进程无法继续推进，始终掌握缓冲池访问权无法释放，因而消费者进程无法取出产品，导致死锁。而V(ull)/V(empty)与V(mutex)的顺序则没有要求，其顺序可以颠倒。这个问题可以延伸到几乎所有关于P、V操作的习题中，在有多个信号量同时存在的情况下，P操作往往是不能颠倒顺序的，必须先对资源信号量进行P操作，再对互斥信号量进行P操作，这样可以在占有信号量访问权时保证有资源可以使用，否则会产生占用使用权而无资源可用的“死，等”现象。 关于 mutex互斥信号量的设置是否必要的问题。在生产者和消费者都唯一的问题中，生产者与消费者是同步关系，生产者与消费者之间使用empty与full两个资源信号量进行同步，一定满足“放完才能取”的条件，因此此时互斥信号量mutex可以去掉。但在多生产者和多消费者的情况下，需要保证多个生产者或者多个消费者互斥地访问缓冲池，否则会导致出错。例如，两个生产者执行了P (empty)操作，此时第一个生产者执行bffr(in)=nextp, 这时第二个生产者也执行这条语句，由于第一个生产 者没有来得及执行in=(in+1)% n,即没有使指针后移，导致第二个生产者的数据覆盖掉了第一个生产者的数据，而不是放在了第一个数据的下一个缓冲区，接下来两个进程分别执行一次后移指针操作，这样就导致了有一个空缓冲区(本来应当放置第二个数据的缓冲区)被当作已有数据缓冲区对待，从而出错。因此，在多生产者或多消费者的情况下，必须设置mutex互斥信号量，以保证对缓冲池的互斥访问。 这里可记住一点: 只要有多个同类进程(同类进程是指使用同一个记录型信号量的进程，比如若干消费者进程都在使用empty信号量)，就一定需要互斥信号量;若同类进程只有一个，则记录型信号量即可完成进程同步。换句话说，互斥信号量就是给同类进程准备的。 读者写者问题 在读者-写者问题中，有一个许多进程共享的数据区，这个数据区可以是一个文件或者主存的一块空间，有一些只读取这个数据区的进程(读者)和一些只往数据区写数据的进程(写者)。此外还需要满足以下条件: 任意多个读者可以同时读这个文件。 一次只能有一个写者可以往文件中写(写者必须互斥)。 如果一个写者正在进行操作，禁止任何读进程读文件和其他任何写进程写文件。 需要分多种情况实现该问题:读者优先、公平情况和写者优先。 读者优先算法 一个读者试图进行读操作时，如果这时正有其他读者在进行读操作，他可以直接开始读操作，而不需要等待。由于只要有读者在进行读操作，写者就不能够写，但后续读者可以直接进行读操作，因此只要读者陆续到来，读者一到就能 够开始读操作，而写者进程只能等待所有读者都退出才能够进行写操作，这就是读者优先。要解决此问题，需要设置如下几个信号量:设置记录读者数量的整型变量readcount,初值为0，当其值大于0时，表明有读者存在，写者不能进行写操作;设置互斥信号量rmutex,初值为1,用于保证多个读者进程对于readcount 的互斥访问;设置互斥信号量mutex，初值为1，用于控制写者进程对于数据区的互斥访问。算法如下: 公平情况算法(按照到达顺序进行操作) 进程的执行顺序完全按照到达顺序，即一个读者试图进行读操作时，如果有写者正等待进行写操作或正在进行写操作，后续读者要等待先到达的写者完成写操作后才开始读操作。要解决此问题，跟读者优先算法相比，需要增设一个信号量wmutex, ，其初值为1，用于表示是否存在正在写或者等待的写者，若存在，则禁止新读者进入。算法如下: ★注:在本算法中，由于存在互斥信号量wmutex,因此当第一个写者到来时， 就会占用该信号量，从而阻止了后续其他读者的进入请求，只有当之前申请写操作的写者进入数据区完成写操作之后，才会释放wmutex信号量，后续读者才能够进入(实际上在这个算法中,将读写两种进程放在平等的地位，完全按照进程到达的顺序来执行。设置wmutex信号量的目的在于控制进程按照顺序来进行操作，避免读进程的优先)。 写者优先算法 有的书把公平情况算法也叫作写者优先，但并不是真正意义上的写者优先，只是按照到达顺序进行读写操作而已。若要实现真正的写者优先(即当写者和读者同时等待时，后续写者到达时可以插队到等待的读者之前，只要等待队列中有写者，不管何时到达，都优先于读者被唤醒)，则需要增设额外的信号量进行控制。为了达到这一目的，需要增设额外的一个信号量readable,用于控制写者到达时可以优先于读者进入临界区，当有写者到达时，只需要等待前面的写者写完就可以直接进入临界区，而不论读者是在该写者之前还是之后到达。另外，需要增设一个整数writecount 用于统计写者的数量。与之前的算法相比，wmutex的作用有所变化，现在是用于控制写者互斥访问writecount。算法如下: 本方法增设了readable 信号量，用于实现写者插队的目的。当第一个写者到达时，申请占用readable信号量，占用成功之后就一直占用，后续到达的读者进程会因申请不到readable信号量而阻塞，而后续写者到达时，由于不需要申请readable 信号量，因此就排在这个写者后面，从而达到插队的目的。直到所有写者都已经写完，最后一个写者释放了readable 信号量之后，读者才能够继续执行读操作。当新的写者到达时，继续占用readable 信号量，阻止后续的读者进行读操作，重复进行此过程。此算法真正实现了写者优先，新写者也可以优先于先到的等待读者占用数据区进行操作。 哲学家进餐问题 5个哲学家围绕一张圆桌而坐，桌子上放着5根筷子，每两个哲学家之间放一根;哲学家的动作包括思考和进餐，进餐时需要同时拿起他左边和右边的两根筷子，思考时则同时将两根筷子放回原处。哲学家进餐问题可以看作并发进程执行时处理临界资源的一个典型问题。筷子是临界资源，不能同时被两个哲学家一起用，因此使用一个信号量数组来表示筷子(哲学家按照编号逆时针围桌而坐，0号哲学家左手筷子为0号筷子，右手筷子为1号筷子，依次类推)。 这种解法存在问题，会导致死锁(假如5个哲学家同时饥饿而各自拿左边的筷子时，会导致5根筷子均被占用，当他们试图拿右边的筷子时，都将因没有筷子而“无限等待”)。对于这种死锁问题，可以采用如下几种解决方法:1、最多只允许4个哲学家同时进餐。2、仅当一个哲学家左右两边的筷子同时可用时，他才可以拿起筷子。3、将哲学家编号，要求奇数号的哲学家先拿左边筷子，偶数号的哲学家先拿右边筷子。现给出最后一种方法的解法:规定奇数号的哲学家先拿左边筷子，然后拿右边筷子;偶数号的哲学家则相反。算法如下: 理发师问题 理发店有一位理发师、一把理发椅和若千供顾客等候用的凳子(这里假设有n个凳子)。若没有顾客，则理发师在理发椅上睡觉。当一个顾客到来时，他必须先叫醒理发师;若理发师正在给顾客理发，则如果有空凳子，该顾客等待;如果没有空凳子，顾客就离开。要为理发师和顾客各设计一段程序来描述其活动。对本题有两种思路:一种是将理发椅 与等待用的凳子分别看作两种不同的资源;另一种是将理发椅和凳子看成统一的一种椅子资源。具体实现略。 ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:3:4","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"管程 用信号量机制可以实现进程间的同步和互斥，但由于信号量的控制分布在整个程序中,其正确性分析很困难，使用不当还可能导致进程死锁。针对信号量机制中存在的这些问题，Dijkstra于1971年提出为每个共享资源设立一个“秘书”来管理对它的访问。一切来访者都要通过“秘书”，而“秘书”每次仅允许一个来访者(进程)访问共享资源。这样既便于系统管理共享资源，又能保证互斥访问和进程间同步。1973 年，Hanson 和Hoare又把“秘书”概念发展为管程概念。 管程定义了一个数据结构和能为并发进程所执行的一组操作 ，这组操作能同步进程和改变管程中的数据。由管程的定义可知，管程由局部于管程的共享数据结构说明、操作这些数据结构的一组过程以及对局部于管程的数据结构设置初值的语句组成(★注:此处的“局部于”的含义为这些数据结构仅定义在管程内部，其作用范围仅在管程范围内)。管程把分散在各个进程中互斥访问公共变量的临界区集中起来，提供对它们的保护。 管程有以下基本特征: 局部于管程的数据只能被局部于管程内的过程所访问。 一个进程只有通过调用管程内的过程才能进入管程访问共享数据。 每次仅允许一个进程在管程内执行某个内部过程，即进程互斥地通过调用内部过程进入管程。其他想进入管程的过程必须等待，并阻塞在等待队列。由于管程是一个语言成分，因此管程的互斥访问完全由编译程序在编译时自动添加，而且保证正确。为实现进程间的同步，管程还必须包含若干用于同步的设施。例如，一个进程因调用管程内的过程而进入管程，在该过程执行过程中，若进程要求的某共享资源目前没有，则必须将该进程阻塞，于是必须有使该进程阻塞并且使它离开管程以便其他进程可以进入管程执行的设施;类似地，以后当被阻塞进程等待的条件得到满足时，必须使阻塞进程恢复运行，允许它重新进入管程并从断点(阻塞点)开始执行。 因此，在管程定义中还应包含以下支持同步的设施:局限于管程并仅能从管程内进行访问的若干条件变量，用于区别各种不同的等待原因。 在条件变量上进行操作的两个函数过程wait和signal。wait将调用此函数的进程阻塞在与该条件变量相关的队列中，并使管程可用，即允许其他进程进入管程。signal 唤醒在该条件变量上阻塞的进程，若有多个这样的进程，则选择其中的一个进程唤醒;若该条件变量上没有阻塞进程，则什么也不做。管程的signal 过程必须在wait过程调用之后调用。 ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:3:5","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"死锁 ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:4:0","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"死锁概念 在多道程序系统中，由于多个进程的并发执行，改善了系统资源的利用率并提高了系统的处理能力。然而，多个进程的并发执行也带来了新的问题一死锁。当多个进程因竞争系统资源或相互通信而处于永久阻塞状态时，若无外力作用，这些进程都将无法向前推进。这些进程中的每一个进程， 均无限期地等待此组进程中某个其他进程占有的、自己永远无法得到的资源，这种现象称为死锁。 下面通过几个例子来说明死锁现象。 某系统中只有一台打印机和一 台输入设备，进程PI正在占用输入设备，同时又提出了使用打印机的请求，但此时打印机正被进程P2占用。而P2在未释放打印机之前，又提出请求使用正被P1占用着的输入设备。这样，两个进程相互无休止地等待下去，均无法继续执行，此时两个进程陷入死锁状态。 在生产者-消费者问题中，若交换生产者进程中的两个P操作的顺序，则有可能出现死锁。改动后的生产者-消费者问题描述如下: 交换生产者进程中两个P操作的次序，一般情况下不会出现死锁，但在特殊情况下会出现死锁。例如，在某一时刻缓冲区中已装满了产品且缓冲区中没有进程工作(这时信号量full的值为n,信号量empty，的值为0,信号量mutex的值为1)， 若系统此时调度生产者进程运行，生产者进程生产了一个产品，执行P(mutex)并顺利进入临界区(这时mutex的值为0),随后它执行P(empty)时因没有空闲缓冲区而受阻等待，等待消费者进程进入缓冲区取走产品以释放出缓冲区;消费者进程执行P(ull)后再执行P(mutex)时，因缓冲区被生产者进程占据而无法进入。这样就形成了生产者进程在占有临界资源的情况下等待消费者进程取走产品，而消费者进程又无法进入临界区取走产品的僵局，此时两进程陷入死锁。 可以由死锁的定义和上述例子得到如下结论: 参与死锁的进程至少有两个。 每个参与死锁的进程均等待资源。 参与死锁的进程中至少有两个进程占有资源。 死锁进程是系统中当前进程集合的一个子集。 ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:4:1","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"死锁产生原因和必要条件 资源分类 操作系统是一个资源管理程序，它负责分配不同类型的资源给进程使用。现代操作系统所管理的资源类型十分丰富，并且可以从不同的角度出发对其进行分类，例如，可以把资源分为可剥夺资源和不可剥夺资源。 可剥夺资源是指虽然资源占有者进程需要使用该资源，但另一个进程可以强行把该资源从占有者进程处剥夺来归自己使用。 不可剥夺资源是指除占有者进程不再需要使用该资源而主动释放资源，其他进程不得在占有者进程使用资源过程中强行剥夺。 一个资源是查属于可剥夺资源，完全取决于资源本身的性质，比如，打印机在一个打印任务未结束之前，是无法被其他打印任务剥夺的，因此它是不可剥夺资源;而主存和CPU却是可剥夺资源。 要研究资源分配，必须弄清资源的类型，资源的不同使用性质是引起系统死锁的原因，如对可剥夺资源的竞争不会引起进程死锁，而对其他类型资源的竞争则有可能导致死锁。 死锁产生的原因 死锁产生的原因是竞争资源。若系统中只有一个进程在运行，所有资源为这个进程独享，则不会出现死锁现象。当系统中有多个进程并发执行时，若系统中的资源不足以同时满足所有进程的需要，则会引起进程对资源的竞争，从而可能导致死锁的产生。假定进程P1和P2分别申请到了资源A和资源B,现在进程P1又提出使用资源B的申请，由于资源B已被进程P2占有，因此进程PI阻塞;而进程P2可以继续运行，进程P2在运行中又提出使用资源A的申请，由于资源A已经被进程P1占有，因此进程P2阻塞。于是进程P1、P2都因资源得不到满足而进入阻塞状态，从而使进程陷入死锁。 虽然资源竞争可能导致死锁，但是资源竞争并不等于死锁，只有在进程运行过程中请求和释放资源的顺序不当时(即进程的推进顺序不当时)，才会导致死锁。 由此可知，死锁产生的原因是系统资源不足和进程推进顺序不当。系统资源不足是产生死锁的根本原因，设计操作系统的目的就是使并发进程共享系统资源。而进程推进顺序不当是产生死锁的重要原因，当系统资源刚好够进程使用时，进程的推进顺序不当就很容易导致进程彼此占有对方需要的资源，从而导致死锁。 死锁产生的必要条件 从上面的论述中可以推出，死锁产生的必要条件有以下4条: 互斥条件。 进程要求对所分配的资源进行排他性控制，即在一段时间内某种资源仅为一个进程所占有。 不剥夺条件。 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放。 请求与保持条件。 进程每次申请它所需的一部分资源。 在等待分配新资源的同时，进程继续占有已经分配到的资源。请求与保持条件也称为部分分配条件。 环路等待条件。存在一种进程资源的循环等待链，而链中的每一个进程已经获得的资源同时被链中的下一个进程所请求。要产生死锁，这4个条件缺一不可，因此可以通过破坏其中的一个或几个条件来避免死锁的产生。 ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:4:2","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"死锁处理策略 目前用于处理死锁的方法主要有以下4种: 鸵鸟算法。像鸵鸟一样对死锁视而不见，即不理睬死锁。 预防死锁。通过设置某些限制条件，去破坏产生死锁的4个必要条件中的一个或几个来预防死锁的产生。 避免死锁。 在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁的产生。 检测及解除死锁。通过系统的检测机构及时检测出死锁的发生，然后采取某种措施解除死锁。 这里要注意区分后3种方法的不同之处。预防死锁是在调度方式上破坏死锁产生的必要条件，使系统无法产生死锁，例如采用可剥夺式的进程调度方法，优先级高的进程总能得到资源并完成运行，因此系统不会产生死锁;避免死锁是在动态分配过程中，预知系统是否会进入不安全状态，若该资源分配有可能产生死锁，则不进行这种分配，后面要讲到的银行家算法就是一种避免死锁的方法;而检测及解除死锁是一种比较被动的方法，是在检测到死锁已经发生之后进行处理，例如采用剥夺死锁进程的资源等方法强制进程释放资源或结束死锁进程来解除死锁状态。 这3种方法有着不同的特点，例如在不能够破坏死锁必要条件的情况下，就无法采用预防死锁的方法，只能采用其他方法;当系统进程过多，预测系统是否进入不安全状态的成本过高时，采用避免死锁的方法并不划算，不如等死锁发生后采用检测及解除死锁的方法。现实中的操作系统并非都采用以上3种处理方法，相反，很多操作系统认为死锁不可能发生，对死锁不进行任何处理(这种说法不够积极，即对死锁采用鸵鸟算法)，如UNIX。 ★注:死锁避免和死锁预防不是同一个概念。 死锁预防和死锁避免采取的措施都是在死锁发生之前，但是它们之间还是有很大区别的。死锁预防对系统加的限制条件通常很严格，对系统的并发性会产生很大的副作用，此后不需要再运行什么算法来计算死锁发生的可能性;死锁避免对系统所加的限制条件则相对宽松，有利于进程的并发执行，但是死锁避免往往在资源被分配出去之前要计算分配之后系统是否安全。这里将死锁检测和死锁解除归为一种方法，有些资料上将这两种方法分开作为不同的解决死锁的策略，但也是有4种方法，不过是直接忽略了鸵鸟算法而已。 ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:4:3","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"死锁预防 根据以上讨论，要想防止死锁的发生，只需破坏死锁产生的4个必要条件之一即可。 下面具体分析与这4个条件相关的技术。 互斥条件 为了破坏互斥条件，就要允许多个进程同时访问资源。但是这会受到资源本身固有特性的限制，有些资源根本不能同时访问，只能互斥访问，如打印机就不允许多个进程在其运行期间交替打印数据，只能互斥使用。由此看来，通过破坏互斥条件来防止死锁的发生是不大可能的。 不剥夺条件 为了破坏不剥夺条件，可以制定这样的策略:对于一个已经获得了某些资源的进程，若新的资源请求不能立即得到满足，则它必须释放所有已经获得的资源，以后需要资源时再重新申请。这就意味着一个进程已获得的资源在运行过程中可以被剥夺，从而破坏了不剥夺条件。该策略实现起来比较复杂，释放已获得资源可能造成前一段 工作的失效，重复申请和释放资源会增加系统开销，降低系统吞吐量。这种方法通常不会用于剥夺资源之后代价较大的场合，比如不会用于对打印机的分配，在一个进程正在打印时，不会采用剥夺的方法来解除死锁。 请求与保持条件 为了破坏请求与保持条件，可以采用预先静态分配方法。预先静态分配法要求进程在其运行之前一次性申请所需要的全部资源，在它的资源未满足前，不投入运行。一旦投入运行后，这些资源就一直归它所有，也不再提出其他资源请求，这样就可以保证系统不会发生死锁。这种方法既简单又安全，但降低了资源利用率，因为采用这种方法必须事先知道该作业(或进程)所需要的全部资源，即使有的资源只能在运行后期使用，甚至有的资源在正常运行中根本不用，也不得不预先统一申请， 结果导致系统资源不能充分利用。以打印机为例，一个作业可能只在最后完成时才需要打印计算结果，但在作业运行前就需要把打印机分配给它，那么在该作业的整个执行过程中打印机基本处于闲置状态。另外其他等待打印机的进程迟迟不能开始运行，导致其他进程产生“饥饿”现象。 环路等待条件 为了破坏环路等待条件，可以采用有序资源分配法。有序资源分配法是将系统中的所有资源都按类型赋予一个编号( 例如打印机为1,磁带机为2)，要求每一个进程均严格按照编号递增的次序请求资源，同类资源一次申请完。 也就是说，只要进程提出请求资源R，则在以后的请求中只能请求排在R;后面的资源(i为资源编号),不能再请求编号排在R;前面的资源。对资源请求做了这种限制后，系统中不会再出现几个进程对资源的请求形成环路的情况。这种方法由于对各种资源编号后不宜修改，从而限制了新设备的增加;不同作业对资源使用的顺序也不会完全相同，即便系统对资源编号考虑到多数情况，但总会有与系统编号不符的作业，从而造成资源浪费;对资源按序使用也会增加程序编写的复杂性。 ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:4:4","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"死锁避免：系统安全状态、银行家算法。 预防死锁方法中所采用的几种策略，总的来说都施加了较强的限制条件，虽然实现起来较为简单，却严重损害了系统性能。在避免死锁的办法中，所施加的限制条件较弱，有可能获得较好的系统性能。在该方法中把系统的状态分为安全状态和不安全状态，只要能使系统始终处于安全状态，便可以避免死锁的发生。 安全状态与不安全状态 在避免死锁的方法中，允许进程动态地申请资源，系统在进行资源分配之前，先计算资源分配的安全性。若此次分配不会导致系统进入不安全状态，便将资源分配给进程，否则进程必须等待。 若在某一时刻，系统能按某种顺序来为每个进程分配其所需的资源，直至最大需求，使每个进程都可顺利完成，则称此时的系统状态为安全状态，称该序列为安全序列。若某一时刻系统中不存在这样的一个安全序列，则称此时的系统状态为不安全状态。需要注意的是, 安全序列在某一时刻可能并不唯一， 即可以同时存在多种安全序列。 虽然并非所有不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态;反之，只要系统处于安全状态，便可避免进入死锁状态。 注:以下两点是常犯的混淆性错误 不安全状态不是指系统中已经产生死锁。不安全状态是指系统可能发生死锁的状态，并不意味着系统已经发生死锁。 处于不安全状态的系统不会必然导致死锁。对系统进行安全性检测是根据进程的最大资源需求而定的，而实际运行过程中进程可能不需要那么多的资源，所以即使系统进入了不安全状态也不一定会导致死锁。而且实际系统运行过程中，有些占有资源但并没有执行完的进程可能主动放弃资源，这也会使得处于不安全状态的系统不产生死锁。死锁是不安全状态的真子集。 银行家算法 具有代表性的避免死锁算法是Djkstra给出的银行家算法。为实现银行家算法，系统中必须设置若千数据结构。假定系统中有n个进程(P1, P2，. Pn)、m类资源(R1, Rz, …Rm)，银行家算法中使用的数据结构如下: 可利用资源向量 Available。这是一个含有 m个元素的数组,其中Available[i]的值表示第i类资源的现有空闲数量，其初始值为系统中所配置的该类资源的数目，其数值随着该类资源的分配和回收而动态改变。 最大需求矩阵 Max。这是一个nxm的矩阵，它定义了系统中每一个进程对m类资源的最大需求数。Mx[)]i]的值 表示第i个进程对第j类资源的最大需求数。 分配矩阵 Allocation。这也是一个nxm的矩阵，它定义了系统中每一类资源当前已经分配给每一个 进程的资源数目。Allocation[i][]的值表示第i个进程当前拥有的第j类资源的数量。 需求矩阵Need。这同样是一个 nxm的矩阵，它定义了系统中每个进程还需要的各类资源数目(注意: 是“还需要”，不是“总需要”，这表示此矩阵也是变化的)。Need[i][]的值表示第i个进程还需要的第j类资源的数量。向量Need;是矩阵Need的第i行，是进程i的需求资源向量。 上述的nxm的“矩阵三兄弟”具有如下关系:Need[i][j]=Max[i]li]-Allocation[i]Di]银行家算法的描述如下: 定义Request;向量: Request 表示第i个进程向系统提出一次申请， 申请的各类资源的数量就是该向量的各个分量。当进程P;向系统发出资源请求后，系统进行如下操作: 1)若Request:≤Need;, 则跳至2)。否则报错，因为进程P;申请的资源数不应该超过它的需求数。 2)若Request:≤Available;,则跳至3)，否则P:进程需要等待，因为可用资源不够。 3)对P:进程所请求的资源进行预分配，修改以下向量: Available=Available-Request; Allocation:=Allocation;+Request; Need=Need;-Request; 4)对于修改后的向量调用安全性算法。若安全性算法返回系统处于安全状态，则按Request:表示的资源数量给P; 进程分配资源;若安全性算法返回系统处于不安全状态，则不分配给P:进程任何资源，让P:等待，并恢复3)中所改变的向量。 ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:4:5","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"死锁检测和解除 暂略 ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:4:6","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"死锁与饿死 死锁、饥饿、饿死通常是容易混淆的概念，这里特别说明一下。 在一个动态系统中，资源请求与释放是经常发生的进程行为。对于每类系统资源，操作系统需要确定一个分配策略，当多个进程同时申请某类资源时，由分配策略确定资源分配给进程的次序。资源分配策略可能是公平的，即能保证请求者在有限的时间内获得所需资源;资源分配策略也可能是不公平的，即不能保证等待时间上界的存在。在后一种情况下， 即使系统没有发生死锁，某些进程也可能会长时间等待。当等待时间给进程推进和响应带来明显影响时，则称此时发生了进程饥饿，当饥饿到一定程度， 进程所赋予的任务即使完成也不再具有实际意义时，称该进程被饿死。 考虑一台打印机分配的例子，当有多个进程需要打印文件时，系统按照短作业优先(SJF)的策略排序，该策略具有平均等待时间短的优点，似乎非常合理，但当短文件打印任务源源不断出现时，长文件的打印任务将被无限期推迟，导致饥饿以至饿死。 与饥饿相关的另外一个概念是活锁。在忙时等待条件下发生的饥饿，称为活锁，例如不公平的互斥算法。虽然此时进程仍然在执行，但有些进程由于无法调度执行，好像发生了死锁一样。 饿死与死锁有一定联系:二者都是由于竞争资源而引起的，但又有明显差别，主要表现在如下几个方面。 从进程状态考虑， 死锁进程都处于等待状态;忙时等待(处于运行或就绪状态)的进程并非处于等待状态，但却可能被饿死。 死锁进程等待的是永远不会被释放的资源;而饿死进程等待的是会被释放但却不会分配给自己的资源，表现为等待时间没有上界(排队等待或忙时等待)。 死锁一定发生了循环等待，而饿死则不然。这也表明通过资源分配图可以检测死锁存在与否，但却不能检测是否有进程饿死。 死锁一定涉及多个进程，而饥饿或被饿死的进程可能只有一个。 饥饿和饿死与资源分配策略有关，因而可从公平性方面考虑防止饥饿与饿死，以确保所有进程不被忽视，如多级反馈队列调度算法。 ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:4:7","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"习题 多级反馈队列算法 管程：针对信号量机制中存在的某些问题，Dijkstra于1971年提出为每个共享资源设立一个“秘书”来管理对它的访问。一切来访者都要通过“秘书”，而“秘书”每次仅允许一个来访者(进程)访问共享资源。这样既便于系统管理共享资源，又能保证互斥访问和进程间同步。 进程调度是宏观的，以完整进程为单位。 读写者问题： ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:5:0","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":"答案 ","date":"2021-11-10 13:14:32","objectID":"https://qizhengzou.github.io/operatingsystem_base_02/:6:0","tags":["operating system"],"title":"OperatingSystem_base_02","uri":"https://qizhengzou.github.io/operatingsystem_base_02/"},{"categories":["School courses"],"content":" 王道考研操作系统笔记 绪论 ","date":"2021-11-10 13:14:26","objectID":"https://qizhengzou.github.io/operatingsystem_base_01/:0:0","tags":["operating system"],"title":"OperatingSystem_base_01","uri":"https://qizhengzou.github.io/operatingsystem_base_01/"},{"categories":["School courses"],"content":"操作系统(Operating System, OS)的概念、特征、功能和提供的服务 引入操作系统的目的是： 提供一个计算机用户与计算机硬件系统之间的接口，使计算机系统更易于使用; 有效地控制和管理计算机系统中的各种硬件和软件资源，使之得到更有效的利用; 合理地组织计算机系统的工作流程，以改善系统性能。 操作系统的概念： 用户角度： 用户不一样，操作系统的设计目的也不一样，pc机重视用户使用方便、服务器重视资源利用率等等 系统角度（资源管理的角度） 操作系统是计算机系统的资源管理程序 进程角度 操作系统可以看作若干个进程以及进程调度的核心 虚拟机角度（机器扩充的角度） 用户不再使用裸机，而是通过操作系统来控制和使用计算机，计算机被扩充为功能更强大、使用更方便的虚拟计算机 操作系统的特征： 并发性： 注意与并行性的区别：并发性是指两个或多个事件在同一时间间隔内发生，而并发性是指两个或多个事件在同一时刻发生 共享性（并发性与共享性是操作系统最基本的特征）： 硬件、软件资源不再被某个程序独占。由不同资源性质得到两种资源共享方式： 互斥共享 同时访问（如磁盘、可重入代码） 宏观上的“同时”，微观上可能是作业交替访问该资源，但访问顺序不影响访问结果。 注：可重入代码是指一种允许多个进程同时访问的代码，要求必须保证资源的互不影响的使用，如io代码通常是不可重入的 虚拟性 比如单cpu的分时使用在宏观上可虚拟为多个cpu在提供服务，此外还有虚拟存储器、虚拟设备等 异步性 多道程序环境中，由于资源等因素的限制，程序的运行时间以及次序都是不确定的 操作系统的功能和提供的服务： 如前所述，操作系统的职能是负责系统中软硬件资源的管理，合理地组织计算机的工作流程，并为用户提供一个良好的工作环境和友好的使用界面。下面来说明操作系统的五大基本功能: 处理器管理 处理器管理的主要任务是对处理器的分配和运行实施有效的管理。在多道程序环境下，处理器的分配和运行是以进程为基本单位的，因此对处理器的管理可归结为对进程的管理。 进程管理应实现下述主要功能: 进程控制。 负责进程的创建、撤销及状态转换。 进程同步。对并发执行的进程进行协调。 进程通信。负贵完成进程间的信息交换。 进程调度。 按一定算法进行处理器分配。 存储器管理 存储器管理的主要任务是对内存进行分配、保护和扩充。存储器管理应实现下述主要功能: 内存分配。按一定的策略为每道程序分配内存。 内存保护。保证各程序在自己的内存区域内运行而不相互干扰。 内存扩充。为允许大型作业或多作业的运行，必须借助虚拟存储技术去获得增加内存的效果。 设备管理 计算机外设的管理是操作系统中最庞杂、琐碎的部分。设备管理的主要任务是对计算机系统内的所有设备实施有效管理。设备管理应具有下述功能: 设备分配。 根据一定的设备分配原则对设备进行分配。为了使设备与主机并行工作，还需采用缓冲技术和虚拟技术。 设备传输控制。实现物理的输入/输出操作，即启动设备、中断处理、结束处理等。 设备独立性。即用户程序中的设备与实际使用的物理设备无关。 文件管理 操作系统中负责信息管理的部分称为文件系统，因此称为文件管理。文件管理的主要任务就是有效地支持文件的存储、检索和修改等操作，解决文件的共享、保密和保护问题。文件管理应实现下述功能: 文件存储空间的管理。负责对文件存储空间进行管理，包括存储空间的分配与回收等功能。 目录管理。目录是为方便文件管理而设置的数据结构，它能提供按名存取的功能。 文件操作管理。实现文件的操作，负责完成数据的读写。 文件保护。提供文件保护功能，防止文件遭到破坏。 用户接口 为方便用户使用操作系统，操作系统还提供了用户接口。通常，操作系统以如下3种接口方式提供给用户使用。 命令接口。提供一组命令供用户直接或间接控制自己的作业。主要有两种命令接口控制方式，即联机命令接口和脱机命令接口。 联机命令接口又称交互式命令接口，适用于分时或实时操作系统，它由一组 键盘操作命令组成，用户通过控制台或终端输入操作命令，向系统提出各种服务要求，用户每输入完一条命令，控制权就转入操作系统的命令解释程序，然后由命令解释程序对输入的命令解释并执行，完成执行的功能。之后控制权又转回到控制台或终端，此时用户又可以输入下一条命令。 脱机命令接口又称批处理命令接口，即适用于批处理系统，它由一组作业控制命令(或称作业控制语句)组成，脱机用户不能直接干预作业的运行，应事先用相应的作业控制命令写成一份作业操作说明书，连同作业一起提交给系统。当系统调度到该作业时，由系统中的命令解释程序对作业说明书上的命令或控制语句逐条解释执行从而间接地控制作业的运行。 程序接口。 也称为系统调用，是程序级的接口，由系统提供一组系统调用命令供用户程序和其他系统程序调用。用户在程序中可以直接使用这组系统调用命令向操作系统提出各种服务要求，如使用外设、申请分配内存、磁盘文件的操作等。 图形接口。近年来出现的图形接口(也称图形界面)是联机命令接口的图形化。由操作系统的功能可以知道操作系统提供哪些服务:操作系统提供了一个用以执行程序的环境，提供的服务有程序执行、I/O 操作、文件操作、资源分配与保护、错误检测与排除等。 ","date":"2021-11-10 13:14:26","objectID":"https://qizhengzou.github.io/operatingsystem_base_01/:1:0","tags":["operating system"],"title":"OperatingSystem_base_01","uri":"https://qizhengzou.github.io/operatingsystem_base_01/"},{"categories":["School courses"],"content":"操作系统的发展与分类 操作系统的形成与发展： 无操作系统阶段 第一代计算机的主要元器件是电子管，人们采用手工操作方式操作计算机。但后来cpu速度越来越快，而手工的慢速便与其形成了“人机矛盾”。cpu与io设备的速度不匹配同样日益突出，为了缓和此矛盾，先后出现了通道技术和缓冲技术，但都未能很好地解决上述矛盾，直到后来引入脱机输入/输出技术，才获得了较为满意的效果。 脱机输入/输出技术是为了解决CPU和I/O设备之间速度不匹配的矛盾而提出的，此技术减少了CPU的空闲等待时间，提高了IO速度。其输入/输出方式如图1-3 所示。 为解决低速输入设备与CPU速度不匹配的问题，可以将用户程序和数据在一台外围机(又称卫星机)的控制下，预先从低速输入设备(纸带机)输入到输入带上，当CPU需要这些程序和数据时，再直接从输入带高速输入到内存，从而大大加快输入速度，减少CPU等待输入的时间，这就是脱机输入技术。 类似地，当程序运行完毕或告一段落，当CPU需要输出时，无须直接把计算结果送至低速输出设备(图1-3中为打印机)，而是高速地把结果送到输出带上，然后在外围机的控制下，把磁带上的计算结果由相应的输出设备输出，这就是脱机输出技术。若输入/输出操作在主机控制下进行，则称为联机输入/输出。采用脱机输入/输出技术后，低速I/O设备.上数据的输入/输出都在外围机的控制下进行，而CPU只与高速的输入带及输出带打交道，从而有效地减少了CPU等待慢速设备输入/输出的时间。 详细说明本方法的目的在于使我们了解脱机输入/输出的模型，因为之后的缓冲区技术以及SPOOLing技术等，都是基于这种原理产生的。理解了这个模型，对之后学习类似技术有较大的帮助。 单道批处理系统 单道批处理系统是最早出现的一种操作系统，严格地说，它只能算作是操作系统的前身而并非是现在人们所理解的操作系统。早期的计算机系统非常昂贵，为了能充分利用，应尽量使系统连续运行，以减少空闲时间。为此，通常是把一批作业以脱机输入方式输入到磁带上，并在系统中配置监督程序(管理作业的运行，负责装入和运行各种系统程序来完成作业的自动过渡)，在其控制下，先把磁带上的第一个作业传送到内存，并把运行的控制权交给第一个作业，当第一个作业处理完后又把控制权交还给监督程序，由监督程序再把第二个作业调入内存。计算机系统按这种方式对磁带上的作业自动地一个接一个进行处理，直至把磁带上的所有作业全部处理完毕，这样便形成了早期的批处理系统。 图1-4给出了单道批处理系统工作示例。 从图1-4中可以看出，每当程序发出I/O请求时，CPU便处于等待I/O完成的状态，致使CPU空闲。 单道批处理系统主要有如下特点: 自动性。在顺利的情况下，在磁带上的一批作业能自动地依次运行，而无须人工干预 顺序性。 磁带上的各道作业顺序地进入内存，各道作业的完成顺序与它们进入内存的顺序在正常情况下应完全相同，亦即先调入内存的作业先完成。 单道性。内存中仅有一道程序运行， 即监督程序每次从磁带上只调入一道程序进入内存运行，当该程序完成或发生异常情况时，才换入其后继程序进入内存运行。 多道批处理系统 为进一步提高CPU的利用率，引入了多道程序设计技术，由此而形成了多道批处理系统。多道程序设计技术是“将一个以上的作业存放在主存中，并且同时处于运行状态。这些作业共享处理器、外设以及其他资源”。现代计算机系统一般都基于多道程序设计技术。图1-5给出了多道程序工作示例。 在单处理器系统中，多道程序运行的特点如下: 多道。计算机内存中同时存放多道相互独立的程序。 宏观上并行。同时进入系统的几道程序都处于运行过程中，即它们先后开始了各自的运行，但都未运行完毕。 微观上串行。实际上，内存中的多道程序轮流占用CPU,交替运行。 多道程序设计技术能有效提高系统的吞吐量和改善资源利用率。但实现多道程序系统时,由于主存中总是同时存在几道作业，因此还需要妥善解决下述一系列问题。 如何分配处理器，以使处理器既能满足各程序运行的需要又有较高的利用率;将处理器分配给某程序后，应何时收回等问题。 如何为每道程序分配必要的内存空间，使它们各得其所又不致因相互重叠而失去信息;如何防止因某个程序出现异常情况而破坏其他程序。 系统中可能有多种类型的I/O设备供多道程序共享，应如何分配这些I/O设备;如何做到既方便用户对设备的使用，又能提高设备的利用率。 在计算机系统中， 通常都存放着大量的程序和数据，应如何组织它们才能便于用户使用并能保证数据的安全性和一致性。 对于系统中的各种应用程序，它们有的属于计算型，有的属于IO型，有的作业既重要又紧迫，有的作业要求系统能及时响应，这时应如何组织这些作业。 操作系统的形成 为了解决上述问题，应在多道程序系统中增设一组软件， 用这组软件对上述问题进行妥善有效的处理。此外，还应提供方便用户使用计算机的软件，这样便形成了操作系统。 操作系统是一组控制和管理计算机硬件和软件资源，合理地组织计算机工作流程以及方便用户的程序的集合。 操作系统的分类： 操作系统有3种基本类型，即批处理操作系统、分时操作系统和实时操作系统。随着计算机体系结构的发展，许多种操作系统应运而生，比如嵌入式操作系统、个人计算机操作系统、网络操作系统和分布式操作系统。 批处理操作系统： 单道批处理操作系统 多道批处理操作系统（大大提高了资源利用率和作业吞吐量，但无交互性，提交作业便失去对作业的控制） 分时操作系统 所谓分时技术，就是把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时停止运行，把处理器让给另一个作业使用，等下一轮时再继续运行。由于计算机速度很快，作业运行轮转也很快，给每个用户的感觉都好像是自己独占一台计算机。 在操作系统中采用分时技术就形成了分时操作系统。在分时操作系统中，一台计算机和许多终端设备连接，用户可以通过终端向系统发出命令，请求完成某项工作，而系统则分析从终端设备发来的命令，完成用户提出的要求，然后用户再根据系统提供的运行结果，向系统提出下一步请求，这样重复上述交互会话过程，直到用户完成预计的全部工作为止。实现分时操作系统有下述几种方法: 简单分时操作系统。在简单分时操作系统中，内存只驻留一道作业，其他作业都在外存上。每当内存中的作业运行一个时间片后,便被调至外存(称为调出),再从外存上选一个作业装入内存(称为调入)并运行一个时间片，按此方法使所有作业都能在规定的时间内轮流运行一个时间片，这样，所有用户都能与自己的作业交互。 具有 “前台”和“后台”的分时操作系统。为了改善系统性能，引入了“前台”和“后台”的概念。这里，把作业划分为“前台”和“后台”两类。“前台”存放按时间片调入/调出的作业流，其工作方式与简单分时操作系统相同;“后台”存放批处理作业。仅当“前台”正在调入/调出或无调入/调出作业流时，才运行“后台”的批处理作业，并给它分配更长的时间片。 多道分时操作系统。在分时操作系统中引入多道程序设计技术后，内存中可以同时装入多道作业，系统把所有具备运行条件的作业排成一个队列，使它们依次轮流获得一个时间片运行。 分时操作系统具有以下特征： 多路性。 指一台计算机与若干台终端相连接，终端上的这些用户可以同时或基本同时使用计算机。 交互性。 分时操作系统中用户的操作方式是联机方式，即用户通过终端采用人机会话的方式直接控制程序运行，同程序进行交互。 独占性。由于分时操作系统采用时间片轮转的方法使一台计算机同时为许多终端用户服务(通常能在2~3s内响应用户请求)，因此客观效果是这些用户彼此之间都感觉不到别人也在使用这台计算机，好像自己独占计算机一样。 及时性。 系统能够在较短时间内响应用户请求。 实时操作系统 实时操作系统是操作系统的又一种类型。对外部输入的信息，实时操作系统能够在规定的时间内处理完毕并做出反应。“实时”的含义是指计算机对于外来信息能够以足够快的速度进行处理，并在被控制对象允许的时间范围内做出快速反应。实时操作系统对响应时间的要求比分时操作系统更高，一般要求秒级、 毫秒级甚至微秒级的响应时间。 实时操作系统可以分成如下两类: 实时控制系统。通常是指以计算机为中心的生产过程控制系统，又称为计算机控制系统。例如，钢铁冶炼和钢板轧制的自动控制，化工、炼油生产过程的自动控制等。在这类系统中，要求实时采集现场数据，并对它们进行及时处理，进而自动控制相应的执行机构，使某参数(如温度、压力、流量等)能按预定规律变化或保持不变，以达到保证产品质量、提高产量的目的。 实时信息处理系统。在这类系统中，计算机及时接收从远程终端发来的服务请求，根据用户提出的问题对信息进行检索和处理，并在很短时间内对用户做出正确响应，如机票订购系统、情报检索系统等，都属于实时信息处理系统。实时操作系统的主要特点是提供及时响应和高可靠性。系统必须保证对实时信息的分析和处理的速度要快，而且系统本身要安全可靠，因为诸如生产过程的实时控制、航空订票等实时事务系统，信息处理的延误或丢失往往会带来不堪设想的后果。批处理操作系统、分时操作系统和实时操作系统是3种基本的操作系统。若一个操作系统兼有批处理、分时和实时系统或其中两者的功能，则称该操作系统为通用操作系统。 其他操作系统： 嵌入式操作系统 集群系统 网络操作系统 分布式操作系统（统一、共享、透明、自治） ","date":"2021-11-10 13:14:26","objectID":"https://qizhengzou.github.io/operatingsystem_base_01/:2:0","tags":["operating system"],"title":"OperatingSystem_base_01","uri":"https://qizhengzou.github.io/operatingsystem_base_01/"},{"categories":["School courses"],"content":"操作系统的运行环境 ","date":"2021-11-10 13:14:26","objectID":"https://qizhengzou.github.io/operatingsystem_base_01/:3:0","tags":["operating system"],"title":"OperatingSystem_base_01","uri":"https://qizhengzou.github.io/operatingsystem_base_01/"},{"categories":["School courses"],"content":"核心态与用户态 为了避免操作系统及其关键数据(如PCB等)受到用户程序有意或无意的破坏，通常将处理器的执行状态分为两种:核心态与用户态。 核心态。核心态又称管态、系统态，是操作系统管理程序执行时机器所处的状态。它具有较高的特权，能执行包括特权指令的一切指令，能访问所有寄存器和存储区。 用户态。用户态又称目态，是用户程序执行时机器所处的状态，是具有较低特权的执行状态，它只能执行规定的指令，只能访问指定的寄存器和存储区。 划分核心态与用户态之后，这两类程序以及各自的存储空间被严格区分了，而且在CPU执行时有着完全不同的待遇。用户态程序不能直接调用核心态程序，而是通过执行访问核心态的命令，引起中断，由中断系统转入操作系统内的相应程序，例如，在系统调用时，将由用户态转换到核心态。 特权指令:只能由操作系统内核部分使用，不允许用户直接使用的指令，如I/O指令、设置中断屏蔽指令、清内存指令、存储保护指令和设置时钟指令。 操作系统中一些与硬件关联较紧密的模块(如时钟管理、中断处理、设备驱动等)以及运行频率较高的程序(如进程管理、存储器管理、设备管理等)构成了操作系统的内核。内核的指令操作工作在核心态，主要包括以下4个方面的内容： 时钟管理。时钟是计算机的各部件中最关键的设备，操作系统通过时钟管理，向用户提供标准的系统时间。另外通过时钟中断的管理，可以实现进程的切换，如时间片轮转调度。 中断机制。键盘或鼠标的输入、进程的管理和调度、系统功能的调用、设备驱动、文件访问等，无不依赖于中断机制。中断机制中，只有一小部分属于内核，负责保护和恢复中断现场的信息，转移控制权到相关的处理程序。这样可以减少终端的处理时间，提高系统的并行处理能力。 原语。原语是一些关闭中断的公用小程序，主要有以下特点。 处于操作 系统最底层，是最接近硬件的部分。 程序运行具有原子性，操作只能一气呵成。 这些程序的运行时间较短， 调用频繁。 系统控制的数据结构及处理。操作系统中需要一些用 来登记状态信息的数据结构，如作业控制块、进程控制块、设备控制块、各类链表、消息队列、缓冲器、空闲登记区、内存分配表等。除此之外还应该定义对这些数据结构的一系列操作:进程管理、存储器管理、设备管理。 ","date":"2021-11-10 13:14:26","objectID":"https://qizhengzou.github.io/operatingsystem_base_01/:3:1","tags":["operating system"],"title":"OperatingSystem_base_01","uri":"https://qizhengzou.github.io/operatingsystem_base_01/"},{"categories":["School courses"],"content":"中断与异常 中断与异常是一对类似但又有区别的概念。 中断，也称外中断，是系统正常功能的一部分，例如，因进程调度使系统停止当前运行的进程转而执行其他进程，或者因缺少所需资源而中断当前操作等待资源到达，在系统处理完其他事情之后，会继续执行中断前的进程。 异常，也称内中断，是由错误引起的，如文件损坏、进程越界等。 通常异常会引起中断，而中断未必是由异常引起的。 ","date":"2021-11-10 13:14:26","objectID":"https://qizhengzou.github.io/operatingsystem_base_01/:3:2","tags":["operating system"],"title":"OperatingSystem_base_01","uri":"https://qizhengzou.github.io/operatingsystem_base_01/"},{"categories":["School courses"],"content":"系统调用 系统调用是操作系统提供的用户接口之一，是由操作系统实现的所有系统调用所构成的集合，即程序接口或应用编程接口(Application Programming Interface, API),是应用程序同系统之间的接口。 操作系统的主要功能是为应用程序的运行创建良好的环境。为了达到这个目的，内核提供了一系列具备预定功能的内核函数，通过一组称为系统调用(System Call) 的接口呈现给用户。系统调用把应用程序的请求传给内核，调用相应的内核函数完成所需的处理，并将处理结果返回给应用程序。如果没有系统调用和内核函数，用户将不能编写大型应用程序。操作系统提供的系统调用通常包括进程控制、文件系统控制(文件读写操作和文件系统操作)、系统控制、内存管理、网络管理、socket控制、用户管理以及进程间通信(信号、消息、管道、信号量和共享内存)。 操作系统执行系统调用的流程如图1-6 所示。用户需要执行系统调用时，首先准备并传递系统调用所需的参数，通过陷入(trap)指令进入操作系统的系统内核，此时将从用户态进入内核态;之后执行相应的系统调用函数，使用特定的系统内核功能;最后将处理结果返回给用户进程，此时将从内核态返回用户态。 ","date":"2021-11-10 13:14:26","objectID":"https://qizhengzou.github.io/operatingsystem_base_01/:3:3","tags":["operating system"],"title":"OperatingSystem_base_01","uri":"https://qizhengzou.github.io/operatingsystem_base_01/"},{"categories":["School courses"],"content":"操作系统的体系结构 操作系统的体系结构就是操作系统的组成结构。操作系统的体系结构主要包括模块组合结构、层次结构和微内核结构。 模块组合结构： 模块组合结构是软件工程出现以前的早期操作系统以及目前一些小型操作系统的体系结构。操作系统是一个有多种功能的系统程序，可以看作一个整体模块，也可以看作若干个模块按一定的结构方式组成的。系统中的每一个模块都是根据它们要完成的功能来划分的，这些功能模块按照一定的结构方式组合起来，协同完成整个系统的功能。 优点:结构紧密、接口简单直接、系统的效率相对较高。 缺点:首先，这种结构的模块之间可以随意转接，各模块相互牵连，不容易把握好模块的独立性，导致系统结构不清晰。其次，这种结构的可扩展性较差。在更换一个模块或修改一个 模块时，要先弄清模块间的接口，如果要按当初设计的模块接口来设计新的模块，而当初设计的模块接口很可能是随意约定的，那么要做这项工作就存在一定难度。 最后，这种结构系统的可适应性差。随着系统规模的不断增大，采用这种结构构造的系统的复杂性会迅速增长，所以它只适用于系统小、模块少、使用环境比较稳定的系统。 层次结构： 要弥补模块组合结构中模块间调用存在的不足之处，就必须改善模块间毫无规则的相互调用、相互依赖的关系，尤其要清除模块间的循环调用。层次结构的设计就是从这一点出发,力求使模块之间调用的无序性变为有序，减少了模块调用的无规则性。按层次结构来设计操作系统，就是将操作系统的所有功能模块按功能的调用次序排列成若干层，使得功能模块之间只存在单向调用和单向依赖。 优点: 模块间的组织和依赖关系清晰明了，上层功能是建立在下层功能基础之，上的，系统的可读性、可适应性以及可靠性都得到了增强。此外，对某一层进行修改或替换时，最多只影响到邻近的两层，便于修改和扩充。 缺点: 操作系统的各个功能模块应该放在哪一层， 如何有效地进行分层是必须要考虑的问题。 为了增强其适应性,必须把与机器特点紧密相关的软件(如中断处理、输入/输出管理等)放在最底层;其次，要将最常用的操作方式放在最内层，而把随着这些操作方式改变的部分放在外层。另外，当前操作系统的设计都是基于进程的概念，通常要将为进程提供服务的系统调用模块放在系统的内层。 微内核结构： 随着网络技术的普遍应用和发展，很有必要为用户提供一个符合处理分布式信息的分布式系统环境。因此，操作系统可以采用微内核结构。微内核的主要思想是:在操作系统内核中只留下一些最基本的功能，而将其他服务尽可能地从内核中分离出去，用若千个运行在用户态下的进程(即服务器进程)来实现，形成所谓的“客户/服务器”模式，即C/S模式。普通用户进程(即客户进程)可通过内核向服务器进程发送请求，以取得操作系统的服务。从微内核结构的主要思想可以看出，它非常适用于分布式系统。 优点:首先，每个服务进程运行在独立的用户进程中，即便某个服务器失败或产生问题，也不会引起系统其他服务器和其他组成部分的崩溃，可靠性好;其次，系统具有很好的灵活性，只要接口规范，操作系统可以方便地增删服务功能;再次，便于维护，即修改服务器的代码不会影响系统其他部分;最后,这种结构的操作系统适合分布式处理的计算环境。 缺点: 这种结构的操作系统效率不高，因为所有用户进程都要通过微内核相互通信，所以微内核本身就成了系统的\"瓶颈”，尤其是通信频繁的系统。 ","date":"2021-11-10 13:14:26","objectID":"https://qizhengzou.github.io/operatingsystem_base_01/:4:0","tags":["operating system"],"title":"OperatingSystem_base_01","uri":"https://qizhengzou.github.io/operatingsystem_base_01/"},{"categories":["School courses"],"content":"习题 多CPU一般用于分布式系统 ","date":"2021-11-10 13:14:26","objectID":"https://qizhengzou.github.io/operatingsystem_base_01/:5:0","tags":["operating system"],"title":"OperatingSystem_base_01","uri":"https://qizhengzou.github.io/operatingsystem_base_01/"},{"categories":["School courses"],"content":"答案 ","date":"2021-11-10 13:14:26","objectID":"https://qizhengzou.github.io/operatingsystem_base_01/:6:0","tags":["operating system"],"title":"OperatingSystem_base_01","uri":"https://qizhengzou.github.io/operatingsystem_base_01/"},{"categories":["School courses"],"content":"分布式系统的特征 ","date":"2021-11-10 10:24:24","objectID":"https://qizhengzou.github.io/distributedsystem_base_01/:0:0","tags":["distributed system"],"title":"DistributedSystem_base_01","uri":"https://qizhengzou.github.io/distributedsystem_base_01/"},{"categories":["School courses"],"content":"简介 我们把分布式系统定义成一个其硬件或软件组件分布在联网的计算机上，组件之间通过传递消息进行通信和动作协调的系统。 我们定义的分布式系统具有如下的具体特征： 并发：在一个计算机网络中，执行并发程序是常见的行为。用户可以在各自的计算机上工作，在必要时共享诸如Web页面或文件之类的资源。系统处理共享资源的能力会随着网络资源（例如，计算机）的增加而提高。 缺乏全局时钟：在程序需要协作时，它们通过交换消息来协调它们的动作。密切的协作通常取决于对程序动作发生的时间的共识。但是，事实证明，网络上的计算机与时钟同步所达到的准确性是有限的，即没有一个正确时间的全局概念。原因也很简单，因为基于网络的通信天然存在时延，而这个时延可能会由于网络状态等条件而不断发生变化，这么一来，就会导致各项动作没办法按照原定的时间来工作，反而会出现一些不好的影响。 故障独立性：所有的计算机系统都可能会出现故障，一般由系统设计者负责为可能的故障设计结果。分布式系统可能会以新的方式出现故障。网络故障导致网上互联的计算机的隔离，但这并不意味着它们停止运行，事实上，计算机上的程序不能检测到网络是出现故障还是网络运行得比通常慢。类似的，计算机的故障或系统中程序得异常终止（崩溃），并不能让与它通信的其他组件了解。系统的每个组件会单独地出现故障，而其他组件还在运行。 ","date":"2021-11-10 10:24:24","objectID":"https://qizhengzou.github.io/distributedsystem_base_01/:1:0","tags":["distributed system"],"title":"DistributedSystem_base_01","uri":"https://qizhengzou.github.io/distributedsystem_base_01/"},{"categories":["School courses"],"content":"分布式系统的例子 ","date":"2021-11-10 10:24:24","objectID":"https://qizhengzou.github.io/distributedsystem_base_01/:2:0","tags":["distributed system"],"title":"DistributedSystem_base_01","uri":"https://qizhengzou.github.io/distributedsystem_base_01/"},{"categories":["School courses"],"content":"web搜索 Web搜索引擎的任务是为万维网的所有内容建立索引，其中包含各种信息类型，例如Web页面、多媒体资源和扫描后的书。考虑到大多数搜索引擎是分析整个Web内容，并在这个巨大的数据库上完成复杂的处理，那么这个任务自身就是对分布式系统涉及的一个巨大挑战。 Google，Web搜索技术上的市场领导者，在支持用于搜索（与其他Google应用和服务，如Google Earth）的复杂的分布式系统基础设施上做出了巨大努力。该设施最突出的亮点包括： 一个底层物理设施：它由超大数目的位于全世界多个数据中心的连网计算机组成。 一个分布式文件系统：支持超大文件，并根据搜索和其他Google应用的使用方式（特别是在文件中以快速而持久的速度读取）进行了深度优化 一个相关的结构化分布式存储系统：它提供了对超大数据集的快速访问 一个锁服务：它提供了诸如分布式加锁和协定等分布式系统功能。 一个编程模式：它支持对底层物理基础设施上的超大并行和分布式计算的管理。 ","date":"2021-11-10 10:24:24","objectID":"https://qizhengzou.github.io/distributedsystem_base_01/:2:1","tags":["distributed system"],"title":"DistributedSystem_base_01","uri":"https://qizhengzou.github.io/distributedsystem_base_01/"},{"categories":["School courses"],"content":"大型多人在线游戏 大型多人在线游戏（Massively Multiplayer Online Game,MMOG）提供了一种身临其境的体验，超大数目用户通过互联网在一个持久的虚拟世界中交互。这类游戏的主要例子是Sony的EverQuest Ⅱ和芬兰公司CCP Games公司的EVE Online。 MMOG工程体现了分布式系统技术面临的巨大挑战，尤其是它对快速响应时间的需求。其他挑战包括事件实时传播给多个玩家和维护对共享世界的一个一致的视图。 针对大型多人在线游戏，提出了许多解决方案： 可能有点出乎意料，最大的在线游戏EVE Online，采用了CS体系结构，在一个集中式服务器上维护了游戏世界状态的单个拷贝，供运行在玩家终端或其他设备上的客户程序访问。为了支持大量客户，服务器自身是一个复杂的实体，拥有上百个计算机节点组成的集群结构。从虚拟世界的管理看，集中式体系结构有极大的益处，单个拷贝也简化了一致性问题。接着，目标是用过优化网络协议和快速响应到达事件来确保快速的响应。为了支持这点，对负载进行分区，把单个“星系”分配给集群中指定的计算机，这样，高负载星系会拥有自己的专用计算机，而其他星系则共享一台计算机。通过跟踪王家在i星系之间的移动，到达事件会被导向集群中正确的计算机上。 其他MMOG采用更多的分布式体系结构，宇宙被划分到大量（可能是超多）服务器上，这些服务器可能地理上分散部署。接着，用户基于当前的使用模式和到服务器的网络延迟（基于地理最近）被动态地分配到一个特定的服务器。这种体系结构风格被EverQuest采用，它通过增加新的服务器，可自然地扩展。 大多数商业系统采用上述两个模型中的一个，但研究者现在也在寻找更极端的体系结构，即不基于客户-服务器原理而是基于对等技术采用完全分散的方法。采用对等技术，意味着每个参与者贡献（存储和处理）资源来容纳游戏。 ","date":"2021-11-10 10:24:24","objectID":"https://qizhengzou.github.io/distributedsystem_base_01/:2:2","tags":["distributed system"],"title":"DistributedSystem_base_01","uri":"https://qizhengzou.github.io/distributedsystem_base_01/"},{"categories":["School courses"],"content":"金融交易 金融行业以其需求一直处在分布式系统技术的最前沿，特别是在实时访问大范围的信息源方面（例如，当前股票价格和趋势，经济和政治发展）。金融行业采用自动监控和交易应用。 此类系统的重点是对感兴趣数据项的通信和处理。感兴趣数据项在分布式系统中称为事件，在金融行业中的需求是可靠和及时地传递事件给可能是大量对此信息有兴趣地客户。这要求底层地体系结构具有与前述风格（例如CS）完全不同的风格，这样的系统通常采用分布式基于事件的系统。 下图说明了一个典型的金融交易的例子。它显示了一系列事件进入一个指定的金融机构。这样的事件输入具有下列特征。（图片来自分布式系统：概念与设计（原书第五版） by George Coulouris Jean Dollimore Tim Kindberg Gordon Blair (z-lib.org)） 首先，事件源通常具有多种格式，例如路透社的市场数据事件和FIX事件（符合金融信息交换协议特定格式的事件），事件源还来自不同的事件技术，这说明了在大多数分布式系统中回到异构性问题。图中使用了适配器，它把异构性格式转换成一个公共的内部格式。 其次交易系统必须处理各种各样的事件流，这些事件流高速到达，经常需要实时处理来检测表示交易机会的模式。这在过去曾今是手工处理的，但在竞争压力下变成自动处理，这就是所谓的复杂事件处理（Complex Event Processing，CEP），它提供了一种方法来将一起发生的事件组成逻辑的、时序的或空间的模式。 ","date":"2021-11-10 10:24:24","objectID":"https://qizhengzou.github.io/distributedsystem_base_01/:2:3","tags":["distributed system"],"title":"DistributedSystem_base_01","uri":"https://qizhengzou.github.io/distributedsystem_base_01/"},{"categories":["School courses"],"content":"分布式系统的趋势 分布式系统正在经历巨大的变化，这可追溯到一系列有影响力的趋势： 出现了泛在联网技术 出现了无处不在计算，它伴随着分布式系统中支持用户移动性的意愿 对多媒体设备的需求 把分布式系统作为一个设施 ","date":"2021-11-10 10:24:24","objectID":"https://qizhengzou.github.io/distributedsystem_base_01/:3:0","tags":["distributed system"],"title":"DistributedSystem_base_01","uri":"https://qizhengzou.github.io/distributedsystem_base_01/"},{"categories":["School courses"],"content":"泛在联网和现代互联网 互联网上的计算机程序通过传递消息进行交互，采用了一种公共的通信手段。互联网通信机制（互联网协议）的设计和构造是一项重大的技术成果，它使得一个在某处运行的程序能给另一个地方的程序发送消息。 互联网是一个超大的分布式系统。互联网和其支持得服务的实现，使得必须开发实用解决方案来解决分布式系统中的许多问题。 ","date":"2021-11-10 10:24:24","objectID":"https://qizhengzou.github.io/distributedsystem_base_01/:3:1","tags":["distributed system"],"title":"DistributedSystem_base_01","uri":"https://qizhengzou.github.io/distributedsystem_base_01/"},{"categories":["School courses"],"content":"移动和无处不在计算 设备小型化和无线网络方面的技术进步已经逐渐使得小型和便携式计算设备集成到分布式系统中。这些设备包括： 笔记本电脑 手持设备（包括移动电话、智能电话、GPS设备、摄像机等） 可穿戴设备 嵌入式家电 这些设备大多具有可便携性，再加上它们可以在不同的地方方便地连接到网络的能力，使得移动计算成为可能。移动计算是指用户在移动或访问某个非常规环境时执行计算任务的性能。 无处不在计算是指对用户的的物理环境（包括家庭、办公室和其他自然环境）中存在的多个小型、便宜的计算设备的利用。 移动和无处不在计算是一个热门的研究领域。 ","date":"2021-11-10 10:24:24","objectID":"https://qizhengzou.github.io/distributedsystem_base_01/:3:2","tags":["distributed system"],"title":"DistributedSystem_base_01","uri":"https://qizhengzou.github.io/distributedsystem_base_01/"},{"categories":["School courses"],"content":"分布式多媒体系统 另一个重要趋势是在分布式系统中支持多媒体服务的需求。多媒体支持可以定义为以集成的方式支持多种媒体类型的能力。人们可以期望分布式多媒体系统支持离散型媒体（如图片或正文消息）的存储、传输和展示。分布式多媒体系统应该能对连续类型媒体（如音频和视频）完成相同的功能，即它应该能存储和定位音频或视频文件，并通过网络传输它们（可能需要以实时的方式，因为流来自摄像机），从而能给用户展示多种媒体类型，以及在一组用户中共享多种类型的媒体。 连续媒体的重要特点时它们包括一个时间维度，媒体类型的完整性从根本上依赖于在媒体类型的元素之间保持实时关系。 分布式多媒体计算的好处时相当大的，因为能在桌面环境提供大量的新（多媒体）服务和应用，包括访问实况或预先录下的电视广播、访问提供视屏点播服务的电影资料库、访问音乐资料库、提供音频和视频会议设施、提供集成的电话功能。 网络播放（webcasting） 是分布式多媒体技术的应用。网络播放是在互联网上广播连续媒体（典型是音频和视频）的能力，现在常见以这种方式广播主要的体育或音乐事件。 分布式多媒体应用（例如网络播放）对底层的分布式基础设施提出了大量的要求，包括： 提供对一系列（可扩展的）编码和加密格式的支持，例如MPEG系列标准（包括如流行的MP3标准，也称MPEG-1音频第三层）和HDTV 提供一系列机制来保障所需的服务质量能够得到满足 提供相关的资源管理策略，包括合适的调度策略，来支持所需的服务质量 提供适配策略类处理在开放系统中不可避免的场景，即服务质量不能得到满足或维持 ","date":"2021-11-10 10:24:24","objectID":"https://qizhengzou.github.io/distributedsystem_base_01/:3:3","tags":["distributed system"],"title":"DistributedSystem_base_01","uri":"https://qizhengzou.github.io/distributedsystem_base_01/"},{"categories":["School courses"],"content":"把分布式计算作为一个公共设施 随着分布式下基础设施的不断成熟，不少公司在推广这样的观点：把分布式资源看作一个商品或公共设施，把分布式资源和其他公共设施进行类比。采用这种模型，资源通过合适的服务提供者提供，能被最终用户有效地租赁而不是拥有。这种模型可以应用到物理资源和更多的逻辑服务上。 联网的计算机可用诸如存储和处理这样的物理资源，从而无需自己拥有这样的资源。从一个维度来看，用户可以为其文件存储需求和文件备份需求选择一个远程存储设施。类似的，利用这个方法，用户能租到一个或多个计算结点，从而满足他们的基本计算需求或者完成分布式计算。从另一个维度来看，用户现在能用像Amazon和Google之类的公司提供的服务访问复杂的数据中心或计算基础设施。操作系统虚拟化时该方法关键的使能技术，它意味着实际上可以通过一个虚拟的而不是物理的结点为用户提供服务。这从资源管理角度给服务提供者提供了更大的灵活性。 用这种方法，软件服务也能跨全球互联网使用。 关于计算作为公共设施，术语云计算（cloud computi）被用来刻画其前景。云被定义成一组基于互联网的应用，并且足以满足大多数用户需求的存储和计算服务的集合，这使得用户能大部分或全部免于本地数据存储和应用软件的使用。该术语也推广“把每个事物看成一个服务”的观点。 通常，云实现在集群计算机上，从而提供每个服务所要求的必须的伸缩性和性能。**集群计算机（cluster computer）**是互联的计算机集合，它们密切协作提供单一的、集成的高性能计算能力。 集群服务器的总目的时提供一系列的云服务，包括高性能计算能力、大容量存储能力（例如通过数据中心）、丰富的应用服务（如Web搜索——Google依赖大容量集群计算机体系结构来实现其搜索引擎和其他服务） 网格计算也能被看作时一种云计算。但网格计算通常被看作时云计算这种更通用模式的先驱，它只是偏重于支持科学计算。 ","date":"2021-11-10 10:24:24","objectID":"https://qizhengzou.github.io/distributedsystem_base_01/:3:4","tags":["distributed system"],"title":"DistributedSystem_base_01","uri":"https://qizhengzou.github.io/distributedsystem_base_01/"},{"categories":["School courses"],"content":"关注资源共享 从硬件资源来看，大家共享设备可以减少花费，但对用户具用更大意义的是共享与用户应用、日常工作和社会活动有关的更高层的资源。例如用户惯性以共享数据库或Web页面集方式出现的共享数据，而不是实现上述服务的硬盘和处理器。类似的，用户关心诸如搜索引擎或货币换算器之类的共享资源，而不关心提供这些服务的服务器。 实际上，资源共享的模式随着其工作范围和与用户工作的密切程度的不同而不同。一种极端是，Web上的搜索引擎是给全世界的用户提供工具，而用户之间并不需要直接接触；另一种极端是，在计算机支持协调工作（Computer Supported Working。CSCW） 中，若干直接进行合作的用户在一个小型封闭的小组中共享诸如文档之类的资源。用户在地理上的分布以及用户之间进行共享的模式决定了系统必须提供协调用户动作的机制。 我们使用属于服务表示计算机系统中管理相关资源并提供功能给用户和应用的一个单独的部分。 服务将资源访问限制为一组定义良好的操作，这在某种程度上属于标准的软件工程实践。同时它也反映出分布式系统的物理组织。分布式相同的资源是物理地封装在计算机内，其他计算机只能通过通信访问。为了实现有效的共享，每个资源必须由一个程序管理，这个程序提供通信接口使得对资源进行可靠和一致的访问和更新。 ","date":"2021-11-10 10:24:24","objectID":"https://qizhengzou.github.io/distributedsystem_base_01/:4:0","tags":["distributed system"],"title":"DistributedSystem_base_01","uri":"https://qizhengzou.github.io/distributedsystem_base_01/"},{"categories":["School courses"],"content":"挑战 随着分布式系统的应用范围和规模扩大，可能会遇到相同的和其他的挑战。 ","date":"2021-11-10 10:24:24","objectID":"https://qizhengzou.github.io/distributedsystem_base_01/:5:0","tags":["distributed system"],"title":"DistributedSystem_base_01","uri":"https://qizhengzou.github.io/distributedsystem_base_01/"},{"categories":["School courses"],"content":"异构性 互联网使得用户能在大量异构计算机和网络上访问服务和运行应用程序。 下面这些均存在异构性（即存在多样性和差别）： 网络 计算机硬件 操作系统 编程语言 由不同开发者完成的软件实现 中间件：指一个软件层，它提供了一个编程抽象，同时屏蔽了底层网络、硬件、操作系统和编程语言的异构性。有些中间件。如Java远程方法调用（Remote Method Invocation,RMI）,仅支持一种编程语言。大多数中间件在互联网协议上实现，由这些协议屏蔽了底层网路的差异，但所有的中间件要解决操作系统和硬件的不同。 处理解决异构性问题之外，中间件为服务器和分布式应用的程序员提供了一致的计算模型。这些模型包括远程方法调用、远程时间通知、远程SQL访问和分布式事务处理。 异构性和移动代码中移动代码是指能从一台计算机发送到另一台计算机发送到另一台计算机，并在目的计算机上执行的代码，Java applet是一个例子。适合在一种计算机上运行的代码未必适合在另一种计算机上运行，因为可执行程序通常依赖于计算机的指令集和操作系统。 虚拟机方法提供了一种使代码可在任何计算机上运行的方法：某种语言的编译器生成一台虚拟机的代码而不是某种硬件代码，例如，Java编译器生成Java虚拟机的代码，虚拟机通过解释的方法来执行它。为了使Java程序嫩个运行，要在每种计算机上实现一次Java虚拟机。 今天，最常使用的移动代码是将一些Web页面的JavaScript程序装载到客户端浏览器中。 ","date":"2021-11-10 10:24:24","objectID":"https://qizhengzou.github.io/distributedsystem_base_01/:5:1","tags":["distributed system"],"title":"DistributedSystem_base_01","uri":"https://qizhengzou.github.io/distributedsystem_base_01/"},{"categories":["School courses"],"content":"开放性 计算机系统的开放性是决定系统能否以不同的方式被扩展和重新实现的特征。分布式系统的开放性主要取决于新的资源共享服务能被增加和供多种客户程序使用的程度。 除非软件开发者能获得系统组件的关键软件接口的规范和文档，否则无法实现开放性。一句话发布关键接口。这个过程类似接口的标准化，但它进程避开官方的标准化过程，官方的标准化过程非常繁琐且进度缓慢。 然而发布接口仅是分布式系统增加和扩展服务的起点。设计者所面临的挑战是解决由不同人构造的由许多组件组成的分布式系统的复杂性。 互联网协议的设计者引入了一系列称为“征求意见文档”（Requests For Comments，RFC）的文档，每个文档有一个编号。 按这种方式支持资源共享的系统之所以被称为开放的分布式系统，主要是强调它们是可扩展的。它们通过在网络中增加计算机实现在硬件层次上的扩展，通过引入新的服务、重新实现旧的服务实现在软件层次上的扩展，最终使得应用程序能够共享资源。开放系统常被提到的好处是它们与销售商无关。 开放的分布式系统的特征总结如下： 发布系统的关键接口是开放系统的特征 开放的分布式系统是基于一致的通信机制和发布接口访问共享资源的。 开放的分布式系统能用不同销售商提供的异构硬件和软件构造，但如果想让系统正确工作，就要仔细测试和验证每个组件与发布的标准之间的一致性。 ","date":"2021-11-10 10:24:24","objectID":"https://qizhengzou.github.io/distributedsystem_base_01/:5:2","tags":["distributed system"],"title":"DistributedSystem_base_01","uri":"https://qizhengzou.github.io/distributedsystem_base_01/"},{"categories":["School courses"],"content":"安全性 分布式系统中维护和使用的众多信息资源对用户具有很高的内在价值，因此它们的安全相当重要。信息资源的安全性包括三个部分：机密性（防止泄露给未授权的个人）、完整性（防止被改变或被破坏）、可用性（防止对访问资源的手段的干扰）。 安全性不止涉及对消息的内容保密，还涉及确切知道用户或代表用户发送消息的其他代理的身份。利用机密技术可满足这两个挑战。 然而，下面两个安全方面所面临的挑战目前还没有完美解决： 拒绝服务攻击：另一个安全问题是处于某些用户可能希望中断服务。可用下面的方法实现这个目的：用大量无意义的请求攻击服务器，使得重要的用户不能使用它。这称为拒绝服务攻击。现在通过在世间发生后抓获和惩罚犯罪者来解决这种攻击，但这不是解决这种问题的通用方法。 移动代码的安全性：移动代码需要小心处理。因为有些程序表面上可能一副有意思的画，但实际上却在访问本地资源，或者可能是拒绝服务攻击的一部分。 ","date":"2021-11-10 10:24:24","objectID":"https://qizhengzou.github.io/distributedsystem_base_01/:5:3","tags":["distributed system"],"title":"DistributedSystem_base_01","uri":"https://qizhengzou.github.io/distributedsystem_base_01/"},{"categories":["School courses"],"content":"可伸缩性 分布式系统可在不同的规模（从小型企业内部网到互联网）下有效且高效地运转。如果资源数量和用户数量激增，系统仍能保持其有效性，那么该系统就被称为可伸缩性。 可伸缩性分布式系统的设计面临下列挑战： 控制物理资源的开销 控制性能损耗 防止软件资源用尽：例如IP地址 避免性能瓶颈：通常，算法应该是分散型，以避免性能瓶颈。例如域名系统的前身，那时名字表被保存在一个主文件中，可被任何需要它的计算机下载。当互联网中只有几百个计算机时，这是可以的，但这不久就变成了一个严重的性能和管理瓶颈。现在，域名系统将名字表分区，分散到互联网中的服务器上，并采用本地管理的方式，从而解决了这个瓶颈。 ","date":"2021-11-10 10:24:24","objectID":"https://qizhengzou.github.io/distributedsystem_base_01/:5:4","tags":["distributed system"],"title":"DistributedSystem_base_01","uri":"https://qizhengzou.github.io/distributedsystem_base_01/"},{"categories":["School courses"],"content":"故障处理 计算机系统有时会出现故障。当硬件或软件发生故障时，程序可能会产生不正确的结果或者在它们完成应该进行的计算之前就停止了。 分布式系统的故障时部分的，也就是说，有些组件出了故障而有些组件运行正常。因此故障的处理相当困难。接下来我们讨论一下处理故障的技术： 检测故障：有些故障能被检测到。例如，校验和可用于检测消息或文件中出现的错误。而有些故障时很难甚至不能被检测到的。面临的挑战是如何在有故障出现的情况下进行管理，这些故障不能被检测到但可以被猜到。 掩盖故障：有些被检测到的故障能被隐藏起来或降低她的严重程度。下面是隐藏故障的两个例子 ： 1）消息在不能到达时重传。 2）将文件数据写入两个磁盘，如果一个磁盘损坏，那么另一个磁盘的数据仍是正确的。 降低故障严重程度的例子是丢掉被损坏的消息。这样，该消息可以被重传。读者可能意识到，隐藏故障的技术不能保证在最坏情况下有效。例如，第二个磁盘上的数据可能也坏了，或消息无论怎样重传都不能在合理的时间到达。 容错：互联网上的大多服务确实可能发生故障，试图检测并隐藏在这样大的网络、这么多的组件中发生的所有故障是不太实际的。服务的客户能被设计成容错的，这通常也涉及用户要容忍错误。例如，当Web浏览器不能与Web服务器连接时，它不会让用户一直等待它与服务器建立连接，而是通知用户这个问题，让用户自由选择是否尝试稍后再连接。 故障恢复：恢复涉及软件的设计，以便在服务器崩溃后，永久数据的状态能被恢复或“回滚”。通常再出现错误时，程序完成的计算是不完整的，被更新的永久数据（文件和其他保存在永久存储介质中的资料）可能处在不一致的状态。 冗余：利用冗余组件，服务可以实现容错。考虑下面的例子： 1）在互联网的任意两个路由器之间，至少存在两个不同的路由。 2）在域名系统中，每个名字表至少被复制到两个不同的服务器上。 3）数据库可以被复制到几个服务器上，以保证在任何一个服务器上有错误时，客户就被重定向到剩下的服务器上。 ","date":"2021-11-10 10:24:24","objectID":"https://qizhengzou.github.io/distributedsystem_base_01/:5:5","tags":["distributed system"],"title":"DistributedSystem_base_01","uri":"https://qizhengzou.github.io/distributedsystem_base_01/"},{"categories":["School courses"],"content":"并发性 在分布式系统中，服务和应用均提供可被客户共享的资源。因此，可能有几个客户同时试图访问一个共享资源的情况。 管理共享资源的进程可以一次接受一个客户请求，但这种方法限制了吞吐量。因此，服务和应用通常被允许并发地处理多个客户请求。 在分布式系统中，代表共享资源的任何一个对象必须负责确保它在并发环境中操作正确，这不仅适用于服务器，也适用于服务器，也适用于应用中的对象。因此，持有未打算用于分布式系统的对象实现的程序员必须做一些事情，使得对象在并发环境中能安全使用。 为了使对象在并发环境中能安全使用，它的操作必须在数据一致的基础上同步。者可通过标准的技术（如大多数操作系统所采用的信号量）来实现。 ","date":"2021-11-10 10:24:24","objectID":"https://qizhengzou.github.io/distributedsystem_base_01/:5:6","tags":["distributed system"],"title":"DistributedSystem_base_01","uri":"https://qizhengzou.github.io/distributedsystem_base_01/"},{"categories":["School courses"],"content":"透明性 透明性被定义成对用户和应用程序员屏蔽分布式系统的组件的分离性，使系统被认为是一个整体，而不是独立组件的集合。 ANSA参考手册和国际化标准化组织的开放分布式处理的参考模型（RM-ODP）识别出八种透明性（并用范围更广的移动透明性替换迁移透明性）： 访问透明性：用相同的操作访问本地资源和远程资源。 位置透明性：不需要知道资源的物理或网络位置就能访问它们 并发透明性：几个进程能并发地使用共享资源进行操作且互不干扰 复制透明性：使用资源的多个实例提升可靠性和性能，而用户和应用程序员无需知道副本的相关信息 故障透明性：屏蔽错误，不论是硬件组件故障还是软件组件故障，用户和应用程序员能够完成他们的任务 移动透明性：资源和客户能够在系统内移动而不会影响用户或程序的操作 性能透明性：当负载发生变化时，系统能被重新配置以提高性能 伸缩透明性：系统和应用能够进行扩展而不改变系统结构或应用算法 最重要的两个透明性是访问透明性和位置透明性，它们的有无对分布式资源的利用有很大影响，又是它们被统一称为网络透明性。 ","date":"2021-11-10 10:24:24","objectID":"https://qizhengzou.github.io/distributedsystem_base_01/:5:7","tags":["distributed system"],"title":"DistributedSystem_base_01","uri":"https://qizhengzou.github.io/distributedsystem_base_01/"},{"categories":["School courses"],"content":"服务质量 一旦提供给用户他们要求的功能，例如在一个分布式系统中的文件服务，我们就能继续探寻所提供的服务质量。系统的主要的非功能特性，即影响客户和用户体验的服务质量是可靠性、安全性和性能。满足变化的系统配置和资源可用性的适用性已被公认为服务质量的一个重要方面。 可靠性和安全性问题再设计大多是计算机系统时时关键的。服务质量的性能源于及时性和计算吞吐量，但它已被重新定义成满足及时性保证的能力。 一些应用，包括多媒体应用，处理时间关键性数据，这些数据是要求以固定速度处理或从一个进程传送到另一个进程的数据流。例如，一个电影服务可能由一个客户程序组成，该程序从一个视频服务器中检索电影并把它呈现到用户的屏幕上。该视频的连续帧在指定时间限制内显示给用户，才算是一个满意的结果。 ","date":"2021-11-10 10:24:24","objectID":"https://qizhengzou.github.io/distributedsystem_base_01/:5:8","tags":["distributed system"],"title":"DistributedSystem_base_01","uri":"https://qizhengzou.github.io/distributedsystem_base_01/"},{"categories":["School courses"],"content":"实例研究：万维网 在1989年3月，互联网还只属于少数人。在这一互联网的黎明期，HTTP诞生了。 蒂姆·伯纳斯-李博士提出了一种让远隔两地的研究者们共享知识的设想，这一最初设想的基本理念是：借助多文档之间相互关联形成的超文本（HyperText），连成可相互参阅的WWW（World Wide Web,万维网）。 超文本（Hypertext）：在互联网早期的时候，我们输入的信息只能保存在本地，无法和其他电脑交互。我们保存的信息通常都以文本即简单字符的形式存在，文本是一种能够被计算机解析的有意义的二进制数据包。而随着互联网的高速发展，两台电脑之间能够进行数据的传输后，人们不再满足只能在两台电脑之间传输文字，还想要传输图片、音频、视频，甚至是超链接，那么文本的语义就被扩大了，这种语义扩大后的文本就被称为超文本（HyperText）。 而为了实现这一理念，现在已经提出了3项WWW构建技术，分别是： 把SGML（Standard Generalized Markup Langrage，标准通用标记语言）作为页面的文本标记语言的HTML（HyperText Markup Language，超文本标记语言） 作为文档传输协议的HTTP（HyperText Transfer Protocol,超文本传输协议） 指定文档所在地址的URL（Uniform Resource Locator，统一资源定位符） WWW这一名称，是Web浏览器当年用来浏览超文本的客户端应用程序是的名称。现在则用来表示这一系列的集合，也可简称为Web。 除了这三样技术外，还有Javascript，提供比HTML标准化窗口部件质量更好的用户交互，用于更新Web页面的部分内容而不必取得该页面的全新版本并重新显示。AJAX处理异步情况等等技术。 Web之所以取得巨大的成功，是因为许多个人或机构能比较容易地发布资源，它的超文本结构适合组织多种类型的信息，而且Web体系结构具有开放性。Web体系结构所基于的标准很简单，且早被广泛发布。它使得许多新的资源类型和服务可以集成到一起。 Web成功的背后也存在一些设计问题，首先，它的超文本模型再某些方面有所欠缺。如果删除或移动了一个资源，那么就会存在对资源所谓“悬空”链接，会使用户请求落空。此外，还存在用户“在超空间迷失”这个常见的问题。用户经常发现自己处于混乱状态下，跟随许多无关的链接打开完全不同的页面，使得有些情况下可靠性值得怀疑。 在Web上查找信息的另一种方法是使用搜索引擎，但这种方法在满足用户真正需求方面是相当不完美的。要解决这个问题，资源描述框架[www.w3.org V]中介绍过,一种方法是生成标准的表达事务元数据的词汇、语法和语义，并将元数据封装在相应的Web资源中供程序访问。除了查找Web页面中出现的词组外，从原理上讲，程序可以完成对针对元数据的搜索，然后，根据语义匹配编译相关的链接列表。总而言之，由互连的元数据资源组成的Web就是语义Web。 作为一个系统体系结构，Web面临规模的问题。常见的Web服务器会在一秒中有很多点击量，结果导致对用户的应答变慢。 ","date":"2021-11-10 10:24:24","objectID":"https://qizhengzou.github.io/distributedsystem_base_01/:6:0","tags":["distributed system"],"title":"DistributedSystem_base_01","uri":"https://qizhengzou.github.io/distributedsystem_base_01/"},{"categories":["School courses"],"content":"小结 分布式系统无处不在。 资源共享是构造分布式系统的主要因素。 分布式系统的构造面临许多挑战： 异构性 开放性 安全性 可伸缩性 故障处理 透明性 服务质量 ","date":"2021-11-10 10:24:24","objectID":"https://qizhengzou.github.io/distributedsystem_base_01/:7:0","tags":["distributed system"],"title":"DistributedSystem_base_01","uri":"https://qizhengzou.github.io/distributedsystem_base_01/"},{"categories":["Go"],"content":" 参考学习go语言中文网、C语言中文网、golang官方文档等 关于Unicode和UTF-8： func TestString(t *testing.T) { var s string t.Log(s) //初始化为默认零值“” s = \"hello\" t.Log(len(s)) //s[1] = '3' //string是不可变的byte slice //s = \"\\xE4\\xB8\\xA5\" //可以存储任何二进制数据 s = \"\\xE4\\xBA\\xBB\\xFF\" t.Log(s) t.Log(len(s)) s = \"中\" t.Log(len(s)) //是byte数 c := []rune(s) t.Log(len(c)) // t.Log(\"rune size:\", unsafe.Sizeof(c[0])) t.Logf(\"中 unicode %x\", c[0]) t.Logf(\"中 UTF8 %x\", s) } Running tool: D:\\go\\bin\\go.exe test -timeout 30s -run ^TestString$ code/code/ch9/string === RUN TestString d:\\Go\\Go_WorkSpace\\go_learning-master\\code\\ch9\\string\\string_test.go:9: d:\\Go\\Go_WorkSpace\\go_learning-master\\code\\ch9\\string\\string_test.go:11: 5 d:\\Go\\Go_WorkSpace\\go_learning-master\\code\\ch9\\string\\string_test.go:15: 亻� d:\\Go\\Go_WorkSpace\\go_learning-master\\code\\ch9\\string\\string_test.go:16: 4 d:\\Go\\Go_WorkSpace\\go_learning-master\\code\\ch9\\string\\string_test.go:18: 3 d:\\Go\\Go_WorkSpace\\go_learning-master\\code\\ch9\\string\\string_test.go:21: 1 d:\\Go\\Go_WorkSpace\\go_learning-master\\code\\ch9\\string\\string_test.go:23: 中 unicode 4e2d d:\\Go\\Go_WorkSpace\\go_learning-master\\code\\ch9\\string\\string_test.go:24: 中 UTF8 e4b8ad --- PASS: TestString (0.00s) PASS ok code/code/ch9/string 0.514s ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:0:0","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"go起源 07年 三位大牛 解决三个困难：多核硬件架构、超大规模的分布式计算集群、如今使用的web开发模式导致的前所未有的开发规模和更新速度 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:1:0","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"环境相关 go1.8前必须设置GOPATH ,之后的版本设置GOPATH也有用，挖个坑，今天填…… ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:2:0","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"主要特征 自动立即回收。(自带GC) 更丰富的内置类型。 函数多返回值。 错误处理。 匿名函数和闭包。 类型和接口。 并发编程。 反射。 有复合，无继承（因为复合大于继承，干脆不要继承） Go的函数、变量、常量、自定义类型、包(package)的命名方式遵循以下规则： 1）首字符可以是任意的Unicode字符（一种字符集，一个字符两个字节，表示包括了每种语言）或者下划线 2）剩余字符可以是Unicode字符、下划线、数字 3）字符长度不限 25关键字： break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var select和switch:select只能应用于channel的操作，既可以用于channel的数据接收，也可以用于channel的数据发送。如果select的多个分支都满足条件，则会随机的选取其中一个满足条件的分支。而switch用于一般的分支判断，顺序执行。 package main import \"time\" import \"fmt\" func main() { c1 := make(chan string) c2 := make(chan string) go func() { time.Sleep(time.Second * 1) c1 \u003c- \"one\" }() go func() { time.Sleep(time.Second * 2) c2 \u003c- \"two\" }() for i := 0; i \u003c 2; i++ { select { case msg1 := \u003c-c1: fmt.Println(\"received\", msg1) case msg2 := \u003c-c2: fmt.Println(\"received\", msg2) } } } fallthrough:可以使用fallthrough强制执行该case执行完下一条case代码，fallthrough不会判断下一条case的判断结果是否为true。 37个保留字： Constants: true false iota nil Types: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error Functions: make len cap new append copy close delete complex real imag panic recover new\u0026make func new(Type) *Type func make(t Type, size …IntegerType) Type go声明：var,const,type,func ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:3:0","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"内置类型与函数 值类型： bool int(32 or 64), int8, int16, int32, int64 uint(32 or 64), uint8(byte), uint16, uint32, uint64 float32, float64 string complex64, complex128 array 引用类型（声明的同时需要分配内存空间，不然会引发panic，分配内存可以用new或者make）： slice map chan 内置函数（无需导入即可使用）: append -- 用来追加元素到数组、slice中,返回修改后的数组、slice close -- 主要用来关闭channel delete -- 从map中删除key对应的value panic -- 停止常规的goroutine （panic和recover：用来做错误处理） recover -- 允许程序定义goroutine的panic动作 real -- 返回complex的实部 （complex、real imag：用于创建和操作复数） imag -- 返回complex的虚部 make -- 用来分配内存，返回Type本身(只能应用于slice, map, channel) make 函数允许在运行期动态指定数组长度，绕开了数组类型必须使用编译期常量的限制。 new -- 用来分配内存，主要用来分配值类型，比如int、struct。返回指向Type的指针 cap -- capacity是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map） copy -- 用于复制和连接slice，返回复制的数目 len -- 用来求长度，比如string、array、slice、map、channel ，返回长度 print、println -- 底层打印函数，在部署环境中建议使用 fmt 包 内直接口error： type error interface { //只要实现了Error()函数，返回值为String的都实现了err接口（鸭子类型） Error() String } ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:4:0","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"init \u0026 main go语言中init函数用于包(package)的初始化，该函数是go语言的一个重要特性。有下面的特征： init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等 每个包可以拥有多个init函数 包的每个源文件也可以拥有多个init函数 同一个包中多个init函数的执行顺序go语言没有明确的定义(说明) 不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序 init函数不能被其他函数调用，而是在main函数执行之前，自动被调用 Go语言程序的默认入口函数(主函数)： func main(){ …… //通过os.Args获取参数eg:os.Args[0] //不支持返回值，可以通过os.Exit()来返回状态 } init函数和main函数的异同： 同 两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用。 异 init可以应用于任意包中，且可以重复定义多个。 main函数只能用于main包中，且只能定义一个。 执行顺序： 对同一个go文件的init()调用顺序是从上到下的。 对同一个package中不同文件是按文件名字符串比较“从小到大”顺序调用各文件中的init()函数。 对于不同的package，如果不相互依赖的话，按照main包中”先import的后调用”的顺序调用其包中的init()，如果package存在依赖，则先调用最早被依赖的package中的init()，最后调用main函数。 如果init函数中使用了println()或者print()你会发现在执行过程中这两个不会按照你想象中的顺序执行。这两个函数官方只推荐在测试环境中使用，对于正式环境不要使用。 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:5:0","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"go命令 PS D:\\Blog\\qizhengzou.github.io-blog\\content\\posts\u003e go Go is a tool for managing Go source code. Usage: go \u003ccommand\u003e [arguments] The commands are: bug start a bug report build compile packages and dependencies clean remove object files and cached files doc show documentation for package or symbol env print Go environment information fix update packages to use new APIs fmt gofmt (reformat) package sources generate generate Go files by processing source get add dependencies to current module and install them install compile and install packages and dependencies list list packages or modules mod module maintenance run compile and run Go program test test packages tool run specified go tool version print Go version vet report likely mistakes in packages Use \"go help \u003ccommand\u003e\" for more information about a command. Additional help topics: buildconstraint build constraints buildmode build modes c calling between Go and C cache build and test caching environment environment variables filetype file types go.mod the go.mod file gopath GOPATH environment variable gopath-get legacy GOPATH go get goproxy module proxy protocol importpath import path syntax modules modules, module versions, and more module-get module-aware go get module-auth module authentication using go.sum packages package lists and patterns private configuration for downloading non-public code testflag testing flags testfunc testing functions vcs controlling version control with GOVCS Use \"go help \u003ctopic\u003e\" for more information about that topic. ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:6:0","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"go env 用于打印Go语言的环境信息。 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:6:1","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"go run命令 可以编译并运行命令源码文件。 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:6:2","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"go get 可以根据要求和实际情况从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装。 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:6:3","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"go build命令 用于编译我们指定的源码文件或代码包以及它们的依赖包。 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:6:4","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"go install 用于编译并安装指定的代码包及它们的依赖包。 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:6:5","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"go clean命令 会删除掉执行其它命令时产生的一些文件和目录。 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:6:6","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"go doc命令 可以打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:6:7","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"go test命令 用于对Go语言编写的程序进行测试。 在命名文件时需要让文件必须以_test结尾。默认的情况下，go test命令不需要任何的参数，它会自动把你源码包下面所有 test 文件测试完毕，当然你也可以带上参数。 这里介绍几个常用的参数： -bench regexp 执行相应的 benchmarks，例如 -bench=.； -cover 开启测试覆盖率； -run regexp 只运行 regexp 匹配的函数，例如 -run=Array 那么就执行包含有 Array 开头的函数； -v 显示测试的详细命令。 单元测试源码文件可以由多个测试用例组成，每个测试用例函数需要以Test为前缀。测试用例文件不会参与正常源码编译，不会被包含到可执行文件中。测试用例文件使用go test指令来执行，没有也不需要 main() 作为函数入口。所有在以_test结尾的源码内以Test开头的函数会自动被执行。测试用例可以不传入 *testing.T 参数。 运行指定示例： PS D:\\Go\\Go_WorkSpace\\go_learning-master\\code\\ch2\\constant_test\u003e go test -v -run TestTest test_test.go === RUN TestTest test_test.go:6: kk --- PASS: TestTest (0.00s) PASS ok command-line-arguments 0.425s t.FailNow()———–标记错误并终止当前测试用例 t.Fail()————–仅编辑错误 每个测试用例可能并发执行，使用 testing.T 提供的日志输出可以保证日志跟随这个测试上下文一起打印输出。testing.T 提供了几种日志输出方法： Log 打印日志 Logf 格式化打印日志 Error 打印错误日志 Errorf 格式化打印错误日志 Fatal 打印致命日志 Fatalf 格式化打印致命日志 基准测试——获得代码内存占用和运行效率的性能数据 使用者无须准备高精度的计时器和各种分析工具，基准测试本身即可以打印出非常标准的测试报告。 package code import \"testing\" func Benchmark_Add(b *testing.B) { var n int for i := 0; i \u003c b.N; i++ { n++ } } 这段代码使用基准测试框架测试加法性能。第 7 行中的 b.N 由基准测试框架提供。测试代码需要保证函数可重入性及无状态，也就是说，测试代码不使用全局变量等带有记忆性质的数据结构。避免多次运行同一段代码时的环境不一致，不能假设 N 值范围。 //-bench=.相当于-run。在windows下使用-bench=\".\" $ go test -v -bench=. benchmark_test.go goos: linux goarch: amd64 Benchmark_Add-4 20000000 0.33 ns/op // 20000000指的是测试执行次数 PASS ok command-line-arguments 0.700s 基准测试原理：基准测试框架对一个测试用例的默认测试时间是 1 秒。开始测试时，当以 Benchmark 开头的基准测试用例函数返回时还不到 1 秒，那么 testing.B 中的 N 值将按 1、2、5、10、20、50……递增，同时以递增后的值重新调用基准测试用例函数。 通过-benchtime参数可以自定义测试时间，例如： $ go test -v -bench=. -benchtime=5s benchmark_test.go goos: linux goarch: amd64 Benchmark_Add-4 10000000000 0.33 ns/op PASS ok command-line-arguments 3.380s 基准测试可以对一段代码可能存在的内存分配进行统计，下面是一段使用字符串格式化的函数，内部会进行一些分配操作。 func Benchmark_Alloc(b *testing.B) { for i := 0; i \u003c b.N; i++ { fmt.Sprintf(\"%d\", i) } } $ go test -v -bench=Alloc -benchmem benchmark_test.go goos: linux goarch: amd64 Benchmark_Alloc-4 20000000 109 ns/op 16 B/op 2 allocs/op PASS ok command-line-arguments 2.311s 第 1 行的代码中-bench后添加了 Alloc，指定只测试 Benchmark_Alloc() 函数。 第 4 行代码的“16 B/op”表示每一次调用需要分配 16 个字节，“2 allocs/op”表示每一次调用有两次分配 开发者根据这些信息可以迅速找到可能的分配点，进行优化和调整。 控制计时器：有些测试需要一定的启动和初始化时间，如果从 Benchmark() 函数开始计时会很大程度上影响测试结果的精准性。testing.B 提供了一系列的方法可以方便地控制计时器，从而让计时器只在需要的区间进行测试。我们通过下面的代码来了解计时器的控制。 func Benchmark_Add_TimerControl(b *testing.B) { // 重置计时器 b.ResetTimer() // 停止计时器 b.StopTimer() // 开始计时器 b.StartTimer() var n int for i := 0; i \u003c b.N; i++ { n++ } } 从 Benchmark() 函数开始，Timer 就开始计数。计数器内部不仅包含耗时数据，还包括内存分配的数据。 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:6:8","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"go list命令 作用是列出指定的代码包的信息。 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:6:9","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"go fix 会把指定代码包的所有Go语言源码文件中的旧版本代码修正为新版本的代码。 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:6:10","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"go vet 是一个用于检查Go语言源码中静态错误的简单工具。 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:6:11","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"go tool pprof命令 交互式的访问概要文件的内容。 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:6:12","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"go modules go modules 是 golang 1.11 新加的特性 go download download modules to local cache(下载依赖包) edit edit go.mod from tools or scripts（编辑go.mod） graph print module requirement graph (打印模块依赖图) init initialize new module in current directory（在当前目录初始化mod） tidy add missing and remove unused modules(拉取缺少的模块，移除不用的模块) vendor make vendored copy of dependencies(将依赖复制到vendor下) verify verify dependencies have expected content (验证依赖是否正确 why explain why packages or modules are needed(解释为什么需要依赖) go.mod文件一旦创建后，它的内容将会被go toolchain全面掌控。go toolchain会在各类命令执行时，比如go get、go build、go mod等修改和维护go.mod文件。 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:6:13","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"运算符 Go 语言内置的运算符有： 算术运算符 ++ –只有后置的，没有前置的，只作为语句，不作为表达式* 关系运算符 逻辑运算符 位运算符 按位置零运算符 x \u0026^ y ——如果y非零，则z为0；如果y为零，则z为x 赋值运算符（一个赋值语句可以给多个变量进行赋值，多重赋值时，变量的左值和右值按从左到右的顺序赋值。多重赋值在 Go 语言的错误处理和函数返回值中会大量地使用。） = 简单的赋值运算符，将一个表达式的值赋给一个左值 += 相加后再赋值 -= 相减后再赋值 *= 相乘后再赋值 /= 相除后再赋值 %= 求余后再赋值 «= 左移后赋值 \u003e\u003e= 右移后赋值 \u0026= 按位与后赋值 l= 按位或后赋值 ^= 按位异或后赋值 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:7:0","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"下划线 “_”是特殊标识符，用来忽略结果。 下划线在import中 import 下划线（如：import _ hello/imp）的作用：当导入一个包时，该包下的文件里所有init()函数都会被执行，然而，有些时候我们并不需要把整个包都导入进来，仅仅是是希望它执行init()函数而已。这个时候就可以使用 import _ 引用该包。即使用【import _ 包路径】只是引用该包，仅仅是为了调用init()函数，所以无法通过包名来调用包中的其他函数。 下划线在代码中 作为占位符 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:8:0","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"格式占位符%…… 普通占位符 占位符 说明 举例 输出 %v 相应值的默认格式。 Printf(\"%v\", people) {zhangsan}， %+v 打印结构体时，会添加字段名 Printf(\"%+v\", people) {Name:zhangsan} %#v 相应值的Go语法表示 Printf(\"#v\", people) main.Human{Name:\"zhangsan\"} %T 相应值的类型的Go语法表示 Printf(\"%T\", people) main.Human %% 字面上的百分号，并非值的占位符 Printf(\"%%\") % 布尔占位符 占位符 说明 举例 输出 %t true 或 false。 Printf(\"%t\", true) true 整数占位符 占位符 说明 举例 输出 %b 二进制表示 Printf(\"%b\", 5) 101 %c 相应Unicode码点所表示的字符 Printf(\"%c\", 0x4E2D) 中 %d 十进制表示 Printf(\"%d\", 0x12) 18 %o 八进制表示 Printf(\"%d\", 10) 12 %q 单引号围绕的字符字面值，由Go语法安全地转义 Printf(\"%q\", 0x4E2D) '中' %x 十六进制表示，字母形式为小写 a-f Printf(\"%x\", 13) d %X 十六进制表示，字母形式为大写 A-F Printf(\"%x\", 13) D %U Unicode格式：U+1234，等同于 \"U+%04X\" Printf(\"%U\", 0x4E2D) U+4E2D 浮点数和复数的组成部分（实部和虚部） 占位符 说明 举例 输出 %b 无小数部分的，指数为二的幂的科学计数法， 与 strconv.FormatFloat 的 'b' 转换格式一致。例如 -123456p-78 %e 科学计数法，例如 -1234.456e+78 Printf(\"%e\", 10.2) 1.020000e+01 %E 科学计数法，例如 -1234.456E+78 Printf(\"%e\", 10.2) 1.020000E+01 %f 有小数点而无指数，例如 123.456 Printf(\"%f\", 10.2) 10.200000 %g 根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(\"%g\", 10.20) 10.2 %G 根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(\"%G\", 10.20+2i) (10.2+2i) 字符串与字节切片 占位符 说明 举例 输出 %s 输出字符串表示（string类型或[]byte) Printf(\"%s\", []byte(\"Go语言\")) Go语言 %q 双引号围绕的字符串，由Go语法安全地转义 Printf(\"%q\", \"Go语言\") \"Go语言\" %x 十六进制，小写字母，每字节两个字符 Printf(\"%x\", \"golang\") 676f6c616e67 %X 十六进制，大写字母，每字节两个字符 Printf(\"%X\", \"golang\") 676F6C616E67 指针 占位符 说明 举例 输出 %p 十六进制表示，前缀 0x Printf(\"%p\", \u0026people) 0x4f57f0 其它标记 占位符 说明 举例 输出 + 总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。 Printf(\"%+q\", \"中文\") \"\\u4e2d\\u6587\" - 在右侧而非左侧填充空格（左对齐该区域） # 备用格式：为八进制添加前导 0（%#o） Printf(\"%#U\", '中') U+4E2D 为十六进制添加前导 0x（%#x）或 0X（%#X），为 %p（%#p）去掉前导 0x； 如果可能的话，%q（%#q）会打印原始 （即反引号围绕的）字符串； 如果是可打印字符，%U（%#U）会写出该字符的 Unicode 编码形式（如字符 x 会被打印成 U+0078 'x'）。 ' ' (空格)为数值中省略的正负号留出空白（% d）； 以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开 0 填充前导的0而非空格；对于数字，这会将填充移到正负号之后 golang没有 ‘%u’ 点位符，若整数为无符号类型，默认就会被打印成无符号的。 宽度与精度的控制格式以Unicode码点为单位。宽度为该数值占用区域的最小宽度；精度为小数点之后的位数。 操作数的类型为int时，宽度与精度都可用字符 ‘*’ 表示。 对于 %g/%G 而言，精度为所有数字的总数，例如：123.45，%.4g 会打印123.5，（而 %6.2f 会打印123.45）。 %e 和 %f 的默认精度为6 对大多数的数值类型而言，宽度为输出的最小字符数，如果必要的话会为已格式化的形式填充空格。 而以字符串类型，精度为输出的最大字符数，如果必要的话会直接截断。 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:9:0","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"变量和常量 变量： 为什么要有变量：程序运行过程中的数据都是保存在内存中，我们想要在代码中操作某个数据时就需要去内存上找到这个变量，但是如果我们直接在代码中通过内存地址去操作变量的话，代码的可读性会非常差而且还容易出错，所以我们就利用变量将这个数据的内存地址保存起来，以后直接通过这个变量就能找到内存上对应的数据了。 Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。并且Go语言的变量声明后必须使用。 批量声明变量： var ( a string b int c bool d float32 ) 在函数内部，可以使用更简略的 := 方式声明并初始化变量。 匿名变量_ 常量: const ( pi = 3.1415 e = 2.7182 ) 如果省略了值则表示和上面一行的值相同 iota是go语言的常量计数器，只能在常量的表达式中使用。iota在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。 可以使用_跳过某些值 const ( _ = iota KB = 1 \u003c\u003c (10 * iota) MB = 1 \u003c\u003c (10 * iota) GB = 1 \u003c\u003c (10 * iota) TB = 1 \u003c\u003c (10 * iota) PB = 1 \u003c\u003c (10 * iota) ) const ( a, b = iota + 1, iota + 2 //1,2 c, d //2,3 e, f //3,4 ) ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:10:0","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"基本类型 类型 长度(字节) 默认值 说明 bool 1 false byte 1 0 uint8，一个ASCII字符 rune 4 0 Unicode Code Point，int32，一个utf-8字符,c:=[]rune(s)//指将字符串s转化为rune的切片 int, uint 4或8 0 由操作系统位数(32/64)决定 int8, uint8 1 0 -128 ~ 127, 0 ~ 255，byte是uint8 的别名 int16, uint16 2 0 -32768 ~ 32767, 0 ~ 65535 int32, uint32 4 0 -21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名 int64, uint64 8 0 float32 4 0.0 float64 8 0.0 complex64 8 complex128 16 uintptr 4或8 以存储指针的 uint32 或 uint64 整数 array 值类型 struct 值类型 string “” UTF-8 字符串 slice nil 引用类型 map nil 引用类型 channel nil 引用类型 interface nil 接口 function nil 函数 uintptr 实际上就是一个 uint 用来表示地址，go 的指针和 c 不一样不能进行偏移操作，如果非要偏移的话就需要 unsafe.Pointer 和 uintptr 配合来实现。uintptr 不是一个指针 所以 GC 时也不会处理 uintptr 的引用。如果不涉及地址偏移时没有必要使用 uintptr 。——来自知乎回答 标准库 math 定义了各数字类型取值范围。 空指针值 nil，而非C/C++ NULL。golang中有多种引用类型：pointer、interface、slice、map、channel、function。go作为一个强类型语言，不同引用类型的判空（nil）规则是不同的；比如：interface的判空规则是，需要判断类型和值是否都为nil(interface的底层是有类型和值构成的)slice的判空，需要判断slice引用底层数组的指针为空，容量和size均为0。 不允许将整型强制转换为布尔型。 字符串的内部实现使用UTF-8编码。（UTF-8是Unicode的存储实现，转化为字节序列的规则） 只有显示类型转化。 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:11:0","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"string： 值类型，空值是空字符串而不是nil。本质就是个只读的（不可变的）byte切片。 多行字符串，用反引号` s1 := `第一行 第二行 第三行 ` fmt.Println(s1) 方法 介绍 len(str) 求长度 +或fmt.Sprintf 拼接字符串 strings.Split 分割 strings.Contains 判断是否包含 strings.HasPrefix,strings.HasSuffix 前缀/后缀判断 strings.Index(),strings.LastIndex() 子串出现的位置 strings.Join(a[]string, sep string) join操作 遍历字符串： // Traversal strings func traversalString() { s := \"JeFo的博客\" for i := 0; i \u003c len(s); i++ { //Traversal by byte fmt.Printf(\"%v(%c) \", s[i], s[i]) } fmt.Println() for _, r := range s { //Traversal by rune fmt.Printf(\"%v(%c) \", r, r) } fmt.Println() } 74(J) 101(e) 70(F) 111(o) 231(ç) 154() 132( ) 229(å) 141() 154() 229(å) 174(®) 162(¢) 74(J) 101(e) 70(F) 111(o) 30340(的) 21338(博) 23458(客) 修改字符串： 要修改字符串，需要先将其转换成[]rune或[]byte，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组。 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:12:0","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"数组 数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是：len-1 支持 “==”、\"!=” 操作符，因为内存总是被初始化过的。 相同类型的数组之间可以使用 == 或 != 进行比较，但不可以使用 \u003c 或 \u003e，也可以相互赋值。 长度不同类型也不同。 指针数组 [n]*T，数组指针 *[n]T。 多维数组除了第一维，初始化时都不能用[…]省略长度声明。 值拷贝行为会造成性能问题，通常会建议使用 slice，或数组指针。 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:13:0","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"切片 只能和nil进行比较。 //用make()初始化 var s3 []int = make([]int, 0, 10)//len=0,cap=10 var s4 []int = make([]int, 5)//len=5 //先初始化一个数组，再截取相应部分得到切片 arr := [5]int{1, 2, 3, 4, 5} var s6 []int s6 = arr[1:4] // 左闭右开 s7 = arr[1:3:5]//len=3-1;cap=5-1，这是一个危险的用法，极易产生bug 切片追加append（内置函数）： // The append built-in function appends elements to the end of a slice. If // it has sufficient capacity, the destination is resliced to accommodate the // new elements. If it does not, a new underlying array will be allocated. // Append returns the updated slice. It is therefore necessary to store the // result of append, often in the variable holding the slice itself: // slice = append(slice, elem1, elem2) // slice = append(slice, anotherSlice...) // As a special case, it is legal to append a string to a byte slice, like this: // slice = append([]byte(\"hello \"), \"world\"...) var a = []int{1, 2, 3} fmt.Printf(\"slice a : %v\\n\", a) var b = []int{4, 5, 6} fmt.Printf(\"slice b : %v\\n\", b) c := append(a, b...) fmt.Printf(\"slice c : %v\\n\", c) d := append(c, 7) fmt.Printf(\"slice d : %v\\n\", d) e := append(d, 8, 9, 10) fmt.Printf(\"slice e : %v\\n\", e) slice := append([]byte(\"hello \"), \"world\"...)//注意是字节数组和字符串。 fmt.Printf(\"slice slice : %v\\n\", slice) 超出原 slice.cap 限制，就会重新分配底层数组，即便原数组并未填满。 通常以 2 倍容量重新分配底层数组。在大批量添加数据时，建议一次性分配足够大的空间，以减少内存分配和数据复制开销。或初始化足够长的 len 属性，改用索引号进行操作。 及时释放不再使用的 slice 对象，避免持有过期数组，造成 GC 无法回收。 切片resize: package main import ( \"fmt\" ) func main() { var a = []int{1, 3, 4, 5} fmt.Printf(\"slice a : %v , len(a) : %v\\n\", a, len(a)) b := a[1:2] fmt.Printf(\"slice b : %v , len(b) : %v\\n\", b, len(b)) c := b[1:3] fmt.Printf(\"slice c : %v , len(c) : %v\\n\", c, len(c)) } slice a : [1 3 4 5] , len(a) : 4 slice b : [3] , len(b) : 1 slice c : [4 5] , len(c) : 2 string \u0026 slice : string底层就是一个byte的数组，因此，也可以进行切片操作。 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:14:0","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"切片底层实现 切片的设计想法是由动态数组概念而来，为了开发者可以更加方便的使一个数据结构可以自动增加和减少。但是切片本身并不是动态数据或者数组指针。切片常见的操作有 reslice、append、copy。与此同时，切片还具有可索引，可迭代的优秀特性。 func main() { arrayA := []int{1, 2} testArrayPoint(\u0026arrayA) // 1.传数组指针 arrayB := arrayA[:] testArrayPoint(\u0026arrayB) // 2.传切片 fmt.Printf(\"arrayA : %p , %v\\n\", \u0026arrayA, arrayA) } func testArrayPoint(x *[]int) { fmt.Printf(\"func Array : %p , %v\\n\", x, *x) (*x)[1] += 1 } func Array : 0xc4200b0140 , [1 2] func Array : 0xc4200b0180 , [1 3] arrayA : 0xc4200b0140 , [1 4] 传指针会有一个弊端，从打印结果可以看到，第一行和第三行指针地址都是同一个，万一原数组的指针指向更改了，那么函数里面的指针指向都会跟着更改。 用切片传数组参数，既可以达到节约内存的目的，也可以达到合理处理好共享内存的问题。打印结果第二行就是切片，切片的指针和原来数组的指针是不同的。 slice数据结构源码： // runtime/slice.go type slice struct { array unsafe.Pointer // 指向一个数组的指针 len int // 切片长度 cap int // 切片容量 } 如果想从 slice 中得到一块内存地址，可以这样做： s := make([]byte, 200) ptr := unsafe.Pointer(\u0026s[0]) 自己构造一个slice: var ptr unsafe.Pointer var s1 = struct { addr uintptr len int cap int }{ptr, length, length} s := *(*[]byte)(unsafe.Pointer(\u0026s1)) 在 Go 的反射中就存在一个与之对应的数据结构 SliceHeader，我们可以用它来构造一个 slice： var o []byte sliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(\u0026o))) sliceHeader.Cap = length sliceHeader.Len = length sliceHeader.Data = uintptr(ptr) 并非所有时候都适合用切片代替数组：因为切片底层数组可能会在堆上分配内存，而且小数组在栈上拷贝的消耗也未必比make 消耗大。 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:14:1","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"创建切片 make 函数允许在运行期动态指定数组长度，绕开了数组类型必须使用编译期常量的限制。 创建切片有两种形式，make 创建切片，字面量创建切片（既可以初始化一个新的，也可以截取一个数组,截取一个数组的时候cap未声明时为数组容量）。 空切片和nil切片 nil切片：| nil (Pointer) | Len(int) | Cap(int) | var slice []int nil 切片被用在很多标准库和内置函数中，描述一个不存在的切片的时候，就需要用到 nil 切片。比如函数在发生异常的时候，返回的切片就是 nil 切片。nil 切片的指针指向 nil。 空切片： | Array (Pointer) | Len(int) | Cap(int) | silce := make( []int , 0 ) slice := []int{ } 空切片一般会用来表示一个空的集合。比如数据库查询，一条结果也没有查到，那么就可以返回一个空切片。 空切片和 nil 切片的区别在于，空切片指向的地址不是nil，指向的是一个内存地址，但是它没有分配任何内存空间，即底层元素包含0个元素。 不管是使用 nil 切片还是空切片，对其调用内置函数 append，len 和 cap 的效果都是一样的。 扩容策略 如果切片的容量小于 1024 个元素，于是扩容的时候就翻倍增加容量。 一旦元素个数超过 1024 个元素，那么增长因子就变成 1.25 ，即每次增加原来容量的四分之一。 注意：扩容扩大的容量都是针对原来的容量而言的，而不是针对原来数组的长度而言的。 扩容后的数组是新数组还是老数组？ 如果如果切片扩容后容量比原来数组的容量最大值还大，扩容切片需要另开一片内存区域，把原来的值拷贝过来，再执行append()操作。 否则，不会开辟新数组，这种情况很危险，因为这种情况下，扩容以后的数组还是指向原来的数组,多个原来的数组上的切片会受新切片所影响！ ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:14:2","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"切片拷贝 slicecopy 方法会把源切片值(即 fm Slice )中的元素复制到目标切片(即 to Slice )中，并返回被复制的元素个数，copy 的两个类型必须一致。slicecopy 方法最终的复制结果取决于较短的那个切片，当较短的切片复制完成，整个复制过程就全部完成了。 如果用 range 的方式去遍历一个切片，拿到的 Value 其实是切片里面的值拷贝。所以每次打印 Value 的地址都不变。由于 Value 是值拷贝的，并非引用传递，所以直接改 Value 是达不到更改原切片值的目的的，需要通过 \u0026slice[index] 获取真实的地址。 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:14:3","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"指针 区别于C/C++中的指针，Go语言中的指针不能进行偏移和运算，是安全指针。 首先需要知道指针地址、指针类型和指针取值。 指针地址和指针类型： Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型 指针取值：* 空指针： 当一个指针被定义后没有分配到任何变量时，它的值为 nil new和make: 在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。 new 函数签名和举例 func new(Type) *Type func main() { var a *int a = new(int) *a = 10 fmt.Println(*a) } new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。 make 只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身,因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。 以map举例： func main() { var b map[string]int b = make(map[string]int, 10) b[\"测试\"] = 100 fmt.Println(b) } ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:15:0","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"map map[KeyType]ValueType 初始化时用make申请内存（或者直接填充元素）： make(map[KeyType]ValueType, [cap])//cap不是必须的，但最好一开始就申请一个合适的容量 // // 初始化 + 赋值一体化 m3 := map[string]string{ \"a\": \"aa\", \"b\": \"bb\", } 判断某个key是否存在： //map[key]会返回两个值，第二个是该键是否存在 value, ok := map[key] map的遍历还是正常用for range，但有一点需要注意：遍历map时元素顺序与添加键值对的顺序无关。 按照指定顺序遍历map:思路是将map的key取出另存为切片再排序，再按照切片的顺序进行遍历即可。 map \u0026 切片： 元素为map的切片： func main() { var mapSlice = make([]map[string]string, 3) for index, value := range mapSlice { fmt.Printf(\"index:%d value:%v\\n\", index, value) } fmt.Println(\"after init\") // 对切片中的map元素进行初始化 mapSlice[0] = make(map[string]string, 10) mapSlice[0][\"name\"] = \"王五\" mapSlice[0][\"password\"] = \"123456\" mapSlice[0][\"address\"] = \"红旗大街\" } value为切片的map: func main() { var sliceMap = make(map[string][]string, 3) fmt.Println(sliceMap) fmt.Println(\"after init\") key := \"中国\" value, ok := sliceMap[key] if !ok { value = make([]string, 0, 2) } value = append(value, \"北京\", \"上海\") sliceMap[key] = value fmt.Println(sliceMap) } map删除键值对： delete(map,key) ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:16:0","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"map实现原理 map底层存储方式为（结构体）数组，在存储时key不能重复，当key重复时，value进行覆盖，我们通过key进行hash运算（可以简单理解为把key转化为一个整形数字）然后对数组的长度取余，得到key存储在数组的哪个下标位置，最后将key和value组装为一个结构体，放入数组下标处。 哈希冲突：即不同key经哈希映射后得到相同的数组下标。 解决办法：开放定址法： 发现hashkey(key)的下标已经被别key占用的时候，在这个数组中空间中重新找一个没被占用的存储这个冲突的key。寻找方式有很多。常见的有线性探测法，线性补偿探测法，随机探测法。 线性探测法： 从冲突的下标处开始往后探测，到达数组末尾时，从数组开始处探测，直到找到一个空位置存储这个key，当数组都找不到的情况下会扩容（事实上当数组容量快满的时候就会扩容了） 查找某一个key的时候，找到key对应的下标，比较key是否相等，如果相等直接取出来，否则按照顺寻探测直到碰到一个空位置，说明key不存在。 拉链法： 当key的hash冲突时，我们在冲突位置的元素上形成一个链表，通过指针互连接。 当查找时，发现key冲突，顺着链表一直往下找，直到链表的尾节点，找不到则返回空 开放定址法的优缺点： 由上面可以看出拉链法比线性探测处理简单 线性探测查找是会被拉链法会更消耗时间 线性探测会更加容易导致扩容，而拉链不会 拉链存储了指针，所以空间上会比线性探测占用多一点 拉链是动态申请存储空间的，所以更适合链长不确定的 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:16:1","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"go中map的实现原理 在go1.16中，map也是数组存储的的，每个数组下标处存储的是一个bucket,这个bucket的类型见下面代码，每个bucket中可以存储8个kv键值对，当每个bucket存储的kv对到达8个之后，会通过overflow指针指向一个新的bucket，从而形成一个链表,看bmap的结构 // A bucket for a Go map. type bmap struct { // tophash generally contains the top byte of the hash value // for each key in this bucket. If tophash[0] \u003c minTopHash, // tophash[0] is a bucket evacuation state instead.即桶疏散状态 tophash [bucketCnt]uint8 // Followed by bucketCnt keys and then bucketCnt elems. // NOTE: packing all the keys together and then all the elems together makes the // code a bit more complicated than alternating key/elem/key/elem/... but it allows // us to eliminate padding which would be needed for, e.g., map[int64]int8. // Followed by an overflow pointer. } tophash用来快速查找key值是否在该bucket中，而不同每次都通过真值进行比较。 map[int64]int8,key是int64（8个字节），value是int8（一个字节），kv的长度不同，如果按照kv格式存放，则考虑内存对齐v也会占用int64，而按照后者存储时，8个v刚好占用一个int64 当往map中存储一个kv对时，通过k获取hash值，hash值的低八位和bucket数组长度取余，定位到在数组中的那个下标，hash值的高八位存储在bucket中的tophash中，用来快速判断key是否存在，key和value的具体值则通过指针运算存储，当一个bucket满时，通过overfolw指针链接到下一个bucket。 map的存储源码： // Like mapaccess, but allocates a slot for the key if it is not present in the map.如果key不在map里为其分配一个插槽（狭槽） func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer { if h == nil { panic(plainError(\"assignment to entry in nil map\")) } if raceenabled { callerpc := getcallerpc() pc := funcPC(mapassign) racewritepc(unsafe.Pointer(h), callerpc, pc) raceReadObjectPC(t.key, key, callerpc, pc) } if msanenabled { //获取hash算法 msanread(key, t.key.size) } if h.flags\u0026hashWriting != 0 { throw(\"concurrent map writes\") } //计算哈希值 hash := t.hasher(key, uintptr(h.hash0)) // Set hashWriting after calling t.hasher, since t.hasher may panic, // in which case we have not actually done a write. h.flags ^= hashWriting //如果bucket数组一开始为空，则初始化 if h.buckets == nil { h.buckets = newobject(t.bucket) // newarray(t.bucket, 1) } again: //定位在哪一个bucket中 bucket := hash \u0026 bucketMask(h.B) if h.growing() { growWork(t, h, bucket) } //得到bucket的结构体 b := (*bmap)(add(h.buckets, bucket*uintptr(t.bucketsize))) //获取高八位的哈希值 top := tophash(hash) var inserti *uint8 var insertk unsafe.Pointer var elem unsafe.Pointer bucketloop: //死循环 for { //循环bucket中的tophash数组 for i := uintptr(0); i \u003c bucketCnt; i++ { //如果hash不相等 if b.tophash[i] != top { //判断是否为空，为空则插入 if isEmpty(b.tophash[i]) \u0026\u0026 inserti == nil { inserti = \u0026b.tophash[i] insertk = add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize)) } //插入成功，终止外层循环 if b.tophash[i] == emptyRest { break bucketloop } continue } //高八位哈希值一样，获取已存在的kay k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) if t.indirectkey() { k = *((*unsafe.Pointer)(k)) } //判断两个key是否相等，不相等就循环下一个 if !t.key.equal(key, k) { continue } // already have a mapping for key. Update it. if t.needkeyupdate() { typedmemmove(t.key, k, key) } //获取已存在的value elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize)) goto done } //如果上一个bucket没能找到插入，则通过overflow获取链表上的下一个bucket ovf := b.overflow(t) if ovf == nil { break } b = ovf } // Did not find mapping for key. Allocate new cell \u0026 add entry. // If we hit the max load factor or we have too many overflow buckets, // and we're not already in the middle of growing, start growing. if !h.growing() \u0026\u0026 (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) { hashGrow(t, h) goto again // Growing the table invalidates everything, so try again } if inserti == nil { // The current bucket and all the overflow buckets connected to it are full, allocate a new one. newb := h.newoverflow(t, b) inserti = \u0026newb.tophash[0] insertk = add(unsafe.Pointer(newb), dataOffset) elem = add(insertk, bucketCnt*uintptr(t.keysize)) } // store new key/elem at insert position if t.indirectkey() { kmem := newobject(t.key) *(*unsafe.Pointer)(insertk) = kmem insertk = kmem } if t.indirectelem() { vmem := newobject(t.elem) *(*unsafe.Pointer)(elem) = vme","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:16:2","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"map与工厂模式 map的value可以是一个方法。 与 Go 的 Dock type 接⼝⽅式⼀起，可以⽅便的实现单⼀⽅法对象的⼯⼚模式 func TestMapWithFunValue(t *testing.T) { m := map[int]func(op int) int{} m[1] = func(op int) int { return op } m[2] = func(op int) int { return op * op } m[3] = func(op int) int { return op * op * op } t.Log(m[1](2), m[2](2), m[3](2)) } ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:16:3","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"set Go 的内置集合中没有 Set 实现， 可以 map[type]bool。 map可以保证添加元素的唯⼀性，方便判断唯一元素的个数 基本操作 添加元素 判断元素是否存在 删除元素 元素个数 func TestMapForSet(t *testing.T) { mySet := map[int]bool{} mySet[1] = true n := 3 if mySet[n] { t.Logf(\"%d is existing\", n) } else { t.Logf(\"%d is not existing\", n) } mySet[3] = true t.Log(len(mySet)) delete(mySet, 1) n = 1 if mySet[n] { t.Logf(\"%d is existing\", n) } else { t.Logf(\"%d is not existing\", n) } } ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:17:0","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"结构体 Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:18:0","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"类型别名和自定义类型 自定义类型（新类型）： //将MyInt定义为int类型 type MyInt int 可以基于内置的基本类型定义，也可以通过struct定义。 类型别名（Go1.9添加的新功能，注意编译后是原来的类型）： //将MyInt作为为int类型的昵称 type MyInt = int ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:18:1","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"结构体 本质上是一种聚合型的数据类型。 通过struct可以实现面向对象。 定义的时候，同样类型的字段也可以写在一行。 只有结构体被实例化时，才会真正被分配内存。 匿名结构体：定义临时数据结构时可能会用到。 语法糖：Go语言中支持对结构体指针直接使用.来访问结构体的成员，在使用new分配内存后得到的便是结构体指针。 使用\u0026对结构体进行取地址操作相当于对该结构体类型进行了一次new实例化操作。 p := \u0026person{} 初始化（没有指定初始值的字段的值就是该字段类型的零值）： p := person{ a: \"1a\", b: \"2b\", } //结构体指针 q := \u0026ss{ a: \"1a\", b: \"2b\", } //简写需注意三点：1.必须初始化结构体的所有字段。2.初始值的填充顺序必须与字段在结构体中的声明顺序一致。3.该方式不能和键值初始化方式混用。 s := \u0026d{ \"aq\", \"sw\", } 自己实现一个结构体构造函数： //值拷贝开销太大，返回结构体指针 func newPerson(name, city string, age int8) *person { return \u0026person{ name: name, city: city, age: age, } } ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:19:0","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"方法和接收者 Go语言中的方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者（Receiver）。接收者的概念就类似于其他语言中的this或者 self。 //接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名的第一个小写字母，而不是self、this之类的命名。例如，Person类型的接收者变量应该命名为 p，Connector类型的接收者变量应该命名为c等。 func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) { 函数体 } 指针类型的接收者： 指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的this或者self。 例如我们为Person添加一个SetAge方法，来修改实例变量的年龄。 // SetAge 设置p的年龄 // 使用指针接收者 func (p *Person) SetAge(newAge int8) { p.age = newAge } //调用该方法 func main() { p1 := NewPerson(\"测试\", 25) fmt.Println(p1.age) // 25 p1.SetAge(30) fmt.Println(p1.age) // 30 } 值类型的接收者： // SetAge2 设置p的年龄 // 使用值接收者 func (p Person) SetAge2(newAge int8) { p.age = newAge } func main() { p1 := NewPerson(\"测试\", 25) p1.Dream() fmt.Println(p1.age) // 25 p1.SetAge2(30) // (*p1).SetAge2(30) fmt.Println(p1.age) // 25 } 什么时候应该使用指针类型接收者： 需要修改接收者中的值 接收者是拷贝代价比较大的大对象 保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。 为任意类型添加方法： 在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的int类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。 注意事项：非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。 结构体的匿名字段： 结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。 匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。 嵌套结构体 一个结构体中可以嵌套包含另一个结构体或结构体指针。 嵌套结构体内部可能存在相同的字段名。这个时候为了避免歧义需要指定具体的内嵌结构体的字段。 结构体的继承： Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。 //Animal 动物 type Animal struct { name string } func (a *Animal) move() { fmt.Printf(\"%s会动！\\n\", a.name) } //Dog 狗 type Dog struct { Feet int8 *Animal //通过嵌套匿名结构体实现继承 } func (d *Dog) wang() { fmt.Printf(\"%s会汪\\n\", d.name) } func main() { d1 := \u0026Dog{ Feet: 4, Animal: \u0026Animal{ //注意嵌套的是结构体指针 name: \"旺财\", }, } d1.wang() //旺财会汪 d1.move() //旺财会动！ } 结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。 结构体与JSON序列化： JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键/值对组合中的键名写在前面并用双引号””包裹，使用冒号:分隔，然后紧接着值；多个键值之间使用英文,分隔。 //Student 学生 type Student struct { ID int Gender string Name string } //Class 班级 type Class struct { Title string Students []*Student } func main() { c := \u0026Class{ Title: \"101\", Students: make([]*Student, 0, 200), } for i := 0; i \u003c 10; i++ { stu := \u0026Student{ Name: fmt.Sprintf(\"stu%02d\", i), Gender: \"男\", ID: i, } c.Students = append(c.Students, stu) } //JSON序列化：结构体--\u003eJSON格式的字符串 data, err := json.Marshal(c) if err != nil { fmt.Println(\"json marshal failed\") return } fmt.Printf(\"json:%s\\n\", data) //JSON反序列化：JSON格式的字符串--\u003e结构体 str := `{\"Title\":\"101\",\"Students\":[{\"ID\":0,\"Gender\":\"男\",\"Name\":\"stu00\"},{\"ID\":1,\"Gender\":\"男\",\"Name\":\"stu01\"},{\"ID\":2,\"Gender\":\"男\",\"Name\":\"stu02\"},{\"ID\":3,\"Gender\":\"男\",\"Name\":\"stu03\"},{\"ID\":4,\"Gender\":\"男\",\"Name\":\"stu04\"},{\"ID\":5,\"Gender\":\"男\",\"Name\":\"stu05\"},{\"ID\":6,\"Gender\":\"男\",\"Name\":\"stu06\"},{\"ID\":7,\"Gender\":\"男\",\"Name\":\"stu07\"},{\"ID\":8,\"Gender\":\"男\",\"Name\":\"stu08\"},{\"ID\":9,\"Gender\":\"男\",\"Name\":\"stu09\"}]}` c1 := \u0026Class{} err = json.Unmarshal([]byte(str), c1) if err != nil { fmt.Println(\"json unmarshal failed!\") return } fmt.Printf(\"%#v\\n\", c1) } 结构体标签Tag: Tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 Tag在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下： `key1:\"value1\" key2:\"value2\"` 结构体标签由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。键值对之间使用一个空格分隔。 注意事项： 为结构体编写Tag时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。 例如我们为Student结构体的每个字段定义json序列化时使用的Tag： //Student 学生 type Student struct { ID int `json:\"id\"` //通过指定tag实现json序列化该字段时的key Gender string //json序列化是默认使用字段名作为key name string //私有不能被json包访问 } func main() { s1 := Student{ ID: 1, Gender: \"女\", name: \"pprof\", } data, err := json.Marshal(s1) if err != nil { fmt.Println(\"json marshal failed!\") return } fmt.Printf(\"json str:%s\\n\", data) //json str:{\"id\":1,\"Gender\":\"女\"} } ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:19:1","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["Go"],"content":"参考 https://cloud.tencent.com/developer/article/1526095 https://www.topgoer.cn/docs/golang/chapter02 ","date":"2021-11-09 20:55:59","objectID":"https://qizhengzou.github.io/go_base_01/:20:0","tags":["go grammar"],"title":"Go_base_01","uri":"https://qizhengzou.github.io/go_base_01/"},{"categories":["School courses"],"content":" 笔记来自哈工大深圳2021秋数据库系统理论课授课老师：刘圣鑫 事务处理 ","date":"2021-11-09 11:28:55","objectID":"https://qizhengzou.github.io/mysql_base_13/:0:0","tags":["mysql"],"title":"Mysql_base_13","uri":"https://qizhengzou.github.io/mysql_base_13/"},{"categories":["School courses"],"content":"为什么需要并发控制 并发控制的缘由: 并发控制及相应的事务处理技术是DBMS的核心技术: ","date":"2021-11-09 11:28:55","objectID":"https://qizhengzou.github.io/mysql_base_13/:1:0","tags":["mysql"],"title":"Mysql_base_13","uri":"https://qizhengzou.github.io/mysql_base_13/"},{"categories":["School courses"],"content":"事务调度及可串行性 事务是数据库管理系统提供的控制数据操作的一种手段，通过这一手段，应用程序员将一系列的数据库操作组合在一起作为一个整体进行操作和控制，以便数据库管理系统能够提供一致性状态转换的保证. 事务的宏观性和微观性: 事务的宏观性(应用程序员看到的事务): 一个存取或改变数据库内容的 程序的一次执行，或者说一条或多条SQL语句的一次执行被看作一个事务。事务一般是由应用程序员提出，因此有开始和结束, 结束前需要提交或撤消。 在嵌入式SQL程序中，任何一条数据库操纵语句(如exec sql select等)都会引发一个新事务的开始，只要该程序当前没有正在处理的事务。而事务的结束是需要应用程序员通过commit或rollback确认的。因此Begin Transaction 和End Transaction两行语句是不需要的 Begin Transaction exec sql … … exec sql … exec sql commit work | exec sql rollback work End Transaction 事务的微观性(DBMS看到的事务): 对数据库的一系列基本操作(读、 写)的一个整体性执行.事务的并发执行：多个事务从宏观上看是并行执行的，但其微观上的基本操作(读、写)则可以是交叉执行的 事务的特性: ACID 原子性Atomicity : DBMS能够保证事务的一组更新操作是原子不可分的，即对 DB而言，要么全做，要么全不做。 一致性Consistency: DBMS保证事务的操作状态是正确的，符合一致性的操作 规则，不能出现三种典型的不一致性。它是进一步由隔离性来保证的。 隔离性Isolation: DBMS保证并发执行的多个事务之间互相不受影响。例如两个事务T1和T2, 即使并发执行，也相当于或者先执行了T1,再执行T2;反之亦然。 持久性Durability: DBMS保证已提交事务的影响是持久的，被撤销事务的影响是可恢复的 具有ACID特性的若干数据库基本操作的组合体被称为事务 DBMS对事务的控制: 事务调度与可串行性: 事务调度(schedule)：一组事务的基本步(读、写、其他控制操作如加锁、解锁等)的一种执行顺序称为对这组事务的一个调度。 并发(或并行)调度：多个事务从宏观上看是并行执行的，但其微观上的基本 操作(读、写)则是交叉执行的。 并发调度的正确性：当且仅当在这个并发调度下所得到的新数据库结果与分别串行地运行这些事务所得的新数据库完全一致，则说调度是正确的。 可串行性：如果不管数据库初始状态如何，一个调度对数据 库状态的影响都和某个串行调度相同，则我们说这个调度是可串行化的 (Serializable)或具有可串行性(Serializability)。 可串行化调度一定是正确的并行调度，但正确的并行调度，却未必都是可串行化的调度。 并行调度的正确性是指内容上结果正确性，而可串行性是指形式上结果正确性，便于操作(如右侧图T2中的B=B-20改为B=B-0,则调度是正确的，但是不可串行化) 可串行化的等效串行序列不一定唯一。 一种简单的事务调度的标记模型,表达事务调度的一种模型 rT(A): 事务T读A。 wT(A)：事务T写A 冲突可串行性 冲突：调度中一对连续的动作：如果它们的顺序交换，那么涉及的事务中至少有一个事务的行为会改变。 有冲突的两个操作是不能交换次序的，没有冲突的两个事务是可交换的 几种冲突的情况： 冲突可串行性： 一个调度，如果通过交换相邻两个无冲突的操作能够转换到某一个串行的调度，则称此调度为冲突可串行化的调度 冲突可串行性是比可串行性要严格的概念 满足冲突可串行性，一定满足可串行性；反之不然 冲突可串行性判别算法 并发调度的正确性：当且仅当在这个并发调度下所得到的新数据库结果与 分别串行地运行这些事务所得的新数据库完全一致，则说调度是正确的。 并发调度的正确性 ⊇ 可串行性 ⊇ 冲突可串行 算法表达 冲突可串行性判别算法 构造一个前驱图(有向图) 结点是每一个事务Ti。如果Ti的一个操作与Tj的一个操作发生冲突，且Ti在Tj前执行，则绘制一条边，由Ti指向Tj, 表征Ti要在Tj前执行。 测试检查: 如果此有向图没有环，则是冲突可串行化的! ","date":"2021-11-09 11:28:55","objectID":"https://qizhengzou.github.io/mysql_base_13/:2:0","tags":["mysql"],"title":"Mysql_base_13","uri":"https://qizhengzou.github.io/mysql_base_13/"},{"categories":["School courses"],"content":"基于封锁的并发控制方法 基于封锁的并发控制方法： 并发调度的正确性：当且仅当在这个并发调度下所得到的新数据库结果与分别串行地运行这些事务所得的新数据库完全一致，则说调度是正确的。 并发调度的正确性 ⊇ 可串行性 ⊇ 冲突可串行性 什么是锁 “锁”是控制并发的一种手段 每一数据元素都有一唯一的锁 每一事务读写数据元素前，要获得锁。 如果被其他事务持有该元素的锁，则要等待。 事务处理完成后要释放锁。 Li(A) : 事务Ti对数据元素A加锁 Ui(A) : 事务Ti对数据元素A解锁 锁本身并不能保证冲突可串行性。 锁为调度提供了控制的手段。但如何用锁，仍需说明。—不同的协议 封锁协议需要考虑什么 封锁协议之锁的类型 排他锁X (exclusive locks) 只有一个事务能读、写，其他任何事务都不能读、写 共享锁S (shared locks) 所有事务都可以读，但任何事务都不能写 更新锁U (Update locks) 初始读，以后可升级为写 增量锁I (Incremental lock) 增量更新(例如A=A+x) 区分增量更新和其他类型的更新 封锁协议之相容性矩阵 当某事务对一数据对象持有一种锁时，另一事务再申请对该对象加某一类型的锁，是允许(是)还是不允许(否) 封锁协议需要考虑什么? 封锁协议之加锁/解锁时机 SQL之隔离性级别(允许程序员选择使用) 读未提交(read uncommitted) 读已提交(read committed) 可重复读(repeatable read) 可串行化(serializable) 封锁协议之封锁粒度(LOCKING GRANULARITY) 封锁粒度是指封锁数据对象的大小。 粒度单位：属性值-\u003e元组-\u003e元组集合-\u003e整个关系-\u003e整个DB某索引项-\u003e整个索引 由前往后:并发度小，封锁开销小 由后往前:并发度大，封锁开销也 封锁协议需要考虑: 封锁的类型 封锁的粒度 相容性矩阵 封锁的时机 衍生出不同的封锁协议： 两段封锁协议 是一种基于锁的控制方法 读写数据之前要获得锁。每个事务中所有封锁请求先于任何一个解锁请求 两阶段：加锁段，解锁段。加锁段中不能有解锁操作，解锁段中不能有加锁操作 两段封锁协议是可以保证冲突可串行性的！ 两段锁协议是可能产生“死锁”的协议！ ","date":"2021-11-09 11:28:55","objectID":"https://qizhengzou.github.io/mysql_base_13/:3:0","tags":["mysql"],"title":"Mysql_base_13","uri":"https://qizhengzou.github.io/mysql_base_13/"},{"categories":["School courses"],"content":"基于时间戳的并发控制方法 基于时间戳的并发控制方法： 时间戳(TIMESTAMP) 一种基于时间的标志，将某一时刻转换成的一个数值。 时间戳具有唯一性和递增性。 事务的时间戳 事务T启动时，系统将该时刻赋予T，为T的时间戳 时间戳可以表征一系列事务执行的先后次序： 时间戳小的事务先执行，时间戳大的事务后执行。 利用时间戳，可以不用锁，来进行并发控制 基于时间戳的并发控制： 借助于时间戳，强制使一组并发事务的交叉执行，等价于一个特定顺序的串行执行。 特定顺序：时间戳由小到大 如何强制：执行时判断冲突 如无冲突，予以执行； 如有冲突，则撤销事务，并重启该事务，此时该事务获得了一个更大的时间戳，表明是后执行的事务。 有哪些冲突： 读-读无冲突； 读-写或写-读冲突； 写-写冲突 基于时间戳的简单调度规则 对DB中的每个数据元素x，系统保留其上的最大时间戳 RT(x): 即R-timestamp(x) 读过该数据事务中最大的时间戳，即最后读x的事务的时间戳。 WT(x): 即W-timestamp(x) 写过该数据事务中最大的时间戳，即最后写x的事务的时间戳。 事务的时间戳 TS(T): 即TimeStam 基于时间戳的另一种调度规则 需要解决的问题：如何放行一些事实上可实现的冲突?—托马斯写规则 对DB中的每个数据元素x，系统保留其上的最大时间戳 RT(x): 即R-timestamp(x) 读过该数据事务中最大的时间戳，即最后读x的事务的时间戳。 WT(x): 即W-timestamp(x) 写过该数据事务中最大的时间戳，即最后写x的事务的时间戳。 C(x): x的提交位。 -该位为真，当且仅当最近写x的事务已经提交。C(x)的目的是避免出现事务读另一事务U所写数据然后U终止这样的情况。 事务的时间戳 TS(T): 即TimeStamp 对来自事务T的读写请求，调度器可以： 同意请求 撤销/终止T，并重启具有新时间戳的T(终止+重启，被称回滚) 推迟T，并在以后决定是终止T还是同意请求(如果请求是读，且此读可能是脏的 调度规则 假设调度器收到请求rT(X) (1)如果TS(T)\u003e=WT(x), 此读是事实上可实现的 如C(x)为真，同意请求。如果TS(T)\u003eRT(x), 置RT(x):=TS(T); 否则不改变RT(x). 如C(x)为假，推迟Ｔ直到C(x)为真或写x的事务终止。 (2)如果TS(T) \u003c WT(x), 此读是事实上不可实现的 回滚T(终止并重启T)；(过晚的读) 假设调度器收到请求wT(X) (1)如果TS(T)\u003e=RT(x), 且TS(T)\u003e=WT(x), 此写是事实上是可实现的 为x写入新值；置WT(x):=TS(T)；置C(x):=false. (2)如果TS(T)\u003e=RT(x),但是TS(T)\u003c WT(x)，此写是事实上可实现的。但x已经有一个更晚的值 如果C(x)为真，那么前一个x的写已提交；则忽略T的写；继续进行。(托马斯写规则) 如果C(x)为假，则我们需推迟T，直到C(x)为真或写x的事务终止。 (3)如果TS(T)\u003c RT(x), 此写是事实上不可实现的 T必须回滚。(过晚的写) 假设调度器收到提交T的请求。 它必须找到T所写的所有数据库元素x, 并置C(x):=true。 如果有任何等待x被提交的事务，这些事务就被允许继续进行。 假设调度器收到终止T的请求 像前述步骤一样确定回滚T。那么任何等待T所写元素x的事务必须重新尝试读或写，看这一动作现在T的写被终止后是否合法。 ","date":"2021-11-09 11:28:55","objectID":"https://qizhengzou.github.io/mysql_base_13/:4:0","tags":["mysql"],"title":"Mysql_base_13","uri":"https://qizhengzou.github.io/mysql_base_13/"},{"categories":["School courses"],"content":"基于有效性确认的并发控制方法 基于有效性确认的并发控制方法: 基于时间戳的并发控制的思想 事务在启动时刻被赋予唯一的时间戳，以示其启动顺序。 为每一数据库元素保存读时间戳和写时间戳，以记录读或写该数据元素的最后的事务。 通过在事务读写数据时判断是否存在冲突(读写冲突、写读冲突、写写冲突)来强制事务以可串行化的方式执行。 基于有效性确认的并发控制的思想 事务在启动时刻被赋予唯一的时间戳，以示其启动顺序。 为每一活跃事务保存其读写数据的集合，RS(T)：事务T读数据的集合； WS(T)：事务T写数据的集合。 通过对多个事务的读写集合，判断是否有冲突(存在事实上不可实现的行为)，即有效性确认，来完成事务的提交与回滚，强制事务以可串行化的方式执行。 基于有效性确认的调度器 事务在启动时刻被赋予唯一的时间戳，以示其启动顺序。 每一事务读写数据的集合，RS(T)：事务T读数据的集合；WS(T)：事务T 写数据的集合。 事务分三个阶段进行 读阶段。事务从数据库中读取读集合中的所有元素。事务还在其局部地址空间计算它将要写的所有值； 有效性确认阶段。调度器通过比较该事务与其它事务的读写集合来确认该事务的有效性。 写阶段。事务往数据库中写入其写集合中元素的值。 每个成功确认的事务是在其有效性确认的瞬间执行的。 并发事务串行的顺序即事务有效性确认的顺序。 调度器维护三个集合 START集合。已经开始但尚未完成有效性确认的事务集合。对此 集合中的事务，调度器维护START(T)，即事务T开始的时间。 VAL集合。已经确认有效性但尚未完成第3阶段写的事务。对此集 合中的事务，调度器维护START(T)和VAL(T)，即T确认的时间。 FIN集合。已经完成第3阶段的事务。对这样的事务T, START(T), VAL(T)和FIN(T)，即T完成的时间。 有效性确认规则: 冲突一：假设存在事务U 和 T满足： (1)U 在VAL或FIN中, 即U已经过有效性确认。 (2)FIN(U)\u003eSTART(T), 即U在T开始前没有完成。 (3)RS(T) ∩ WS(U)非空, 特别地，设其均包含数据库元素为x。则T和U的执行存在冲突，T不应进行有效性确认 如果一个较早的事务U现在正在写入T应该读过的某些对象，则T的有效性不能确认 冲突二：假设存在事务U 和T 满足: (1)U 在VAL, 即U有效性已经成功确认。 (2)FIN(U)\u003eVAL(T), 即U在T进入其有效性确认阶段以前没有完成。 (3)WS(T)∩WS(U)非空, 特别地，设其均包含数据库元素x。 则T和U的执行存在冲突，T不应进行有效性确认 如果T在有效性确认后可能比一个较早的事务先写某个对象，则T的有效性不能确认 有效性确认规则 (1)对于所有已经过有效性确认, 且在T开始前没有完成的U, 即对于满足FIN(U)\u003eSTART(T)的U,检测:RS(T) ∩ WS(U)是否为空。若为空，则确认。否则，不予确认。 (2)对于所有已经过有效性确认，且在T有效性确认前没有完成的U, 即对于满足FIN(U)\u003eVAL(T)的U, 检测：WS(T) ∩ WS(U)是否为空。若为空，则确认。否则，不予确认。 U的有效性确认 无需检测，直接确认U。 T的有效性确认因FIN(U)\u003eSTART(T), 需检测RS(T) ∩ WS(U) 因FIN(U)\u003eVAL(T),需检测WS(T) ∩ WS(U) 检测结果：均为空，则确认T。 V的有效性确认 因FIN(U)\u003eSTART(V), 需检测RS(V) ∩ WS(U) 因FIN(T)\u003eSTART(V),需检测RS(V) ∩ WS(T) 因FIN(T)\u003eVAL(V),需检测WS(T) ∩ WS(V)检测结果：均为空，则确认V。 W的有效性确认 因FIN(T)\u003eSTART(W), 需检测RS(W) ∩ WS(T) 因FIN(V)\u003eSTART(W),需检测RS(W) ∩ WS(V) 因FIN(V)\u003eVAL(W),需检测WS(V) ∩ WS(W) 检测结果：不全为空,则W不能确认,W被回滚。 ","date":"2021-11-09 11:28:55","objectID":"https://qizhengzou.github.io/mysql_base_13/:5:0","tags":["mysql"],"title":"Mysql_base_13","uri":"https://qizhengzou.github.io/mysql_base_13/"},{"categories":["School courses"],"content":"总结 ","date":"2021-11-09 11:28:55","objectID":"https://qizhengzou.github.io/mysql_base_13/:6:0","tags":["mysql"],"title":"Mysql_base_13","uri":"https://qizhengzou.github.io/mysql_base_13/"},{"categories":["School courses"],"content":" 笔记来自哈工大深圳2021秋数据库系统理论课授课老师：刘圣鑫 数据查询优化 在建表和建索引的时候，要更有意识地为将来的查询优化做综合考虑，比如确定是否使用递增主键、主键的列怎样选择，等等。 ","date":"2021-11-09 11:28:51","objectID":"https://qizhengzou.github.io/mysql_base_12/:0:0","tags":["mysql"],"title":"Mysql_base_12","uri":"https://qizhengzou.github.io/mysql_base_12/"},{"categories":["School courses"],"content":"为什么要及什么是查询优化? 为什么需要查询优化: 关系数据库的执行效率问题 关系代数操作执行次序对效率的影响 什么是查询优化 “如何使数据库查询的执行时间最短？” 三个层面进行优化： 语义优化：利用模型的语义及完整性规则，优化查询。 语法优化—逻辑层优化：利用语法结构，优化操作执行顺序； 执行优化—物理层优化：存取路径和执行算法的选择与执行次序优化； ","date":"2021-11-09 11:28:51","objectID":"https://qizhengzou.github.io/mysql_base_12/:1:0","tags":["mysql"],"title":"Mysql_base_12","uri":"https://qizhengzou.github.io/mysql_base_12/"},{"categories":["School courses"],"content":"查询优化的基本思路 查询优化的总体思路 语义优化—内容等价性 语法优化(逻辑层优化)—语法等价性：基本思想：改变关系代数的操作次序：尽可能早做选择和投影运算 执行优化(物理层优化) 在DBMS中的位置 简要回顾 ","date":"2021-11-09 11:28:51","objectID":"https://qizhengzou.github.io/mysql_base_12/:2:0","tags":["mysql"],"title":"Mysql_base_12","uri":"https://qizhengzou.github.io/mysql_base_12/"},{"categories":["School courses"],"content":"逻辑查询优化 一个待优化的示例背景： 用语法树表达关系代数表达式: 逻辑层优化策略: (1)尽可能地早做选择和投影：可使中间结果变小，节省几个数量级的执行时间。 (2)把选择与投影串接起来：一元运算序列可一起执行，只需对整个关系扫描一遍。 (3)把投影与其前或后的二元运算结合起来：在第一次用关系时去掉一些无关属性，可以避免多次扫描整个关系。 (4)把某些选择与其前的笛卡尔积合并成一个连接：当R×S前有选择运算且其中有条件是R、S属性间比较的运算时，可将其转化为连接运算可节省时间。 (5)执行连接运算前对关系做适当预处理：文件排序、建立临时索引等，可使两关系公共值高效联接。 (6)找出表达式里的公共子表达式：若公共子表达式结果不大，则预先计算，以后可读入此结果，节时多，尤当视图情况下有用。 关系代数操作次序交换的等价性: “哪些关系代数操作能够交换次序” 什么是关系操作次序交换的等价性? [定义] 设E1, E2是两个关系操作表达式。若E1, E2表示相同的映射，即当E1, E2的同名变量代入相同关系后产生相同的结果(映像集合)，则说E1, E2是等价的，记为E1 = E2 哪些关系操作次序可以交换? 定理L1：连接与连接，积与积的交换律 设E1, E2是关系代数表达式， F是E1, E2中属性的附加限制条件，则有： 定理L2：连接与连接、积和积的结合律若E1, E2, E3是关系代数表达式，F1，F2是条件，则有： 定理L3：投影串接律 定理L4：选择串接律 若E是关系代数表达式，F1, F2是条件，则有： 定理L5：选择和投影交换律 定理L6：选择和积的交换律 定理L7：投影和积的交换律 定理L8：选择和并的交换律 定理L9：选择和差的交换律 L10：投影和并的交换律 基于关系代数的查询优化算法及示例 略 ","date":"2021-11-09 11:28:51","objectID":"https://qizhengzou.github.io/mysql_base_12/:3:0","tags":["mysql"],"title":"Mysql_base_12","uri":"https://qizhengzou.github.io/mysql_base_12/"},{"categories":["School courses"],"content":"物理查询优化 为什么要物理查询优化？ 物理查询优化—总体思路 如何衡量一个物理查询计划的好与坏? DBMS如何衡量物理查询计划的优劣呢？ 衡量I/O访问次数 衡量CPU的占用时间 内存使用代价(与缓冲区数目与大小的匹配) 中间结果存储代价 计算量(如搜索记录、合并记录、排序记录、字段值的计算等) 网络通信量 …… 依据什么信息判断物理查询计划的好与坏 如何收集这些信息? 当一个表装入内存和创建索引的时候，统计信息不是被自动收集的，必须由DBA使用特定的命令来完成信息统计，这些命令就是收集统计信息并把其存入系统目录中的实用程序 随着表的更新操作，统计信息可能会过时，过时的统计信息会使DBMS确定方案时决策错误，因此要求DBA定期的对有频繁更新操作的Table进行统计 DBA要熟悉统计信息收集命令的使用，并定期执行 IBM DB2使用Runstats收集统计信息 RUNSTATS ON TABLE username.tablename [ WITH DISTRIBUTION [ AND DETAILED ] { INDEXES ALL | INDEX indexname ]; 例如，收集SCT数据库的Student表的统计信息 Runstats on table SCT.student; Oracle使用Analyze命令收集统计信息并将其放入系统表中 ANALYZE { INDEX | TABLE | CLUSTER }{ indexname | tablename | clustername } COMPUTE STATISTICS { FOR TABLE | FOR ALL [ INDEXED ] COLUMNS [SIZE n] }; 例如，收集SCT数据库的Student表的统计信息 Analyze table student compute statistics for table ; 代价估算 什么是代价估算? 投影运算的代价估算? 不同选择运算的代价估算? 代价估计简要结论 ","date":"2021-11-09 11:28:51","objectID":"https://qizhengzou.github.io/mysql_base_12/:4:0","tags":["mysql"],"title":"Mysql_base_12","uri":"https://qizhengzou.github.io/mysql_base_12/"},{"categories":["School courses"],"content":" 笔记来自哈工大深圳2021秋数据库系统理论课授课老师：刘圣鑫 数据库查询实现算法 ","date":"2021-11-09 11:28:46","objectID":"https://qizhengzou.github.io/mysql_base_11/:0:0","tags":["mysql"],"title":"Mysql_base_11","uri":"https://qizhengzou.github.io/mysql_base_11/"},{"categories":["School courses"],"content":"数据库查询实现算法-I ","date":"2021-11-09 11:28:46","objectID":"https://qizhengzou.github.io/mysql_base_11/:1:0","tags":["mysql"],"title":"Mysql_base_11","uri":"https://qizhengzou.github.io/mysql_base_11/"},{"categories":["School courses"],"content":"数据库查询实现算法概述 查询实现\u0026查询优化： 查询实现算法总览： ","date":"2021-11-09 11:28:46","objectID":"https://qizhengzou.github.io/mysql_base_11/:1:1","tags":["mysql"],"title":"Mysql_base_11","uri":"https://qizhengzou.github.io/mysql_base_11/"},{"categories":["School courses"],"content":"以连接操作为例看逻辑实现算法与物理实现算法 连接操作的逻辑实现算法： 物理算法需要考虑：关系是存储在磁盘上的，磁盘是以磁盘块为操作单位，首先要被装载进内存(I/O操作)，然后再进行元组的处理 连接操作的基本实现算法： 连接操作的全主存实现算法： 连接操作的半主存实现算法： 连接操作的大关系实现算法： 连接操作的其他物理实现算法： 表空间扫描法 基本实现算法P1 适用于任何情况：3块内存即可，但算法复杂性高: BR + BR * BS 全主存实现算法P2 要求内存能够完全装载两个关系。算法复杂性低：BR + BS 半主存实现算法P3 要求内存能够完全装载一个关系。算法复杂性低：BR + BS 大关系实现算法P4 适用于任何情况，尤其是大关系情况下比算法P1好。 算法复杂性低：BR(BS/(M-2)) + BS 归并排序(Sort-Merge)连接算法P5 散列连接(Hash连接)算法P6 索引连接算法P7 ","date":"2021-11-09 11:28:46","objectID":"https://qizhengzou.github.io/mysql_base_11/:1:2","tags":["mysql"],"title":"Mysql_base_11","uri":"https://qizhengzou.github.io/mysql_base_11/"},{"categories":["School courses"],"content":"利用迭代器构造查询实现算法 例如： 迭代器算法流水线计算策略： 迭代器：迭代的读取一个集合中的每一个元素，而封装其读取细节 有一个抽象类： class iterator { void Open(); tuple GetNext(); void Close(); iterator \u0026inputs[]; } 所有关系操作可继承此迭代器进行构造。不同操作，可以构造不同的Open(),GetNext(), Close()函数 迭代器的构造,迭代器示例： 表空间扫描法— 读取关系–R: Open() { b := R的第一块； t := b的第一个元组； } GetNext() { IF ( t 已超过块b的最后一个元组 ） { 将b前进到下一块 IF (没有下一块) RETURN NotFound; ELSE /* b是一个新块 */ t := b的第一个元组； } oldt := t; 将t前进到b的下一元组； RETURN t； } Close() { } SELECTION(R): Open() { R.Open(); } GetNext() { Cont: t:=R.GetNext(); IF (t\u003c\u003e NotFound) IF F(t) == TRUE RETURN t; ELSE GOTO Cont; ELSE RETURN NotFound; } Close() { R.Close(); } PROJECTION(SELECTION(R)): Open() { SELECTION.Open(); } GetNext() { t:= SELECTION.GetNext(); IF (t\u003c\u003e NotFound) { p := PROJECTION(t, ) RETURN p; } ELSE RETURN NotFound; } Close() { SELECTION.Close(); } R Join S: Open() { R.Open(); S.Open(); r:= R.GetNext(); } GetNext() { REPEAT{ s:= S.GetNext(); IF ( s == NotFound ） { S.Close(); r: = R.GetNext(); IF (r == NotFound) RETURN NotFound; ELSE { S.Open(); s := S.GetNext(); } } } UNTIL (r与s能够连接); RETURN r和s的连接； } Close() { R.Close(); S.Close(); } ","date":"2021-11-09 11:28:46","objectID":"https://qizhengzou.github.io/mysql_base_11/:1:3","tags":["mysql"],"title":"Mysql_base_11","uri":"https://qizhengzou.github.io/mysql_base_11/"},{"categories":["School courses"],"content":"几个关系操作的一趟扫描算法 关系/表数据的读取—完整地读取一个关系（B(R)是R的存储块数目 T(R)是R的元组数目） 聚簇关系—关系的元组集中存放(一个块中仅是一个关系中的元组): TableScan(R) —表空间扫描算法 扫描结果未排序: B(R) SortTableScan(R) 扫描结果排序: 3B(R) IndexScan(R)—索引扫描算法 扫描结果未排序: B(R) SortIndexScan(R) 扫描结果排序: B(R) or 3B 非聚簇关系—关系的元组不一定集中存放(一个块中不仅是一个关系中的元组): 扫描结果未排序: T(R) 扫描结果排序: T(R) + 2B(R 整个关系的一元操作实现算法 去重复：\u0026(R) 需要在内存中保存已处理过的元组 当新元组到达时，需与之前处理过的元组进行比较 建立不同的内存数据结构，来保存之前处理过的数据，以便快速处理整个关系上的操作 算法复杂性：B(R) 应用条件：B(\u0026(R))\u003c=M-2 分组聚集Y L(R) 需要在内存中保存所有的分组 保存每个分组上的聚集信息 建立不同的内存数据结构(建立内存数据结构，以快速定位一个元组，如排序结构/散列结构/B+树等)，来保存之前处理过的数据，以便快速处理整个关系上的操作 算法复杂性：B(R) 应用条件：所有分组的数量应能在内存中完整保存 整个关系的二元操作实现算法 集合上的操作(并交差) 扫描一个关系，然后再扫描另一个关系 集合的操作需要去重复 算法复杂性：B(R)+B(S) 应用条件：min(B(R), B(S))\u003c=M-2 ","date":"2021-11-09 11:28:46","objectID":"https://qizhengzou.github.io/mysql_base_11/:1:4","tags":["mysql"],"title":"Mysql_base_11","uri":"https://qizhengzou.github.io/mysql_base_11/"},{"categories":["School courses"],"content":"基于索引的算法 基于索引的选择算法 选择条件中有涉及到索引属性时，可以使用索引，辅助快速检索； 在某些属性上存在着索引，可能在多个属性上都存在着索引； 聚簇和非聚簇索引，使用时其效率是不一样的。 如何通过索引来判断范围性的条件？ 索引应用分析示例 基于有序索引的连接算法–Zig-Zag连接算法 ","date":"2021-11-09 11:28:46","objectID":"https://qizhengzou.github.io/mysql_base_11/:1:5","tags":["mysql"],"title":"Mysql_base_11","uri":"https://qizhengzou.github.io/mysql_base_11/"},{"categories":["School courses"],"content":"总结 ","date":"2021-11-09 11:28:46","objectID":"https://qizhengzou.github.io/mysql_base_11/:1:6","tags":["mysql"],"title":"Mysql_base_11","uri":"https://qizhengzou.github.io/mysql_base_11/"},{"categories":["School courses"],"content":"数据库查询实现算法-II ","date":"2021-11-09 11:28:46","objectID":"https://qizhengzou.github.io/mysql_base_11/:2:0","tags":["mysql"],"title":"Mysql_base_11","uri":"https://qizhengzou.github.io/mysql_base_11/"},{"categories":["School courses"],"content":"为什么需要两趟算法? 整个关系操作存在的问题? 两趟算法的基本思路? ","date":"2021-11-09 11:28:46","objectID":"https://qizhengzou.github.io/mysql_base_11/:2:1","tags":["mysql"],"title":"Mysql_base_11","uri":"https://qizhengzou.github.io/mysql_base_11/"},{"categories":["School courses"],"content":"两阶段多路归并排序TPMMS 内排序和外排序问题 内排序问题: 待排序的数据可一次性地装入内存中，即排序者可以完整地看到和操纵所有数据。内存中数据的排序算法：插入排序算法、选择排序算法、冒泡排序算法…。 外排序问题: 待排序的数据不能一次性装入内存，即排序者不能一次完整地看到和操纵所有数据，需要将数据分批装入内存分批处理的排序问题； 外排序问题分析 算法基本思想 ","date":"2021-11-09 11:28:46","objectID":"https://qizhengzou.github.io/mysql_base_11/:2:2","tags":["mysql"],"title":"Mysql_base_11","uri":"https://qizhengzou.github.io/mysql_base_11/"},{"categories":["School courses"],"content":"基于排序的两趟扫描算法 去重复操作 分组聚集操作 基于排序的并、交和差 对于集合差：R - S，当且仅当t出现在R中但不出现在S中时输出 基于排序的连接运算 第一趟：划分R和S的子表并进行子表排序，排序均基于Y属性排序。 第二趟：归并时注意是R的输入还是S的输入。R和S的两路输入之间进行连接检查并连接后输出。 “排序-连接”算法，“归并-连接”算法，“排序-归并-连接”算法 SORT-JOIN， MERGE-JOIN， SORT-MERGE-JOIN ","date":"2021-11-09 11:28:46","objectID":"https://qizhengzou.github.io/mysql_base_11/:2:3","tags":["mysql"],"title":"Mysql_base_11","uri":"https://qizhengzou.github.io/mysql_base_11/"},{"categories":["School courses"],"content":"基于散列的两趟扫描算法 基本思想 去重复操作 分组聚集操作 基于散列的并、交和差操作 基于散列的连接操作 ","date":"2021-11-09 11:28:46","objectID":"https://qizhengzou.github.io/mysql_base_11/:2:4","tags":["mysql"],"title":"Mysql_base_11","uri":"https://qizhengzou.github.io/mysql_base_11/"},{"categories":["School courses"],"content":"总结 ","date":"2021-11-09 11:28:46","objectID":"https://qizhengzou.github.io/mysql_base_11/:2:5","tags":["mysql"],"title":"Mysql_base_11","uri":"https://qizhengzou.github.io/mysql_base_11/"},{"categories":["School courses"],"content":" 笔记来自哈工大深圳2021秋数据库系统理论课授课老师：刘圣鑫 数据库索引 ","date":"2021-11-09 11:28:43","objectID":"https://qizhengzou.github.io/mysql_base_10/:0:0","tags":["mysql"],"title":"Mysql_base_10","uri":"https://qizhengzou.github.io/mysql_base_10/"},{"categories":["School courses"],"content":"为什么需要索引与什么是索引 索引：定义在存储表(Table)基础之上，无需检查所有记录，快速定位所需记录的一种辅助存储结构，由一系列存储在磁盘上的索引项(index entries)组成，每一索引项又由两部分构成: 索引字段：由Table中某些列(通常是一列)中的值串接而成。索引中通常存储了索引字段的每一个值(也有不是这样的)。索引字段类似于词典中的词条。 行指针：指向Table中包含索引字段值的记录在磁盘上的存储位置。行指针类似于词条在书籍、词典中出现的页码 存储索引项的文件为索引文件，相对应，存储表又称为主文件 索引一般性特点: 索引文件是一种辅助存储结构，其存在与否不改变存储表的物理存储结构；目的提高存储表的访问速度。 索引文件组织方式有两种：(相对照的，主文件组织有堆文件、排序文件、散列文件、聚簇文件等多种方式) 排序索引文件(Ordered indices): 按索引字段值的某一种顺序组织存储 散列索引文件(Hash indices): 依据索引字段值使用散列函数分配散列桶的方式存储 在一个表上，可针对不同属性或属性组合，建立不同的索引文件，可建立多个索引文件。（索引字段的值可以是Table中的任何一个属性的值或任何多个属性值的组合值） 索引文件比主文件小很多。通过检索一个小的索引文件(可全部装载进内存)，快速定位后，再有针对性的读取非常大的主文件中的有关记录 有索引时，更新操作必须同步更新索引文件和主文件。 索引技术应用使检索效率大幅度提高，但同时其也增加了存储空间、使维护负担加重(不仅要维护主文件，而且要维护索引文件) 衡量索引性能好坏： 访问时间 插入时间 删除时间 空间负载 支持存取的有效性, 比如：支持的是属性的限定值(是否符合单一值)，还是支持属性的限定范围的值(是否符合一定范围) SQL语言关于索引的基本知识 当定义Table后，如果定义了主键，则系统将自动创建主索引，利用主索引对Table进行快速定位、检索与更新操作; 索引可以由用户创建，也可以由用户撤消 当索引被创建后，无论是主索引，还是用户创建的索引，DBMS都将自动维护所有的索引，使其与Table保持一致，即：当一条记录被插入到Table中后，所有索引也自动的被更新 当Table被删除后(drop table), 定义在该Table上的所有索引将自动被撤消 ","date":"2021-11-09 11:28:43","objectID":"https://qizhengzou.github.io/mysql_base_10/:1:0","tags":["mysql"],"title":"Mysql_base_10","uri":"https://qizhengzou.github.io/mysql_base_10/"},{"categories":["School courses"],"content":"索引的简单分类 稠密索引与稀疏索引： 对于主文件中每一个记录(形成的每一个索引字段值)，都有一个索引项和它对应，指明该记录所在位置。这样的索引称稠密索引(dense index) 对于主文件中部分记录(形成的索引字段值)，有索引项和它对应，这样的索引称非稠密索引(undense index)或稀疏索引(sparse index) 稀疏索引如何定位记录: 定位索引字段值为K的记录，需要 首先找相邻的小于K的，最大索引字段值，所对应的索引项 从该索引项所对应的记录，开始顺序进行Table的检索 稀疏索引的使用要求—主文件必须是按对应索引字段属性排序存储 相比稠密索引：空间占用更少，维护任务更轻，但速度更慢 平衡: 索引项不指向记录指针，而是指向记录所在存储块的指针，即每一存储块有一个索引项，而不是每条记录有一索引项—-主索引 候选键属性的稠密索引—先查索引，然后再依据索引读主文件 无论是候选键属性的稠密索引，还是非候选键属性的稠密索引： 索引文件中不存在搜索码的值，那么主文件中没有对应搜索码的记录 主索引与辅助索引： 主索引通常是对每一存储块有一个索引项，索引项的总数和存储表所占的存储块数目相同，存储表的每一存储块的第一条记录，又称为锚记录 (anchor record), 或简称为块锚(block anchor) 主索引的索引字段值为块锚的索引字段值，而指针指向其所在的存储块。 主索引是按索引字段值进行排序的一个有序文件，通常建立在有序主文件的基于主码的排序字段上，即主索引的索引字段与主文件的排序码(主码)有对应关系 主索引是稀疏索引。 辅助索引是定义在主文件的任一或多个非排序字段上的辅助存储结构。 辅助索引通常是对某一非排序字段上的每一个不同值有一个索引项：索引字段即是该字段的不同值，而指针则指向包含该记录的块或该记录本身； 当非排序字段为索引字段时，如该字段值不唯一，则要采用一个类似链表的结构来保存包含该字段值的所有记录的位置。 辅助索引是稠密索引，其检索效率有时相当高 主索引vs辅助索引： 一个主文件仅可以有一个主索引，但可以有多个辅助索引 主索引通常建立于主码/排序码上面；辅助索引建立于其他属性上面 可以利用主索引重新组织主文件数据，但辅助索引不能改变主文件数据 主索引是稀疏索引，辅助索引是稠密索引 其他类型索引： 聚簇索引：是指索引中邻近的记录在主文件中也是临近存储的； 非聚簇索引：是指索引中邻近的记录在主文件中不一定是邻近存储的。 倒排索引 多级索引：当索引项比较多时，可以对索引再建立索引 多属性索引：索引字段由Table的多个属性值组合在一起形成的索引 散列索引：使用散列技术组织索引 网格索引(Grid file)：使用多索引字段进行交叉联合定位与检索 ","date":"2021-11-09 11:28:43","objectID":"https://qizhengzou.github.io/mysql_base_10/:2:0","tags":["mysql"],"title":"Mysql_base_10","uri":"https://qizhengzou.github.io/mysql_base_10/"},{"categories":["School courses"],"content":"B+树索引 B+树索引：一种以树型数据结构来组织索引项的多级索引 一块索引项的组织 Ki—索引字段值 Pj—指针，指向索引块或数据块或数据块中记录的指针 B+树的存储约定： 有n-1个索引项(\u003c索引字段值Ki, 指针Pi\u003e)+1个指针(Pn) 非叶结点指针指向索引块，叶结点指针指向主文件的数据块或数据记录，叶结点的最后一个指针始终指向其下一个数据块 一索引块实际使用的索引指针个数d，满足(根结点除外)：n/2 \u003c= d \u003c= n。 根结点至少2个指针被使用 索引字段值重复出现于叶结点和非叶结点 指向主文件的指针仅出现于叶结点 所有叶结点即可覆盖所有键值的索引 索引字段值在叶结点中是按顺序排列的 级数(或层数)相同–平衡。如何保证? 插入/删除记录时，伴随着结点的分裂与合并； 分裂与合并将调整部分结点块中的索引项 用B+树建立不同的索引: 用B+树建立键属性稠密索引: 索引字段是主文件的主键，索引是稠密的。主文件可以按主键排序，也可以不按主键排序。指针指向的是记录。 用B+树建立稀疏索引(或主索引): 索引字段是主文件的主键，索引是稀疏的。主文件必须按主键排序 指针指向的是数据块 用B+树建立非键属性稠密索引: 索引字段是主文件的非键属性，索引是稠密的。主文件按非键属性排序 索引文件的索引字段是无重复的。指针指向的是记录。 用B+树建立非键属性稠密索引: 索引字段是主文件的非键属性。主文件不按此非键属性排序 索引文件的索引字段值是有重复的。指针指向的是记录。 索引字段带有重复值的B+树的非叶结点示例: B树： 索引字段值仅出现一次或者在叶结点或者在非叶结点； 指向主文件的指针出现于叶结点或非叶结点； 所有结点才能覆盖所有键值的索引。 ","date":"2021-11-09 11:28:43","objectID":"https://qizhengzou.github.io/mysql_base_10/:3:0","tags":["mysql"],"title":"Mysql_base_10","uri":"https://qizhengzou.github.io/mysql_base_10/"},{"categories":["School courses"],"content":"散列索引 散列 有M个桶，每个桶是有相同容量的存储(可以是内存页，也可以是磁盘块) 散列函数 h(k)，可以将键值k映射到 { 0, 1, …, M-1 }中的某一个值 将具有键值k的记录Record(k)存储在对应h(k)编号的桶中 目标：选择一个合适的散列函数，将一个Record集合(每个Record都包含一个关键字k)均匀地映射到M个桶中。即：对于集合中任一个关键字，经散列函数映射到地址集合中任何一个地址的概率是近乎相等的 散列索引 内存数据可采用散列确定存储页，主文件可采用散列确定存储块，索引亦可采用散列确定索引项的存储块 Ｍ个桶。一个桶可以是一个存储块，亦可是若干个连续的存储块。 散列索引的目标：最好是没有溢出桶，每一个散列值仅有一个桶。读写每一个键值都只读写一个存储块。 均匀分布如何做到？ 期望将所有数据分布均匀地存储于M个桶中，使每一个桶的数据成为具有某种特征值h(k)的数据集合。—散列函数的选择。 桶的数目Ｍ如何计算？在键值几倍于桶的数目时，每个散列值都可能多于一个桶，形成一个主桶和多个溢出桶的列表，此时需要二次检索：先散列找到主桶号，再依据链表逐一找到每个溢出桶。—桶的数目的确定。 桶的数目M是固定值—-静态散列索引 如果桶的数目M不变：M过大，则浪费；M过小，则将产生更多的溢出桶，增加散列索引检索的时间。 桶的数目随键值增多，动态增加—-动态散列索引 h(k)是和桶的数目M相关的。M的变化会否影响原来存储的内容呢？ 是否需要将原来已经散列-存储的数据按新的桶数重新进行散列-存储呢？ 动态散列索引 可扩展散列索引 为桶引入一间接层，即用一个指向块的指针数组来表示桶，而不是用数据块本身组成的数组来表示桶 指针数组能增长，其长度总是2的幂。因而数组每增长一次，桶的数目就翻倍。不过，并非每个桶都有一个数据块；如果某些桶中的所有记录可以放在一个块中，则这些桶可能共享一个块。 散列函数h为每个键计算出一个K位二进制序列，该K足够大，比如32。但是桶的数目总是使用从序列第一位或最后一位算起的若干位，此位数小于K,比如说i位。也就是说，当i是使用的位数时，桶数组将有2的i次方个项。 线性散列索引 桶数n的选择：总是使存储块的平均记录数，保持与存储块所能容纳的记录总数成一个固定的比例，例如80%。超过此比例，则桶数增长1块，分裂。—线性增长，每次增1。 存储块并不总是可以分裂，所以允许有溢出块，尽管每个桶的平均溢出块数远小于1。 用来做桶数组项序号的二进制位数是log2 n ，其中n是当前的桶数。这些位总是从散列函数得到的位序列的右端(即低位)开始取。 ","date":"2021-11-09 11:28:43","objectID":"https://qizhengzou.github.io/mysql_base_10/:4:0","tags":["mysql"],"title":"Mysql_base_10","uri":"https://qizhengzou.github.io/mysql_base_10/"},{"categories":["School courses"],"content":" 笔记来自哈工大深圳2021秋数据库系统理论课授课老师：刘圣鑫 数据库物理存储 ","date":"2021-11-09 11:28:24","objectID":"https://qizhengzou.github.io/mysql_base_09/:0:0","tags":["mysql"],"title":"Mysql_base_09","uri":"https://qizhengzou.github.io/mysql_base_09/"},{"categories":["School courses"],"content":"基础回顾-计算机系统的存储体系 ","date":"2021-11-09 11:28:24","objectID":"https://qizhengzou.github.io/mysql_base_09/:1:0","tags":["mysql"],"title":"Mysql_base_09","uri":"https://qizhengzou.github.io/mysql_base_09/"},{"categories":["School courses"],"content":"数据库的存储与检索问题 两个基本问题如何解决？ 如何高效率的存储？–数据组织与索引 如何快速的检索？–查询实现与查询优化 面向大规模用户, 又如何解决? ","date":"2021-11-09 11:28:24","objectID":"https://qizhengzou.github.io/mysql_base_09/:1:1","tags":["mysql"],"title":"Mysql_base_09","uri":"https://qizhengzou.github.io/mysql_base_09/"},{"categories":["School courses"],"content":"什么是存储体系 数据组织的基础–存储体系 将不同性价比的存储器组织在一起，满足高速度、大容量、低价格需求 CPU与内存直接交换信息，按存储单元(存储字)进行访问 外存按存储块进行访问，其信息需先装入内存，才能被CPU处理 ","date":"2021-11-09 11:28:24","objectID":"https://qizhengzou.github.io/mysql_base_09/:1:2","tags":["mysql"],"title":"Mysql_base_09","uri":"https://qizhengzou.github.io/mysql_base_09/"},{"categories":["School courses"],"content":"不同层次存储的访问时间上的差异 ","date":"2021-11-09 11:28:24","objectID":"https://qizhengzou.github.io/mysql_base_09/:1:3","tags":["mysql"],"title":"Mysql_base_09","uri":"https://qizhengzou.github.io/mysql_base_09/"},{"categories":["School courses"],"content":"操作系统如何管理磁盘和数据 操作系统对数据的组织： FAT(文件分配表-File Allocation Table)-目录(文件夹)-磁盘块/簇 ","date":"2021-11-09 11:28:24","objectID":"https://qizhengzou.github.io/mysql_base_09/:1:4","tags":["mysql"],"title":"Mysql_base_09","uri":"https://qizhengzou.github.io/mysql_base_09/"},{"categories":["School courses"],"content":"操作系统对内存-缓冲区的管理 内存管理 一条记录的地址=存储单元的地址=内存地址=页面：页内偏移量 页面(Page) = 块(Block) 内存页面的分配 内存页面的置换 ","date":"2021-11-09 11:28:24","objectID":"https://qizhengzou.github.io/mysql_base_09/:1:5","tags":["mysql"],"title":"Mysql_base_09","uri":"https://qizhengzou.github.io/mysql_base_09/"},{"categories":["School courses"],"content":"磁盘的结构与特性 磁盘及磁盘的容量： 示例：一个磁盘的基本信息 8个圆盘，16个盘面 每个盘面有216或65536个磁道 每个磁道(平均)有28=256个扇区 每个扇区有212=4096个字节 磁盘的容量=2421628*212=240字节 磁盘数据读写时间： 寻道时间(约在1-20ms) 旋转时间(约0-10ms) 传输时间(每4KB页\u003c1ms) 物理存取算法考虑的关键: 降低I/O次数 降低排队等待时间 降低寻道/旋转延迟时间： 同一磁道连续块存储； 同一柱面不同磁道并行块存储； 多个磁盘并行块存储 提高磁盘数据读写时间与存储可靠性的方法： RAID技术: Redundant Array of Independent Disk 并行处理: 并行读取多个磁盘 可靠性: 奇偶校验与纠错 ","date":"2021-11-09 11:28:24","objectID":"https://qizhengzou.github.io/mysql_base_09/:2:0","tags":["mysql"],"title":"Mysql_base_09","uri":"https://qizhengzou.github.io/mysql_base_09/"},{"categories":["School courses"],"content":"DBMS数据存储与查询实现的基本思想 数据存储的映射关系示意： 数据存储与查询实现的基本框架示意： ","date":"2021-11-09 11:28:24","objectID":"https://qizhengzou.github.io/mysql_base_09/:3:0","tags":["mysql"],"title":"Mysql_base_09","uri":"https://qizhengzou.github.io/mysql_base_09/"},{"categories":["School courses"],"content":"数据库之表和记录与磁盘块的映射 数据库概念与磁盘相关概念的映射示意： 数据库中记录的区分及记录内属性值的区分： 数据库记录在磁盘上的存储，定长记录，还是变长记录(靠分隔符区分开始与结束) 数据库中的记录是跨块储存（靠指针连接）还是非跨块储存？ 跨块储存：节省一些存储空间,磁盘块间有关联需串行 非跨块储存：浪费一些存储空间，磁盘块间无关联可并行 数据库-表所占磁盘块的分配方法： 连续分配: 数据块被分配到连续的磁盘块上(会存在扩展困难问题) 链接分配: 数据块中包含指向下一数据块的指针(访问速度问题) 按簇分配: 按簇分配，簇之间靠指针连接; 簇有时也称片段Segment或盘区extent 索引分配: 索引块中存放指向实际数据块的指针 ","date":"2021-11-09 11:28:24","objectID":"https://qizhengzou.github.io/mysql_base_09/:4:0","tags":["mysql"],"title":"Mysql_base_09","uri":"https://qizhengzou.github.io/mysql_base_09/"},{"categories":["School courses"],"content":"数据库之文件组织方法 数据组织与存取方法 数据组织要考虑更新(增、删、改)和检索需求 更新将涉及数据存储空间的扩展与回收问题 检索将涉及扫描整个数据库的问题、大批量处理数据问题 不同的需求要求不同的数据组织方法和存取方法 文件组织(File Organization)指的是数据组织成记录、块和访问结构的方式，包括把记录和块存储在磁盘上的方式，以及记录和块之间相互联系的方法 存取方法(Access Method)指的是对文件所采取的存取操作方法 一种文件组织可以采取多种存取方法进行访问 文件组织方法之一：无序记录文件(堆文件heap或pile file) 特点：记录可存储于任意有空间的位置，磁盘上存储的记录是无序的。更新效率高，但检索效率可能低 方法1：新记录总插入到文件尾部；删除记录时，可以直接删除该记录所在位置的内容，也可以在该记录前标记“删除标记” 方法2：在前者基础上，新增记录可以利用那些标记为“删除标记”的记录空间 频繁删增记录时会造成空间浪费，所以需要周期性重新组织数据库 数据库重组(Reorganization)是通过移走被删除的记录使有效记录连续存放，从而回收那些由删除记录而产生的未利用空间。 文件组织方法之二：有序记录文件(排序文件Sequential) 特点：记录按某属性或属性组值的顺序插入，磁盘上存储的记录是有序的。检索效率可能高。 用于存储排序的属性通常称为排序字段(Ordering field)，通常，排序字段使用关系中的主码， 所以又称排序码(Ordering key) 当按排序字段进行检索时，速度得到很大提高；但当按非排序字段检索时，速度可能不会提高很多 有序记录文件的更新效率可能很低，因为：在更新时要移动其他记录，为插入记录留出空间 改进办法（使用溢出）：为将来可能插入元组预留空间(这可能造成空间浪费), 或使用一个临时的无序文件(被称为溢出文件)保留新增的记录。 当采取溢出文件措施时，检索操作既要操作主文件，又要操作溢出文件。所以需要周期性重新组织数据库 数据库重组将溢出文件合并到主文件，并恢复主文件中的记录顺序。 文件组织方法之三：散列文件(Hash file) 特点：可以把记录按某属性或属性组的值, 依据一个散列函数来计算其应存放的位置：桶号(Bucket,块号或簇号等)。检索效率和更新效率都有一定程度的提高 用于进行散列函数计算的属性通常称为散列字段(Hash field)，散列字段通常也采用关系中的主码，所以又称散列码(hash key) 不同记录可能被hash成同一桶号，此时需在桶内顺序检索出某一记录 链接法处理溢出 散列还有许多问题及许多的处理技巧, 如散列桶的数目以及桶的大小，动态散列技术等等 文件组织方法之四：聚簇文件(Clustering file) 聚簇：将具有相同或相似属性值的记录存放于连续的磁盘簇块中 多表聚簇：将若干个相互关联的Table存储于一个文件中—这可提高多表情况下的查询速度 ","date":"2021-11-09 11:28:24","objectID":"https://qizhengzou.github.io/mysql_base_09/:5:0","tags":["mysql"],"title":"Mysql_base_09","uri":"https://qizhengzou.github.io/mysql_base_09/"},{"categories":["School courses"],"content":"Oracle数据库的数据组织 Oracle数据库组织为数据库(database)、表空间(tablespace)、操作系统文件、table、段(segment)、盘区(extent)和基本数据块(data blocks) 简要理解： 逻辑储存层 每个数据库分成一个或多个表空间，所有表空间的组合存储容量即是数据库的存储容量 有系统表空间SYSTEM和用户表空间；系统表空间由Oracle在创建数据库 时自动创建，用于数据字典等的管理；用户表空间可由用户创建 每个表空间由一个或多个操作系统文件构成, 一个操作系统文件只能与一个数据库相联，操作系统文件仅起占位的作用。数据在表空间中可跨文件进行操作。 操作系统文件中存储一个表(Table)或多个表，一个表可存储在一个文件中也可能存储在多个文件中。 物理存储层 物理存储层由段(segment)、盘区(extent)和数据块(data block)构成 数据块是最小的IO存储单位，又称为Oracle块、页(相当于扇区) 盘区是特定数量的连续数据块(相当于簇)。Oracle中的盘区是可以动态变化的，随不同数据库存储需求而调整 段是一组分配了特定数据结构的盘区，又分为数据段、索引段和临时段等 一个表的数据可以存放在一个段内，也可以存放在多个段内。一个段可以存放一个表的数据，也可以存放多个表的数据(如聚簇文件) ","date":"2021-11-09 11:28:24","objectID":"https://qizhengzou.github.io/mysql_base_09/:6:0","tags":["mysql"],"title":"Mysql_base_09","uri":"https://qizhengzou.github.io/mysql_base_09/"},{"categories":["School courses"],"content":" 笔记来自哈工大深圳2021秋数据库系统理论课授课老师：刘圣鑫 模式分解存在的问题 ","date":"2021-11-09 11:28:20","objectID":"https://qizhengzou.github.io/mysql_base_08/:0:0","tags":["mysql"],"title":"Mysql_base_08","uri":"https://qizhengzou.github.io/mysql_base_08/"},{"categories":["School courses"],"content":"模式分解存在什么问题 模式分解需要关注： R与p在数据内容方面是否等价：分解的无损连接性； R与p在数据依赖方面是否等价：分解的保持依赖性。 数据约束的等价性,分解后是否有约束丢失了? 当模式不符合关系范式时，进行模式分解时，分解后的关系的连接与分解前关系的等价性? 分解前的约束，在分解后是否还存在? ","date":"2021-11-09 11:28:20","objectID":"https://qizhengzou.github.io/mysql_base_08/:1:0","tags":["mysql"],"title":"Mysql_base_08","uri":"https://qizhengzou.github.io/mysql_base_08/"},{"categories":["School courses"],"content":"无损连接分解及其检验算法 ","date":"2021-11-09 11:28:20","objectID":"https://qizhengzou.github.io/mysql_base_08/:2:0","tags":["mysql"],"title":"Mysql_base_08","uri":"https://qizhengzou.github.io/mysql_base_08/"},{"categories":["School courses"],"content":"保持依赖分解及其检验算法 保持依赖分解： 保持依赖性检验算法： ","date":"2021-11-09 11:28:20","objectID":"https://qizhengzou.github.io/mysql_base_08/:3:0","tags":["mysql"],"title":"Mysql_base_08","uri":"https://qizhengzou.github.io/mysql_base_08/"},{"categories":["School courses"],"content":"关系模式无损连接或保持依赖的分解算法 无损连接分解成BCNF的算法： 保持依赖分解成3NF的算法： 无损连接分解成4NF： 连接依赖： 5NF: ","date":"2021-11-09 11:28:20","objectID":"https://qizhengzou.github.io/mysql_base_08/:4:0","tags":["mysql"],"title":"Mysql_base_08","uri":"https://qizhengzou.github.io/mysql_base_08/"},{"categories":["School courses"],"content":"数据库设计需要知道的 数据库设计理论要解决的根本问题： 哪些属性被组织成一个关系? 是一个大关系模式呢，还是若干小关系模式? 大关系模式存在什么问题? 关系模式设计的折中： 关系模式设计需要折中 遵循关系范式原则，则需要将一个关系模式，拆解成两个或多个小的模式；而查询时，需要将这两个或多个小的模式联结成一个模式； 遵循关系范式原则避免了冗余、插入异常、删除异常等问题，但由于联结运算的低效率，使得查询速度很慢。因此需要折中。 ","date":"2021-11-09 11:28:20","objectID":"https://qizhengzou.github.io/mysql_base_08/:5:0","tags":["mysql"],"title":"Mysql_base_08","uri":"https://qizhengzou.github.io/mysql_base_08/"},{"categories":["School courses"],"content":"总结 ","date":"2021-11-09 11:28:20","objectID":"https://qizhengzou.github.io/mysql_base_08/:6:0","tags":["mysql"],"title":"Mysql_base_08","uri":"https://qizhengzou.github.io/mysql_base_08/"},{"categories":["School courses"],"content":" 笔记来自哈工大深圳2021秋数据库系统理论课授课老师：刘圣鑫 函数依赖及其公理定理 ","date":"2021-11-09 11:28:16","objectID":"https://qizhengzou.github.io/mysql_base_07/:0:0","tags":["mysql"],"title":"Mysql_base_07","uri":"https://qizhengzou.github.io/mysql_base_07/"},{"categories":["School courses"],"content":"函数依赖 定义： 函数依赖: 设R(U)是属性集合U={A1,A2,…,An}上的一个关系模式，X, Y是U上的两个子集，若对R(U)的任意一个可能的关系r, r中不可能有两个元组满足在X中的属性值相等而在Y中的属性值不等，则称“X函数决定Y”或“Y函数依赖于X”,记作X-\u003eY。 示例：U = {学号，姓名，年龄，班号，班长，课号，成绩} 学号-\u003e{姓名，年龄} {学号，课号} -\u003e 成绩 函数依赖的特性： 对X-\u003eY,但Y不包含于X, 则称X-\u003eY为非平凡的函数依赖； 若X-\u003eY,则任意两个元组,若X上值相等,则Y上值必然相等,则称X为决定因素； 若X-\u003eY,Y-\u003eX,则记作X\u003c-\u003eY； X-\u003eY,有基于模式R的,则要求对任意的关系r成立；有基于具体关系r 的,则要求对某一关系r成立； 如一关系r的某属性集X,r中根本没有X上相等的两个元组存在,则X-\u003eY恒 成立。 ","date":"2021-11-09 11:28:16","objectID":"https://qizhengzou.github.io/mysql_base_07/:1:0","tags":["mysql"],"title":"Mysql_base_07","uri":"https://qizhengzou.github.io/mysql_base_07/"},{"categories":["School courses"],"content":"完全函数依赖与传递函数依赖 部分或完全函数依赖： 在R(U)中，若X-\u003eY并且对于X的任何真子集X'都有y不依赖于x’,则称Y完全函数依赖于X, 记为：否则称Y部分函数依赖于X,记为：传递函数依赖: 在R(U)中，则称Z传递函于X。 几个重要概念： 候选键 设K为R(U)中的属性或属性组合，若U部分依赖于K, 则称K为R(U)上的候选键(Candidate Key)。说明： 可任选一候选键作为R的主键(Primary Key)； 包含在任一候选键中的属性称主属性(Prime Attribute), 其他属性称非主属性； 若K是R的一个候选键，S包含于K, 则称S为R的一个超键(Super Key) 逻辑蕴含 设F是关系模式R(U)中的一个函数依赖集合X，Y是R的属性子集，如果从F中的函数依赖能够推导出X-\u003eY，则称F逻辑蕴涵X-\u003eY，或称X-\u003eY是F的逻辑蕴涵。记作F|= X-\u003eY 设F是关系模式R(U)的函数依赖集, X-\u003eY是一个函数依赖，若对R中的每个满足F的关系r, 能够用逻辑推理的方法推出r也满足X-\u003eY，则称F|= X-\u003eY。 闭包 被F逻辑蕴涵的所有函数依赖集合称为F的闭包(Closure)，记作F+。 若F+=F, 则说F是一个全函数依赖族(函数依赖完备集)。 属性(集)闭包 ","date":"2021-11-09 11:28:16","objectID":"https://qizhengzou.github.io/mysql_base_07/:2:0","tags":["mysql"],"title":"Mysql_base_07","uri":"https://qizhengzou.github.io/mysql_base_07/"},{"categories":["School courses"],"content":"关于函数依赖的公理和定理 用于隐含函数依赖推导： 设R(U)是属性集U={A1,A2,…,An}上的一个关系模式，F为R(U)的一组函数依赖，记为R(U, F), 则有如下规则： [A1]自反律(Reflexivity rule)：若Y真包含于X真包含于U，则X-\u003eY被F逻辑蕴涵。 [A2]增广律(Augmentation rule)：若X真包含于Y真包含于F，且Z-\u003eU,则XZ-\u003eYZ被F逻辑蕴涵。 [A3]传递律(Transtivity rule)：若X真包含于Y真包含于F，且Y-\u003eZ，则X-\u003eZ被F逻辑蕴涵。 由A1.A2,A3可推出如下结论： 合并律(Union Rule)：若X-\u003eY且X-\u003eZ, 则X-\u003eYZ。 伪传递律(Pseudo Transitivity)：若X-\u003eY且WY-\u003eZ，则XW-\u003eZ。 分解律(Decomposition Rule)：若X-\u003eY且Z-\u003eY, 则X-\u003eZ 如果A1,A2,…,An是属性，则X-\u003eA1,A2,…,An当且仅当对每个Ai有X-\u003eAi(1 \u003c= i \u003c= n) X-\u003eY，可从F由Armstrong Axiom(即A1,A2,A3)导出，当且仅当真包含于X的属性闭包 ","date":"2021-11-09 11:28:16","objectID":"https://qizhengzou.github.io/mysql_base_07/:3:0","tags":["mysql"],"title":"Mysql_base_07","uri":"https://qizhengzou.github.io/mysql_base_07/"},{"categories":["School courses"],"content":"函数依赖集的最小覆盖 覆盖： 对R(U)上的两个函数依赖集合F、G, 如果F+=G+，则称F和G是等价的，也称F覆盖G或者G覆盖 引理： 每个函数依赖集F可被一个其右端至多有一个属性的函数依赖之集G覆盖。 最小覆盖： 若F满足以下条件，则称F为最小覆盖(minimal Cover)或最小依赖集 (minimal set of Functional Depandency)： F中每个函数依赖的右部是单个属性； 对任何X-\u003eA属于F，有F- {X-\u003eA}不等价于F； 对任何X-\u003eA属于F，Z包含于X，(F- {X-\u003eA})U{Z-\u003eA}不等价于F 每个函数依赖集F都有等价的最小覆盖F’。 ","date":"2021-11-09 11:28:16","objectID":"https://qizhengzou.github.io/mysql_base_07/:4:0","tags":["mysql"],"title":"Mysql_base_07","uri":"https://qizhengzou.github.io/mysql_base_07/"},{"categories":["School courses"],"content":"关系模式设计之规范形式 ","date":"2021-11-09 11:28:16","objectID":"https://qizhengzou.github.io/mysql_base_07/:5:0","tags":["mysql"],"title":"Mysql_base_07","uri":"https://qizhengzou.github.io/mysql_base_07/"},{"categories":["School courses"],"content":"关系的第1NF和第2NF 若关系模式R(U)中关系的每个分量都是不可分的数据项(值、原子)，则称R(U)属于第一范式，记为：R(U) 属于 1NF。 1NF要求关系中不能有复合属性、多值属性及其组合 若R(U)属于1NF且U中的每一非主属性完全函数依赖于候选键，则称R(U)属于第二范式，记为：R(U) 属于 2NF。 第二范式消除了非主属性对候选键的部分依赖 ","date":"2021-11-09 11:28:16","objectID":"https://qizhengzou.github.io/mysql_base_07/:5:1","tags":["mysql"],"title":"Mysql_base_07","uri":"https://qizhengzou.github.io/mysql_base_07/"},{"categories":["School courses"],"content":"关系的第3NF和Boyce-Codd NF 第3范式消除了非主属性对侯选键的传递依赖 ","date":"2021-11-09 11:28:16","objectID":"https://qizhengzou.github.io/mysql_base_07/:5:2","tags":["mysql"],"title":"Mysql_base_07","uri":"https://qizhengzou.github.io/mysql_base_07/"},{"categories":["School courses"],"content":"多值依赖及其公理定理 多值依赖： [Armstrong’s Axioms A4~A8]关于多值依赖的公理： 在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。 ","date":"2021-11-09 11:28:16","objectID":"https://qizhengzou.github.io/mysql_base_07/:5:3","tags":["mysql"],"title":"Mysql_base_07","uri":"https://qizhengzou.github.io/mysql_base_07/"},{"categories":["School courses"],"content":"关系的第4NF 第四范式消除了非主属性对候选键以外属性的多值依赖 ","date":"2021-11-09 11:28:16","objectID":"https://qizhengzou.github.io/mysql_base_07/:5:4","tags":["mysql"],"title":"Mysql_base_07","uri":"https://qizhengzou.github.io/mysql_base_07/"},{"categories":["School courses"],"content":" 笔记来自哈工大深圳2021秋数据库系统理论课授课老师：刘圣鑫 数据库设计 ","date":"2021-11-09 11:28:11","objectID":"https://qizhengzou.github.io/mysql_base_06/:0:0","tags":["mysql"],"title":"Mysql_base_06","uri":"https://qizhengzou.github.io/mysql_base_06/"},{"categories":["School courses"],"content":"强弱实体的个人理解 在正文之前，我总结一下我对强弱实体的个人理解： 区别弱实体与强实体的关键在于主键，“依赖”的实质是主键之间的关系。所以可以看作主键之间是否有关系、主键是否是组合主键的问题。 弱实体与强实体可以相互转换，没有绝对意义上的强与弱。既然区别弱实体与强实体的关键在于主键，那么一个同样意义的表，当我给它一个编号作为主键，那么它就不是弱实体，而如果我令它的主键是组合主键，它就是弱实体。 弱实体也可以依赖于弱实体。 弱实体与它所依赖的实体之间的关系只能是1：1或n：1。也就是说，一个弱实体实例不可能依赖于同一实体的多个实例。这个其实很好理解，因为如果弱实体实例A依赖于实例B，那么A的主键要包括B的主键，所以A当然不可以依赖于很多个B。 ","date":"2021-11-09 11:28:11","objectID":"https://qizhengzou.github.io/mysql_base_06/:1:0","tags":["mysql"],"title":"Mysql_base_06","uri":"https://qizhengzou.github.io/mysql_base_06/"},{"categories":["School courses"],"content":"数据库设计过程概述 需求分析 概念数据库设计 逻辑数据库设计 物理数据库设计 ","date":"2021-11-09 11:28:11","objectID":"https://qizhengzou.github.io/mysql_base_06/:2:0","tags":["mysql"],"title":"Mysql_base_06","uri":"https://qizhengzou.github.io/mysql_base_06/"},{"categories":["School courses"],"content":"数据库设计过程之需求分析 目标：理解企业、理解企业业务过程与数据处理流程、理解数据处理的性能需求 提交物：需求分析报告 使以下内容清楚： 企业的部门-岗位划分：不同岗位负责的各种日常管理信息表/报表 形成各种报表的基础数据表 各种数据表之间的处理关系(What–How) 围绕数据表的业务处理关系(Who—When–Where) 尚未实施但未来可能实施的需求 形成数据库设计的“源”清单和“属性”清单，及详细描述，尤其注意业务规则与属性处理规则 注意收集和理解: 业务规则及其在表的处理方面的体现 不仅报表、单据是源，企业的查询需求与管理需求等也是源 注意命名: 命名要规范，并且要含义明确 尤其要注意类似于“数量”这样的多含义属性，比如“计划数量”“采购数量”“到货数量”等 ","date":"2021-11-09 11:28:11","objectID":"https://qizhengzou.github.io/mysql_base_06/:3:0","tags":["mysql"],"title":"Mysql_base_06","uri":"https://qizhengzou.github.io/mysql_base_06/"},{"categories":["School courses"],"content":"数据库设计过程之概念数据库设计 目标：进一步深入理解企业，对信息源进行抽象，发现信息(属性)之间的内在本质联系，这些本质联系可能隐藏于需求分析得到的信息源中。 提交物：概念数据库设计报告 使以下内容清楚： 各种实体的发现、划分和定义 各种实体属性的发现、分析和定义 各种实体联系的发现、分析和定义 外部视图(模式)和概念视图(模式)的定义 用统一的表达方法，如E-R模型给出描述；不仅绘制出来，而且绘制正确； 消除冲突 属性冲突 属性域的冲突：属性的类型、取值范围不同 如不同学校的学号编码方式不同 属性取值单位冲突 如重量分别采用磅、千克 结构冲突 同一对象在不同应用中的抽象不同 *如职工在某应用中是实体，在另一应用中则抽象为属性 同一实体在不同E-R图中属性组成不同 实体之间的联系在不同E-R图中呈现不同的类型 命名冲突 同名异义：不同意义的对象具有相同的名字 异名同义：同一意义的对象具有不同的名字 ","date":"2021-11-09 11:28:11","objectID":"https://qizhengzou.github.io/mysql_base_06/:4:0","tags":["mysql"],"title":"Mysql_base_06","uri":"https://qizhengzou.github.io/mysql_base_06/"},{"categories":["School courses"],"content":"数据库设计过程之逻辑数据库设计 目标：用指定DBMS要求的模式描述方法，给出概念数据库的逻辑模式描述。 提交物：逻辑数据库设计报告 使以下内容清楚： 将E-R转换成逻辑模式 遵循关系范式的设计原则 也要注意折中，但折中时需要提示应用开发者或使用者可能存在的问题 外模式和概念模式的定义 用关系模型规定的模式描述方法进行描述 ","date":"2021-11-09 11:28:11","objectID":"https://qizhengzou.github.io/mysql_base_06/:5:0","tags":["mysql"],"title":"Mysql_base_06","uri":"https://qizhengzou.github.io/mysql_base_06/"},{"categories":["School courses"],"content":"E-R图向关系模式的转换 基本转换规则： 实体-属性-关键字的转换 E-R图的实体转换为关系 E-R图的属性转换为关系的属性 E-R图的关键字转换为关系的关键字 复合属性的转化 将每个分量属性作为复合属性所在实体的属性 或者，将复合属性本身作为所在实体的属性 多值属性的转换 将多值属性与所在实体的关键字一起组成一个新的关系 联系的转换 一对一联系： 若联系双方均部分参与(0..1)，则将联系定义为一个新的关系，属性为参与双方的关键字属性 若联系一方全部参与(1..1) ，则将其关键字作为另一方属性，不需要联系集 一对多联系： 将单方参与实体的关键字，作为多方参与实体对应关系的属性 多对多联系： 将联系定义为新的关系，属性为参与双方实体的关键字 弱实体的转换 所对应关系的关键字由弱实体本身的区分属性再加上所依赖的强实体的关键字构成 弱实体集(从属实体)与强实体集(独立实体)之间的联系已经在弱实体集所对应的关系中表示出来了 多元联系的转换 多元联系可以通过继承参与联系的各个实体的关键字而形成新的关系 这些继承过来的关键字可作为新关系的关键字 也可以新增一个区分属性作为关键字 注意这两种转换的差异 多元联系更需注意分析参与联系的实体的最小基数和最大基数 如是否允许参与联系的多实体中有一个或多个实体不参与？ 多元联系可以转换为多个二元联系进行处理 1型转换：供应(工程项目号，供货商号，零件号，数量) 2型转换：供应(条目号,工程项目号，供货商号，零件号，数量） 不正确设计数据库会导致：冗余（受控冗余，非受控冗余（如table中的外键））、插入异常、删除异常 ","date":"2021-11-09 11:28:11","objectID":"https://qizhengzou.github.io/mysql_base_06/:5:1","tags":["mysql"],"title":"Mysql_base_06","uri":"https://qizhengzou.github.io/mysql_base_06/"},{"categories":["School courses"],"content":"数据库设计过程之物理数据库设计 目标：结合指定DBMS物理数据库管理方法，给出概 念数据库的物理模式描述。 提交物：物理数据库设计报告 使以下内容清楚： DBMS选型 确定数据库的存储结构，文件类型：如定长文件、不定长文件；堆文件、散列文件或B-Tree文件等 用Triggers, 设计一些完整性控制约束 确定数据库的高效访问方式(索引访问，直接访问… …) 评估和设置磁盘空间需求 设计用户视图及访问控制规则，以进行安全性控制 建立索引 设计使数据库运行达到最佳效率的一些措施 设计备份Backup和恢复Recovery的步骤 理解Oracle、Sybase或其他DBMS的物理数据库管理 方式，这是数据库管理员(DBA)的基本责任 ","date":"2021-11-09 11:28:11","objectID":"https://qizhengzou.github.io/mysql_base_06/:6:0","tags":["mysql"],"title":"Mysql_base_06","uri":"https://qizhengzou.github.io/mysql_base_06/"},{"categories":["School courses"],"content":" 笔记来自哈工大深圳2021秋数据库系统理论课授课老师：刘圣鑫 数据库建模思想与方法 ","date":"2021-11-09 11:28:06","objectID":"https://qizhengzou.github.io/mysql_base_05/:0:0","tags":["mysql"],"title":"Mysql_base_05","uri":"https://qizhengzou.github.io/mysql_base_05/"},{"categories":["School courses"],"content":"为什么要数据建模和数据库设计? 数据模型与概念模型: 表达计算机世界的模型称数据模型；表达信息世界的模型称概念数据模型，简称概念模型，信息世界是对现实世界的理解与抽象 数据建模是抽象，抽象是理解-区分-命名-表达: 现实世界需要理解：现实中的卡片、单据、表格、报表… … 理解的标志是区分：表与表的区分，表内数据项的区分，数据项之间关系的区分，表之间关系的区分？ 区分的标志是命名：命名表、命名数据项、命名表之间的联系 抽象的最终结果是正确的表达：用其他人能理解的表达方法来表达(E-R图/Crow’s Foot) ","date":"2021-11-09 11:28:06","objectID":"https://qizhengzou.github.io/mysql_base_05/:1:0","tags":["mysql"],"title":"Mysql_base_05","uri":"https://qizhengzou.github.io/mysql_base_05/"},{"categories":["School courses"],"content":"E-R模型–数据建模之基本思想 E-R模型 E-R模型：Entity-Relationship Model 1976年, P.P.S.Chen提出E-R模型，用E-R图来描述概念模型 E-R模型的基本观点：世界是由一组称作实体的基本对象和这些对象之间的联系构成的 E-R模型给出了一组基本概念，用这组概念可以刻画信息世界 实体 属性 联系(参与发生联系的实体的数目，称为联系的度或元。) 一对一联系(1:1)：实体A的实例只能和实体B的一个实例发生联系，反之，实体B的实例也只能和实体A的一个实例发生联系。一个“经理”只管理一个“商店”，一个“商店”只能有一个“经理” 一对多联系(1:m和m:1)：实体A的实例能和实体B的多个实例发生联系，反之，实体B的实例只能和实体A的一个实例发生联系。一个“画家”可以绘制多幅“作品”，一幅“作品”只能由一个“画家”来完成 多对多联系(m:n)：实体A的实例可以和实体B的多个实例发生联系，反之，实体B的实例也可以和实体A的多个实例发生联系。一位同学可以选学多门课程，一门课程可由多个人来选学 完全参与联系，即该端实例至少有一个参与到联系中, 最小基数为1 (1..m) 部分参与联系，即该端实例可以不参与联系，最小基数为0 (0..m) 关键字/码 ","date":"2021-11-09 11:28:06","objectID":"https://qizhengzou.github.io/mysql_base_05/:2:0","tags":["mysql"],"title":"Mysql_base_05","uri":"https://qizhengzou.github.io/mysql_base_05/"},{"categories":["School courses"],"content":"E-R模型的两种图示化表达方法 Chen 方法 或者 Step1 理解需求，寻找实体 Step2用属性刻画每一个实体 Step3确定每一个实体的关键字/码 Step4数据建模的重点是分析实体之间的联系 Step5检查是否覆盖了需求 Crow’s Foot方法 联系：菱形框表示，也可以将菱形框省略而直接以联系名来替代 ","date":"2021-11-09 11:28:06","objectID":"https://qizhengzou.github.io/mysql_base_05/:3:0","tags":["mysql"],"title":"Mysql_base_05","uri":"https://qizhengzou.github.io/mysql_base_05/"},{"categories":["School courses"],"content":" 笔记来自哈工大深圳2021秋数据库系统理论课授课老师：刘圣鑫 数据库管理与维护 ","date":"2021-11-09 11:17:14","objectID":"https://qizhengzou.github.io/mysql_base_04/:0:0","tags":["mysql"],"title":"Mysql_base_04","uri":"https://qizhengzou.github.io/mysql_base_04/"},{"categories":["School courses"],"content":"数据库完整性与安全性控制 ","date":"2021-11-09 11:17:14","objectID":"https://qizhengzou.github.io/mysql_base_04/:1:0","tags":["mysql"],"title":"Mysql_base_04","uri":"https://qizhengzou.github.io/mysql_base_04/"},{"categories":["School courses"],"content":"数据库完整性的概念及分类 数据库完整性(DB Integrity)是指DBMS应保证DB在任何情况下的正确性、有效性和一致性 广义完整性：语义完整性、并发控制、安全控制、DB故障恢复等 狭义完整性：专指语义完整性，DBMS通常有专门的完整性管理机 制与程序来处理语义完整性问题。(指语义完整性) 关系模型中有完整性要求 实体完整性 参照完整性 用户自定义完整性 为什么会引发数据库完整性的问题呢？ 不正当的数据库操作，如输入错误、操作失误、程序处理失误等 数据库完整性管理的作用 防止和避免数据库中不合理数据的出现（salary\u003c0） DBMS应尽可能地自动防止DB中语义不合理现象 如DBMS不能自动防止，则需要应用程序员和用户在进行数据库操作时处处加以小心，每写一条SQL语句都要考虑是否符合语义完整性，这种工作负担是非常沉重的，因此应尽可能多地让DBMS来承担 推到前端的时候DB校验逻辑太复杂 DBMS怎样自动保证完整性呢？ DBMS允许用户定义一些完整性约束规则(用SQL-DDL来定义) 当有DB更新操作时，DBMS自动按照完整性约束条件进行检查，以确保更新操作符合语义完整 完整性约束条件(或称完整性约束规则)的一般形式 （Quad四元组） Integrity Constraint ::= ( O，P，A，R) O―数据集合：约束的对象？ 列、多列(元组)、元组集合 P―谓词条件：什么样的约束？ A―触发条件：什么时候检查？ R―响应动作：不满足时怎么办？ 按约束对象分类 完整性约束条件的类别 域完整性约束条件：施加于某一列上，对给定列上所要更新的某一候选值是否可以接受进行约束条件判断，这是孤立进行的。 关系完整性约束条件：施加于关系/table上，对给定table上所要更新的某一候选元组是否可以接受进行约束条件判断，或是对一个关系中的若干元组和另一个关系中的若干元组间的联系是否可以接受进行约束条件判断 按约束来源分类 结构约束：来自于模型的约束，例如函数依赖约束、主键约束(实体完整性)、外键约束(参照完整性)，只关心数值相等与否、是否允许空值等； 内容约束：来自于用户的约束，如用户自定义完整性，关心元组或属性的取值范围。例如Student表的Sage属性值在15岁至40岁之间等 按约束状态分类 静态约束：要求DB在任一时候均应满足的约束；例如Sage在任何时候都应满足大于0而小于150(假定人活最大年龄是150)。 动态约束：要求DB从一状态变为另一状态时应满足的约束；例如工资只能升，不能降：工资可以是800元，也可以是1000元；可以从800元更改为1000元，但不能从1000元更改为800元。 SQL语言支持如下几种约束 静态约束 列完整性—域完整性约束 表完整性—关系完整性约束 动态约束 触发器 ","date":"2021-11-09 11:17:14","objectID":"https://qizhengzou.github.io/mysql_base_04/:1:1","tags":["mysql"],"title":"Mysql_base_04","uri":"https://qizhengzou.github.io/mysql_base_04/"},{"categories":["School courses"],"content":"SQL-DDL中关于完整性的命令 Create Table Create Table有三种功能：定义关系模式、定义完整性约束、定义物理存储特性 定义完整性约束条件：列完整性、表完整性 Col_constr列约束： 一种域约束类型，对单一列的值进行约束 只能应用在单一列上，其后面的约束如UNIQUE,PRIMARY及search_cond只能是单一列唯一、单一列为主键、和单一列相关 示例： Create Table Student ( S# char(8) not null unique, Sname char(10), Ssex char(2) constraint ctssex check (Ssex=‘男’ or Ssex=‘女’), Sage integer check (Sage\u003e=1 and Sage\u003c=150), D# char(2) references Dept(D#) on delete cascade, Sclass char(6) ); //假定Ssex只能取{男，女}, 1=\u003cSage\u003c=150, D# 是外键 table_constr表约束： 一种关系约束类型，对多列或元组的值进行约束 是应用在关系上，即对关系的多列或元组进行约束，列约束是其特例 示例： Create Table Course ( C# char(3) , Cname char(12), Chours integer, Credit float(1) constraint ctcredit check (Credit \u003e=0.0 and Credit\u003c=5.0 ), T# char(3) references Teacher(T#) on delete cascade, primary(C#), constraint ctcc check(Chours/Credit = 20) ); //假定严格约束20学时一个学分 check中的条件可以是Select-From-Where内任何Where后的语句，包含子查询,示例： Create Table SC ( S# char(8) check( S# in (select S# from student)) , C# char(3) check( C# in (select C# from course)) , Score float(1) constraint ctscore check (Score\u003e=0.0 and Score\u003c=100.0); Creat Table中定义的表约束或者列约束可以用Alter Table 进行撤销（未命名的约束不能撤销） 断言ASSERTION 语法：CREATE ASSERTION CHECK 表约束，列约束是特殊的断言 Predicate写法如where子句 DB每次更新都要检查断言，增加负担 触发器Trigger 为实现动态约束以及多个元组之间的完整性约束，就需要触发器技术Trigger 而Create Table中的表约束和列约束基本上都是静态的约束，也基本上都是对单一列或单一元组的约束(尽管有参照完整性)， Trigger是一种过程性完整性约束(相比之下，Create Table中定义的都是非过程性约束), 是一段程序，该程序可以在特定的时刻被自动触发执行，比如在一次更新操作之前执行，或在更新操作之后执行。 代码： CREATE TRIGGER trigger_name BEFORE | AFTER { INSERT | DELETE | UPDATE [OF colname {, colname...}]} ON tablename [REFERENCING corr_name_def {, corr_name_def...} ] [FOR EACH ROW | FOR EACH STATEMENT] //对更新操作的每一条结果(前者)，或整个更新操作完成(后者) [WHEN (search_condition)]//检查条件，如满足执行下述程序 { statement//单行程序直接书写，多行程序要用下行方式 | BEGIN ATOMIC statement; { statement;...} END 触发器Trigger意义：当某一事件发生时(Before|After),对该事件产生的结果(或是每一元组，或是整个操作的所有元组), 检查条件search_condition,如果满足条件，则执行后面的程序段。条件或程序段中引用的变量可用corr_name_def来限定。 示例：设计一个触发器当进行Teacher表更新元组时, 使其工资只能升不能降 create trigger teacher_chgsal before update of salary on teacher referencing new x, old y for each row when (x.salary \u003c y.salary) begin raise_application_error(-20003, 'invalid salary on update'); //Oracle的错误处理函数 end; ","date":"2021-11-09 11:17:14","objectID":"https://qizhengzou.github.io/mysql_base_04/:1:2","tags":["mysql"],"title":"Mysql_base_04","uri":"https://qizhengzou.github.io/mysql_base_04/"},{"categories":["School courses"],"content":"数据库安全性的概念 数据库安全性是指DBMS能够保证使DB免受非法、非授权用户的使用、泄漏、更改或破坏的机制和手段 数据库安全性管理涉及许多方面 社会法律及伦理方面：私人信息受到保护，未授权人员访问私人信息会违法 公共政策/制度方面：例如，政府或组织的信息公开或非公开制度 安全策略：政府、企业或组织所实施的安全性策略，如集中管理和分散管理，需者方知策略(也称最少特权策略) 数据库系统DBS的安全级别：物理控制、网络控制、操作系统控制、DBMS控制 数据的安全级别: 绝密(Top Secret), 机密(Secret),可信(Confidential) 和无分类(Unclassified) DBMS的安全机制： 自主安全性机制：存取控制(Access Control) 通过权限在用户之间的传递，使用户自主管理数据库安全性 强制安全性机制： 通过对数据和用户强制分类，使得不同类别用户能够访问不同类别的数据 推断控制机制： 防止通过历史信息，推断出不该被其知道的信息； 防止通过公开信息(通常是一些聚集信息)推断出私密信息(个体信息)，通常在一些由个体数据构成的公共数据库中此问题尤为重要 数据加密存储机制： 通过加密、解密保护数据，密钥、加密/解密方法与传输 DBA在安全性方面的责任和义务 熟悉相关的法规、政策，协助组织的决策者制定好相关的安全策略 规划好安全控制保障措施，例如，系统安全级别、不同级别上的安全控制措施，对安全遭破坏的响应 划分好数据的安全级别以及用户的安全级别 实施安全性控制：DBMS专门提供一个DBA帐户，该帐户是一个超级用户或称系统用户。DBA利用该帐户的特权可以进行用户帐户的创建以及权限授予和撤消、安全级别控制调整等 自主安全性机制 通常情况下，自主安全性是通过授权机制来实现的。用户在使用数据库前 必须由DBA处获得一个帐户，并由DBA授予该帐户一定的权限，该帐户的用户依据其所拥有的权限对数据库进行操作; 同时，该帐户用户也可将其所拥有的权利转授给其他的用户(帐户)，由此实现权限在用户之间的传播和控制。 授权者：决定用户权利的人 授权：授予用户访问的权力 DBMS如何实现自主安全性 DBMS允许用户定义安全规则（DCL） 发生DB访问操作时，DBMS自动按照安全性控制规则进行检查，通过则可访问，否则拒绝访问 DBMS将权利和用户(帐户)结合在一起，形成一个访问规则表，依据该规则表可以实现对数据库的安全性控制 AccessRule ::= ( S, O, t, P ) S: 请求主体(用户) O: 访问对象 t: 访问权利 P: 谓词 { AccessRule｝通常存放在数据字典或称系统目录中，构成了所有用户对DB的访问权利; 用户多时，可以按用户组建立访问规则 访问对象可大可小(目标粒度Object granularity):属性/字段、记录/元组、关系、数据库 权利：create，增删改查等 P：拥有权利需满足条件 访问权利被分成以下几种 (级别1)Select: 读(读DB, Table, Record, Attribute, … ) (级别2)Modify: 更新 Insert: 插入(插入新元组, … ) Update: 更新(更新元组中的某些值, …) Delete: 删除(删除元组, …) (级别3)Create: 创建(创建表空间、模式、表、索引、视图等) Create: 创建 Alter: 更新 Drop: 删除 级别高的权利自动包含级别低的权利。如某人拥有更新的权利，它也自动拥有读的权利。在有些DBMS中，将级别3的权利称为帐户级别的权利，而将级别1和2称为关系级别的权利。 超级用户(DBA) \u003e 帐户级别(程序员用户) \u003e 关系级 强制安全性机制 强制安全性通过对数据对象进行安全性分级:绝密(Top Secret), 机密(Secret),可信(Confidential)和无分类(Unclassified)以及对用户也进行上述的安全性分级，从而强制实现不同级别用户访问不同级别数据的一种机制. 访问规则如下： 用户S, 不能读取数据对象O, 除非Level(S)\u003e=Level(O) 用户S, 不能写数据对象, 除非Level(S)\u003c=Level(O)。 可以通过扩展关系模式来实现:关系模式: R(A1: D1, A2: D2, …, An:Dn) 对属性和元组引入安全性分级特性或称分类特性：R(A1: D1, C1, A2: D2, C2…, An:Dn, Cn, TC)其中 C1,C2,…,Cn分别为属性D1,D2,…,Dn的安全分类特性; TC为元组的分类特性 强制安全性机制使得关系形成为多级关系(不同级别用户所能看到的关系的子集)，也出现多重实例、多级关系完整性等许多新的问题或新的处理技巧，在使用中需注意仔细研究。 ","date":"2021-11-09 11:17:14","objectID":"https://qizhengzou.github.io/mysql_base_04/:1:3","tags":["mysql"],"title":"Mysql_base_04","uri":"https://qizhengzou.github.io/mysql_base_04/"},{"categories":["School courses"],"content":"MySQL 有关权限的表都有哪几个？ MySQL 服务器通过权限表来控制用户对数据库的访问，权限表存放在 mysql 数据库里，由 mysql_install_db 脚本初始化。这些权限表分别 user，db，table_priv，columns_priv 和 host。下面分别介绍一下这些表的结构和内容： user 权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。 db 权限表：记录各个帐号在各个数据库上的操作权限。 table_priv 权限表：记录数据表级的操作权限。 columns_priv 权限表：记录数据列级的操作权限。 host 权限表：配合 db 权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受 GRANT 和 REVOKE 语句的影响。 ","date":"2021-11-09 11:17:14","objectID":"https://qizhengzou.github.io/mysql_base_04/:1:4","tags":["mysql"],"title":"Mysql_base_04","uri":"https://qizhengzou.github.io/mysql_base_04/"},{"categories":["School courses"],"content":"SQL-DCL中关于安全性的命令 授权命令 GRANT {all PRIVILEGES | privilege {,privilege…} } ON [TABLE] tablename | viewname TO {public | user-id {, user-id…} } [WITH GRANT OPTION]; user-id, 某一个用户帐户，由DBA创建的合法帐户 public, 允许所有有效用户使用授予的权利 privilege 是下面的权利 SELECT | INSERT | UPDATE | DELETE | ALL PRIVILEDGES WITH GRANT OPTION选项是允许被授权者传播这些权利 注意授权的传播范围问题： 传播范围包括两个方面：水平传播数量和垂直传播数量 水平传播数量是授权者的再授权用户数目(树的广度) 垂直传播数量是授权者传播给被授权者，再被传播给另一个被授权者, …传播的深度(树的深度) 有些系统提供了传播范围控制，有些系统并没有提供，SQL标准中也并没有限制。 收回授权命令 REVOKE {all privilEges | priv {, priv…} } ON tablename | viewname FROM {public | user {, user…}; 当一个用户的权利被收回时，通过其传播给其他用户的权利也将被收回 如果一个用户从多个用户处获得了授权，则当其中某一个用户收回授权时，该用户可能仍保有权利。例如UserC从UserB和UserE处获得了授权，当UserB收回时，其还将保持UserE赋予其的权利。 ","date":"2021-11-09 11:17:14","objectID":"https://qizhengzou.github.io/mysql_base_04/:1:5","tags":["mysql"],"title":"Mysql_base_04","uri":"https://qizhengzou.github.io/mysql_base_04/"},{"categories":["School courses"],"content":"数据字典/系统目录和模式 系统目录 系统目录(System Catalogs)是系统维护的，包含数据库中定义的各类对象 信息的表或视图，这些对象包括用Create语句定义的表、列、索引、视图、 权限、约束等, 这些信息又称数据库的元数据—-关于数据的数据。在不同 DBMS中，又称数据字典(Data Dictionary(Oracle))、目录表(DB2 UDB)、系统目录(INFORMIX)、系统视图(X/Open) 不同DBMS中系统目录存储方式可能是不同的, 但会有一些信息对DBA公开。这些公开的信息, DBA可以使用一些特殊的SQL命令来检索。 DBA需要清楚地知道系统目录的内容构成，并知道这些信息的含义和作用,以便能更有效地维护DB以及DBS系统的效率。 DBA需要熟悉DBMS提供的各种检索系统目录的命令，以便能更好地操作系统目录 典型的系统目录 X/Open标准中有一个目录表Info_Schem.Tables, 该表中的一行是一个已 经定义的表的有关信息 可以使用SQL语句来访问这个表中的信息，比如了解已经定义了哪些表，可如下进行： Select Table_Name From Tables; 模式 系统目录的Tables中有一列是模式Schema，模式的含义是指某一用户所设计和使用的表、索引及其他与数据库有关的对象的集合，因此表的完整名应是：模式名.表名。这样做可允许不同用户使用相同的表名，而不混淆。 一般而言，一个用户有一个模式。可以使用Create Schema语句来创建模式(用法略，参见相关文章)，在Create Table等语句可以使用所定义的模式名称。 Oracle的数据字典 Oracle数据字典由视图组成，分为三种不同形式，由不同的前缀标识 USER_ :用户视图，用户所拥有的对象，在用户模式中 ALL_ :扩展的用户视图，用户可访问的对象 DBA_ :DBA视图(所有用户都可访问的DBA对象的子集) Oracle数据字典中定义了三个视图USER_Tables, ALL_Tables, 和 DBA_Tables供DBA和用户使用数据字典中关于表的信息 同样, Oracle数据字典中也定义了三个视图USER_TAB_Columns, ALL_TAB_Columns(Accessible_Columns), 和DBA_TAB_Columns供DBA 和用户使用数据字典中关于表的列的信息 可以使用SQL语句来访问这些表中的信息： Select Column_Name From ALL_TAB_Columns Where Table_Name = ‘STUDENT’ ; ","date":"2021-11-09 11:17:14","objectID":"https://qizhengzou.github.io/mysql_base_04/:1:6","tags":["mysql"],"title":"Mysql_base_04","uri":"https://qizhengzou.github.io/mysql_base_04/"},{"categories":["School courses"],"content":"小结 充分了解了DB完整性的有关概念, 充分了解了SQL-DDL关于完整性约束的定义方法 包括列约束和表约束; 结构约束和内容约束; 静态约束和动态约束; 触发器等 要进一步理解SQL-DDL的使用方法, 以便能更有效地维护数据库 进一步理解Triggers, 有优点，也有不足 充分了解了DB安全性的有关概念, 充分了解了SQL-DCL中关于授权与收回授权的使用方法, 进一步理解了视图作为安全性控制的重要意义 包括安全性管理的责任素质要求, 自主安全性机制(访问权利、存取矩阵、授权), 强制安全性机制 进一步理解安全性，掌握DBA应掌握的安全性常识与能力 基本了解了数据字典，初步了解DBA通过SQL命令访问数据字典的方法 ","date":"2021-11-09 11:17:14","objectID":"https://qizhengzou.github.io/mysql_base_04/:2:0","tags":["mysql"],"title":"Mysql_base_04","uri":"https://qizhengzou.github.io/mysql_base_04/"},{"categories":["School courses"],"content":" 笔记来自哈工大深圳2021秋数据库系统理论课授课老师：刘圣鑫 sql语言 ","date":"2021-11-09 11:17:06","objectID":"https://qizhengzou.github.io/mysql_base_03/:0:0","tags":["mysql"],"title":"Mysql_base_03","uri":"https://qizhengzou.github.io/mysql_base_03/"},{"categories":["School courses"],"content":"SQL语言概述 ","date":"2021-11-09 11:17:06","objectID":"https://qizhengzou.github.io/mysql_base_03/:1:0","tags":["mysql"],"title":"Mysql_base_03","uri":"https://qizhengzou.github.io/mysql_base_03/"},{"categories":["School courses"],"content":"SQL语言提出和发展 1974年，由Boyce和Chamber提出 1975-1979年，在System R上首次实现，由IBM的San Jose研究室研制， 称为Sequel(Structured English QUEry Language) 1986年推出了SQL标准：SQL-86， “数据库语言SQL: Structured Query Language” 1989年ANSI / ISO推出了SQL标准: SQL-89, 数据库语言SQL的标准集合 1992年进一步推出了SQL标准：SQL-92，也称为SQL2 是SQL-89的超集 增加了许多新特性，如新数据类型，更丰富数据操作，更强完整性支持等 原SQL-89被称为entry-SQL, 扩展的被称为Intermediate级和Full级 1999年进一步推出了SQL标准： SQL-99，也称为SQL3 对面向对象的一些特征予以支持，支持抽象数据类型，支持行对象和列对象等 对递归、触发等复杂操作也予以规范化定义 有些特征，现有数据库厂商尚不能做到完全支持 废弃了SQL2的分级，但定义了core-SQL及扩展的SQL SQL 2003； SQL 2006； SQL 2008 SQL还有一个标准是X/Open标准，主要强调各厂商产品的可移植性，只包含被各厂商广泛认可的操作 ","date":"2021-11-09 11:17:06","objectID":"https://qizhengzou.github.io/mysql_base_03/:1:1","tags":["mysql"],"title":"Mysql_base_03","uri":"https://qizhengzou.github.io/mysql_base_03/"},{"categories":["School courses"],"content":"SQL语言概览 SQL语言是集DDL、DML和DCL于一体的数据库语言 SQL语言主要由以下9个单词引导的操作语句来构成，但每一种语句都能 表达复杂的操作请求 DDL语句引导词：Create(建立), Alter (修改), Drop(撤消) 模式的定义和删除，包括定义Database, Table, View,Index,完整性约束条件等，也包括定义对象(RowType行对象, Type列对象) DML语句引导词：Insert, Update, Delete, Select 各种方式的更新与检索操作，如直接输入记录，从其他Table(由SubQuery建立)输入,各种复杂条件的检索，如连接查找，模糊查找，分组查找，嵌套查找等 各种聚集操作，求平均、求和、…等，分组聚集，分组过滤等 DCL语句引导词：Grant, Revoke 安全性控制：授权和撤消授权 ","date":"2021-11-09 11:17:06","objectID":"https://qizhengzou.github.io/mysql_base_03/:1:2","tags":["mysql"],"title":"Mysql_base_03","uri":"https://qizhengzou.github.io/mysql_base_03/"},{"categories":["School courses"],"content":"简单的SQL-DDL/DML: 创建数据库 create database 数据库名; create table 表名( 列名 数据类型 [Primary key |UNIQUE] [not null][, 列名 数据类型 [not null] , … ]) ; 在表中追加元组的值要使用DML（Data Manipulation Language） 向Table中追加新的元组：Insert 修改Table中某些元组中的某些属性的值: Update 删除Table中的某些元组: Delete 对Table中的数据进行各种条件的检索: Select ","date":"2021-11-09 11:17:06","objectID":"https://qizhengzou.github.io/mysql_base_03/:2:0","tags":["mysql"],"title":"Mysql_base_03","uri":"https://qizhengzou.github.io/mysql_base_03/"},{"categories":["School courses"],"content":"SQL-DML之查询Select ","date":"2021-11-09 11:17:06","objectID":"https://qizhengzou.github.io/mysql_base_03/:3:0","tags":["mysql"],"title":"Mysql_base_03","uri":"https://qizhengzou.github.io/mysql_base_03/"},{"categories":["School courses"],"content":"基本的检索操作 Select 的简单语法形式为： Select 列名 [[, 列名] … ] From 表名 [ Where 检索条件 ] ; 基本检索操作： 结果唯一性问题：尽管关系模型要求无重复元组出现在数据库中，但现实DBMS操作中，是允许检索结果出现重复元组的，但也允许无重复元组 结果排序问题：DBMS可以对检索结果进行排序，可以升序排列，也可以 降序排列。order by 列名 [asc | desc] 模糊查询问题： 含有like运算符的表达式 列名 [not ] like “字符串” 找出匹配给定字符串的字符串。其中给定字符串中可以出现%, _等匹配符 匹配规则 % 0个或多个字符 _ 任意单个字符 \\ 转义字符，用于去掉一些特殊字符的特定含义 举例：Select S#, Sname From StudentWhere Sname Like ‘张%’ ","date":"2021-11-09 11:17:06","objectID":"https://qizhengzou.github.io/mysql_base_03/:3:1","tags":["mysql"],"title":"Mysql_base_03","uri":"https://qizhengzou.github.io/mysql_base_03/"},{"categories":["School courses"],"content":"多表联合检索 连接运算涉及到重名的问题，如两个表中的属性重名，连接的两个表重名 (同一表的连接)等，因此需要使用别名以便区分 select中采用别名的方式（as可省略）： Select 列名 as 列别名 [ [, 列名 as 列别名] … ] From 表名1 as 表别名1, 表名2 as 表别名2, … Where 检索条件 ","date":"2021-11-09 11:17:06","objectID":"https://qizhengzou.github.io/mysql_base_03/:3:2","tags":["mysql"],"title":"Mysql_base_03","uri":"https://qizhengzou.github.io/mysql_base_03/"},{"categories":["School courses"],"content":"子查询 出现在Where子句中的Select语句被称为子查询(subquery) , 子查询返回了一个集合，可以通过与这个集合的比较来确定另一个查询集合。 子查询类型： in谓词:表达式 [not ] in (子查询) 非相关子查询： 内层查询独立进行，没有涉及任何外层查询相关信息的子查询被称为非相关子查询。 相关子查询：内层查询需要依靠外层查询的某些参量作为限定条件才能进行，这样的子查询称为相关子查询。外层向内层传递的参量需要使用外层的表名或表别名来限定 *some / *all谓词（*为\u003c , \u003e , \u003e=, \u003c=）：后接子查询 语义：将表达式的值与子查询的结果进行比较： 如果表达式的值至少与子查询结果的某一个值相比较满足* 关系，则“表达式 * some (子查询)”的结果便为真； 如果表达式的值与子查询结果的所有值相比较都满足* 关系，则“表达式 * all (子查询)”的结果便为真； 表达式 = some (子查询)和表达式 in (子查询)等价；表达式 not in (子查询)与表达式 \u003c\u003e all (子查询)等价 Exists谓词：[not] Exists (子查询)，不加not形式的Exists谓词可以不用。 ","date":"2021-11-09 11:17:06","objectID":"https://qizhengzou.github.io/mysql_base_03/:3:3","tags":["mysql"],"title":"Mysql_base_03","uri":"https://qizhengzou.github.io/mysql_base_03/"},{"categories":["School courses"],"content":"结果计算与聚集函数 前面介绍的select-from-where语句中，select子句后面不仅可以是列名，而且可以是一些计算表达式或聚集函数，表明在选择和投影的同时直接进行一些运算，如下所示： Select 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ] From 表名1 [, 表名2 … ] [ Where 检索条件]; 计算表达式可以是常量、列名或由常量、列名、特殊函数及算术运算符构 成的算术运算式。特殊函数的使用需结合各自DBMS的说明书。 例如，有计算表达式投影列的示例:求有差额(差额\u003e0)的任意两位教师的薪水差额 Select T1.Tname as TR1, T2.Tname as TR2, T1.Salary – T2.Salary From Teacher T1, Teacher T2 Where T1.Salary \u003e T2.Salary; SQL提供了五个作用在简单列值集合上的内置聚集函数agfunc, 分别是：COUNT、SUM、AVG、MAX、MIN SQL聚集函数的参数类型、结果类型与作用如下： eg: Select Sum(Salary) From Teacher; Select AVG(Score) From Course C, SC Where C.Cname = ‘数据库’ and C.C# = SC.C; ","date":"2021-11-09 11:17:06","objectID":"https://qizhengzou.github.io/mysql_base_03/:3:4","tags":["mysql"],"title":"Mysql_base_03","uri":"https://qizhengzou.github.io/mysql_base_03/"},{"categories":["School courses"],"content":"分组查询与分组过滤 为解决同时求解若干个集合的聚集运算问题，引出了分组的概念。SQL可 以将检索到的元组按照某一条件进行分类，具有相同条件值的元组划到一个组或一个集合中，这一过程就是分组过程。 Select 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ] From 表名1 [, 表名2 … ] [ Where 检索条件 ] [ Group by 分组条件(列名) ]; 若要对集合(即分组)进行条件过滤，可使用Having子句 Having子句，又称为分组过滤子句。需要有Group by子句支持，换句话说，没有Group by子句，便不能有Having子句。 Select 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ] From 表名1 [, 表名2 … ] [ Where 检索条件 ] [ Group by 分组条件 [ Having 分组过滤条件] ]; 例如 Select S# From SC Where Score \u003c 60 Group by S# Having Count(*)\u003e2; Select C# From SC Where Score \u003c 60 Group by C# Having Count(*)\u003e10; 分组查询仍需要注意语义问题: 例如求有两门以上不及格课程的同学的学号及其平均成绩: 错误写法： Select S#, Avg(Score) From SC Where Score \u003c 60 Group by S# Having Count(*)\u003e2; 前述写法是不正确的，它求出的是那两门不及格课程的平均成绩，而不是 该同学所有课程的平均成绩，后者是题目要求的。因此正确写法为： Select S#, AVG(Score) From SC Where S# in ( Select S# From SC Where Score \u003c 60 Group by S# Having Count(*)\u003e2 ) Group by S#; ","date":"2021-11-09 11:17:06","objectID":"https://qizhengzou.github.io/mysql_base_03/:3:5","tags":["mysql"],"title":"Mysql_base_03","uri":"https://qizhengzou.github.io/mysql_base_03/"},{"categories":["School courses"],"content":"并、交、差的处理 SQL语言中为并运算提供了运算符UNION, 为交运算提供了运算符 INTERSECT, 为差运算提供了运算符EXCEPT，其基本语法形式为： 子查询 { Union [ALL] | Intersect [ALL] | Except [ALL] 子查询 通常情况下是自动删除重复元组。但有时为了保留重复的元 组，则需使用ALL保留字，ALL保留字是允许重复元组出现，具体使用如下： 假设子查询1的一个元组出现m次，子查询2的一个元组出现n次，则 该元组在： 子查询1 Union ALL 子查询2 ，出现m + n次 子查询1 Intersect ALL 子查询2 ，出现min(m,n)次 子查询1 Except ALL 子查询2 ，出现max(0, m – n)次 示例： Select S# From SC Where C# = ‘002’ UNION Select S# From SC Where C# ='003'; 交运算符Intersect并没有增强SQL的表达能力，没有Intersect， SQL也 可以用其他方式表达同样的查询需求，如上例所述。只是有了Intersect更容易表达一些，但增加了SQL语言的不唯一性。 它们都是Core-SQL99的一部分，但有些DBMS并不支持这些运算，使用时要注意。 ","date":"2021-11-09 11:17:06","objectID":"https://qizhengzou.github.io/mysql_base_03/:3:6","tags":["mysql"],"title":"Mysql_base_03","uri":"https://qizhengzou.github.io/mysql_base_03/"},{"categories":["School courses"],"content":"空值处理 空值是其值不知道、不确定、不存在的值 数据库中有了空值，会影响许多方面，如影响聚集函数运算的正确性，不能参与算术、比较或逻辑运算等 在SQL标准中和许多现流行的DBMS中，空值被用一种特殊的符号Null来 标记，使用特殊的空值检测函数来获得某列的值是否为空值 eg: Select Sname From Student Where Sage is null ; ","date":"2021-11-09 11:17:06","objectID":"https://qizhengzou.github.io/mysql_base_03/:3:7","tags":["mysql"],"title":"Mysql_base_03","uri":"https://qizhengzou.github.io/mysql_base_03/"},{"categories":["School courses"],"content":"内连接、外连接 关系代数运算中，有连接运算，又分为连接和外连接 在SQL的高级语法中引入了内连接与外连接运算，具体形式如下： Select 列名 [ [, 列名] … ] From 表名1 [NATURAL] [ INNER | { LEFT | RIGHT | FULL} [OUTER]] JOIN 表名2 { ON 连接条件 | Using (Colname {, Colname …}) } [ Where 检索条件 ] … 连接运算由两部分构成：连接类型和连接条件 Inner Join: 即关系代数中的-连接运算 Left Outer Join, Right Outer Join, Full Outer Join: 即关系代数中的外连接运算 如“表1 Left Outer Join 表2”，则连接后，表1的任何元组t都会出现在结果表中，如表2中有满足连接条件的元组s, 则t与s连接；否则t与空值元组连接； 如“表1 Right Outer Join 表2”，则连接后，表2的任何元组s都会出现在结果表中，如表1中有满足连接条件的元组t, 则t与s连接；否则s与空值元组连接； 如“表1 Full Outer Join 表2”，是前两者的并。 连接中使用 natural 出现在结果关系中的两个连接关系的元组在公共属性上取值相等，且公共属性只出现一次 连接中使用 on \u003c连接条件\u003e 出现在结果关系中的两个连接关系的元组取值满足连接条件，且公共属性出现两次 连接中使用 using (Col1, Col2, …, Coln) (Col1, Col2, …, Coln)是两个连接关系的公共属性的子集，元组在(Col1,Col2, …, Coln)上取值相等，且(Col1, Col2, …, Coln)只出现一次 ","date":"2021-11-09 11:17:06","objectID":"https://qizhengzou.github.io/mysql_base_03/:3:8","tags":["mysql"],"title":"Mysql_base_03","uri":"https://qizhengzou.github.io/mysql_base_03/"},{"categories":["School courses"],"content":"SQL的完整语法 Subquery ::== SELECT [ ALL | DISTINCT ] { * | expr [[AS] c_alias] {, … } } FROM tableref {, … } [WHERE search_condition] [GROUP BY column {, … }] [HAVING search_condition] | subquery [UNION [ALL] | INTERSECT [ALL] | EXCEPT [ALL]] [CORRESPONDING [BY] (colname {, … })] subquery; Tableref ::== tablename [corr_name] Select statement ::== Subquery [ORDER BY result_column[ASC | DESC] { , … }] ","date":"2021-11-09 11:17:06","objectID":"https://qizhengzou.github.io/mysql_base_03/:3:9","tags":["mysql"],"title":"Mysql_base_03","uri":"https://qizhengzou.github.io/mysql_base_03/"},{"categories":["School courses"],"content":"SQL-DML之更新Insert/Update/Delete 元组新增Insert命令有两种形式 单一元组新增命令形式：插入一条指定元组值的元组insert into 表名 [(列名[，列名]…)]values (值 [，值]…)； 批数据新增命令形式：插入子查询结果中的若干条元组。待插入的元 组由子查询给出。insert into 表名 [(列名[，列名]…)]子查询; eg: Insert Into St (S#, Sname, avgScore) Select S#, Sname, Avg(Score) From Student, SC Where Student.S# = SC.S# Group by Student.S# 当有元组新增操作时，DBMS会检查用户定义的完整性约束条件等，如不符合完整性约束条件，则将不会执行新增动作（同删除操作）。 SQL-DML之元组更新Update 元组更新Update命令: 用指定要求的值更新指定表中满足指定条 件的元组的指定的列的值 Update 表名 Set 列名 = 表达式 | (子查询) [ [ , 列名 = 表达式 | (子查询) ] … ] [ Where 条件表达式] ; 如果Where条件省略，则更新所有的元组。 ","date":"2021-11-09 11:17:06","objectID":"https://qizhengzou.github.io/mysql_base_03/:4:0","tags":["mysql"],"title":"Mysql_base_03","uri":"https://qizhengzou.github.io/mysql_base_03/"},{"categories":["School courses"],"content":"SQL-视图及DDL的进一步介绍 ","date":"2021-11-09 11:17:06","objectID":"https://qizhengzou.github.io/mysql_base_03/:5:0","tags":["mysql"],"title":"Mysql_base_03","uri":"https://qizhengzou.github.io/mysql_base_03/"},{"categories":["School courses"],"content":"视图的定义与使用 Create View CompStud AS ( Select * From Student Where D# in ( Select D# From Dept Where Dname = ‘计算机’ ); ","date":"2021-11-09 11:17:06","objectID":"https://qizhengzou.github.io/mysql_base_03/:5:1","tags":["mysql"],"title":"Mysql_base_03","uri":"https://qizhengzou.github.io/mysql_base_03/"},{"categories":["School courses"],"content":"视图更新问题 SQL视图更新操作受到很大的约束，很多情况是不能进行视图 更新的: 如果视图的select目标列包含聚集函数，则不能更新 如果视图的select子句使用了unique或distinct，则不能更新 如果视图中包括了group by子句，则不能更新 如果视图中包括经算术表达式计算出来的列，则不能更新 如果视图是由单个表的列构成，但并没有包括主键，则不能更新 对于由单一Table子集构成的视图，即如果视图是从单个基本表使用选 择、投影操作导出的，并且包含了基本表的主键，则可以更新 ","date":"2021-11-09 11:17:06","objectID":"https://qizhengzou.github.io/mysql_base_03/:5:2","tags":["mysql"],"title":"Mysql_base_03","uri":"https://qizhengzou.github.io/mysql_base_03/"},{"categories":["School courses"],"content":"SQL-DDL的进一步介绍: 撤消语句的使用 不仅视图可以撤消，基本表、数据库等都可以撤消 撤消基本表：drop table 表名 注意，SQL-delete语句只是删除表中的元组, 而撤消基本表drop table的 操作是撤消包含表格式、表中所有元组、由该表导出的视图、等相关的所有内容，所以使用要特别注意。当表定义完成后，通常不是撤消表，而可能要修正表的定义，此时可使用Alter table语句修正基本表的定义： alter table tablename [add {colname datatype}] [drop {完整性约束名}] [modify {colname datatype, …}] 指定当前数据库 use 数据库名; 关闭当前数据库 close 数据库; ","date":"2021-11-09 11:17:06","objectID":"https://qizhengzou.github.io/mysql_base_03/:5:3","tags":["mysql"],"title":"Mysql_base_03","uri":"https://qizhengzou.github.io/mysql_base_03/"},{"categories":["School courses' list"],"content":" base来自王道考研操作系统 base_01（绪论） 操作系统(Operating System, OS)的概念、特征、功能和提供的服务 操作系统的发展与分类 单道批处理系统 多道批处理系统 批处理操作系统 分时操作系统 实时操作系统 操作系统的运行环境 核心态与用户态 中断与异常 系统调用 操作系统的体系结构 base_02（进程管理） 进程与线程 进程概念 进程的状态与转换 若通过硬件实现方法解决临界段问题，进程不能实现让权等待，也就不会被阻塞，此时退出临界区的进程唤醒是处于就绪态的进程。 进程控制 线程概念与多线程模型 进程通信:共享存储系统、消息传递系统、管道通信. 处理器调度 处理器的三层调度 调度的基本准则 进程调度 典型调度算法：先来先服务调度算法、短作业(短进程、短线程)优先调度算法、时间片轮转调度算法、优先级调度算法、高响应比优先调度算法以及多级反馈队列调度算法 同步与互斥 进程同步的基本概念 实现临界区互斥的基本方法：软件实现方法、硬件实现方法。 信号量 管程 经典同步问题：生产者消费者问题、读者写者问题、哲学家进餐问题 死锁 死锁概念 死锁处理策略 死锁预防 死锁避免：系统安全状态、银行家算法 死锁检测和解除 base_03（内存管理） 内存管理基础 内存管理概念：程序装入与链接、逻辑地址与物理地址空间、内存保护。 程序装入 交换与覆盖 连续分配管理方式 单一连续分配 固定分区分配 动态分区分配 分区分配算法 FF NF BF WF 非连续分配管理方式：分页管理方式、分段管理方式、段页式管理方式 虚拟内存管理 虚拟内存基本概念 请求分页管理方式 页面置换算法：最佳置换算法(OPT)、先进先出置换算法(FIFO)、最近最少使用置换算法(LRU)、时钟置换算法(CLOCK) 页面分配策略 抖动现象与工作集 belady异常 抖动 缺页率 base_04（文件管理） 文件系统基础 文件的概念 文件的逻辑结构：顺序文件、索引文件、索引顺序文件 目录结构：文件控制块和索引结点、单级目录结构和两级目录结构、树形目录结构、图形目录结构 文件共享 文件保护：访问类型、访问控制。 文件系统实现 文件系统层次结构 目录实现 文件实现 外存分配方式 文件存储空间管理 磁盘组织与管理 磁盘的结构 磁盘调度算法 先来先服务(FCFS) 算法 最短寻道时间优先(SSTF) 算法 扫描算法(SCAN)或电梯调度算法 循环扫描(C-SCAN)算法 磁盘的管理 base_05（设备管理） I/O 管理概述 I/O 控制方式：程序直接控制方式、中断控制方式、DMA控制方式和通道控制方式 I/O软件层次结构 I/O核心子系统 I/O 调度概念 高速缓存与缓冲区 设备分配与回收 假脱机技术(SPOOLing) advanced_01（操作系统重要性） advanced_02（程序运行过程） 程序编译过程 程序装载执行 HELLO OS ","date":"2021-11-08 16:44:08","objectID":"https://qizhengzou.github.io/operatingsystem_catalogue/:0:0","tags":["catalogue"],"title":"OperatingSystem_catalogue","uri":"https://qizhengzou.github.io/operatingsystem_catalogue/"},{"categories":["School courses' list"],"content":" base笔记来自哈工大深圳数据库理论课授课老师：刘圣鑫 base_01（数据库概念结构） 基本概念 什么是数据库及为什么要学数据库？ 数据库(信息库) 数据库系统(工作环境) 数据库管理系统(软件系统) 数据库工作者的分类及要求 标准结构 DBMS管理数据的三个层次：(外部)视图、全局视图、内部视图 模式的概念：外模式、(概念)模式、内模式 数据模型与模式 简要发展史及发展趋势 base_02（关系模型与关系运算） 关系模型与关系运算简述 关系模型的提出与作用 关系模型与关系运算概览 关系与关系模型 关系 关系模型 关系代数运算 base_03（sql语言） SQL语言概述 SQL语言提出和发展 SQL语言概览 简单的SQL-DDL/DML: 创建数据库 SQL-DML之查询Select 基本的检索操作 多表联合检索 子查询 结果计算与聚集函数 分组查询与分组过滤 并、交、差的处理 空值处理 内连接、外连接 SQL的完整语法 SQL-DML之更新Insert/Update/Delete SQL-视图及DDL的进一步介绍 视图的定义与使用 视图更新问题 SQL-DDL的进一步介绍: 撤消语句的使用 base_04（数据库管理与维护） 数据库完整性与安全性控制 数据库完整性的概念及分类 SQL-DDL中关于完整性的命令 数据库安全性的概念 MySQL 有关权限的表都有哪几个？ SQL-DCL中关于安全性的命令 数据字典/系统目录和模式 小结 base_05（数据库建模思想与方法） 为什么要数据建模和数据库设计? E-R模型–数据建模之基本思想 E-R模型的两种图示化表达方法 base_06（数据库设计） 强弱实体的个人理解 数据库设计过程概述 数据库设计过程之需求分析 数据库设计过程之概念数据库设计 数据库设计过程之逻辑数据库设计 E-R图向关系模式的转换 数据库设计过程之物理数据库设计 base_07（函数依赖及其公理定理） 函数依赖 完全函数依赖与传递函数依赖 关于函数依赖的公理和定理 函数依赖集的最小覆盖 关系模式设计之规范形式 关系的第1NF和第2NF 关系的第3NF和Boyce-Codd NF 多值依赖及其公理定理 关系的第4NF base_08（模式分解存在的问题） 模式分解存在什么问题 无损连接分解及其检验算法 保持依赖分解及其检验算法 关系模式无损连接或保持依赖的分解算法 数据库设计需要知道的 总结 base_09（数据库物理存储） 基础回顾-计算机系统的存储体系 数据库的存储与检索问题 什么是存储体系 不同层次存储的访问时间上的差异 操作系统如何管理磁盘和数据 操作系统对内存-缓冲区的管理 磁盘的结构与特性 DBMS数据存储与查询实现的基本思想 数据库之表和记录与磁盘块的映射 数据库之文件组织方法 Oracle数据库的数据组织 base_10（数据库索引） 为什么需要索引与什么是索引 索引的简单分类 B+树索引 散列索引 base_11（数据库查询实现算法） 数据库查询实现算法-I 数据库查询实现算法概述 以连接操作为例看逻辑实现算法与物理实现算法 利用迭代器构造查询实现算法 几个关系操作的一趟扫描算法 基于索引的算法 总结 数据库查询实现算法-II 为什么需要两趟算法? 两阶段多路归并排序TPMMS 基于排序的两趟扫描算法 基于散列的两趟扫描算法 总结 base_12（数据库查询优化） 为什么要及什么是查询优化? 查询优化的基本思路 逻辑查询优化 物理查询优化 base_13（事务处理） 为什么需要并发控制 事务调度及可串行性 基于封锁的并发控制方法 基于时间戳的并发控制方法 基于有效性确认的并发控制方法 总结 base_14（故障恢复） 数据库的故障类型及其影响 数据库故障恢复的宏观思路 什么是日志 Undo型日志及其故障恢复 Redo型日志及其故障恢复 Undo/Redo结合型日志及其故障恢复 advanced_01（详解MYSQL查询语句） 连接器 长连接和短连接 查询缓存 分析器 优化器 执行器 advanced_02（详解MYSQL更新语句） 重要的日志模块redo log 重要的日志模块 两阶段提交 一天一备份和一周一备份的区别 ","date":"2021-11-08 16:43:15","objectID":"https://qizhengzou.github.io/mysql_catalogue/:0:0","tags":["catalogue"],"title":"Mysql_catalogue","uri":"https://qizhengzou.github.io/mysql_catalogue/"},{"categories":["Advanced learning"],"content":"1. Linux 背景知识 Linux 有两种含义： 一种是 Linus 编写的开源操作系统的内核 另一种是广义的操作系统 执行环境 云主机 虚拟机（较推荐） 无数据的 PC（不推荐多系统混跑） linux版本： 内核版本 内核版本分为三个部分 主版本号、次版本号、末版本号 次版本号是奇数为开发版，偶数为稳定版 发行版本（因为linux是开源的）5种 Redhat Enterprise Linux:RedHat公司发行，软件经过专业人员的测试，非常稳定，但是需要付费。 Fedora发行版本，也是RadHat发行，组建一个社区免费提供这个操作系统，软件较新，但未经过RedHat的专业测试，稳定性较差。 centos，是基于Enterprise Linux 的源代码经行编译的，把RedHad的商标和字样去掉了，故免费。 Debian和Ubuntu 不是字符桌面，有图形界面。 ","date":"2021-11-08 15:34:58","objectID":"https://qizhengzou.github.io/linux_base_01/:1:0","tags":["linux"],"title":"Linux_base_01","uri":"https://qizhengzou.github.io/linux_base_01/"},{"categories":["Advanced learning"],"content":"2. 系统操作 ","date":"2021-11-08 15:34:58","objectID":"https://qizhengzou.github.io/linux_base_01/:2:0","tags":["linux"],"title":"Linux_base_01","uri":"https://qizhengzou.github.io/linux_base_01/"},{"categories":["Advanced learning"],"content":"帮助命令man help info manual: man ls;man 章节号 man；man -a passwd help: 内部命令(命令解释器shell自带的命令 type cd查看cd命令类型)：help cd 外部命令：ls –help info：比help 更详细，可以作为help的补充，全英文。 ","date":"2021-11-08 15:34:58","objectID":"https://qizhengzou.github.io/linux_base_01/:2:1","tags":["linux"],"title":"Linux_base_01","uri":"https://qizhengzou.github.io/linux_base_01/"},{"categories":["Advanced learning"],"content":"linux文件管理 一切皆文件 windows里有注册表，资源管理器等组件，控制linux自身的统统都是文件，linux文件管理非常重要 ","date":"2021-11-08 15:34:58","objectID":"https://qizhengzou.github.io/linux_base_01/:2:2","tags":["linux"],"title":"Linux_base_01","uri":"https://qizhengzou.github.io/linux_base_01/"},{"categories":["Advanced learning"],"content":"文件查看 tab可以进行目录补全 pwd cd cd - 回到上次目录 cd ..(/)回到上一级目录 cd /path/to/…. 绝对路径 cd ./path/to/… 相对路径（./可以省略） ls -l长格式显示（显示大小单位为Mb时可用-lh） -a显示隐藏文件 -r逆序显示 -t时间顺序显示 -R递归显示 ","date":"2021-11-08 15:34:58","objectID":"https://qizhengzou.github.io/linux_base_01/:2:3","tags":["linux"],"title":"Linux_base_01","uri":"https://qizhengzou.github.io/linux_base_01/"},{"categories":["Advanced learning"],"content":"目录文件的创建和删除 只列出了少量命令 mkdir mkdir a b c mkdir /a/b /a目录已存在 mkdir -p /a/b/c/d 无需a b c等目录存在 mkdir a b c -p 忽略已存在a b c 的报错 rmdir 删除空目录，目录下有空目录也不行，体现了“一切皆文件” rm -r -f（/rf） 可以删除非空目录，不去进行提示删除目录，具有一定危险性 eg: rm -r -f / a 不小心在/a之间加空格会导致删除所有目录且不提示 -i 删除前逐一询问确认 -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认 -r 将目录及以下之档案亦逐一删除 cp -r 复制⽬录 -p 保留访问权限、修改时间 -a 等同于 -dpR（保留权限、属组、修改时间） -v 显示复制过程 mv mv /a /b将a改名为b（可与移动同时进行），在linux底层操作即进行了一个移动 更多命令见命令大全 ","date":"2021-11-08 15:34:58","objectID":"https://qizhengzou.github.io/linux_base_01/:2:4","tags":["linux"],"title":"Linux_base_01","uri":"https://qizhengzou.github.io/linux_base_01/"},{"categories":["Advanced learning"],"content":"通配符（通用的匹配符号） 是shell内建的符号，用于多个相似的文件进行操作 *匹配任何字符串 ？匹配单个字符 [abc]匹配abc任意一个字符 [a-z]匹配一个范围 [!xyz]或[^xyz] 不匹配 ","date":"2021-11-08 15:34:58","objectID":"https://qizhengzou.github.io/linux_base_01/:2:5","tags":["linux"],"title":"Linux_base_01","uri":"https://qizhengzou.github.io/linux_base_01/"},{"categories":["Advanced learning"],"content":"文件操作 文本内容查看 cat ⽂本内容显示到终端 head 查看⽂件开头（默认10行，-5可显示5行） tail 查看⽂件结尾（行数同head）(-f可进行跟踪) eg:tail -10 /etc/passwd 查看psaawd文件中倒数十行 常⽤参数 -f ⽂件内容更新后，显示信息同步更新 wc 统计⽂件内容信息（-l查看行数） more 分行显示 （空格继续显示） less more和less: less:由于more不能后退，就取more的反义词less加上后退功能 所以Linux里流传着这样一句话：“less is more”. 总结下more 和 less的区别: less可以按键盘上下方向键显示上下内容,more不能这样 less不必读整个文件，加载速度会比more更快 less退出后shell不会留下刚显示的内容,而more退出后会在shell上留下刚显示的内容 打包压缩解压 最早的 Linux 备份介质是磁带，使⽤的命令是 tar 可以打包后的磁带⽂件进⾏压缩储存，压缩的命令是 gzip 和 bzip2 经常使⽤的扩展名是 .tar.gz .tar.bz2 .tgz tar 打包命令 c 打包(cf .tar) x 解包 f 指定操作类型为⽂件 可以使⽤ gzip 和 bzip2 命令单独操作通常和 tar 命令配合操作 -z gzip 格式压缩和解压缩(czf .tar.gz) -j bzip2 格式压缩和解压缩(cjf .tar.bz2)，压缩比例更高，执行时间更慢。 vim的四种模式 vim是一个vi向上兼容的文本编辑器 正常模式 正常模式下输入： i:进入插入模式光标位置不动 I:进入插入模式光标移到行首 a:进入插入模式光标移到下一位 A:进入插入模式光标移到行末 o:进入插入模式光标在原来那一行的下一行，另起一行 O:进入插入模式光标在原来那一行的上一行，另起一行 ::进入命令模式 hjkl:正常模式下光标上下左右移动 复制剪切粘贴输入错误进行重做 y: yy:光标在某一行输入n(不输入时默认为1，作为从当前行开始要复制的行数) yy，粘贴用p y$:复制当前字符到行末的字符 d:剪切 dd d$ u:撤销 ctrl+r:重做 x:单个字符删除 r:替换当前字符 n(你要移动光标到哪一行)+G g到第一行 G到最后一行 ^到当前行的开头 $到当前行的结尾 命令模式 文件的保存、退出、查找、替换，在正常模式下输入： w /test.txt 将文本保存到新文件，w直接保存到原始文件 wq保存并推出 q!不保存退出 ！执行linux命令，有时候在打开vim的同时需要临时执行一条命令，eg:!ifconfig(查看ip地址) /查找eg:/x+enter光标自动移到第一个x,按n可以移动到下一个x，按N可以移到上一个x s/old/new 在光标所在行，将第一个旧的字符替换成新的字符 %s/old/new 所有行，将第一个旧的字符替换成新的字符 %s/old/new/g 所有行，将所有旧的字符替换成新的字符、 n,m+前三个命令是在[n,m]行进行替换，左闭右闭 set nohlsearch去除高亮显示 set nu:显示行数 set nonu:不显示行数 修改vim配置在/etc/vimrc文件里操作 比如在最后一行添加set nu则以后每次打开文件都会显示行号 可视模式 用于对文件进行重复的大量操作可以一次性执行完成 v 字符可视模式 V 行可视模式 ctrl+v 块可视模式（用的最多） 配合d和I可以进行块的便利操作 eg:进入块可视模式，用hjkl选择一个块，I可以在块头插入比如abc再按两次esc可见每行都被插入了abc；选中一个块，按d直接删除块 ","date":"2021-11-08 15:34:58","objectID":"https://qizhengzou.github.io/linux_base_01/:2:6","tags":["linux"],"title":"Linux_base_01","uri":"https://qizhengzou.github.io/linux_base_01/"},{"categories":["Advanced learning"],"content":"用户和用户组管理及密码管理 windows linux都是多用户操作系统。只是windows的用户一般只有一个。 多用户操作系统的目的是隔离 用户权限隔离 系统资源隔离 root 用户与普通用户的区别 用户管理常用命令 useradd 新建用户 id+用户名 可显示相关信息（uid gid 以及组号） userdel 删除用户 一般会加-r选项，因为如果不加，用户的家目录就会被保留下来，防止误删数据，加-r后都会删除 可查看/etc/passwd /etc/shadow passwd 修改用户密码 usermod 修改用户属性 可接很多属性如-a -c -d -e -g……。经常使用的一个属性是-d（用户的新登陆目录，家目录） 修改用户组 eg: usermod -g group1 user1 chage 修改用户属性 change age的缩写，可更改用户密码过期信息 组管理命令 groupadd 新建用户组 新建用户加入组有两种方法： 先新建用户再用usermod -g 直接useradd -g group1 user1 groupdel 删除用户组 ","date":"2021-11-08 15:34:58","objectID":"https://qizhengzou.github.io/linux_base_01/:2:7","tags":["linux"],"title":"Linux_base_01","uri":"https://qizhengzou.github.io/linux_base_01/"},{"categories":["Advanced learning"],"content":"su和sudo 用户切换 su 切换用户 su - USERNAME 使用 login shell 方式切换用户 -的作用是在用户切换的同时将运行环境也变更为目标用户的运行环境 不带 - 为不完全切换，只切换了身份，需要额外切换目录 sudo 以其他用户身份执行命令 visudo 设置需要使用 sudo 的用户（组） ","date":"2021-11-08 15:34:58","objectID":"https://qizhengzou.github.io/linux_base_01/:2:8","tags":["linux"],"title":"Linux_base_01","uri":"https://qizhengzou.github.io/linux_base_01/"},{"categories":["Advanced learning"],"content":"用户和用户组的配置文件介绍 用户配置文件 /root root 用户的家目录 /home/USERNAME 普通用户默认家目录位置 /etc/passwd 用户配置文件 /etc/shadow 用户密码相关配置文件 /etc/group 用户组配置文件 ","date":"2021-11-08 15:34:58","objectID":"https://qizhengzou.github.io/linux_base_01/:2:9","tags":["linux"],"title":"Linux_base_01","uri":"https://qizhengzou.github.io/linux_base_01/"},{"categories":["Advanced learning"],"content":"文件和目录权限的表示方法 字符权限表示方法 r 读 w 写 x 执行 数字权限的表示方法 r = 4 w = 2 x = 1 - rw- r-x r- - 1 userame groupname mtime filename rw- 文件属主的权限 r-x 文件属组的权限 r- - 其他用户的权限 创建文件有默认权限，根据 umask 值计算 目录权限： x 进入目录 rx 显示目录内的文件名 wx 修改目录内的文件名 ","date":"2021-11-08 15:34:58","objectID":"https://qizhengzou.github.io/linux_base_01/:2:10","tags":["linux"],"title":"Linux_base_01","uri":"https://qizhengzou.github.io/linux_base_01/"},{"categories":["Advanced learning"],"content":"文件权限的修改方法和数字表示方法 修改权限： chmod 修改文件、目录权限 chown 更改属主、属组 chgrp 可以单独更改属组，不常用 特殊权限： SUID 用于二进制可执行文件，执行命令时取得文件属主权限 SGID 用于目录，在该目录下创建新的文件和目录，权限自动更改为该目录的属组 SBIT 用于目录，该目录下新建的文件和目录，仅 root 和自己可以删除 ","date":"2021-11-08 15:34:58","objectID":"https://qizhengzou.github.io/linux_base_01/:2:11","tags":["linux"],"title":"Linux_base_01","uri":"https://qizhengzou.github.io/linux_base_01/"},{"categories":["Advanced learning"],"content":"权限管理和文件的特殊权限 ","date":"2021-11-08 15:34:58","objectID":"https://qizhengzou.github.io/linux_base_01/:2:12","tags":["linux"],"title":"Linux_base_01","uri":"https://qizhengzou.github.io/linux_base_01/"},{"categories":["Advanced learning"],"content":"3. 服务管理 ","date":"2021-11-08 15:34:58","objectID":"https://qizhengzou.github.io/linux_base_01/:3:0","tags":["linux"],"title":"Linux_base_01","uri":"https://qizhengzou.github.io/linux_base_01/"},{"categories":["Advanced learning"],"content":"4. Shell ","date":"2021-11-08 15:34:58","objectID":"https://qizhengzou.github.io/linux_base_01/:4:0","tags":["linux"],"title":"Linux_base_01","uri":"https://qizhengzou.github.io/linux_base_01/"},{"categories":["Advanced learning"],"content":"5. 文本操作 ","date":"2021-11-08 15:34:58","objectID":"https://qizhengzou.github.io/linux_base_01/:5:0","tags":["linux"],"title":"Linux_base_01","uri":"https://qizhengzou.github.io/linux_base_01/"},{"categories":["Advanced learning"],"content":"6. 服务篇 ","date":"2021-11-08 15:34:58","objectID":"https://qizhengzou.github.io/linux_base_01/:6:0","tags":["linux"],"title":"Linux_base_01","uri":"https://qizhengzou.github.io/linux_base_01/"},{"categories":["Advanced learning"],"content":"7. 实战 ","date":"2021-11-08 15:34:58","objectID":"https://qizhengzou.github.io/linux_base_01/:7:0","tags":["linux"],"title":"Linux_base_01","uri":"https://qizhengzou.github.io/linux_base_01/"},{"categories":["School courses"],"content":" 笔记来自哈工大深圳2021秋数据库系统理论课授课老师：刘圣鑫 关系模型与关系运算 ","date":"2021-11-07 09:18:21","objectID":"https://qizhengzou.github.io/mysql_base_02/:0:0","tags":["mysql"],"title":"Mysql_base_02","uri":"https://qizhengzou.github.io/mysql_base_02/"},{"categories":["School courses"],"content":"关系模型与关系运算简述 ","date":"2021-11-07 09:18:21","objectID":"https://qizhengzou.github.io/mysql_base_02/:1:0","tags":["mysql"],"title":"Mysql_base_02","uri":"https://qizhengzou.github.io/mysql_base_02/"},{"categories":["School courses"],"content":"关系模型的提出与作用 关系模型最早由E.F.Codd在1970年提出 是从表(Table)及表的处理方式抽象出来的, 是在对传统表及其操作严格定义基础上，引入集合理论与逻辑学理论提出的 是数据库的三大经典数据模型之一,也是现在大多数商品化数据库系统 所仍然使用的数据模型 标准的数据库语言(SQL语言)是建立在关系模型基础之上的,数据库领 域的众多理论也都是建立在关系模型基础之上的 ","date":"2021-11-07 09:18:21","objectID":"https://qizhengzou.github.io/mysql_base_02/:1:1","tags":["mysql"],"title":"Mysql_base_02","uri":"https://qizhengzou.github.io/mysql_base_02/"},{"categories":["School courses"],"content":"关系模型与关系运算概览 一个关系(relation)就是一个Table 关系模型就是处理Table的，它由三个部分组成： • 描述DB各种数据的基本结构形式(采用Table描述) • 描述Table与Table之间所可能发生的各种操作(关系运算) • 描述这些操作所应遵循的约束条件(被称为完整性条件) 关系运算：关系代数和关系演算 关系演算：元组演算和域演算 关系代数示例：基于集合的运算 元组演算示例：检索出课程都及格的所有同学： 域演算示例：检索出不是03系的所有学生: ","date":"2021-11-07 09:18:21","objectID":"https://qizhengzou.github.io/mysql_base_02/:1:2","tags":["mysql"],"title":"Mysql_base_02","uri":"https://qizhengzou.github.io/mysql_base_02/"},{"categories":["School courses"],"content":"关系与关系模型 ","date":"2021-11-07 09:18:21","objectID":"https://qizhengzou.github.io/mysql_base_02/:2:0","tags":["mysql"],"title":"Mysql_base_02","uri":"https://qizhengzou.github.io/mysql_base_02/"},{"categories":["School courses"],"content":"关系 域 (Domain) 元组 (Tuple) 笛卡尔积 关系 (Relation) 关系模式 (Relational Schema) 属性 (Attribute) 关系的度 (Degree)与关系的基数 (Cardinality) 候选码、主码、主属性与非主属性、外码等 域(Domain)：一组值的集合，这组值具有相同的数据类型，集合中元素的个数称为域的基数(Cardinality) 元组(d1 , d2 , … , dn)的每一个值di叫做一个分量(component),元组(d1 , d2 , … , dn)是从每一个域任取一个值所形成的一种组合，笛卡尔积是所有这种可能组合的集合，即：笛卡尔积是由n个域形成的所有可能的n- 元组的集合。 关系可用R(A1:D1 , A2:D2 , … , An:Dn )表示，可简记为R(A1 , A2 , … , An )，这种描述又被称为关系模式(Schema)或表标题(head)。R是关系的名字,Ai是属性,Di是属性所对应的域,n是关系的度或目(degree), 关系中元组的数目称为关系的基数(Cardinality) 关系模式与关系： 同一关系模式下，可有很多的关系 关系模式是关系的结构,关系是关系模式在某一时刻的数据 关系模式是稳定的；而关系是某一时刻的值，随时间变化 理论上：任意两个元组不能完全相同。(集合的要求：集合内不能有相同的 两个元素)；真实Table可能有完全相同的两行! 属性不可再分特性:又被称为关系第一范式 候选码(Candidate Key)/候选键：关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉任何一个属性，它就不具有这一性质了，这样的属性组称作候选码 主码( Primary Key)/主键：当有多个候选码时，可以选定一个作为主码。DBMS以主码为主要线索管理关系中的各个元组。 主属性与非主属性：包含在任何一个候选码中的属性被称作主属性，而其他属性被称作非主属性 外码(Foreign Key)/外键：关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码相对应，则称这个属性组为R的外码或外键 超码：是指一个或多个属性的集合，这些属性的组合可以使我们在一个实体集中唯一地标识一个实体 ","date":"2021-11-07 09:18:21","objectID":"https://qizhengzou.github.io/mysql_base_02/:2:1","tags":["mysql"],"title":"Mysql_base_02","uri":"https://qizhengzou.github.io/mysql_base_02/"},{"categories":["School courses"],"content":"关系模型 关系模型 DB数据的基本结构：Relation/Table DB数据的基本操作有：∪(并, UNION)、-(差, DIFFERENCE)、×(广义积, PRODUCT)、 (选择, SELECTION)、 ∏(投影，PROJECTION)、 ∩(交, INTERSECTION) 、Join(连接, JOIN)、 ÷(除, DIVISION)运算 DB数据的结构与操作受三个完整性的约束：实体完整性、参照完 整性和用户自定义的完整性 关系的完整性 实体完整性 关系的主码中的属性值不能为空值 空值：不知道或无意义的值 意义：关系中的元组对应到现实世界相互之间可区分的一个个个体，这些个体是通过主码来唯一标识的；若主码为空，则出现不可标识的 个体，这是不容许的 空值的含义 空值：不知道、不存在或无意义的值 在进行关系操作时，有时关系中的某属性值在当前是填不上的，比如档案中有“生日不详”、“下落不明”、“日程尚待公布”等，这时就需要空值来代表这种情况。关系模型中用‘?’表征 数据库中有了空值，会影响许多方面，如影响聚集函数运算的正确 性，不能参与算术、比较或逻辑运算 有空值的时候是需要特殊处理的，要特别注意 参照完整性 如果关系R1的外码Fk与关系R2的主 码Pk相对应，则R1中的每一个元组的 Fk值或者等于R2中某个元组的Pk值，或者为空值 意义：如果关系R1的某个元组t1参照 了关系R2的某个元组t2，则t2必须存在 用户自定义完整性 用户针对具体的应用环境定义的完整性约束条件 如S#要求是10位整数，其中前四位为年度，当前年度与他们的 差必须在4以内 DBMS对关系完整性的支持 实体完整性和参照完整性由DBMS系统自动支持 DBMS系统通常提供了如下机制： 它使用户可以自行定义有关的完整性约束条件 当有更新操作时，自动检验更新操作的正确性，即是否符合用户自定义的完整性 ","date":"2021-11-07 09:18:21","objectID":"https://qizhengzou.github.io/mysql_base_02/:2:2","tags":["mysql"],"title":"Mysql_base_02","uri":"https://qizhengzou.github.io/mysql_base_02/"},{"categories":["School courses"],"content":"关系代数运算 基于集合，提供了一系列的关系代数操作：并、差、笛卡尔积(广义积)、 交、选择、投影、连接和关系除，是一种集合思维的操作语言。关系代数操作以一个或多个关系为输入，结果是一个新的关系 关系代数基本操作分为：集合操作（并、交、差、笛卡尔积）和纯关系操作（选择、投影、连接、除） 并相容性（不一定要属性都一样）： 参与运算的两个关系及其相关属性之间有一定的对应性 定义：关系R与关系S存在相容性，当且仅当： 关系R和关系S的属性数目必须相同； 对于任意i，关系R的第i个属性的域必须和关系S的第i个属性的域相同 笛卡尔积：又叫cross join，是SQL中两表连接的一种方式。 假如A表中的数据为m行，B表中的数据有n行，那么A和B做笛卡尔积，结果为m*n行。 通常我们都要在实际SQL中避免直接使用笛卡尔积，因为它会使“数据爆炸”，尤其是数据量很大的时候。 但某些时候，巧妙的使用笛卡尔积，反而能快速帮助我们解决实际问题。笛卡尔积参考 选择 投影 连接 θ-连接 注：上式p SC1 (SC)表更名操作，即将表SC更名为SC1，当一个表需要和其自身进行连接运算时，通常要使用更名操作。 在讲解θ-连接操作时，使用笛卡尔积然后再进行选择来得到θ- 连接结果。这主要是方便大家理解。但当引入连接操作后，DBMS可直接进行连接操作，而不必先形成笛卡尔积 等值连接 θ -连接的特例 自然连接 自然连接=特殊的等值连接+去除重复属性组。 组合示例 除 前提条件：给定关系R(A1 ,A2 , … ,An)为n度关系和关系S(B1 ,B2 , …,Bm)为m度关系，如果可以进行关系R与关系S的除运算，当且仅当：属性集{ B1 ,B2, … ,Bm}是属性集{ A1 ,A2, … ,An}的真子集，即m \u003c n 示例 外连接 定义：两个关系R与S进行连接时，如果关系R(或S)中的元组在S(或R)中找不到相匹配的元组，则为了避免该元组信息丢失，从而将该元组与S(或R)中假定存在的全为空值的元组形成连接，放置在结果关系中，这种连接称之为外连接(Outer Join) 外连接 = 自然连接 (或 连接) + 失配的元组(与全空元组形成的连接) 外连接的形式：左外连接、右外连接、全外连接 左外连接 = 自然连接(或θ连接) + 左侧表中失配的元组 右外连接 = 自然连接(或θ连接) + 右侧表中失配的元组 全外连接 = 自然连接(或θ连接) + 两侧表中失配的元组 ","date":"2021-11-07 09:18:21","objectID":"https://qizhengzou.github.io/mysql_base_02/:3:0","tags":["mysql"],"title":"Mysql_base_02","uri":"https://qizhengzou.github.io/mysql_base_02/"},{"categories":["School courses"],"content":" 笔记来自哈工大深圳2021秋数据库系统理论课授课老师：刘圣鑫 数据库概念结构 ","date":"2021-11-07 09:14:50","objectID":"https://qizhengzou.github.io/mysql_base_01/:0:0","tags":["mysql"],"title":"Mysql_base_01","uri":"https://qizhengzou.github.io/mysql_base_01/"},{"categories":["School courses"],"content":"基本概念 32 ","date":"2021-11-07 09:14:50","objectID":"https://qizhengzou.github.io/mysql_base_01/:1:0","tags":["mysql"],"title":"Mysql_base_01","uri":"https://qizhengzou.github.io/mysql_base_01/"},{"categories":["School courses"],"content":"什么是数据库及为什么要学数据库？ 现代信息社会有异于传统社会，业务工作是建立在计算机网络以及数据库的支持上的。数据库将传统纸张上记录的各种信息规范化并使之电子化,形成电子信息‘库’以便利用计算机对这些信息进行快速有效的检索、统计与管理。 ","date":"2021-11-07 09:14:50","objectID":"https://qizhengzou.github.io/mysql_base_01/:1:1","tags":["mysql"],"title":"Mysql_base_01","uri":"https://qizhengzou.github.io/mysql_base_01/"},{"categories":["School courses"],"content":"数据库(信息库) E.F.Codd, 基于对“表”的理解:提出了“关系”及关系模型，提出了关系数据库理论，开创了数据库的时代，是当前普遍应用的数据库管理系统的奠基者，并获得了计算机领域最高奖“图灵奖”。 ","date":"2021-11-07 09:14:50","objectID":"https://qizhengzou.github.io/mysql_base_01/:1:2","tags":["mysql"],"title":"Mysql_base_01","uri":"https://qizhengzou.github.io/mysql_base_01/"},{"categories":["School courses"],"content":"数据库系统(工作环境) 数据库(DB): Database 数据库管理系统(DBMS): Database Management System 数据库应用(DBAP): DataBase Application 数据库管理员(DBA): DataBase Administrator ","date":"2021-11-07 09:14:50","objectID":"https://qizhengzou.github.io/mysql_base_01/:1:3","tags":["mysql"],"title":"Mysql_base_01","uri":"https://qizhengzou.github.io/mysql_base_01/"},{"categories":["School courses"],"content":"数据库管理系统(软件系统) DBMS提供一套数据定义语言(DDL:Data Definition Language)给用户,用户使用DDL描述其所要建立表的格式,DBMS依照用户的定义，创建数据库及其中的Table。 数据操纵语言(DML:Data Manipulation Language)，用户使用DML描述其所要进行的增、删、改、查等操作，DBMS依照用户的操作描述，实际执行这些操作。 数据控制语言(DCL:Data Control Language)，用户使用DCL描述其对数据库所要实施的控制，DBMS依照用户的描述，实际进行控制。 语言翻译器：将用数据库语言书写的内容，翻译成DBMS可执行的命令。 例如: DDL编译器, DML编译器, DCL编译器等; 查询优化与查询实现(执行引擎)：提高数据库检索速度的手段；例如贯穿于数据存取各个阶段的优化程序; 数据存取：提供数据在磁盘、磁带等上的高效存取手段。例如:存储管理器, 缓冲区管理器,索引/文件和记录管理器等; 通信控制：提供网络环境下数据库操作的手段。 ","date":"2021-11-07 09:14:50","objectID":"https://qizhengzou.github.io/mysql_base_01/:1:4","tags":["mysql"],"title":"Mysql_base_01","uri":"https://qizhengzou.github.io/mysql_base_01/"},{"categories":["School courses"],"content":"数据库工作者的分类及要求 终端用户（ End Users ）： 无经验用户（naive Users） 非固定用户（casual users ）——交互式SQL 应用程序程序员——过程SQL，关于事务的概念 数据库分析员和设计员——数据建模，关于规范化的概念 数据库管理员（DBA）——数据库维护、安全性、完整性、恢复 数据库管理系统的设计者和实现者——实现以上技术 专用和新型数据库管理系统技术 ","date":"2021-11-07 09:14:50","objectID":"https://qizhengzou.github.io/mysql_base_01/:2:0","tags":["mysql"],"title":"Mysql_base_01","uri":"https://qizhengzou.github.io/mysql_base_01/"},{"categories":["School courses"],"content":"标准结构 ","date":"2021-11-07 09:14:50","objectID":"https://qizhengzou.github.io/mysql_base_01/:3:0","tags":["mysql"],"title":"Mysql_base_01","uri":"https://qizhengzou.github.io/mysql_base_01/"},{"categories":["School courses"],"content":"DBMS管理数据的三个层次：(外部)视图、全局视图、内部视图 External Level = User Level，某一用户能够看到与处理的数据, 全局数据中的某一部分 Conceptual Level = Logic level，从全局角度理解/管理的数据, 含相应的关联约束 Internal Level = Physical level，存储在介质上的数据，含存储路径、存储方式 、索引方式等 ","date":"2021-11-07 09:14:50","objectID":"https://qizhengzou.github.io/mysql_base_01/:3:1","tags":["mysql"],"title":"Mysql_base_01","uri":"https://qizhengzou.github.io/mysql_base_01/"},{"categories":["School courses"],"content":"模式的概念：外模式、(概念)模式、内模式 数据的结构—-模式 所观察到数据的结构信息eg:学生登记表( 学号 char(8), 姓名 char(10), 性别 Char(2), 出生年月 datetime, 入学日 期 Datetime, 家庭住址 Char(40) ) 展现的数据—-视图 某一种表现形式下表现出来的数据库中的数据 两层映像: E-C Mapping：External Schema-Conceptual Schema Mapping —-将外模式映射为概念模式，从而支持实现数据概念视图向外部视图的转换 —-便于用户观察和使用 C-I Mapping：Conceptual Schema-Internal Schema Mapping —-将概念模式映射为内模式，从而支持实现数据概念视图向内部视图的转换 —-便于计算机进行存储和处理 两个独立性: 逻辑数据独立性:当概念模式变化时，可以不改变外部模式(只需改变E-C Mapping)，从而无需改变应用程序 物理数据独立性:当内部模式变化时，可以不改变概念模式(只需改变C-I Mapping) ，从而不改变外部模式 ","date":"2021-11-07 09:14:50","objectID":"https://qizhengzou.github.io/mysql_base_01/:3:2","tags":["mysql"],"title":"Mysql_base_01","uri":"https://qizhengzou.github.io/mysql_base_01/"},{"categories":["School courses"],"content":"数据模型与模式 数据模型是对模式本身结构的抽象，模式是对数据本身结构形式的抽象。 关系模型中的所有模式都可为抽象表(Table)的形式，而每一个具体的模式都是 拥有不同列名的具体的表。 三大经典数据模型： • 关系模型：表的形式组织数据 • 层次模型：树的形式组织数据 • 网状模型：图的形式组织数据 层次模型的优缺点： 优点： Ø 数据结构简单清晰。 Ø 查询效率高。记录之间的联系用有向边表示，这种联系在DBMS中通常使 用指针实现。 Ø 层次模型数据库性能优于关系数据库，不低于网状数据库。提供了良好的 完整性支持。 缺点： Ø 现实世界中的很多联系是非层次性的。如果结点之间具有多对多联系，不 再适合使用层次模型表示。如果一个子女结点确实具有多个双亲结点，使 用层次结构模型表示的时候就会出现大量的冗余，且操作复杂。 Ø 查询子女结点必须通过双亲结点。由于结构严密，层次命令趋于程序化。 网状模型的优缺点： 优点： 能够更为直接地表示现实世界。具有良好的性能，存取效率高。 缺点： Ø 结构复杂，伴随应用环境的扩大，数据结构变得越来越复杂，不利于最终 用户掌握。 Ø 网状模型的数据定义语言和数据管理语言复杂。 Ø 应用程序编写困难。由于记录之间的联系通过存取路径实现，应用程序在 访问数据的时候必须选择恰当的存取路径，因此用户必须了解系统结构的 细节，导致加重了编写应用程序的负担。 ","date":"2021-11-07 09:14:50","objectID":"https://qizhengzou.github.io/mysql_base_01/:3:3","tags":["mysql"],"title":"Mysql_base_01","uri":"https://qizhengzou.github.io/mysql_base_01/"},{"categories":["School courses"],"content":"简要发展史及发展趋势 参考发展史与发展趋势 ","date":"2021-11-07 09:14:50","objectID":"https://qizhengzou.github.io/mysql_base_01/:4:0","tags":["mysql"],"title":"Mysql_base_01","uri":"https://qizhengzou.github.io/mysql_base_01/"},{"categories":null,"content":"关于网站 个人博客,学习笔记 ","date":"2021-11-06 00:00:00","objectID":"https://qizhengzou.github.io/about/:1:0","tags":null,"title":"About","uri":"https://qizhengzou.github.io/about/"},{"categories":null,"content":"关于我 哈尔滨工业大学（深圳）19 级计算机本科生，01 年出生，籍贯江西，共青团员，目前坐标深圳。 菜鸡一枚，争取持续学习就好 ","date":"2021-11-06 00:00:00","objectID":"https://qizhengzou.github.io/about/:2:0","tags":null,"title":"About","uri":"https://qizhengzou.github.io/about/"},{"categories":null,"content":"关于博客笔记 目前输出的博客很少，很多都是学习笔记，日后会改善。 博客标题被我规格化了，虽无法直接从标题获取具体内容，但方便管理。 将某标签所有博客的目录放在单独的一个markdown文件（可在catalogue目录里找到）里： 有利于复习 有利于该方向所有博客的知识体系框架的建立 查找相关内容时更方便 ","date":"2021-11-06 00:00:00","objectID":"https://qizhengzou.github.io/about/:3:0","tags":null,"title":"About","uri":"https://qizhengzou.github.io/about/"},{"categories":null,"content":"致谢 本站所有文章受创作共享 署名-非商业性 4.0 许可协议 / CC BY-NC 4.0 保护。 本站图片部分来自互联网以及哈尔滨工业大学（深圳）教学课件，仅供公益性的学习参考，在此表示感谢！此类图片的原版权所有者可在任何时候、以任何理由要求本站停止使用有关图片，其中包括被本站编辑（比如加注中文说明）过的图片， 联系方式见本站首页。 转载注明来源为本站首页网址 qizhengzou.github.io，或所转内容在本站的完整网址 ","date":"2021-11-06 00:00:00","objectID":"https://qizhengzou.github.io/about/:4:0","tags":null,"title":"About","uri":"https://qizhengzou.github.io/about/"}]