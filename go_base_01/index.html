<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>Go_base_01 - Jefo</title><meta name=Description content="Jefo"><meta property="og:title" content="Go_base_01"><meta property="og:description" content="主要特征 自动立即回收。(自带GC) 更丰富的内置类型。 函数多返回值。 错误处理。 匿名函数和闭包。 类型和接口。 并发编程。 反射。 语言交互性。 Go的函"><meta property="og:type" content="article"><meta property="og:url" content="https://qizhengzou.github.io/go_base_01/"><meta property="og:image" content="https://qizhengzou.github.io/logo.png"><meta property="article:published_time" content="2021-11-09T20:55:59+08:00"><meta property="article:modified_time" content="2021-11-09T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://qizhengzou.github.io/logo.png"><meta name=twitter:title content="Go_base_01"><meta name=twitter:description content="主要特征 自动立即回收。(自带GC) 更丰富的内置类型。 函数多返回值。 错误处理。 匿名函数和闭包。 类型和接口。 并发编程。 反射。 语言交互性。 Go的函"><meta name=application-name content="LoveIt"><meta name=apple-mobile-web-app-title content="LoveIt"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://qizhengzou.github.io/go_base_01/><link rel=prev href=https://qizhengzou.github.io/mysql_base_13/><link rel=next href=https://qizhengzou.github.io/distributedsystem_base_01/><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Go_base_01","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/qizhengzou.github.io\/go_base_01\/"},"image":["https:\/\/qizhengzou.github.io\/images\/Apple-Devices-Preview.png"],"genre":"posts","keywords":"go grammar","wordcount":13200,"url":"https:\/\/qizhengzou.github.io\/go_base_01\/","datePublished":"2021-11-09T20:55:59+08:00","dateModified":"2021-11-09T00:00:00+00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"Jefo","logo":"https:\/\/qizhengzou.github.io\/images\/avatar.png"},"author":{"@type":"Person","name":"Jefo"},"description":""}</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-193031966-2"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-193031966-2');</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><div class=header-wrapper><div class=header-title><a href=/ title=Jefo><span class=header-title-pre><i class="far fa-kiss-wink-heart fa-fw"></i></span>Jefo</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/>关于 </a><a class=menu-item href=https://github.com/qizhengzou title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i></a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item language" title=选择语言>简体中文<i class="fas fa-chevron-right fa-fw"></i>
<select class=language-select id=language-select-desktop onchange="location=this.value;"><option value=/go_base_01/ selected>简体中文</option></select>
</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=Jefo><span class=header-title-pre><i class="far fa-kiss-wink-heart fa-fw"></i></span>Jefo</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/>所有文章</a><a class=menu-item href=/tags/>标签</a><a class=menu-item href=/categories/>分类</a><a class=menu-item href=/about/>关于</a><a class=menu-item href=https://github.com/qizhengzou title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i></a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a><a href=javascript:void(0); class=menu-item title=选择语言>简体中文<i class="fas fa-chevron-right fa-fw"></i>
<select class=language-select onchange="location=this.value;"><option value=/go_base_01/ selected>简体中文</option></select></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">Go_base_01</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>Jefo</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/go/><i class="far fa-folder fa-fw"></i>go</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-11-09 20:55:59">2021-11-09 20:55:59</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 13200 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 27 分钟&nbsp;<span id=busuanzi_container_page_pv>
<i class="far fa-eye fa-fw"></i>&nbsp;<span id=busuanzi_value_page_pv></span>&nbsp;次阅读量</span></span></div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#主要特征>主要特征</a></li><li><a href=#内置类型与函数>内置类型与函数</a></li><li><a href=#init--main>init & main</a></li><li><a href=#go命令>go命令</a></li><li><a href=#运算符>运算符</a></li><li><a href=#下划线>下划线</a></li><li><a href=#变量和常量>变量和常量</a></li><li><a href=#基本类型>基本类型</a></li><li><a href=#字符串>字符串：</a></li><li><a href=#数组>数组</a></li><li><a href=#切片>切片</a><ul><li><a href=#切片底层实现>切片底层实现</a></li><li><a href=#创建切片>创建切片</a><ul><li><a href=#空切片和nil切片>空切片和nil切片</a></li><li><a href=#扩容策略>扩容策略</a></li></ul></li><li><a href=#切片拷贝>切片拷贝</a></li></ul></li><li><a href=#指针>指针</a></li><li><a href=#map>map</a><ul><li><a href=#map实现原理>map实现原理</a></li><li><a href=#go中map的实现原理>go中map的实现原理</a></li></ul></li><li><a href=#结构体>结构体</a><ul><li><a href=#类型别名和自定义类型>类型别名和自定义类型</a></li></ul></li><li><a href=#结构体-1>结构体</a><ul><li><a href=#方法和接收者>方法和接收者</a></li></ul></li><li><a href=#参考>参考</a></li></ul></nav></div></div><div class=content id=content><h2 id=主要特征>主要特征</h2><ol><li>自动立即回收。(自带GC)</li><li>更丰富的内置类型。</li><li>函数多返回值。</li><li>错误处理。</li><li>匿名函数和闭包。</li><li>类型和接口。</li><li>并发编程。</li><li>反射。</li><li>语言交互性。</li></ol><p>Go的函数、变量、常量、自定义类型、包(package)的命名方式遵循以下规则：</p><ul><li>1）首字符可以是任意的Unicode字符（一个字符两个字节，表示包括了每种语言）或者下划线</li><li>2）剩余字符可以是Unicode字符、下划线、数字</li><li>3）字符长度不限</li></ul><p>25关键字：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>    <span class=k>break</span>        <span class=k>default</span>      <span class=kd>func</span>         <span class=kd>interface</span>    <span class=k>select</span>
    <span class=k>case</span>         <span class=k>defer</span>        <span class=k>go</span>           <span class=kd>map</span>          <span class=kd>struct</span>
    <span class=kd>chan</span>         <span class=k>else</span>         <span class=k>goto</span>         <span class=kn>package</span>      <span class=k>switch</span>
    <span class=kd>const</span>        <span class=k>fallthrough</span>  <span class=k>if</span>           <span class=k>range</span>        <span class=kd>type</span>
    <span class=k>continue</span>     <span class=k>for</span>          <span class=kn>import</span>       <span class=k>return</span>       <span class=kd>var</span>
</code></pre></td></tr></table></div></div><ul><li>select和switch:select只能应用于channel的操作，既可以用于channel的数据接收，也可以用于channel的数据发送。如果select的多个分支都满足条件，则会随机的选取其中一个满足条件的分支。而switch用于一般的分支判断，顺序执行。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>
<span class=kn>import</span> <span class=s>&#34;time&#34;</span>
<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>c1</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>string</span><span class=p>)</span>
    <span class=nx>c2</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>string</span><span class=p>)</span>
    <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=mi>1</span><span class=p>)</span>
        <span class=nx>c1</span> <span class=o>&lt;-</span> <span class=s>&#34;one&#34;</span>
    <span class=p>}</span><span class=p>(</span><span class=p>)</span>
    <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=mi>2</span><span class=p>)</span>
        <span class=nx>c2</span> <span class=o>&lt;-</span> <span class=s>&#34;two&#34;</span>
    <span class=p>}</span><span class=p>(</span><span class=p>)</span>
    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>2</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
        <span class=k>select</span> <span class=p>{</span>
        <span class=k>case</span> <span class=nx>msg1</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>c1</span><span class=p>:</span>
            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;received&#34;</span><span class=p>,</span> <span class=nx>msg1</span><span class=p>)</span>
        <span class=k>case</span> <span class=nx>msg2</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>c2</span><span class=p>:</span>
            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;received&#34;</span><span class=p>,</span> <span class=nx>msg2</span><span class=p>)</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><ul><li>fallthrough:可以使用fallthrough强制执行该case执行完下一条case代码，fallthrough不会判断下一条case的判断结果是否为true。
37个保留字：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>    <span class=nx>Constants</span><span class=p>:</span>    <span class=kc>true</span>  <span class=kc>false</span>  <span class=kc>iota</span>  <span class=kc>nil</span>

    <span class=nx>Types</span><span class=p>:</span>    <span class=kt>int</span>  <span class=kt>int8</span>  <span class=kt>int16</span>  <span class=kt>int32</span>  <span class=kt>int64</span>  
              <span class=kt>uint</span>  <span class=kt>uint8</span>  <span class=kt>uint16</span>  <span class=kt>uint32</span>  <span class=kt>uint64</span>  <span class=kt>uintptr</span>
              <span class=kt>float32</span>  <span class=kt>float64</span>  <span class=kt>complex128</span>  <span class=kt>complex64</span>
              <span class=kt>bool</span>  <span class=kt>byte</span>  <span class=kt>rune</span>  <span class=kt>string</span>  <span class=kt>error</span>

    <span class=nx>Functions</span><span class=p>:</span>   <span class=nx>make</span>  <span class=nx>len</span>  <span class=nx>cap</span>  <span class=nx>new</span>  <span class=nx>append</span>  <span class=nx>copy</span>  <span class=nx>close</span>  <span class=nx>delete</span>
                 <span class=nx>complex</span>  <span class=nx>real</span>  <span class=nx>imag</span>
                 <span class=nx>panic</span>  <span class=nx>recover</span>
</code></pre></td></tr></table></div></div><ul><li>new&make<ul><li>func new(Type) *Type</li><li>func make(t Type, size &mldr;IntegerType) Type</li></ul></li></ul><p>go声明：var,const,type,func</p><h2 id=内置类型与函数>内置类型与函数</h2><p>值类型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kt>bool</span>
<span class=nb>int</span><span class=p>(</span><span class=mi>32</span> <span class=nx>or</span> <span class=mi>64</span><span class=p>)</span><span class=p>,</span> <span class=kt>int8</span><span class=p>,</span> <span class=kt>int16</span><span class=p>,</span> <span class=kt>int32</span><span class=p>,</span> <span class=kt>int64</span>
<span class=nb>uint</span><span class=p>(</span><span class=mi>32</span> <span class=nx>or</span> <span class=mi>64</span><span class=p>)</span><span class=p>,</span> <span class=nb>uint8</span><span class=p>(</span><span class=kt>byte</span><span class=p>)</span><span class=p>,</span> <span class=kt>uint16</span><span class=p>,</span> <span class=kt>uint32</span><span class=p>,</span> <span class=kt>uint64</span>
<span class=kt>float32</span><span class=p>,</span> <span class=kt>float64</span>
<span class=kt>string</span>
<span class=kt>complex64</span><span class=p>,</span> <span class=kt>complex128</span>
<span class=nx>array</span>
</code></pre></td></tr></table></div></div><p><strong>引用类型</strong>（声明的同时需要分配内存空间，不然会引发panic，分配内存可以用new或者make）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>slice</span>
<span class=kd>map</span>
<span class=kd>chan</span>
</code></pre></td></tr></table></div></div><p>内置函数（无需导入即可使用）:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>append</span>          <span class=o>--</span> <span class=nx>用来追加元素到数组</span><span class=err>、</span><span class=nx>slice中</span><span class=p>,</span><span class=nx>返回修改后的数组</span><span class=err>、</span><span class=nx>slice</span>
<span class=nx>close</span>           <span class=o>--</span> <span class=nx>主要用来关闭channel</span>
<span class=nx>delete</span>            <span class=o>--</span> <span class=nx>从map中删除key对应的value</span>
<span class=nx>panic</span>            <span class=o>--</span> <span class=nx>停止常规的goroutine</span>  <span class=err>（</span><span class=nx>panic和recover</span><span class=err>：</span><span class=nx>用来做错误处理</span><span class=err>）</span>
<span class=nx>recover</span>         <span class=o>--</span> <span class=nx>允许程序定义goroutine的panic动作</span>
<span class=nx>real</span>            <span class=o>--</span> <span class=nx>返回complex的实部</span>   <span class=err>（</span><span class=nx>complex</span><span class=err>、</span><span class=nx>real</span> <span class=nx>imag</span><span class=err>：</span><span class=nx>用于创建和操作复数</span><span class=err>）</span>
<span class=nx>imag</span>            <span class=o>--</span> <span class=nx>返回complex的虚部</span>
<span class=nx>make</span>            <span class=o>--</span> <span class=nx>用来分配内存</span><span class=err>，</span><span class=nx>返回Type本身</span><span class=p>(</span><span class=nx>只能应用于slice</span><span class=p>,</span> <span class=kd>map</span><span class=p>,</span> <span class=nx>channel</span><span class=p>)</span> <span class=nx>make</span> <span class=nx>函数允许在运行期动态指定数组长度</span><span class=err>，</span><span class=nx>绕开了数组类型必须使用编译期常量的限制</span><span class=err>。</span>
<span class=nx>new</span>                <span class=o>--</span> <span class=nx>用来分配内存</span><span class=err>，</span><span class=nx>主要用来分配值类型</span><span class=err>，</span><span class=nx>比如int</span><span class=err>、</span><span class=kd>struct</span><span class=err>。</span><span class=nx>返回指向Type的指针</span>
<span class=nx>cap</span>                <span class=o>--</span> <span class=nx>capacity是容量的意思</span><span class=err>，</span><span class=nx>用于返回某个类型的最大容量</span><span class=err>（</span><span class=nx>只能用于切片和</span> <span class=kd>map</span><span class=err>）</span>
<span class=nx>copy</span>            <span class=o>--</span> <span class=nx>用于复制和连接slice</span><span class=err>，</span><span class=nx>返回复制的数目</span>
<span class=nx>len</span>                <span class=o>--</span> <span class=nx>用来求长度</span><span class=err>，</span><span class=nx>比如string</span><span class=err>、</span><span class=nx>array</span><span class=err>、</span><span class=nx>slice</span><span class=err>、</span><span class=kd>map</span><span class=err>、</span><span class=nx>channel</span> <span class=err>，</span><span class=nx>返回长度</span>
<span class=nx>print</span><span class=err>、</span><span class=nx>println</span>     <span class=o>--</span> <span class=nx>底层打印函数</span><span class=err>，</span><span class=nx>在部署环境中建议使用</span> <span class=nx>fmt</span> <span class=nx>包</span>
</code></pre></td></tr></table></div></div><p>内直接口error：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=kt>error</span> <span class=kd>interface</span> <span class=p>{</span> <span class=c1>//只要实现了Error()函数，返回值为String的都实现了err接口（鸭子类型）
</span><span class=c1></span>    <span class=nf>Error</span><span class=p>(</span><span class=p>)</span>    <span class=nx>String</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=init--main>init & main</h2><p>go语言中init函数用于包(package)的初始化，该函数是go语言的一个重要特性。有下面的特征：</p><ol><li>init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等</li><li>每个包可以拥有多个init函数</li><li>包的每个源文件也可以拥有多个init函数</li><li>同一个包中多个init函数的执行顺序go语言没有明确的定义(说明)</li><li>不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序</li><li>init函数不能被其他函数调用，而是在main函数执行之前，自动被调用</li></ol><p>Go语言程序的默认入口函数(主函数)：func main(){
……
}</p><p>init函数和main函数的异同：</p><ul><li>同<ul><li>两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用。</li></ul></li><li>异<ul><li>init可以应用于任意包中，且可以重复定义多个。</li><li>main函数只能用于main包中，且只能定义一个。</li></ul></li></ul><p>执行顺序：</p><ul><li>对同一个go文件的init()调用顺序是从上到下的。</li><li>对同一个package中不同文件是按<strong>文件名字符串比较“从小到大”顺序</strong>调用各文件中的init()函数。</li><li>对于不同的package，如果不相互依赖的话，按照main包中”先import的后调用”的顺序调用其包中的init()，如果package存在依赖，则先调用最早被依赖的package中的init()，最后调用main函数。</li><li>如果init函数中使用了println()或者print()你会发现在执行过程中这两个不会按照你想象中的顺序执行。这两个函数官方只推荐在测试环境中使用，对于正式环境不要使用。</li></ul><h2 id=go命令>go命令</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>PS</span> <span class=nx>D</span><span class=p>:</span><span class=err>\</span><span class=nx>Blog</span><span class=err>\</span><span class=nx>qizhengzou</span><span class=p>.</span><span class=nx>github</span><span class=p>.</span><span class=nx>io</span><span class=o>-</span><span class=nx>blog</span><span class=err>\</span><span class=nx>content</span><span class=err>\</span><span class=nx>posts</span><span class=p>&gt;</span> <span class=k>go</span>
<span class=nx>Go</span> <span class=nx>is</span> <span class=nx>a</span> <span class=nx>tool</span> <span class=k>for</span> <span class=nx>managing</span> <span class=nx>Go</span> <span class=nx>source</span> <span class=nx>code</span><span class=p>.</span>

<span class=nx>Usage</span><span class=p>:</span>

        <span class=k>go</span> <span class=p>&lt;</span><span class=nx>command</span><span class=p>&gt;</span> <span class=p>[</span><span class=nx>arguments</span><span class=p>]</span>

<span class=nx>The</span> <span class=nx>commands</span> <span class=nx>are</span><span class=p>:</span>

        <span class=nx>bug</span>         <span class=nx>start</span> <span class=nx>a</span> <span class=nx>bug</span> <span class=nx>report</span>
        <span class=nx>build</span>       <span class=nx>compile</span> <span class=nx>packages</span> <span class=nx>and</span> <span class=nx>dependencies</span>       
        <span class=nx>clean</span>       <span class=nx>remove</span> <span class=nx>object</span> <span class=nx>files</span> <span class=nx>and</span> <span class=nx>cached</span> <span class=nx>files</span>    
        <span class=nx>doc</span>         <span class=nx>show</span> <span class=nx>documentation</span> <span class=k>for</span> <span class=kn>package</span> <span class=nx>or</span> <span class=nx>symbol</span>
        <span class=nx>env</span>         <span class=nx>print</span> <span class=nx>Go</span> <span class=nx>environment</span> <span class=nx>information</span>        
        <span class=nx>fix</span>         <span class=nx>update</span> <span class=nx>packages</span> <span class=nx>to</span> <span class=nx>use</span> <span class=nx>new</span> <span class=nx>APIs</span>
        <span class=nx>fmt</span>         <span class=nf>gofmt</span> <span class=p>(</span><span class=nx>reformat</span><span class=p>)</span> <span class=kn>package</span> <span class=nx>sources</span>        
        <span class=nx>generate</span>    <span class=nx>generate</span> <span class=nx>Go</span> <span class=nx>files</span> <span class=nx>by</span> <span class=nx>processing</span> <span class=nx>source</span>  
        <span class=nx>get</span>         <span class=nx>add</span> <span class=nx>dependencies</span> <span class=nx>to</span> <span class=nx>current</span> <span class=nx>module</span> <span class=nx>and</span> <span class=nx>install</span> <span class=nx>them</span>
        <span class=nx>install</span>     <span class=nx>compile</span> <span class=nx>and</span> <span class=nx>install</span> <span class=nx>packages</span> <span class=nx>and</span> <span class=nx>dependencies</span>
        <span class=nx>list</span>        <span class=nx>list</span> <span class=nx>packages</span> <span class=nx>or</span> <span class=nx>modules</span>
        <span class=nx>mod</span>         <span class=nx>module</span> <span class=nx>maintenance</span>
        <span class=nx>run</span>         <span class=nx>compile</span> <span class=nx>and</span> <span class=nx>run</span> <span class=nx>Go</span> <span class=nx>program</span>
        <span class=nx>test</span>        <span class=nx>test</span> <span class=nx>packages</span>
        <span class=nx>tool</span>        <span class=nx>run</span> <span class=nx>specified</span> <span class=k>go</span> <span class=nx>tool</span>
        <span class=nx>version</span>     <span class=nx>print</span> <span class=nx>Go</span> <span class=nx>version</span>
        <span class=nx>vet</span>         <span class=nx>report</span> <span class=nx>likely</span> <span class=nx>mistakes</span> <span class=nx>in</span> <span class=nx>packages</span>

<span class=nx>Use</span> <span class=s>&#34;go help &lt;command&gt;&#34;</span> <span class=k>for</span> <span class=nx>more</span> <span class=nx>information</span> <span class=nx>about</span> <span class=nx>a</span> <span class=nx>command</span><span class=p>.</span>

<span class=nx>Additional</span> <span class=nx>help</span> <span class=nx>topics</span><span class=p>:</span>

        <span class=nx>buildconstraint</span> <span class=nx>build</span> <span class=nx>constraints</span>
        <span class=nx>buildmode</span>       <span class=nx>build</span> <span class=nx>modes</span>
        <span class=nx>c</span>               <span class=nx>calling</span> <span class=nx>between</span> <span class=nx>Go</span> <span class=nx>and</span> <span class=nx>C</span>
        <span class=nx>cache</span>           <span class=nx>build</span> <span class=nx>and</span> <span class=nx>test</span> <span class=nx>caching</span>
        <span class=nx>environment</span>     <span class=nx>environment</span> <span class=nx>variables</span>
        <span class=nx>filetype</span>        <span class=nx>file</span> <span class=nx>types</span>
        <span class=k>go</span><span class=p>.</span><span class=nx>mod</span>          <span class=nx>the</span> <span class=k>go</span><span class=p>.</span><span class=nx>mod</span> <span class=nx>file</span>
        <span class=nx>gopath</span>          <span class=nx>GOPATH</span> <span class=nx>environment</span> <span class=nx>variable</span>
        <span class=nx>gopath</span><span class=o>-</span><span class=nx>get</span>      <span class=nx>legacy</span> <span class=nx>GOPATH</span> <span class=k>go</span> <span class=nx>get</span>
        <span class=nx>goproxy</span>         <span class=nx>module</span> <span class=nx>proxy</span> <span class=nx>protocol</span>
        <span class=nx>importpath</span>      <span class=kn>import</span> <span class=nx>path</span> <span class=nx>syntax</span>
        <span class=nx>modules</span>         <span class=nx>modules</span><span class=p>,</span> <span class=nx>module</span> <span class=nx>versions</span><span class=p>,</span> <span class=nx>and</span> <span class=nx>more</span>
        <span class=nx>module</span><span class=o>-</span><span class=nx>get</span>      <span class=nx>module</span><span class=o>-</span><span class=nx>aware</span> <span class=k>go</span> <span class=nx>get</span>
        <span class=nx>module</span><span class=o>-</span><span class=nx>auth</span>     <span class=nx>module</span> <span class=nx>authentication</span> <span class=nx>using</span> <span class=k>go</span><span class=p>.</span><span class=nx>sum</span>
        <span class=nx>packages</span>        <span class=kn>package</span> <span class=nx>lists</span> <span class=nx>and</span> <span class=nx>patterns</span>
        <span class=nx>private</span>         <span class=nx>configuration</span> <span class=k>for</span> <span class=nx>downloading</span> <span class=nx>non</span><span class=o>-</span><span class=nx>public</span> <span class=nx>code</span>
        <span class=nx>testflag</span>        <span class=nx>testing</span> <span class=nx>flags</span>
        <span class=nx>testfunc</span>        <span class=nx>testing</span> <span class=nx>functions</span>
        <span class=nx>vcs</span>             <span class=nx>controlling</span> <span class=nx>version</span> <span class=nx>control</span> <span class=nx>with</span> <span class=nx>GOVCS</span>

<span class=nx>Use</span> <span class=s>&#34;go help &lt;topic&gt;&#34;</span> <span class=k>for</span> <span class=nx>more</span> <span class=nx>information</span> <span class=nx>about</span> <span class=nx>that</span> <span class=nx>topic</span><span class=p>.</span>
</code></pre></td></tr></table></div></div><p>go env用于打印Go语言的环境信息。</p><p>go run命令可以编译并运行命令源码文件。</p><p>go get可以根据要求和实际情况从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装。</p><p>go build命令用于编译我们指定的源码文件或代码包以及它们的依赖包。</p><p>go install用于编译并安装指定的代码包及它们的依赖包。</p><p>go clean命令会删除掉执行其它命令时产生的一些文件和目录。</p><p>go doc命令可以打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。</p><p>go test命令用于对Go语言编写的程序进行测试。</p><p>go list命令的作用是列出指定的代码包的信息。</p><p>go fix会把指定代码包的所有Go语言源码文件中的旧版本代码修正为新版本的代码。</p><p>go vet是一个用于检查Go语言源码中静态错误的简单工具。</p><p>go tool pprof命令来交互式的访问概要文件的内容。</p><p>go modules 是 golang 1.11 新加的特性</p><ul><li>go<ul><li>download<ul><li>download modules to local cache(下载依赖包)</li></ul></li><li>edit<ul><li>edit go.mod from tools or scripts（编辑go.mod）</li></ul></li><li>graph<ul><li>print module requirement graph (打印模块依赖图)</li></ul></li><li>init<ul><li>initialize new module in current directory（在当前目录初始化mod）</li></ul></li><li>tidy<ul><li>add missing and remove unused modules(拉取缺少的模块，移除不用的模块)</li></ul></li><li>vendor<ul><li>make vendored copy of dependencies(将依赖复制到vendor下)</li></ul></li><li>verify<ul><li>verify dependencies have expected content (验证依赖是否正确</li></ul></li><li>why<ul><li>explain why packages or modules are needed(解释为什么需要依赖)</li></ul></li></ul></li><li>go.mod文件一旦创建后，它的内容将会被go toolchain全面掌控。go toolchain会在各类命令执行时，比如go get、go build、go mod等修改和维护go.mod文件。</li></ul><h2 id=运算符>运算符</h2><p>Go 语言内置的运算符有：</p><ul><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>赋值运算符<ul><li>= 简单的赋值运算符，将一个表达式的值赋给一个左值</li><li>+= 相加后再赋值</li><li>-= 相减后再赋值</li><li>*= 相乘后再赋值</li><li>/= 相除后再赋值</li><li>%= 求余后再赋值</li><li>&#171;= 左移后赋值</li><li>>>= 右移后赋值</li><li>&= 按位与后赋值</li><li>l= 按位或后赋值</li><li>^= 按位异或后赋值</li></ul></li></ul><h2 id=下划线>下划线</h2><p>“_”是特殊标识符，用来忽略结果。</p><ul><li>下划线在import中<ul><li>import 下划线（如：import _ hello/imp）的作用：当导入一个包时，该包下的文件里所有init()函数都会被执行，然而，有些时候我们并不需要把整个包都导入进来，仅仅是是希望它执行init()函数而已。这个时候就可以使用 import _ 引用该包。即使用【import _ 包路径】只是引用该包，仅仅是为了调用init()函数，所以无法通过包名来调用包中的其他函数。</li></ul></li><li>下划线在代码中<ul><li>占位符</li></ul></li></ul><h2 id=变量和常量>变量和常量</h2><p>变量：</p><ul><li>为什么要有变量：程序运行过程中的数据都是保存在内存中，我们想要在代码中操作某个数据时就需要去内存上找到这个变量，但是如果我们直接在代码中通过内存地址去操作变量的话，代码的可读性会非常差而且还容易出错，所以我们就利用变量将这个数据的内存地址保存起来，以后直接通过这个变量就能找到内存上对应的数据了。</li><li>Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。并且Go语言的变量声明后必须使用。</li><li>批量声明变量：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=p>(</span>
        <span class=nx>a</span> <span class=kt>string</span>
        <span class=nx>b</span> <span class=kt>int</span>
        <span class=nx>c</span> <span class=kt>bool</span>
        <span class=nx>d</span> <span class=kt>float32</span>
    <span class=p>)</span>
</code></pre></td></tr></table></div></div><ul><li>在函数内部，可以使用更简略的 := 方式声明并初始化变量。</li><li>匿名变量_</li></ul><p>常量:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>const (
        pi = 3.1415
        e = 2.7182
    )
</code></pre></td></tr></table></div></div><ul><li>如果省略了值则表示和上面一行的值相同</li><li><strong>iota</strong>是go语言的常量计数器，只能在常量的表达式中使用。iota在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。<ul><li>可以使用_跳过某些值</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go> <span class=kd>const</span> <span class=p>(</span>
            <span class=nx>_</span>  <span class=p>=</span> <span class=kc>iota</span>
            <span class=nx>KB</span> <span class=p>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=mi>10</span> <span class=o>*</span> <span class=kc>iota</span><span class=p>)</span>
            <span class=nx>MB</span> <span class=p>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=mi>10</span> <span class=o>*</span> <span class=kc>iota</span><span class=p>)</span>
            <span class=nx>GB</span> <span class=p>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=mi>10</span> <span class=o>*</span> <span class=kc>iota</span><span class=p>)</span>
            <span class=nx>TB</span> <span class=p>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=mi>10</span> <span class=o>*</span> <span class=kc>iota</span><span class=p>)</span>
            <span class=nx>PB</span> <span class=p>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=mi>10</span> <span class=o>*</span> <span class=kc>iota</span><span class=p>)</span>
        <span class=p>)</span>
 <span class=kd>const</span> <span class=p>(</span>
            <span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=p>=</span> <span class=kc>iota</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=kc>iota</span> <span class=o>+</span> <span class=mi>2</span> <span class=c1>//1,2
</span><span class=c1></span>            <span class=nx>c</span><span class=p>,</span> <span class=nx>d</span>                      <span class=c1>//2,3
</span><span class=c1></span>            <span class=nx>e</span><span class=p>,</span> <span class=nx>f</span>                      <span class=c1>//3,4
</span><span class=c1></span>        <span class=p>)</span>
</code></pre></td></tr></table></div></div><h2 id=基本类型>基本类型</h2><table><thead><tr><th align=left>类型</th><th align=left>长度(字节)</th><th align=left>默认值</th><th align=left>说明</th></tr></thead><tbody><tr><td align=left>bool</td><td align=left>1</td><td align=left><strong>false</strong></td><td></td></tr><tr><td align=left>byte</td><td align=left>1</td><td align=left>0</td><td align=left>uint8，一个ASCII字符</td></tr><tr><td align=left>rune</td><td align=left>4</td><td align=left>0</td><td align=left>Unicode Code Point，int32，一个utf-8字符</td></tr><tr><td align=left>int, uint</td><td align=left>4或8</td><td align=left>0</td><td align=left>由操作系统位数(32/64)决定</td></tr><tr><td align=left>int8, uint8</td><td align=left>1</td><td align=left>0</td><td align=left>-128 ~ 127, 0 ~ 255，<strong>byte是uint8 的别名</strong></td></tr><tr><td align=left>int16, uint16</td><td align=left>2</td><td align=left>0</td><td align=left>-32768 ~ 32767, 0 ~ 65535</td></tr><tr><td align=left>int32, uint32</td><td align=left>4</td><td align=left>0</td><td align=left>-21亿~ 21亿, 0 ~ 42亿，<strong>rune是int32 的别名</strong></td></tr><tr><td align=left>int64, uint64</td><td align=left>8</td><td align=left>0</td><td></td></tr><tr><td align=left>float32</td><td align=left>4</td><td align=left>0.0</td><td></td></tr><tr><td align=left>float64</td><td align=left>8</td><td align=left>0.0</td><td></td></tr><tr><td align=left>complex64</td><td align=left>8</td><td></td><td></td></tr><tr><td align=left>complex128</td><td align=left>16</td><td></td><td></td></tr><tr><td align=left>uintptr</td><td align=left>4或8</td><td align=left></td><td align=left>以存储指针的 uint32 或 uint64 整数</td></tr><tr><td align=left>array</td><td align=left></td><td align=left></td><td align=left>值类型</td></tr><tr><td align=left>struct</td><td align=left></td><td align=left></td><td align=left>值类型</td></tr><tr><td align=left>string</td><td align=left></td><td align=left>“”</td><td align=left>UTF-8 字符串</td></tr><tr><td align=left>slice</td><td align=left></td><td align=left>nil</td><td align=left>引用类型</td></tr><tr><td align=left>map</td><td align=left></td><td align=left>nil</td><td align=left>引用类型</td></tr><tr><td align=left>channel</td><td align=left></td><td align=left>nil</td><td align=left>引用类型</td></tr><tr><td align=left>interface</td><td align=left></td><td align=left>nil</td><td align=left>接口</td></tr><tr><td align=left>function</td><td align=left></td><td align=left>nil</td><td align=left>函数</td></tr></tbody></table><ul><li>uintptr 实际上就是一个 uint 用来表示地址，go 的指针和 c 不一样不能进行偏移操作，如果非要偏移的话就需要 unsafe.Pointer 和 uintptr 配合来实现。uintptr 不是一个指针 所以 GC 时也不会处理 uintptr 的引用。如果不涉及地址偏移时没有必要使用 uintptr 。&mdash;&mdash;<a href=https://www.zhihu.com/question/439659823 target=_blank rel="noopener noreffer">来自知乎回答</a></li><li>标准库 math 定义了各数字类型取值范围。</li><li>空指针值 nil，而非C/C++ NULL。golang中有多种引用类型：pointer、interface、slice、map、channel、function。go作为一个强类型语言，不同引用类型的判空（nil）规则是不同的；比如：interface的判空规则是，需要判断类型和值是否都为nil(interface的底层是有类型和值构成的)slice的判空，需要判断slice引用底层数组的指针为空，容量和size均为0。</li><li>不允许将整型强制转换为布尔型。</li><li>字符串的内部实现使用UTF-8编码。</li><li>只有显示类型转化。</li></ul><h2 id=字符串>字符串：</h2><ul><li>多行字符串，用反引号`</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>s1</span> <span class=o>:=</span> <span class=s>`</span><span class=s>第一行
</span><span class=s>    第二行
</span><span class=s>    第三行
</span><span class=s>    </span><span class=s>`</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>s1</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><table><thead><tr><th align=left>方法</th><th align=left>介绍</th></tr></thead><tbody><tr><td align=left>len(str)</td><td align=left>求长度</td></tr><tr><td align=left>+或fmt.Sprintf</td><td align=left>拼接字符串</td></tr><tr><td align=left>strings.Split</td><td align=left>分割</td></tr><tr><td align=left>strings.Contains</td><td align=left>判断是否包含</td></tr><tr><td align=left>strings.HasPrefix,strings.HasSuffix</td><td align=left>前缀/后缀判断</td></tr><tr><td align=left>strings.Index(),strings.LastIndex()</td><td align=left>子串出现的位置</td></tr><tr><td align=left>strings.Join(a[]string, sep string)</td><td align=left>join操作</td></tr></tbody></table><p>遍历字符串：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go> <span class=c1>// Traversal strings
</span><span class=c1></span>    <span class=kd>func</span> <span class=nf>traversalString</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>s</span> <span class=o>:=</span> <span class=s>&#34;JeFo的博客&#34;</span>
        <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span> <span class=c1>//Traversal by byte
</span><span class=c1></span>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%v(%c) &#34;</span><span class=p>,</span> <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span><span class=p>,</span> <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span><span class=p>)</span>
        <span class=p>}</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=p>)</span>
        <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>r</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span> <span class=p>{</span> <span class=c1>//Traversal by rune
</span><span class=c1></span>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%v(%c) &#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
        <span class=p>}</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=p>)</span>
    <span class=p>}</span>
</code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>74(J) 101(e) 70(F) 111(o) 231(ç) 154() 132(
                                           ) 229(å) 141() 154() 229(å) 174(®) 162(¢) 
74(J) 101(e) 70(F) 111(o) 30340(的) 21338(博) 23458(客)
</code></pre></td></tr></table></div></div><p>修改字符串：</p><ul><li>要修改字符串，需要先将其转换成[]rune或[]byte，完成后再转换为string。无论哪种转换，<strong>都会重新分配内存，并复制字节数组。</strong></li></ul><h2 id=数组>数组</h2><ul><li>数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是：len-1</li><li>支持 &ldquo;==&rdquo;、"!=&rdquo; 操作符，因为内存总是被初始化过的。<ul><li>相同类型的数组之间可以使用 == 或 != 进行比较，但不可以使用 &lt; 或 >，也可以相互赋值。</li><li>长度不同类型也不同。</li></ul></li><li>指针数组 [n]*T，数组指针 *[n]T。</li><li>多维数组除了第一维，初始化时都不能用[&mldr;]省略长度声明。</li><li>值拷贝行为会造成性能问题，通常会建议使用 slice，或数组指针。</li></ul><h2 id=切片>切片</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>//用make()初始化
</span><span class=c1></span><span class=kd>var</span> <span class=nx>s3</span> <span class=p>[</span><span class=p>]</span><span class=kt>int</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=p>[</span><span class=p>]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span><span class=c1>//len=0,cap=10
</span><span class=c1></span><span class=kd>var</span> <span class=nx>s4</span> <span class=p>[</span><span class=p>]</span><span class=kt>int</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=p>[</span><span class=p>]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span><span class=c1>//len=5
</span><span class=c1></span><span class=c1>//先初始化一个数组，再截取相应部分得到切片
</span><span class=c1></span><span class=nx>arr</span> <span class=o>:=</span> <span class=p>[</span><span class=mi>5</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>}</span>
<span class=kd>var</span> <span class=nx>s6</span> <span class=p>[</span><span class=p>]</span><span class=kt>int</span>
<span class=nx>s6</span> <span class=p>=</span> <span class=nx>arr</span><span class=p>[</span><span class=mi>1</span><span class=p>:</span><span class=mi>4</span><span class=p>]</span>  <span class=c1>// 左闭右开
</span><span class=c1></span><span class=nx>s7</span> <span class=p>=</span> <span class=nx>arr</span><span class=p>[</span><span class=mi>1</span><span class=p>:</span><span class=mi>3</span><span class=p>:</span><span class=mi>5</span><span class=p>]</span><span class=c1>//len=3-1;cap=5-1，这是一个危险的用法，极易产生bug
</span></code></pre></td></tr></table></div></div><p>切片追加append（内置函数）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// The append built-in function appends elements to the end of a slice. If
</span><span class=c1></span><span class=c1>// it has sufficient capacity, the destination is resliced to accommodate the
</span><span class=c1></span><span class=c1>// new elements. If it does not, a new underlying array will be allocated.
</span><span class=c1></span><span class=c1>// Append returns the updated slice. It is therefore necessary to store the
</span><span class=c1></span><span class=c1>// result of append, often in the variable holding the slice itself:
</span><span class=c1></span><span class=c1>//	slice = append(slice, elem1, elem2)
</span><span class=c1></span><span class=c1>//	slice = append(slice, anotherSlice...)
</span><span class=c1></span><span class=c1>// As a special case, it is legal to append a string to a byte slice, like this:
</span><span class=c1></span><span class=c1>//	slice = append([]byte(&#34;hello &#34;), &#34;world&#34;...)
</span><span class=c1></span><span class=kd>var</span> <span class=nx>a</span> <span class=p>=</span> <span class=p>[</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;slice a : %v\n&#34;</span><span class=p>,</span> <span class=nx>a</span><span class=p>)</span>
<span class=kd>var</span> <span class=nx>b</span> <span class=p>=</span> <span class=p>[</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>}</span>
<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;slice b : %v\n&#34;</span><span class=p>,</span> <span class=nx>b</span><span class=p>)</span>
<span class=nx>c</span> <span class=o>:=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=o>...</span><span class=p>)</span>
<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;slice c : %v\n&#34;</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span>
<span class=nx>d</span> <span class=o>:=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=mi>7</span><span class=p>)</span>
<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;slice d : %v\n&#34;</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
<span class=nx>e</span> <span class=o>:=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>d</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>9</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span>
<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;slice e : %v\n&#34;</span><span class=p>,</span> <span class=nx>e</span><span class=p>)</span>
<span class=nx>slice</span> <span class=o>:=</span> <span class=nb>append</span><span class=p>(</span><span class=p>[</span><span class=p>]</span><span class=nb>byte</span><span class=p>(</span><span class=s>&#34;hello &#34;</span><span class=p>)</span><span class=p>,</span> <span class=s>&#34;world&#34;</span><span class=o>...</span><span class=p>)</span><span class=c1>//注意是字节数组和字符串。
</span><span class=c1></span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;slice slice : %v\n&#34;</span><span class=p>,</span> <span class=nx>slice</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><ul><li>超出原 slice.cap 限制，就会重新分配底层数组，即便原数组并未填满。</li><li>通常以 2 倍容量重新分配底层数组。在大批量添加数据时，建议一次性分配足够大的空间，以减少内存分配和数据复制开销。或初始化足够长的 len 属性，改用索引号进行操作。</li><li>及时释放不再使用的 slice 对象，避免持有过期数组，造成 GC 无法回收。</li></ul><p>切片resize:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>
    <span class=s>&#34;fmt&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=kd>var</span> <span class=nx>a</span> <span class=p>=</span> <span class=p>[</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>}</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;slice a : %v , len(a) : %v\n&#34;</span><span class=p>,</span> <span class=nx>a</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span><span class=p>)</span>
    <span class=nx>b</span> <span class=o>:=</span> <span class=nx>a</span><span class=p>[</span><span class=mi>1</span><span class=p>:</span><span class=mi>2</span><span class=p>]</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;slice b : %v , len(b) : %v\n&#34;</span><span class=p>,</span> <span class=nx>b</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span><span class=p>)</span>
    <span class=nx>c</span> <span class=o>:=</span> <span class=nx>b</span><span class=p>[</span><span class=mi>1</span><span class=p>:</span><span class=mi>3</span><span class=p>]</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;slice c : %v , len(c) : %v\n&#34;</span><span class=p>,</span> <span class=nx>c</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>slice a : [1 3 4 5] , len(a) : 4
slice b : [3] , len(b) : 1
slice c : [4 5] , len(c) : 2
</code></pre></td></tr></table></div></div><p>string & slice :
string底层就是一个byte的数组，因此，也可以进行切片操作。</p><h3 id=切片底层实现>切片底层实现</h3><p>切片的设计想法是由动态数组概念而来，为了开发者可以更加方便的使一个数据结构可以自动增加和减少。但是切片本身并不是动态数据或者数组指针。切片常见的操作有 <strong>reslice、append、copy</strong>。与此同时，切片还具有<strong>可索引，可迭代</strong>的优秀特性。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>arrayA</span> <span class=o>:=</span> <span class=p>[</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>}</span>
    <span class=nf>testArrayPoint</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>arrayA</span><span class=p>)</span>   <span class=c1>// 1.传数组指针
</span><span class=c1></span>    <span class=nx>arrayB</span> <span class=o>:=</span> <span class=nx>arrayA</span><span class=p>[</span><span class=p>:</span><span class=p>]</span>
    <span class=nf>testArrayPoint</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>arrayB</span><span class=p>)</span>   <span class=c1>// 2.传切片
</span><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;arrayA : %p , %v\n&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>arrayA</span><span class=p>,</span> <span class=nx>arrayA</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>testArrayPoint</span><span class=p>(</span><span class=nx>x</span> <span class=o>*</span><span class=p>[</span><span class=p>]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;func Array : %p , %v\n&#34;</span><span class=p>,</span> <span class=nx>x</span><span class=p>,</span> <span class=o>*</span><span class=nx>x</span><span class=p>)</span>
    <span class=p>(</span><span class=o>*</span><span class=nx>x</span><span class=p>)</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>+=</span> <span class=mi>1</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>func Array : 0xc4200b0140 , [1 2]
func Array : 0xc4200b0180 , [1 3]
arrayA : 0xc4200b0140 , [1 4]
</code></pre></td></tr></table></div></div><ul><li>传指针会有一个弊端，从打印结果可以看到，第一行和第三行指针地址都是同一个，万一原数组的指针指向更改了，那么函数里面的指针指向都会跟着更改。</li><li>用切片传数组参数，既可以达到节约内存的目的，也可以达到合理处理好共享内存的问题。打印结果第二行就是切片，切片的指针和原来数组的指针是不同的。
slice数据结构源码：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// runtime/slice.go
</span><span class=c1></span><span class=kd>type</span> <span class=nx>slice</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>array</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=c1>// 指向一个数组的指针
</span><span class=c1></span>	<span class=nx>len</span>   <span class=kt>int</span> <span class=c1>// 切片长度 
</span><span class=c1></span>	<span class=nx>cap</span>   <span class=kt>int</span> <span class=c1>// 切片容量
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>如果想从 slice 中得到一块内存地址，可以这样做：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>s</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=p>[</span><span class=p>]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>200</span><span class=p>)</span>
<span class=nx>ptr</span> <span class=o>:=</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>s</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>自己构造一个slice:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=nx>ptr</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>
<span class=kd>var</span> <span class=nx>s1</span> <span class=p>=</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>addr</span> <span class=kt>uintptr</span>
    <span class=nx>len</span> <span class=kt>int</span>
    <span class=nx>cap</span> <span class=kt>int</span>
<span class=p>}</span><span class=p>{</span><span class=nx>ptr</span><span class=p>,</span> <span class=nx>length</span><span class=p>,</span> <span class=nx>length</span><span class=p>}</span>
<span class=nx>s</span> <span class=o>:=</span> <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=p>[</span><span class=p>]</span><span class=kt>byte</span><span class=p>)</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>s1</span><span class=p>)</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>在 Go 的反射中就存在一个与之对应的数据结构 SliceHeader，我们可以用它来构造一个 slice：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=nx>o</span> <span class=p>[</span><span class=p>]</span><span class=kt>byte</span>
<span class=nx>sliceHeader</span> <span class=o>:=</span> <span class=p>(</span><span class=o>*</span><span class=nx>reflect</span><span class=p>.</span><span class=nx>SliceHeader</span><span class=p>)</span><span class=p>(</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>o</span><span class=p>)</span><span class=p>)</span><span class=p>)</span>
<span class=nx>sliceHeader</span><span class=p>.</span><span class=nx>Cap</span> <span class=p>=</span> <span class=nx>length</span>
<span class=nx>sliceHeader</span><span class=p>.</span><span class=nx>Len</span> <span class=p>=</span> <span class=nx>length</span>
<span class=nx>sliceHeader</span><span class=p>.</span><span class=nx>Data</span> <span class=p>=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>ptr</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>并非所有时候都适合用切片代替数组：因为切片底层数组可能会在堆上分配内存，而且小数组在栈上拷贝的消耗也未必比make 消耗大。</p><h3 id=创建切片>创建切片</h3><p><strong>make 函数允许在运行期动态指定数组长度，绕开了数组类型必须使用编译期常量的限制。</strong>
创建切片有两种形式，make 创建切片，字面量创建切片（既可以初始化一个新的，也可以截取一个数组,截取一个数组的时候cap未声明时为数组容量）。</p><h4 id=空切片和nil切片>空切片和nil切片</h4><p>nil切片：| nil (Pointer) | Len(int) | Cap(int) |</p><ul><li>var slice []int
nil 切片被用在很多标准库和内置函数中，描述一个不存在的切片的时候，就需要用到 nil 切片。比如函数在发生异常的时候，返回的切片就是 nil 切片。nil 切片的指针指向 nil。</li></ul><p>空切片： | Array (Pointer) | Len(int) | Cap(int) |</p><ul><li>silce := make( []int , 0 )</li><li>slice := []int{ }
空切片一般会用来表示一个空的集合。比如数据库查询，一条结果也没有查到，那么就可以返回一个空切片。</li></ul><p>空切片和 nil 切片的区别在于，空切片指向的地址不是nil，指向的是一个内存地址，但是它没有分配任何内存空间，即底层元素包含0个元素。</p><p>不管是使用 nil 切片还是空切片，对其调用内置函数 append，len 和 cap 的效果都是一样的。</p><h4 id=扩容策略>扩容策略</h4><p>如果切片的容量小于 1024 个元素，于是扩容的时候就翻倍增加容量。</p><p>一旦元素个数超过 1024 个元素，那么增长因子就变成 1.25 ，即每次增加原来容量的四分之一。</p><p>注意：扩容扩大的容量都是针对原来的容量而言的，而不是针对原来数组的长度而言的。</p><p>扩容后的数组是新数组还是老数组？</p><ul><li>如果如果切片扩容后容量比原来数组的容量最大值还大，扩容切片需要另开一片内存区域，把原来的值拷贝过来，再执行append()操作。</li><li>否则，不会开辟新数组，这种情况很危险，因为这种情况下，扩容以后的数组还是指向原来的数组,多个原来的数组上的切片会受新切片所影响！</li></ul><h3 id=切片拷贝>切片拷贝</h3><p>slicecopy 方法会把源切片值(即 fm Slice )中的元素复制到目标切片(即 to Slice )中，并返回被复制的元素个数，copy 的两个类型必须一致。slicecopy 方法最终的复制结果取决于较短的那个切片，当较短的切片复制完成，整个复制过程就全部完成了。</p><p>如果用 range 的方式去遍历一个切片，拿到的 Value 其实是切片里面的值拷贝。所以每次打印 Value 的地址都不变。由于 Value 是值拷贝的，并非引用传递，所以直接改 Value 是达不到更改原切片值的目的的，需要通过 &slice[index] 获取真实的地址。</p><h2 id=指针>指针</h2><p>区别于C/C++中的指针，Go语言中的指针不能进行偏移和运算，是安全指针。</p><p>首先需要知道指针地址、指针类型和指针取值。</p><p>指针地址和指针类型：</p><ul><li>Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型</li></ul><p>指针取值：*</p><p><strong>空指针</strong>：</p><ul><li>当一个指针被定义后没有分配到任何变量时，它的值为 nil</li></ul><p><strong>new和make</strong>:</p><ul><li>在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。</li><li>new<ul><li>函数签名和举例</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nb>new</span><span class=p>(</span><span class=nx>Type</span><span class=p>)</span> <span class=o>*</span><span class=nx>Type</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
<span class=kd>var</span> <span class=nx>a</span> <span class=o>*</span><span class=kt>int</span>
<span class=nx>a</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span>
<span class=o>*</span><span class=nx>a</span> <span class=p>=</span> <span class=mi>10</span>
<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=o>*</span><span class=nx>a</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><ul><li>new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。</li></ul></li><li>make<ul><li><strong>只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身</strong>,因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。</li><li>以map举例：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
<span class=kd>var</span> <span class=nx>b</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span>
<span class=nx>b</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span>
<span class=nx>b</span><span class=p>[</span><span class=s>&#34;测试&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=mi>100</span>
<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div></li></ul><h2 id=map>map</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>    <span class=kd>map</span><span class=p>[</span><span class=nx>KeyType</span><span class=p>]</span><span class=nx>ValueType</span>
</code></pre></td></tr></table></div></div><p>初始化时用make申请内存（或者直接填充元素）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>    <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=nx>KeyType</span><span class=p>]</span><span class=nx>ValueType</span><span class=p>,</span> <span class=p>[</span><span class=nx>cap</span><span class=p>]</span><span class=p>)</span><span class=c1>//cap不是必须的，但最好一开始就申请一个合适的容量
</span></code></pre></td></tr></table></div></div><p><strong>判断某个key是否存在</strong>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>//map[key]会返回两个值，第二个是该键是否存在
</span><span class=c1></span>    <span class=nx>value</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span>   
</code></pre></td></tr></table></div></div><p>map的遍历还是正常用for range，但有一点需要注意：<strong>遍历map时元素顺序与添加键值对的顺序无关。</strong></p><p>按照指定顺序遍历map:思路是将map的key取出另存为切片再排序，再按照切片的顺序进行遍历即可。</p><p><strong>map & 切片</strong>：</p><ul><li>元素为map的切片：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=kd>var</span> <span class=nx>mapSlice</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=p>[</span><span class=p>]</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
    <span class=k>for</span> <span class=nx>index</span><span class=p>,</span> <span class=nx>value</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>mapSlice</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;index:%d value:%v\n&#34;</span><span class=p>,</span> <span class=nx>index</span><span class=p>,</span> <span class=nx>value</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;after init&#34;</span><span class=p>)</span>
    <span class=c1>// 对切片中的map元素进行初始化
</span><span class=c1></span>    <span class=nx>mapSlice</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span>
    <span class=nx>mapSlice</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=p>[</span><span class=s>&#34;name&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;王五&#34;</span>
    <span class=nx>mapSlice</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=p>[</span><span class=s>&#34;password&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;123456&#34;</span>
    <span class=nx>mapSlice</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=p>[</span><span class=s>&#34;address&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;红旗大街&#34;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><ul><li>value为切片的map:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=kd>var</span> <span class=nx>sliceMap</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=p>[</span><span class=p>]</span><span class=kt>string</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>sliceMap</span><span class=p>)</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;after init&#34;</span><span class=p>)</span>
    <span class=nx>key</span> <span class=o>:=</span> <span class=s>&#34;中国&#34;</span>
    <span class=nx>value</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>sliceMap</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span>
    <span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
        <span class=nx>value</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=p>[</span><span class=p>]</span><span class=kt>string</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=nx>value</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>value</span><span class=p>,</span> <span class=s>&#34;北京&#34;</span><span class=p>,</span> <span class=s>&#34;上海&#34;</span><span class=p>)</span>
    <span class=nx>sliceMap</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span> <span class=p>=</span> <span class=nx>value</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>sliceMap</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>map删除键值对：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nb>delete</span><span class=p>(</span><span class=kd>map</span><span class=p>,</span><span class=nx>key</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><h3 id=map实现原理>map实现原理</h3><p>map底层存储方式为（结构体）数组，在存储时key不能重复，当key重复时，value进行覆盖，<strong>我们通过key进行hash运算（可以简单理解为把key转化为一个整形数字）然后对数组的长度取余，得到key存储在数组的哪个下标位置，最后将key和value组装为一个结构体，放入数组下标处</strong>。</p><p>哈希冲突：即不同key经哈希映射后得到相同的数组下标。</p><ul><li>解决办法：开放定址法：<ul><li>发现hashkey(key)的下标已经被别key占用的时候，在这个数组中空间中重新找一个没被占用的存储这个冲突的key。寻找方式有很多。常见的有线性探测法，线性补偿探测法，随机探测法。<ul><li>线性探测法：<ul><li>从冲突的下标处开始往后探测，到达数组末尾时，从数组开始处探测，直到找到一个空位置存储这个key，当数组都找不到的情况下会扩容（事实上当数组容量快满的时候就会扩容了）</li><li>查找某一个key的时候，找到key对应的下标，比较key是否相等，如果相等直接取出来，否则按照顺寻探测直到碰到一个空位置，说明key不存在。</li></ul></li><li>拉链法：<ul><li>当key的hash冲突时，我们在冲突位置的元素上形成一个链表，通过指针互连接。</li><li>当查找时，发现key冲突，顺着链表一直往下找，直到链表的尾节点，找不到则返回空</li></ul></li></ul></li><li>开放定址法的优缺点：<ul><li>由上面可以看出拉链法比线性探测处理简单</li><li>线性探测查找是会被拉链法会更消耗时间</li><li>线性探测会更加容易导致扩容，而拉链不会</li><li>拉链存储了指针，所以空间上会比线性探测占用多一点</li><li>拉链是动态申请存储空间的，所以更适合链长不确定的</li></ul></li></ul></li></ul><h3 id=go中map的实现原理>go中map的实现原理</h3><p>在go1.16中，map也是数组存储的的，每个数组下标处存储的是一个bucket,这个bucket的类型见下面代码，每个bucket中可以存储8个kv键值对，当每个bucket存储的kv对到达8个之后，会通过overflow指针指向一个新的bucket，从而形成一个链表,看bmap的结构</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// A bucket for a Go map.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>bmap</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=c1>// tophash generally contains the top byte of the hash value
</span><span class=c1></span>	<span class=c1>// for each key in this bucket. If tophash[0] &lt; minTopHash,
</span><span class=c1></span>	<span class=c1>// tophash[0] is a bucket evacuation state instead.即桶疏散状态
</span><span class=c1></span>	<span class=nx>tophash</span> <span class=p>[</span><span class=nx>bucketCnt</span><span class=p>]</span><span class=kt>uint8</span>
	<span class=c1>// Followed by bucketCnt keys and then bucketCnt elems.
</span><span class=c1></span>	<span class=c1>// NOTE: packing all the keys together and then all the elems together makes the
</span><span class=c1></span>	<span class=c1>// code a bit more complicated than alternating key/elem/key/elem/... but it allows
</span><span class=c1></span>	<span class=c1>// us to eliminate padding which would be needed for, e.g., map[int64]int8.
</span><span class=c1></span>	<span class=c1>// Followed by an overflow pointer.
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><ul><li>tophash用来快速查找key值是否在该bucket中，而不同每次都通过真值进行比较。</li><li><strong>map[int64]int8,key是int64（8个字节），value是int8（一个字节），kv的长度不同，如果按照kv格式存放，则考虑内存对齐v也会占用int64，而按照后者存储时，8个v刚好占用一个int64</strong></li><li><strong>当往map中存储一个kv对时，通过k获取hash值，hash值的低八位和bucket数组长度取余，定位到在数组中的那个下标，hash值的高八位存储在bucket中的tophash中，用来快速判断key是否存在，key和value的具体值则通过指针运算存储，当一个bucket满时，通过overfolw指针链接到下一个bucket。</strong></li><li>map的存储源码：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// Like mapaccess, but allocates a slot for the key if it is not present in the map.如果key不在map里为其分配一个插槽（狭槽）
</span><span class=c1></span><span class=kd>func</span> <span class=nf>mapassign</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>maptype</span><span class=p>,</span> <span class=nx>h</span> <span class=o>*</span><span class=nx>hmap</span><span class=p>,</span> <span class=nx>key</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=p>{</span>
	<span class=k>if</span> <span class=nx>h</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=nb>panic</span><span class=p>(</span><span class=nf>plainError</span><span class=p>(</span><span class=s>&#34;assignment to entry in nil map&#34;</span><span class=p>)</span><span class=p>)</span>
	<span class=p>}</span>
	<span class=k>if</span> <span class=nx>raceenabled</span> <span class=p>{</span>
		<span class=nx>callerpc</span> <span class=o>:=</span> <span class=nf>getcallerpc</span><span class=p>(</span><span class=p>)</span>
		<span class=nx>pc</span> <span class=o>:=</span> <span class=nf>funcPC</span><span class=p>(</span><span class=nx>mapassign</span><span class=p>)</span>
		<span class=nf>racewritepc</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>h</span><span class=p>)</span><span class=p>,</span> <span class=nx>callerpc</span><span class=p>,</span> <span class=nx>pc</span><span class=p>)</span>
		<span class=nf>raceReadObjectPC</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>key</span><span class=p>,</span> <span class=nx>key</span><span class=p>,</span> <span class=nx>callerpc</span><span class=p>,</span> <span class=nx>pc</span><span class=p>)</span>
	<span class=p>}</span>
	<span class=k>if</span> <span class=nx>msanenabled</span> <span class=p>{</span>
        <span class=c1>//获取hash算法
</span><span class=c1></span>		<span class=nf>msanread</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>t</span><span class=p>.</span><span class=nx>key</span><span class=p>.</span><span class=nx>size</span><span class=p>)</span>
	<span class=p>}</span>
	<span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>flags</span><span class=o>&amp;</span><span class=nx>hashWriting</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;concurrent map writes&#34;</span><span class=p>)</span>
	<span class=p>}</span>
    <span class=c1>//计算哈希值
</span><span class=c1></span>	<span class=nx>hash</span> <span class=o>:=</span> <span class=nx>t</span><span class=p>.</span><span class=nf>hasher</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>hash0</span><span class=p>)</span><span class=p>)</span>

	<span class=c1>// Set hashWriting after calling t.hasher, since t.hasher may panic,
</span><span class=c1></span>	<span class=c1>// in which case we have not actually done a write.
</span><span class=c1></span>	<span class=nx>h</span><span class=p>.</span><span class=nx>flags</span> <span class=p>^</span><span class=p>=</span> <span class=nx>hashWriting</span>

    <span class=c1>//如果bucket数组一开始为空，则初始化
</span><span class=c1></span>	<span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span> <span class=p>=</span> <span class=nf>newobject</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>bucket</span><span class=p>)</span> <span class=c1>// newarray(t.bucket, 1)
</span><span class=c1></span>	<span class=p>}</span>

<span class=nx>again</span><span class=p>:</span>
    <span class=c1>//定位在哪一个bucket中
</span><span class=c1></span>	<span class=nx>bucket</span> <span class=o>:=</span> <span class=nx>hash</span> <span class=o>&amp;</span> <span class=nf>bucketMask</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nf>growing</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
		<span class=nf>growWork</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>h</span><span class=p>,</span> <span class=nx>bucket</span><span class=p>)</span>
	<span class=p>}</span>
    <span class=c1>//得到bucket的结构体
</span><span class=c1></span>	<span class=nx>b</span> <span class=o>:=</span> <span class=p>(</span><span class=o>*</span><span class=nx>bmap</span><span class=p>)</span><span class=p>(</span><span class=nf>add</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span><span class=p>,</span> <span class=nx>bucket</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>bucketsize</span><span class=p>)</span><span class=p>)</span><span class=p>)</span>
    <span class=c1>//获取高八位的哈希值
</span><span class=c1></span>	<span class=nx>top</span> <span class=o>:=</span> <span class=nf>tophash</span><span class=p>(</span><span class=nx>hash</span><span class=p>)</span>

	<span class=kd>var</span> <span class=nx>inserti</span> <span class=o>*</span><span class=kt>uint8</span>
	<span class=kd>var</span> <span class=nx>insertk</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>
	<span class=kd>var</span> <span class=nx>elem</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>
<span class=nx>bucketloop</span><span class=p>:</span>
    <span class=c1>//死循环
</span><span class=c1></span>	<span class=k>for</span> <span class=p>{</span>
        <span class=c1>//循环bucket中的tophash数组
</span><span class=c1></span>		<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>bucketCnt</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
            <span class=c1>//如果hash不相等
</span><span class=c1></span>			<span class=k>if</span> <span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>!=</span> <span class=nx>top</span> <span class=p>{</span>
                <span class=c1>//判断是否为空，为空则插入
</span><span class=c1></span>				<span class=k>if</span> <span class=nf>isEmpty</span><span class=p>(</span><span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=nx>inserti</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
					<span class=nx>inserti</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
					<span class=nx>insertk</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span><span class=p>,</span> <span class=nx>dataOffset</span><span class=o>+</span><span class=nx>i</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>keysize</span><span class=p>)</span><span class=p>)</span>
					<span class=nx>elem</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span><span class=p>,</span> <span class=nx>dataOffset</span><span class=o>+</span><span class=nx>bucketCnt</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>keysize</span><span class=p>)</span><span class=o>+</span><span class=nx>i</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>elemsize</span><span class=p>)</span><span class=p>)</span>
				<span class=p>}</span>
                <span class=c1>//插入成功，终止外层循环
</span><span class=c1></span>				<span class=k>if</span> <span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>==</span> <span class=nx>emptyRest</span> <span class=p>{</span>
					<span class=k>break</span> <span class=nx>bucketloop</span>
				<span class=p>}</span>
				<span class=k>continue</span>
			<span class=p>}</span>
            <span class=c1>//高八位哈希值一样，获取已存在的kay
</span><span class=c1></span>			<span class=nx>k</span> <span class=o>:=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span><span class=p>,</span> <span class=nx>dataOffset</span><span class=o>+</span><span class=nx>i</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>keysize</span><span class=p>)</span><span class=p>)</span>
			<span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nf>indirectkey</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
				<span class=nx>k</span> <span class=p>=</span> <span class=o>*</span><span class=p>(</span><span class=p>(</span><span class=o>*</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)</span><span class=p>(</span><span class=nx>k</span><span class=p>)</span><span class=p>)</span>
			<span class=p>}</span>
            <span class=c1>//判断两个key是否相等，不相等就循环下一个
</span><span class=c1></span>			<span class=k>if</span> <span class=p>!</span><span class=nx>t</span><span class=p>.</span><span class=nx>key</span><span class=p>.</span><span class=nf>equal</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>k</span><span class=p>)</span> <span class=p>{</span>
				<span class=k>continue</span>
			<span class=p>}</span>
			<span class=c1>// already have a mapping for key. Update it.
</span><span class=c1></span>			<span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nf>needkeyupdate</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
				<span class=nf>typedmemmove</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>key</span><span class=p>,</span> <span class=nx>k</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
			<span class=p>}</span>
            <span class=c1>//获取已存在的value
</span><span class=c1></span>			<span class=nx>elem</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span><span class=p>,</span> <span class=nx>dataOffset</span><span class=o>+</span><span class=nx>bucketCnt</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>keysize</span><span class=p>)</span><span class=o>+</span><span class=nx>i</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>elemsize</span><span class=p>)</span><span class=p>)</span>
			<span class=k>goto</span> <span class=nx>done</span>
		<span class=p>}</span>
        <span class=c1>//如果上一个bucket没能找到插入，则通过overflow获取链表上的下一个bucket
</span><span class=c1></span>		<span class=nx>ovf</span> <span class=o>:=</span> <span class=nx>b</span><span class=p>.</span><span class=nf>overflow</span><span class=p>(</span><span class=nx>t</span><span class=p>)</span>
		<span class=k>if</span> <span class=nx>ovf</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=k>break</span>
		<span class=p>}</span>
		<span class=nx>b</span> <span class=p>=</span> <span class=nx>ovf</span>
	<span class=p>}</span>

	<span class=c1>// Did not find mapping for key. Allocate new cell &amp; add entry.
</span><span class=c1></span>
	<span class=c1>// If we hit the max load factor or we have too many overflow buckets,
</span><span class=c1></span>	<span class=c1>// and we&#39;re not already in the middle of growing, start growing.
</span><span class=c1></span>	<span class=k>if</span> <span class=p>!</span><span class=nx>h</span><span class=p>.</span><span class=nf>growing</span><span class=p>(</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nf>overLoadFactor</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>count</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span> <span class=o>||</span> <span class=nf>tooManyOverflowBuckets</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>noverflow</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=p>)</span> <span class=p>{</span>
		<span class=nf>hashGrow</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>h</span><span class=p>)</span>
		<span class=k>goto</span> <span class=nx>again</span> <span class=c1>// Growing the table invalidates everything, so try again
</span><span class=c1></span>	<span class=p>}</span>

	<span class=k>if</span> <span class=nx>inserti</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=c1>// The current bucket and all the overflow buckets connected to it are full, allocate a new one.
</span><span class=c1></span>		<span class=nx>newb</span> <span class=o>:=</span> <span class=nx>h</span><span class=p>.</span><span class=nf>newoverflow</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>b</span><span class=p>)</span>
		<span class=nx>inserti</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>newb</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
		<span class=nx>insertk</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>newb</span><span class=p>)</span><span class=p>,</span> <span class=nx>dataOffset</span><span class=p>)</span>
		<span class=nx>elem</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>insertk</span><span class=p>,</span> <span class=nx>bucketCnt</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>keysize</span><span class=p>)</span><span class=p>)</span>
	<span class=p>}</span>

	<span class=c1>// store new key/elem at insert position
</span><span class=c1></span>	<span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nf>indirectkey</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
		<span class=nx>kmem</span> <span class=o>:=</span> <span class=nf>newobject</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>key</span><span class=p>)</span>
		<span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)</span><span class=p>(</span><span class=nx>insertk</span><span class=p>)</span> <span class=p>=</span> <span class=nx>kmem</span>
		<span class=nx>insertk</span> <span class=p>=</span> <span class=nx>kmem</span>
	<span class=p>}</span>
	<span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nf>indirectelem</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
		<span class=nx>vmem</span> <span class=o>:=</span> <span class=nf>newobject</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>elem</span><span class=p>)</span>
		<span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)</span><span class=p>(</span><span class=nx>elem</span><span class=p>)</span> <span class=p>=</span> <span class=nx>vmem</span>
	<span class=p>}</span>
	<span class=nf>typedmemmove</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>key</span><span class=p>,</span> <span class=nx>insertk</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
    <span class=c1>//将高八位hash值存储
</span><span class=c1></span>	<span class=o>*</span><span class=nx>inserti</span> <span class=p>=</span> <span class=nx>top</span>
	<span class=nx>h</span><span class=p>.</span><span class=nx>count</span><span class=o>++</span>

<span class=nx>done</span><span class=p>:</span>
	<span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>flags</span><span class=o>&amp;</span><span class=nx>hashWriting</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;concurrent map writes&#34;</span><span class=p>)</span>
	<span class=p>}</span>
	<span class=nx>h</span><span class=p>.</span><span class=nx>flags</span> <span class=o>&amp;^=</span> <span class=nx>hashWriting</span>
	<span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nf>indirectelem</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
		<span class=nx>elem</span> <span class=p>=</span> <span class=o>*</span><span class=p>(</span><span class=p>(</span><span class=o>*</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)</span><span class=p>(</span><span class=nx>elem</span><span class=p>)</span><span class=p>)</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=nx>elem</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=结构体>结构体</h2><p><strong>Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</strong></p><h3 id=类型别名和自定义类型>类型别名和自定义类型</h3><p>自定义类型（新类型）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go> <span class=c1>//将MyInt定义为int类型
</span><span class=c1></span>    <span class=kd>type</span> <span class=nx>MyInt</span> <span class=kt>int</span> 
</code></pre></td></tr></table></div></div><ul><li>可以基于内置的基本类型定义，也可以通过struct定义。</li></ul><p>类型别名（Go1.9添加的新功能，注意编译后是原来的类型）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>//将MyInt作为为int类型的昵称
</span><span class=c1></span>    <span class=kd>type</span> <span class=nx>MyInt</span> <span class=p>=</span> <span class=kt>int</span> 
</code></pre></td></tr></table></div></div><h2 id=结构体-1>结构体</h2><p>本质上是一种聚合型的数据类型。</p><p>通过struct可以实现面向对象。</p><p>定义的时候，同样类型的字段也可以写在一行。</p><p>只有结构体被实例化时，才会真正被分配内存。</p><p>匿名结构体：定义临时数据结构时可能会用到。</p><p>语法糖：Go语言中支持对结构体指针直接使用.来访问结构体的成员，在使用new分配内存后得到的便是结构体指针。</p><p><strong>使用&对结构体进行取地址操作相当于对该结构体类型进行了一次new实例化操作。</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>p</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>person</span><span class=p>{</span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>初始化（没有指定初始值的字段的值就是该字段类型的零值）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>p</span> <span class=o>:=</span> <span class=nx>person</span><span class=p>{</span>
    <span class=nx>a</span><span class=p>:</span> <span class=s>&#34;1a&#34;</span><span class=p>,</span>
    <span class=nx>b</span><span class=p>:</span> <span class=s>&#34;2b&#34;</span><span class=p>,</span>
<span class=p>}</span>
<span class=c1>//结构体指针
</span><span class=c1></span><span class=nx>q</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>ss</span><span class=p>{</span>
    <span class=nx>a</span><span class=p>:</span> <span class=s>&#34;1a&#34;</span><span class=p>,</span>
    <span class=nx>b</span><span class=p>:</span> <span class=s>&#34;2b&#34;</span><span class=p>,</span>
<span class=p>}</span>
<span class=c1>//简写需注意三点：1.必须初始化结构体的所有字段。2.初始值的填充顺序必须与字段在结构体中的声明顺序一致。3.该方式不能和键值初始化方式混用。  
</span><span class=c1></span><span class=nx>s</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>d</span><span class=p>{</span>
    <span class=s>&#34;aq&#34;</span><span class=p>,</span>
    <span class=s>&#34;sw&#34;</span><span class=p>,</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>自己实现一个结构体构造函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>//值拷贝开销太大，返回结构体指针
</span><span class=c1></span><span class=kd>func</span> <span class=nf>newPerson</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>city</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>age</span> <span class=kt>int8</span><span class=p>)</span> <span class=o>*</span><span class=nx>person</span> <span class=p>{</span>
    <span class=k>return</span> <span class=o>&amp;</span><span class=nx>person</span><span class=p>{</span>
        <span class=nx>name</span><span class=p>:</span> <span class=nx>name</span><span class=p>,</span>
        <span class=nx>city</span><span class=p>:</span> <span class=nx>city</span><span class=p>,</span>
        <span class=nx>age</span><span class=p>:</span>  <span class=nx>age</span><span class=p>,</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h3 id=方法和接收者>方法和接收者</h3><p>Go语言中的方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者（Receiver）。<strong>接收者的概念就类似于其他语言中的this或者 self。</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>//接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名的第一个小写字母，而不是self、this之类的命名。例如，Person类型的接收者变量应该命名为 p，Connector类型的接收者变量应该命名为c等。
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>接收者变量</span> <span class=nx>接收者类型</span><span class=p>)</span> <span class=nx>方法名</span><span class=p>(</span><span class=nx>参数列表</span><span class=p>)</span> <span class=p>(</span><span class=nx>返回参数</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>函数体</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p><strong>指针类型的接收者：</strong></p><ul><li>指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的this或者self。</li><li>例如我们为Person添加一个SetAge方法，来修改实例变量的年龄。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// SetAge 设置p的年龄
</span><span class=c1></span><span class=c1>// 使用指针接收者
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>Person</span><span class=p>)</span> <span class=nf>SetAge</span><span class=p>(</span><span class=nx>newAge</span> <span class=kt>int8</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>p</span><span class=p>.</span><span class=nx>age</span> <span class=p>=</span> <span class=nx>newAge</span>
<span class=p>}</span>
<span class=c1>//调用该方法
</span><span class=c1></span><span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>p1</span> <span class=o>:=</span> <span class=nf>NewPerson</span><span class=p>(</span><span class=s>&#34;测试&#34;</span><span class=p>,</span> <span class=mi>25</span><span class=p>)</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>p1</span><span class=p>.</span><span class=nx>age</span><span class=p>)</span> <span class=c1>// 25
</span><span class=c1></span>    <span class=nx>p1</span><span class=p>.</span><span class=nf>SetAge</span><span class=p>(</span><span class=mi>30</span><span class=p>)</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>p1</span><span class=p>.</span><span class=nx>age</span><span class=p>)</span> <span class=c1>// 30
</span><span class=c1></span><span class=p>}</span> 
</code></pre></td></tr></table></div></div><p>值类型的接收者：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// SetAge2 设置p的年龄
</span><span class=c1></span><span class=c1>// 使用值接收者
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=nx>Person</span><span class=p>)</span> <span class=nf>SetAge2</span><span class=p>(</span><span class=nx>newAge</span> <span class=kt>int8</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>p</span><span class=p>.</span><span class=nx>age</span> <span class=p>=</span> <span class=nx>newAge</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>p1</span> <span class=o>:=</span> <span class=nf>NewPerson</span><span class=p>(</span><span class=s>&#34;测试&#34;</span><span class=p>,</span> <span class=mi>25</span><span class=p>)</span>
    <span class=nx>p1</span><span class=p>.</span><span class=nf>Dream</span><span class=p>(</span><span class=p>)</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>p1</span><span class=p>.</span><span class=nx>age</span><span class=p>)</span> <span class=c1>// 25
</span><span class=c1></span>    <span class=nx>p1</span><span class=p>.</span><span class=nf>SetAge2</span><span class=p>(</span><span class=mi>30</span><span class=p>)</span> <span class=c1>// (*p1).SetAge2(30)
</span><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>p1</span><span class=p>.</span><span class=nx>age</span><span class=p>)</span> <span class=c1>// 25
</span><span class=c1></span><span class=p>}</span> 
</code></pre></td></tr></table></div></div><p><strong>什么时候应该使用指针类型接收者：</strong></p><ol><li>需要修改接收者中的值</li><li>接收者是拷贝代价比较大的大对象</li><li>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li></ol><p>为任意类型添加方法：</p><ul><li>在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的int类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。</li><li>注意事项：非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。</li></ul><p>结构体的匿名字段：</p><ul><li>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</li><li>匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</li></ul><p><strong>嵌套结构体</strong>
一个结构体中可以嵌套包含另一个结构体或结构体指针。</p><p>嵌套结构体内部可能存在相同的字段名。这个时候为了避免歧义需要指定具体的内嵌结构体的字段。</p><p><strong>结构体的继承</strong>：
Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>//Animal 动物
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Animal</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>name</span> <span class=kt>string</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>a</span> <span class=o>*</span><span class=nx>Animal</span><span class=p>)</span> <span class=nf>move</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%s会动！\n&#34;</span><span class=p>,</span> <span class=nx>a</span><span class=p>.</span><span class=nx>name</span><span class=p>)</span>
<span class=p>}</span>

<span class=c1>//Dog 狗
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Dog</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>Feet</span>    <span class=kt>int8</span>
    <span class=o>*</span><span class=nx>Animal</span> <span class=c1>//通过嵌套匿名结构体实现继承
</span><span class=c1></span><span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>Dog</span><span class=p>)</span> <span class=nf>wang</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%s会汪\n&#34;</span><span class=p>,</span> <span class=nx>d</span><span class=p>.</span><span class=nx>name</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>d1</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Dog</span><span class=p>{</span>
        <span class=nx>Feet</span><span class=p>:</span> <span class=mi>4</span><span class=p>,</span>
        <span class=nx>Animal</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>Animal</span><span class=p>{</span> <span class=c1>//注意嵌套的是结构体指针
</span><span class=c1></span>            <span class=nx>name</span><span class=p>:</span> <span class=s>&#34;旺财&#34;</span><span class=p>,</span>
        <span class=p>}</span><span class=p>,</span>
    <span class=p>}</span>
    <span class=nx>d1</span><span class=p>.</span><span class=nf>wang</span><span class=p>(</span><span class=p>)</span> <span class=c1>//旺财会汪
</span><span class=c1></span>    <span class=nx>d1</span><span class=p>.</span><span class=nf>move</span><span class=p>(</span><span class=p>)</span> <span class=c1>//旺财会动！
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>结构体中字段大写开头表示可公开访问，小写表示私有（<strong>仅在定义当前结构体的包中可访问</strong>）。</p><p><strong>结构体与JSON序列化</strong>：</p><ul><li>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键/值对组合中的键名写在前面并用双引号””包裹，使用冒号:分隔，然后紧接着值；多个键值之间使用英文,分隔。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>//Student 学生
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Student</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>ID</span>     <span class=kt>int</span>
    <span class=nx>Gender</span> <span class=kt>string</span>
    <span class=nx>Name</span>   <span class=kt>string</span>
<span class=p>}</span>

<span class=c1>//Class 班级
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Class</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>Title</span>    <span class=kt>string</span>
    <span class=nx>Students</span> <span class=p>[</span><span class=p>]</span><span class=o>*</span><span class=nx>Student</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>c</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Class</span><span class=p>{</span>
        <span class=nx>Title</span><span class=p>:</span>    <span class=s>&#34;101&#34;</span><span class=p>,</span>
        <span class=nx>Students</span><span class=p>:</span> <span class=nb>make</span><span class=p>(</span><span class=p>[</span><span class=p>]</span><span class=o>*</span><span class=nx>Student</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>200</span><span class=p>)</span><span class=p>,</span>
    <span class=p>}</span>
    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
        <span class=nx>stu</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Student</span><span class=p>{</span>
            <span class=nx>Name</span><span class=p>:</span>   <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;stu%02d&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span><span class=p>,</span>
            <span class=nx>Gender</span><span class=p>:</span> <span class=s>&#34;男&#34;</span><span class=p>,</span>
            <span class=nx>ID</span><span class=p>:</span>     <span class=nx>i</span><span class=p>,</span>
        <span class=p>}</span>
        <span class=nx>c</span><span class=p>.</span><span class=nx>Students</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>Students</span><span class=p>,</span> <span class=nx>stu</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=c1>//JSON序列化：结构体--&gt;JSON格式的字符串
</span><span class=c1></span>    <span class=nx>data</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Marshal</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;json marshal failed&#34;</span><span class=p>)</span>
        <span class=k>return</span>
    <span class=p>}</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;json:%s\n&#34;</span><span class=p>,</span> <span class=nx>data</span><span class=p>)</span>
    <span class=c1>//JSON反序列化：JSON格式的字符串--&gt;结构体
</span><span class=c1></span>    <span class=nx>str</span> <span class=o>:=</span> <span class=s>`</span><span class=s>{</span><span class=s>&#34;Title&#34;:&#34;101&#34;,&#34;Students&#34;:[</span><span class=s>{</span><span class=s>&#34;ID&#34;:0,&#34;Gender&#34;:&#34;男&#34;,&#34;Name&#34;:&#34;stu00&#34;},</span><span class=s>{</span><span class=s>&#34;ID&#34;:1,&#34;Gender&#34;:&#34;男&#34;,&#34;Name&#34;:&#34;stu01&#34;},</span><span class=s>{</span><span class=s>&#34;ID&#34;:2,&#34;Gender&#34;:&#34;男&#34;,&#34;Name&#34;:&#34;stu02&#34;},</span><span class=s>{</span><span class=s>&#34;ID&#34;:3,&#34;Gender&#34;:&#34;男&#34;,&#34;Name&#34;:&#34;stu03&#34;},</span><span class=s>{</span><span class=s>&#34;ID&#34;:4,&#34;Gender&#34;:&#34;男&#34;,&#34;Name&#34;:&#34;stu04&#34;},</span><span class=s>{</span><span class=s>&#34;ID&#34;:5,&#34;Gender&#34;:&#34;男&#34;,&#34;Name&#34;:&#34;stu05&#34;},</span><span class=s>{</span><span class=s>&#34;ID&#34;:6,&#34;Gender&#34;:&#34;男&#34;,&#34;Name&#34;:&#34;stu06&#34;},</span><span class=s>{</span><span class=s>&#34;ID&#34;:7,&#34;Gender&#34;:&#34;男&#34;,&#34;Name&#34;:&#34;stu07&#34;},</span><span class=s>{</span><span class=s>&#34;ID&#34;:8,&#34;Gender&#34;:&#34;男&#34;,&#34;Name&#34;:&#34;stu08&#34;},</span><span class=s>{</span><span class=s>&#34;ID&#34;:9,&#34;Gender&#34;:&#34;男&#34;,&#34;Name&#34;:&#34;stu09&#34;}]}</span><span class=s>`</span>
    <span class=nx>c1</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Class</span><span class=p>{</span><span class=p>}</span>
    <span class=nx>err</span> <span class=p>=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>(</span><span class=p>[</span><span class=p>]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>str</span><span class=p>)</span><span class=p>,</span> <span class=nx>c1</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;json unmarshal failed!&#34;</span><span class=p>)</span>
        <span class=k>return</span>
    <span class=p>}</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%#v\n&#34;</span><span class=p>,</span> <span class=nx>c1</span><span class=p>)</span>
<span class=p>}</span> 
</code></pre></td></tr></table></div></div><p><strong>结构体标签Tag:</strong>
Tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来。</p><p>Tag在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>    <span class=s>`</span><span class=s>key1:&#34;value1&#34; key2:&#34;value2&#34;</span><span class=s>`</span>  
</code></pre></td></tr></table></div></div><ul><li>结构体标签由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。键值对之间使用一个空格分隔。 注意事项： 为结构体编写Tag时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。</li><li>例如我们为Student结构体的每个字段定义json序列化时使用的Tag：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>//Student 学生
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Student</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>ID</span>     <span class=kt>int</span>    <span class=s>`</span><span class=s>json:&#34;id&#34;</span><span class=s>`</span> <span class=c1>//通过指定tag实现json序列化该字段时的key
</span><span class=c1></span>    <span class=nx>Gender</span> <span class=kt>string</span> <span class=c1>//json序列化是默认使用字段名作为key
</span><span class=c1></span>    <span class=nx>name</span>   <span class=kt>string</span> <span class=c1>//私有不能被json包访问
</span><span class=c1></span><span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>s1</span> <span class=o>:=</span> <span class=nx>Student</span><span class=p>{</span>
        <span class=nx>ID</span><span class=p>:</span>     <span class=mi>1</span><span class=p>,</span>
        <span class=nx>Gender</span><span class=p>:</span> <span class=s>&#34;女&#34;</span><span class=p>,</span>
        <span class=nx>name</span><span class=p>:</span>   <span class=s>&#34;pprof&#34;</span><span class=p>,</span>
    <span class=p>}</span>
    <span class=nx>data</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Marshal</span><span class=p>(</span><span class=nx>s1</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;json marshal failed!&#34;</span><span class=p>)</span>
        <span class=k>return</span>
    <span class=p>}</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;json str:%s\n&#34;</span><span class=p>,</span> <span class=nx>data</span><span class=p>)</span> <span class=c1>//json str:{&#34;id&#34;:1,&#34;Gender&#34;:&#34;女&#34;}
</span><span class=c1></span><span class=p>}</span> 
</code></pre></td></tr></table></div></div><h2 id=参考>参考</h2><ul><li><a href=https://cloud.tencent.com/developer/article/1526095>https://cloud.tencent.com/developer/article/1526095</a></li><li><a href=https://www.topgoer.cn/docs/golang/chapter02>https://www.topgoer.cn/docs/golang/chapter02</a></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2021-11-09 00:00:00</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://qizhengzou.github.io/go_base_01/ data-title=Go_base_01 data-hashtags="go grammar"><i class="fab fa-twitter fa-fw"></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://qizhengzou.github.io/go_base_01/ data-hashtag="go grammar"><i class="fab fa-facebook-square fa-fw"></i></a><a href=javascript:void(0); title="分享到 Reddit" data-sharer=reddit data-url=https://qizhengzou.github.io/go_base_01/><i class="fab fa-reddit fa-fw"></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://qizhengzou.github.io/go_base_01/ data-title=Go_base_01><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/line.svg></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://qizhengzou.github.io/go_base_01/ data-title=Go_base_01><i class="fab fa-weibo fa-fw"></i></a><a href=javascript:void(0); title="分享到 百度" data-sharer=baidu data-url=https://qizhengzou.github.io/go_base_01/ data-title=Go_base_01><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/baidu.svg></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/go-grammar/>go grammar</a></section><section><span><a href=javascript:void(0); onclick=window.history.back();>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/mysql_base_13/ class=prev rel=prev title=Mysql_base_13><i class="fas fa-angle-left fa-fw"></i>Mysql_base_13</a>
<a href=/distributedsystem_base_01/ class=next rel=next title=DistributedSystem_base_01>DistributedSystem_base_01<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=disqus_thread class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://disqus.com/?ref_noscript>Disqus</a>.</noscript></div></article></div></main></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><script type=text/javascript src=https://jefos-blog.disqus.com/embed.js defer></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{}};</script><script type=text/javascript src=/js/theme.min.js></script></body></html>